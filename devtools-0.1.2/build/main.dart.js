// Generated by dart2js (fast startup emitter, strong), the Dart to JavaScript compiler version: 2.4.0-dev.0.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// dartCallInstrumentation(id, qualifiedName):
//    if this function is defined, it will be called at each entry of a
//    method or constructor. Used only when compiling programs with
//    --experiment-call-instrumentation.
{
}
(function dartProgram() {
  function copyProperties(from, to) {
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      to[key] = from[key];
    }
  }
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function setFunctionNamesIfNecessary(holders) {
    function t() {
    }
    ;
    if (typeof t.name == "string")
      return;
    for (var i = 0; i < holders.length; i++) {
      var holder = holders[i];
      var keys = Object.keys(holder);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        var f = holder[key];
        if (typeof f == 'function')
          f.name = key;
      }
    }
  }
  function inherit(cls, sup) {
    cls.prototype.constructor = cls;
    cls.prototype["$is" + cls.name] = cls;
    if (sup != null) {
      if (supportsDirectProtoAccess) {
        cls.prototype.__proto__ = sup.prototype;
        return;
      }
      var clsPrototype = Object.create(sup.prototype);
      copyProperties(cls.prototype, clsPrototype);
      cls.prototype = clsPrototype;
    }
  }
  function inheritMany(sup, classes) {
    for (var i = 0; i < classes.length; i++)
      inherit(classes[i], sup);
  }
  function mixin(cls, mixin) {
    copyProperties(mixin.prototype, cls.prototype);
    cls.prototype.constructor = cls;
  }
  function lazy(holder, name, getterName, initializer) {
    var uninitializedSentinel = holder;
    holder[name] = uninitializedSentinel;
    holder[getterName] = function() {
      holder[getterName] = function() {
        H.throwCyclicInit(name);
      };
      var result;
      var sentinelInProgress = initializer;
      try {
        if (holder[name] === uninitializedSentinel) {
          result = holder[name] = sentinelInProgress;
          result = holder[name] = initializer();
        } else
          result = holder[name];
      } finally {
        if (result === sentinelInProgress)
          holder[name] = null;
        holder[getterName] = function() {
          return this[name];
        };
      }
      return result;
    };
  }
  function makeConstList(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  }
  function convertToFastObject(properties) {
    function t() {
    }
    t.prototype = properties;
    new t();
    return properties;
  }
  function convertAllToFastObject(arrayOfObjects) {
    for (var i = 0; i < arrayOfObjects.length; ++i)
      convertToFastObject(arrayOfObjects[i]);
  }
  var functionCounter = 0;
  function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(receiver) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, true, name);" + "return new c(this, funcs[0], receiver, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, false, name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
  }
  function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
    var cache = null;
    return isStatic ? function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, false, name).prototype;
      return cache;
    } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
  }
  var typesOffset = 0;
  function installTearOff(container, getterName, isStatic, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    var funs = [];
    for (var i = 0; i < funsOrNames.length; i++) {
      var fun = funsOrNames[i];
      if (typeof fun == 'string')
        fun = container[fun];
      fun.$callName = callNames[i];
      funs.push(fun);
    }
    var fun = funs[0];
    fun.$requiredArgCount = requiredParameterCount;
    fun.$defaultValues = optionalParameterDefaultValues;
    var reflectionInfo = funType;
    if (typeof reflectionInfo == "number")
      reflectionInfo += typesOffset;
    var name = funsOrNames[0];
    fun.$stubName = name;
    var getterFunction = tearOff(funs, applyIndex || 0, reflectionInfo, isStatic, name, isIntercepted);
    container[getterName] = getterFunction;
    if (isStatic)
      fun.$tearOff = getterFunction;
  }
  function installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, true, false, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex) {
    return installTearOff(container, getterName, false, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, funsOrNames, funType, applyIndex);
  }
  function setOrUpdateInterceptorsByTag(newTags) {
    var tags = init.interceptorsByTag;
    if (!tags) {
      init.interceptorsByTag = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function setOrUpdateLeafTags(newTags) {
    var tags = init.leafTags;
    if (!tags) {
      init.leafTags = newTags;
      return;
    }
    copyProperties(newTags, tags);
  }
  function updateTypes(newTypes) {
    var types = init.types;
    var length = types.length;
    types.push.apply(types, newTypes);
    return length;
  }
  function updateHolder(holder, newHolder) {
    copyProperties(newHolder, holder);
    return holder;
  }
  var hunkHelpers = function() {
    var mkInstance = function(isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installInstanceTearOff(container, getterName, isIntercepted, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      },
      mkStatic = function(requiredParameterCount, optionalParameterDefaultValues, callNames, applyIndex) {
        return function(container, getterName, name, funType) {
          return installStaticTearOff(container, getterName, requiredParameterCount, optionalParameterDefaultValues, callNames, [name], funType, applyIndex);
        };
      };
    return {inherit: inherit, inheritMany: inheritMany, mixin: mixin, installStaticTearOff: installStaticTearOff, installInstanceTearOff: installInstanceTearOff, _instance_0u: mkInstance(0, 0, null, ["call$0"], 0), _instance_1u: mkInstance(0, 1, null, ["call$1"], 0), _instance_2u: mkInstance(0, 2, null, ["call$2"], 0), _instance_0i: mkInstance(1, 0, null, ["call$0"], 0), _instance_1i: mkInstance(1, 1, null, ["call$1"], 0), _instance_2i: mkInstance(1, 2, null, ["call$2"], 0), _static_0: mkStatic(0, null, ["call$0"], 0), _static_1: mkStatic(1, null, ["call$1"], 0), _static_2: mkStatic(2, null, ["call$2"], 0), makeConstList: makeConstList, lazy: lazy, updateHolder: updateHolder, convertToFastObject: convertToFastObject, setFunctionNamesIfNecessary: setFunctionNamesIfNecessary, updateTypes: updateTypes, setOrUpdateInterceptorsByTag: setOrUpdateInterceptorsByTag, setOrUpdateLeafTags: setOrUpdateLeafTags};
  }();
  function initializeDeferredHunk(hunk) {
    typesOffset = init.types.length;
    hunk(hunkHelpers, init, holders, $);
  }
  function getGlobalFromName(name) {
    for (var i = 0; i < holders.length; i++) {
      if (holders[i] == C)
        continue;
      if (holders[i][name])
        return holders[i][name];
    }
  }
  var C = {},
  H = {JS_CONST: function JS_CONST() {
    },
    CastIterable_CastIterable: function(source, $S, $T) {
      H.assertSubtype(source, "$isIterable", [$S], "$asIterable");
      if (H.checkSubtype(source, "$isEfficientLengthIterable", [$S], "$asEfficientLengthIterable"))
        return new H._EfficientLengthCastIterable(source, [$S, $T]);
      return new H.CastIterable(source, [$S, $T]);
    },
    hexDigitValue: function(char) {
      var letter,
        digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
      P.RangeError_checkNotNegative(_start, "start");
      if (_endOrLength != null) {
        P.RangeError_checkNotNegative(_endOrLength, "end");
        if (_start > _endOrLength)
          H.throwExpression(P.RangeError$range(_start, 0, _endOrLength, "start", null));
      }
      return new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
    },
    MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
      H.assertSubtype(iterable, "$isIterable", [$S], "$asIterable");
      H.functionTypeCheck($function, {func: 1, ret: $T, args: [$S]});
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
      return new H.MappedIterable(iterable, $function, [$S, $T]);
    },
    TakeIterable_TakeIterable: function(iterable, takeCount, $E) {
      H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable");
      P.RangeError_checkNotNegative(takeCount, "takeCount");
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable)
        return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
      return new H.TakeIterable(iterable, takeCount, [$E]);
    },
    SkipIterable_SkipIterable: function(iterable, count, $E) {
      H.assertSubtype(iterable, "$isIterable", [$E], "$asIterable");
      if (!!J.getInterceptor$(iterable).$isEfficientLengthIterable) {
        P.RangeError_checkNotNegative(count, "count");
        return new H.EfficientLengthSkipIterable(iterable, count, [$E]);
      }
      P.RangeError_checkNotNegative(count, "count");
      return new H.SkipIterable(iterable, count, [$E]);
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort_sort: function(a, compare, $E) {
      var t1;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      t1 = J.get$length$asx(a);
      if (typeof t1 !== "number")
        return t1.$sub();
      H.Sort__doSort(a, 0, t1 - 1, compare, $E);
    },
    Sort__doSort: function(a, left, right, compare, $E) {
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      if (right - left <= 32)
        H.Sort__insertionSort(a, left, right, compare, $E);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare, $E);
    },
    Sort__insertionSort: function(a, left, right, compare, $E) {
      var i, t1, el, j, t2, j0;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          if (j > left) {
            t2 = compare.call$2(t1.$index(a, j - 1), el);
            if (typeof t2 !== "number")
              return t2.$gt();
            t2 = t2 > 0;
          } else
            t2 = false;
          if (!t2)
            break;
          j0 = j - 1;
          t1.$indexSet(a, j, t1.$index(a, j0));
          j = j0;
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare, $E) {
      var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t2, t0, less, great, k, ak, comp, great0, less0, pivots_are_equal, comp_pivot1, comp_pivot2;
      H.assertSubtype(a, "$isList", [$E], "$asList");
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [$E, $E]});
      sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
      index1 = left + sixth;
      index5 = right - sixth;
      index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
      index2 = index3 - sixth;
      index4 = index3 + sixth;
      t1 = J.getInterceptor$asx(a);
      el1 = t1.$index(a, index1);
      el2 = t1.$index(a, index2);
      el3 = t1.$index(a, index3);
      el4 = t1.$index(a, index4);
      el5 = t1.$index(a, index5);
      t2 = compare.call$2(el1, el2);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el4, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t2 = compare.call$2(el1, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el2, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el1, el4);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      t2 = compare.call$2(el3, el4);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      t2 = compare.call$2(el2, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el2, el3);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      t2 = compare.call$2(el4, el5);
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 > 0) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t1.$indexSet(a, index1, el1);
      t1.$indexSet(a, index3, el3);
      t1.$indexSet(a, index5, el5);
      t1.$indexSet(a, index2, t1.$index(a, left));
      t1.$indexSet(a, index4, t1.$index(a, right));
      less = left + 1;
      great = right - 1;
      if (J.$eq$(compare.call$2(el2, el4), 0)) {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp = compare.call$2(ak, el2);
          if (comp === 0)
            continue;
          if (typeof comp !== "number")
            return comp.$lt();
          if (comp < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else
            for (; true;) {
              comp = compare.call$2(t1.$index(a, great), el2);
              if (typeof comp !== "number")
                return comp.$gt();
              if (comp > 0) {
                --great;
                continue;
              } else {
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
        pivots_are_equal = true;
      } else {
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          comp_pivot1 = compare.call$2(ak, el2);
          if (typeof comp_pivot1 !== "number")
            return comp_pivot1.$lt();
          if (comp_pivot1 < 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else {
            comp_pivot2 = compare.call$2(ak, el4);
            if (typeof comp_pivot2 !== "number")
              return comp_pivot2.$gt();
            if (comp_pivot2 > 0)
              for (; true;) {
                comp = compare.call$2(t1.$index(a, great), el4);
                if (typeof comp !== "number")
                  return comp.$gt();
                if (comp > 0) {
                  --great;
                  if (great < k)
                    break;
                  continue;
                } else {
                  comp = compare.call$2(t1.$index(a, great), el2);
                  if (typeof comp !== "number")
                    return comp.$lt();
                  great0 = great - 1;
                  if (comp < 0) {
                    t1.$indexSet(a, k, t1.$index(a, less));
                    less0 = less + 1;
                    t1.$indexSet(a, less, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                    less = less0;
                  } else {
                    t1.$indexSet(a, k, t1.$index(a, great));
                    t1.$indexSet(a, great, ak);
                  }
                  great = great0;
                  break;
                }
              }
          }
        }
        pivots_are_equal = false;
      }
      t2 = less - 1;
      t1.$indexSet(a, left, t1.$index(a, t2));
      t1.$indexSet(a, t2, el2);
      t2 = great + 1;
      t1.$indexSet(a, right, t1.$index(a, t2));
      t1.$indexSet(a, t2, el4);
      H.Sort__doSort(a, left, less - 2, compare, $E);
      H.Sort__doSort(a, great + 2, right, compare, $E);
      if (pivots_are_equal)
        return;
      if (less < index1 && great > index5) {
        for (; J.$eq$(compare.call$2(t1.$index(a, less), el2), 0);)
          ++less;
        for (; J.$eq$(compare.call$2(t1.$index(a, great), el4), 0);)
          --great;
        for (k = less; k <= great; ++k) {
          ak = t1.$index(a, k);
          if (compare.call$2(ak, el2) === 0) {
            if (k !== less) {
              t1.$indexSet(a, k, t1.$index(a, less));
              t1.$indexSet(a, less, ak);
            }
            ++less;
          } else if (compare.call$2(ak, el4) === 0)
            for (; true;)
              if (compare.call$2(t1.$index(a, great), el4) === 0) {
                --great;
                if (great < k)
                  break;
                continue;
              } else {
                comp = compare.call$2(t1.$index(a, great), el2);
                if (typeof comp !== "number")
                  return comp.$lt();
                great0 = great - 1;
                if (comp < 0) {
                  t1.$indexSet(a, k, t1.$index(a, less));
                  less0 = less + 1;
                  t1.$indexSet(a, less, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                  less = less0;
                } else {
                  t1.$indexSet(a, k, t1.$index(a, great));
                  t1.$indexSet(a, great, ak);
                }
                great = great0;
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare, $E);
      } else
        H.Sort__doSort(a, less, great, compare, $E);
    },
    CastStream: function CastStream(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastStreamSubscription: function CastStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._source = t0;
      _.__internal$_zone = t1;
      _.__internal$_handleError = _.__internal$_handleData = null;
      _.$ti = t2;
    },
    _CastIterableBase: function _CastIterableBase() {
    },
    CastIterator: function CastIterator(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastIterable: function CastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _EfficientLengthCastIterable: function _EfficientLengthCastIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    _CastListBase: function _CastListBase() {
    },
    _CastListBase_sort_closure: function _CastListBase_sort_closure(t0, t1) {
      this.$this = t0;
      this.compare = t1;
    },
    CastList: function CastList(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CastSet: function CastSet(t0, t1, t2) {
      this._source = t0;
      this._emptySet = t1;
      this.$ti = t2;
    },
    CastSet_removeWhere_closure: function CastSet_removeWhere_closure(t0, t1) {
      this.$this = t0;
      this.test = t1;
    },
    CastQueue: function CastQueue(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    CodeUnits: function CodeUnits(t0) {
      this.__internal$_string = t0;
    },
    EfficientLengthIterable: function EfficientLengthIterable() {
    },
    ListIterable: function ListIterable() {
    },
    SubListIterable: function SubListIterable(t0, t1, t2, t3) {
      var _ = this;
      _.__internal$_iterable = t0;
      _._start = t1;
      _._endOrLength = t2;
      _.$ti = t3;
    },
    ListIterator: function ListIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_iterable = t0;
      _.__internal$_length = t1;
      _.__internal$_index = 0;
      _.__internal$_current = null;
      _.$ti = t2;
    },
    MappedIterable: function MappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    EfficientLengthMappedIterable: function EfficientLengthMappedIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    MappedIterator: function MappedIterator(t0, t1, t2) {
      var _ = this;
      _.__internal$_current = null;
      _._iterator = t0;
      _._f = t1;
      _.$ti = t2;
    },
    MappedListIterable: function MappedListIterable(t0, t1, t2) {
      this._source = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterable: function WhereIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._f = t1;
      this.$ti = t2;
    },
    WhereIterator: function WhereIterator(t0, t1, t2) {
      this._iterator = t0;
      this._f = t1;
      this.$ti = t2;
    },
    TakeIterable: function TakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    EfficientLengthTakeIterable: function EfficientLengthTakeIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._takeCount = t1;
      this.$ti = t2;
    },
    TakeIterator: function TakeIterator(t0, t1, t2) {
      this._iterator = t0;
      this._remaining = t1;
      this.$ti = t2;
    },
    SkipIterable: function SkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EfficientLengthSkipIterable: function EfficientLengthSkipIterable(t0, t1, t2) {
      this.__internal$_iterable = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    SkipIterator: function SkipIterator(t0, t1, t2) {
      this._iterator = t0;
      this._skipCount = t1;
      this.$ti = t2;
    },
    EmptyIterable: function EmptyIterable(t0) {
      this.$ti = t0;
    },
    EmptyIterator: function EmptyIterator(t0) {
      this.$ti = t0;
    },
    FixedLengthListMixin: function FixedLengthListMixin() {
    },
    UnmodifiableListMixin: function UnmodifiableListMixin() {
    },
    UnmodifiableListBase: function UnmodifiableListBase() {
    },
    ReversedListIterable: function ReversedListIterable(t0, t1) {
      this._source = t0;
      this.$ti = t1;
    },
    Symbol: function Symbol(t0) {
      this.__internal$_name = t0;
    },
    __CastListBase__CastIterableBase_ListMixin: function __CastListBase__CastIterableBase_ListMixin() {
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    instantiate1: function(f, T1) {
      var t1;
      H.interceptedTypeCheck(f, "$isClosure");
      t1 = new H.Instantiation1(f, [T1]);
      t1.Instantiation$1(f);
      return t1;
    },
    unminifyOrTag: function(rawClassName) {
      var preserved = H.stringTypeCheck(init.mangledGlobalNames[rawClassName]);
      if (typeof preserved === "string")
        return preserved;
      return rawClassName;
    },
    getType: function(index) {
      return init.types[H.intTypeCheck(index)];
    },
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor$(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives_parseInt: function(source, radix) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = H.stringTypeCheck(match[3]);
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return;
      }
      return parseInt(source, radix);
    },
    Primitives_parseDouble: function(source) {
      var result, trimmed;
      if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
        return;
      result = parseFloat(source);
      if (isNaN(result)) {
        trimmed = C.JSString_methods.trim$0(source);
        if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
          return result;
        return;
      }
      return result;
    },
    Primitives_objectTypeName: function(object) {
      return H.Primitives__objectClassName(object) + H._joinArguments(H.getRuntimeTypeInfo(object), 0, null);
    },
    Primitives__objectClassName: function(object) {
      var interceptorConstructorName, $name, t1, dispatchName, objectConstructor, match, decompiledName,
        interceptor = J.getInterceptor$(object),
        interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      t1 = $name == null;
      if (t1 || interceptor === C.Interceptor_methods || !!interceptor.$isUnknownJavaScriptObject) {
        dispatchName = C.C_JS_CONST6(object);
        if (t1)
          $name = dispatchName;
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
        }
        return $name;
      }
      $name = $name;
      return H.unminifyOrTag($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36 ? C.JSString_methods.substring$1($name, 1) : $name);
    },
    Primitives_dateNow: function() {
      return Date.now();
    },
    Primitives_initTicker: function() {
      var $window, performance;
      if ($.Primitives_timerFrequency != null)
        return;
      $.Primitives_timerFrequency = 1000;
      $.Primitives_timerTicks = H._js_helper_Primitives_dateNow$closure();
      if (typeof window == "undefined")
        return;
      $window = window;
      if ($window == null)
        return;
      performance = $window.performance;
      if (performance == null)
        return;
      if (typeof performance.now != "function")
        return;
      $.Primitives_timerFrequency = 1000000;
      $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
    },
    Primitives_currentUri: function() {
      if (!!self.location)
        return self.location.href;
      return;
    },
    Primitives__fromCharCodeApply: function(array) {
      var end, result, i, i0, chunkEnd;
      H.listTypeCheck(array);
      end = J.get$length$asx(array);
      if (typeof end !== "number")
        return end.$le();
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var t1, i,
        a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(codePoints, "$isIterable")); t1.moveNext$0();) {
        i = t1.get$current(t1);
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          C.JSArray_methods.add$1(a, i);
        else if (i <= 1114111) {
          C.JSArray_methods.add$1(a, 55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          C.JSArray_methods.add$1(a, 56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, i;
      for (H.listSuperNativeTypeCheck(charCodes, "$isIterable"), t1 = J.get$iterator$ax(charCodes); t1.moveNext$0();) {
        i = t1.get$current(t1);
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(H.listTypeCheck(charCodes));
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (typeof end !== "number")
        return end.$le();
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (typeof charCode !== "number")
        return H.iae(charCode);
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_valueFromDecomposedDate: function(years, month, day, hours, minutes, seconds, milliseconds, isUtc) {
      var value,
        jsMonth = month - 1;
      if (0 <= years && years < 100) {
        years += 400;
        jsMonth -= 4800;
      }
      value = new Date(years, jsMonth, day, hours, minutes, seconds, milliseconds).valueOf();
      if (isNaN(value) || value < -864e13 || value > 864e13)
        return;
      return value;
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
    },
    Primitives_getMonth: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
    },
    Primitives_getDay: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
    },
    Primitives_getHours: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
    },
    Primitives_getMinutes: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
    },
    Primitives_getSeconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
    },
    Primitives_getMilliseconds: function(receiver) {
      return receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
    },
    Primitives_getWeekday: function(receiver) {
      return C.JSInt_methods.$mod((receiver.isUtc ? H.Primitives_lazyAsJsDate(receiver).getUTCDay() + 0 : H.Primitives_lazyAsJsDate(receiver).getDay() + 0) + 6, 7) + 1;
    },
    Primitives_getProperty: function(object, key) {
      if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
        throw H.wrapException(H.argumentErrorValue(object));
      return object[key];
    },
    Primitives_setProperty: function(object, key, value) {
      var t1 = typeof object === "boolean" || typeof object === "number" || typeof object === "string";
      if (t1)
        throw H.wrapException(H.argumentErrorValue(object));
      object[key] = value;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var $arguments, namedArgumentList, t1 = {};
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      t1.argumentCount = positionalArguments.length;
      C.JSArray_methods.addAll$1($arguments, positionalArguments);
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      "" + t1.argumentCount;
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, 0, $arguments, namedArgumentList, 0));
    },
    Primitives_applyFunction: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, argumentCount, jsStub;
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      if (positionalArguments instanceof Array)
        t1 = namedArguments == null || namedArguments.get$isEmpty(namedArguments);
      else
        t1 = false;
      if (t1) {
        $arguments = positionalArguments;
        argumentCount = $arguments.length;
        if (argumentCount === 0) {
          if (!!$function.call$0)
            return $function.call$0();
        } else if (argumentCount === 1) {
          if (!!$function.call$1)
            return $function.call$1($arguments[0]);
        } else if (argumentCount === 2) {
          if (!!$function.call$2)
            return $function.call$2($arguments[0], $arguments[1]);
        } else if (argumentCount === 3) {
          if (!!$function.call$3)
            return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
        } else if (argumentCount === 4) {
          if (!!$function.call$4)
            return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
        } else if (argumentCount === 5)
          if (!!$function.call$5)
            return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
        jsStub = $function["call" + "$" + argumentCount];
        if (jsStub != null)
          return jsStub.apply($function, $arguments);
      }
      return H.Primitives__genericApplyFunction2($function, positionalArguments, namedArguments);
    },
    Primitives__genericApplyFunction2: function($function, positionalArguments, namedArguments) {
      var $arguments, argumentCount, requiredParameterCount, defaultValuesClosure, t1, defaultValues, interceptor, jsFunction, keys, _i, used, t2;
      H.assertSubtype(namedArguments, "$isMap", [P.String, null], "$asMap");
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      argumentCount = $arguments.length;
      requiredParameterCount = $function.$requiredArgCount;
      if (argumentCount < requiredParameterCount)
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      defaultValuesClosure = $function.$defaultValues;
      t1 = defaultValuesClosure == null;
      defaultValues = !t1 ? defaultValuesClosure() : null;
      interceptor = J.getInterceptor$($function);
      jsFunction = interceptor["call*"];
      if (typeof jsFunction === "string")
        jsFunction = interceptor[jsFunction];
      if (t1) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount === requiredParameterCount)
          return jsFunction.apply($function, $arguments);
        return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
      }
      if (defaultValues instanceof Array) {
        if (namedArguments != null && namedArguments.get$isNotEmpty(namedArguments))
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        if (argumentCount > requiredParameterCount + defaultValues.length)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        C.JSArray_methods.addAll$1($arguments, defaultValues.slice(argumentCount - requiredParameterCount));
        return jsFunction.apply($function, $arguments);
      } else {
        if (argumentCount > requiredParameterCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        keys = Object.keys(defaultValues);
        if (namedArguments == null)
          for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i)
            C.JSArray_methods.add$1($arguments, defaultValues[H.stringTypeCheck(keys[_i])]);
        else {
          for (t1 = keys.length, used = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
            t2 = H.stringTypeCheck(keys[_i]);
            if (namedArguments.containsKey$1(0, t2)) {
              ++used;
              C.JSArray_methods.add$1($arguments, namedArguments.$index(0, t2));
            } else
              C.JSArray_methods.add$1($arguments, defaultValues[t2]);
          }
          if (used !== namedArguments.get$length(namedArguments))
            return H.Primitives_functionNoSuchMethod($function, $arguments, namedArguments);
        }
        return jsFunction.apply($function, $arguments);
      }
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, t1, _s5_ = "index";
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, _s5_, null);
      $length = H.intTypeCheck(J.get$length$asx(indexable));
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, _s5_, null, $length);
      return P.RangeError$value(index, _s5_);
    },
    diagnoseRangeError: function(start, end, $length) {
      var _s13_ = "Invalid value";
      if (start < 0 || start > $length)
        return new P.RangeError(0, $length, true, start, "start", _s13_);
      if (end != null)
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", _s13_);
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: function() {
      return J.toString$0$(this.dartException);
    },
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    TypeErrorDecoder_extractPattern: function(message) {
      var match, $arguments, argumentsExpr, expr, method, receiver;
      message = H.quoteStringForRegExp(message.replace(String({}), '$receiver$'));
      match = message.match(/\\\$[a-zA-Z]+\\\$/g);
      if (match == null)
        match = H.setRuntimeTypeInfo([], [P.String]);
      $arguments = match.indexOf("\\$arguments\\$");
      argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
      expr = match.indexOf("\\$expr\\$");
      method = match.indexOf("\\$method\\$");
      receiver = match.indexOf("\\$receiver\\$");
      return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
    },
    TypeErrorDecoder_provokeCallErrorOn: function(expression) {
      return function($expr$) {
        var $argumentsExpr$ = '$arguments$';
        try {
          $expr$.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
      return function($expr$) {
        try {
          $expr$.$method$;
        } catch (e) {
          return e.message;
        }
      }(expression);
    },
    NullError$: function(_message, match) {
      return new H.NullError(_message, match == null ? null : match.method);
    },
    JsNoSuchMethodError$: function(_message, match) {
      var t1 = match == null,
        t2 = t1 ? null : match.method;
      return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
    },
    unwrapException: function(ex) {
      var message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2, _null = null,
        t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", _null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(H.stringTypeCheck(message), match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(H.stringTypeCheck(message), match));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, _null, _null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var index, index0, index1,
        $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      H.interceptedTypeCheck(closure, "$isFunction");
      switch (H.intTypeCheck(numberOfArguments)) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
    },
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      H.intTypeCheck(arity);
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, propertyName) {
      var $constructor, t1, trampoline, signatureFunction, getReceiver, applyTrampoline, i, stub, stubCallName, _null = null,
        $function = functions[0],
        callName = $function.$callName,
        $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(_null, _null, _null, _null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function static_tear_off() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        t1 = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
        $constructor = t1;
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
      }
      if (typeof reflectionInfo == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, reflectionInfo);
      else if (typeof reflectionInfo == "function")
        if (isStatic)
          signatureFunction = reflectionInfo;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(reflectionInfo, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (applyTrampoline = trampoline, i = 1; i < functions.length; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.Closure_functionCounter = t1 + 1;
        selfName = "self" + t1;
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      $arguments += t1;
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      return new Function(t1 + H.S(t2 == null ? $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self") : t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf = H.BoundClosure_selfOf,
        getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var t2, stubName, arity, lookedUpFunction, t3, t4, $arguments,
        t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null)
        t1 = $.BoundClosure_selfFieldNameCache = H.BoundClosure_computeFieldNamed("self");
      t2 = $.BoundClosure_receiverFieldNameCache;
      if (t2 == null)
        t2 = $.BoundClosure_receiverFieldNameCache = H.BoundClosure_computeFieldNamed("receiver");
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t3 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t4 = !t3 || arity >= 28;
      if (t4)
        return H.Closure_cspForwardInterceptedCall(arity, !t3, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ");";
        t2 = $.Closure_functionCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.Closure_functionCounter = t2 + 1;
        return new Function(t1 + t2 + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, isIntercepted, $name) {
      return H.Closure_fromTearOff(receiver, functions, H.intTypeCheck(applyTrampolineIndex), reflectionInfo, !!isStatic, !!isIntercepted, $name);
    },
    BoundClosure_selfOf: function(closure) {
      return closure._self;
    },
    BoundClosure_receiverOf: function(closure) {
      return closure._receiver;
    },
    BoundClosure_computeFieldNamed: function(fieldName) {
      var t1, i, $name,
        template = new H.BoundClosure("self", "target", "receiver", "name"),
        names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (template[$name] === fieldName)
          return $name;
      }
    },
    boolConversionCheck: function(value) {
      if (value == null)
        H.assertThrow("boolean expression must not be null");
      return value;
    },
    stringTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "String"));
    },
    stringTypeCast: function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "String"));
    },
    doubleTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "double"));
    },
    numTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "num"));
    },
    boolTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "boolean")
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "bool"));
    },
    intTypeCheck: function(value) {
      if (value == null)
        return value;
      if (typeof value === "number" && Math.floor(value) === value)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "int"));
    },
    propertyTypeError: function(value, property) {
      throw H.wrapException(H.TypeErrorImplementation$(value, H.unminifyOrTag(H.stringTypeCheck(property).substring(3))));
    },
    propertyTypeCastError: function(value, property) {
      throw H.wrapException(H.CastErrorImplementation$(value, H.unminifyOrTag(H.stringTypeCheck(property).substring(3))));
    },
    interceptedTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if ((typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor$(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    numberOrStringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    numberOrStringSuperNativeTypeCast: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (typeof value === "number")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeCastError(value, property);
    },
    stringSuperNativeTypeCheck: function(value, property) {
      if (value == null)
        return value;
      if (typeof value === "string")
        return value;
      if (J.getInterceptor$(value)[property])
        return value;
      H.propertyTypeError(value, property);
    },
    listTypeCheck: function(value) {
      if (value == null)
        return value;
      if (!!J.getInterceptor$(value).$isList)
        return value;
      throw H.wrapException(H.TypeErrorImplementation$(value, "List<dynamic>"));
    },
    listSuperNativeTypeCheck: function(value, property) {
      var t1;
      if (value == null)
        return value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isList)
        return value;
      if (t1[property])
        return value;
      H.propertyTypeError(value, property);
    },
    extractFunctionTypeObjectFromInternal: function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return init.types[H.intTypeCheck(signature)];
        else
          return o.$signature();
      }
      return;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor$(value));
      if (functionTypeObject == null)
        return false;
      return H._isFunctionSubtype(functionTypeObject, null, functionTypeRti, null);
    },
    functionTypeCheck: function(value, functionTypeRti) {
      var $self, t1;
      if (value == null)
        return value;
      if ($._inTypeAssertion)
        return value;
      $._inTypeAssertion = true;
      try {
        if (H.functionTypeTest(value, functionTypeRti))
          return value;
        $self = H.runtimeTypeToString(functionTypeRti);
        t1 = H.TypeErrorImplementation$(value, $self);
        throw H.wrapException(t1);
      } finally {
        $._inTypeAssertion = false;
      }
    },
    futureOrCheck: function(o, futureOrRti) {
      if (o != null && !H.checkSubtypeOfRuntimeType(o, futureOrRti))
        H.throwExpression(H.TypeErrorImplementation$(o, H.runtimeTypeToString(futureOrRti)));
      return o;
    },
    TypeErrorImplementation$: function(value, type) {
      return new H.TypeErrorImplementation("TypeError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    CastErrorImplementation$: function(value, type) {
      return new H.CastErrorImplementation("CastError: " + P.Error_safeToString(value) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
    },
    _typeDescription: function(value) {
      var functionTypeObject,
        t1 = J.getInterceptor$(value);
      if (!!t1.$isClosure) {
        functionTypeObject = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    },
    assertThrow: function(message) {
      throw H.wrapException(new H._AssertionError(message));
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(H.stringTypeCheck(staticName)));
    },
    RuntimeError$: function(message) {
      return new H.RuntimeError(message);
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    createRuntimeType: function(rti) {
      return new H.TypeImpl(rti);
    },
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(interceptor, object, substitutionName) {
      return H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(object));
    },
    getRuntimeTypeArgumentIntercepted: function(interceptor, target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments;
      H.stringTypeCheck(substitutionName);
      H.intTypeCheck(index);
      $arguments = H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti;
      H.intTypeCheck(index);
      rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    runtimeTypeToString: function(rti) {
      return H._runtimeTypeToString(rti, null);
    },
    _runtimeTypeToString: function(rti, genericContext) {
      var t1, t2;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (rti == null)
        return "dynamic";
      if (rti === -1)
        return "void";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.unminifyOrTag(rti[0].name) + H._joinArguments(rti, 1, genericContext);
      if (typeof rti == "function")
        return H.unminifyOrTag(rti.name);
      if (rti === -2)
        return "dynamic";
      if (typeof rti === "number") {
        H.intTypeCheck(rti);
        if (genericContext == null || rti < 0 || rti >= genericContext.length)
          return "unexpected-generic-index:" + rti;
        t1 = genericContext.length;
        t2 = t1 - rti - 1;
        if (t2 < 0 || t2 >= t1)
          return H.ioore(genericContext, t2);
        return H.S(genericContext[t2]);
      }
      if ('func' in rti)
        return H._functionRtiToString(rti, genericContext);
      if ('futureOr' in rti)
        return "FutureOr<" + H._runtimeTypeToString("type" in rti ? rti.type : null, genericContext) + ">";
      return "unknown-reified-type";
    },
    _functionRtiToString: function(rti, genericContext) {
      var boundsRti, outerContextLength, offset, i, i0, typeParameters, typeSep, t2, boundRti, returnTypeText, $arguments, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t3, _s2_ = ", ",
        t1 = [P.String];
      H.assertSubtype(genericContext, "$isList", t1, "$asList");
      if ("bounds" in rti) {
        boundsRti = rti.bounds;
        if (genericContext == null) {
          genericContext = H.setRuntimeTypeInfo([], t1);
          outerContextLength = null;
        } else
          outerContextLength = genericContext.length;
        offset = genericContext.length;
        for (i = boundsRti.length, i0 = i; i0 > 0; --i0)
          C.JSArray_methods.add$1(genericContext, "T" + (offset + i0));
        for (typeParameters = "<", typeSep = "", i0 = 0; i0 < i; ++i0, typeSep = _s2_) {
          typeParameters += typeSep;
          t1 = genericContext.length;
          t2 = t1 - i0 - 1;
          if (t2 < 0)
            return H.ioore(genericContext, t2);
          typeParameters = C.JSString_methods.$add(typeParameters, genericContext[t2]);
          boundRti = boundsRti[i0];
          if (boundRti != null && boundRti !== P.Object)
            typeParameters += " extends " + H._runtimeTypeToString(boundRti, genericContext);
        }
        typeParameters += ">";
      } else {
        typeParameters = "";
        outerContextLength = null;
      }
      returnTypeText = !!rti.v ? "void" : H._runtimeTypeToString(rti.ret, genericContext);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = _s2_) {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H._runtimeTypeToString(argument, genericContext);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = _s2_) {
          t3 = H.stringTypeCheck(t1[_i]);
          argumentsText = argumentsText + sep + H._runtimeTypeToString(namedArguments[t3], genericContext) + (" " + H.S(t3));
        }
        argumentsText += "}";
      }
      if (outerContextLength != null)
        genericContext.length = outerContextLength;
      return typeParameters + "(" + argumentsText + ") => " + returnTypeText;
    },
    _joinArguments: function(types, startIndex, genericContext) {
      var buffer, index, separator, allDynamic, t1, argument;
      H.assertSubtype(genericContext, "$isList", [P.String], "$asList");
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, separator = "", allDynamic = true, t1 = ""; index < types.length; ++index, separator = ", ") {
        buffer._contents = t1 + separator;
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H._runtimeTypeToString(argument, genericContext);
      }
      return "<" + buffer.toString$0(0) + ">";
    },
    getRti: function(o) {
      var functionRti, type, rti,
        t1 = J.getInterceptor$(o);
      if (!!t1.$isClosure) {
        functionRti = H.extractFunctionTypeObjectFromInternal(t1);
        if (functionRti != null)
          return functionRti;
      }
      type = t1.constructor;
      if (typeof o != "object")
        return type;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return type;
    },
    getRuntimeType: function(object) {
      return new H.TypeImpl(H.getRti(object));
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtype: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor$(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypes(H.substitute(interceptor[asField], $arguments), null, checks, null);
    },
    subtypeCast: function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.CastErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.unminifyOrTag(isField.substring(3)) + H._joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    assertSubtype: function(object, isField, checks, asField) {
      H.stringTypeCheck(isField);
      H.listTypeCheck(checks);
      H.stringTypeCheck(asField);
      if (object == null)
        return object;
      if (H.checkSubtype(object, isField, checks, asField))
        return object;
      throw H.wrapException(H.TypeErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(H.unminifyOrTag(isField.substring(3)) + H._joinArguments(checks, 0, null), init.mangledGlobalNames)));
    },
    assertIsSubtype: function(subtype, supertype, prefix, infix, suffix) {
      H.stringTypeCheck(prefix);
      H.stringTypeCheck(infix);
      H.stringTypeCheck(suffix);
      if (!H._isSubtype(subtype, null, supertype, null))
        H.throwTypeError("TypeError: " + H.S(prefix) + H.runtimeTypeToString(subtype) + H.S(infix) + H.runtimeTypeToString(supertype) + H.S(suffix));
    },
    throwTypeError: function(message) {
      throw H.wrapException(new H.TypeErrorImplementation(H.stringTypeCheck(message)));
    },
    areSubtypes: function(s, sEnv, t, tEnv) {
      var len, i;
      if (t == null)
        return true;
      if (s == null) {
        len = t.length;
        for (i = 0; i < len; ++i)
          if (!H._isSubtype(null, null, t[i], tEnv))
            return false;
        return true;
      }
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H._isSubtype(s[i], sEnv, t[i], tEnv))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.substitute(J.getInterceptor$(context)["$as" + H.S(contextName)], H.getRuntimeTypeInfo(context)));
    },
    isSupertypeOfNullRecursive: function(type) {
      var typeArgument;
      if (typeof type === "number")
        return false;
      if ('futureOr' in type) {
        typeArgument = "type" in type ? type.type : null;
        return type == null || type.name === "Object" || type.name === "Null" || type === -1 || type === -2 || H.isSupertypeOfNullRecursive(typeArgument);
      }
      return false;
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var type, rti;
      if (o == null)
        return t == null || t.name === "Object" || t.name === "Null" || t === -1 || t === -2 || H.isSupertypeOfNullRecursive(t);
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (typeof t == "object") {
        if ('futureOr' in t)
          if (H.checkSubtypeOfRuntimeType(o, "type" in t ? t.type : null))
            return true;
        if ('func' in t)
          return H.functionTypeTest(o, t);
      }
      type = J.getInterceptor$(o).constructor;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      return H._isSubtype(type, null, t, null);
    },
    subtypeOfRuntimeTypeCast: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    },
    assertSubtypeOfRuntimeType: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.TypeErrorImplementation$(object, H.runtimeTypeToString(type)));
      return object;
    },
    _isSubtype: function(s, sEnv, t, tEnv) {
      var t1, typeOfS, tTypeArgument, futureSubstitution, futureArguments, t2, typeOfT, typeOfTString, substitution, _null = null;
      if (s === t)
        return true;
      if (t == null || t === -1 || t.name === "Object" || t === -2)
        return true;
      if (s === -2)
        return true;
      if (s == null || s === -1 || s.name === "Object" || s === -2) {
        if (typeof t === "number")
          return false;
        if ('futureOr' in t)
          return H._isSubtype(s, sEnv, "type" in t ? t.type : _null, tEnv);
        return false;
      }
      if (typeof s === "number")
        return false;
      if (typeof t === "number")
        return false;
      if (s.name === "Null")
        return true;
      if ('func' in t)
        return H._isFunctionSubtype(s, sEnv, t, tEnv);
      if ('func' in s)
        return t.name === "Function";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      if ('futureOr' in t) {
        tTypeArgument = "type" in t ? t.type : _null;
        if ('futureOr' in s)
          return H._isSubtype("type" in s ? s.type : _null, sEnv, tTypeArgument, tEnv);
        else if (H._isSubtype(s, sEnv, tTypeArgument, tEnv))
          return true;
        else {
          if (!('$is' + "Future" in typeOfS.prototype))
            return false;
          futureSubstitution = typeOfS.prototype["$as" + "Future"];
          futureArguments = H.substitute(futureSubstitution, t1 ? s.slice(1) : _null);
          return H._isSubtype(typeof futureArguments === "object" && futureArguments !== null && futureArguments.constructor === Array ? futureArguments[0] : _null, sEnv, tTypeArgument, tEnv);
        }
      }
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = typeOfT.name;
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = _null;
      if (!t2)
        return true;
      t1 = t1 ? s.slice(1) : _null;
      t2 = t.slice(1);
      return H.areSubtypes(H.substitute(substitution, t1), sEnv, t2, tEnv);
    },
    _isFunctionSubtype: function(s, sEnv, t, tEnv) {
      var sBounds, tBounds, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, tPos, sPos, sNamedParameters, tNamedParameters;
      if (!('func' in s))
        return false;
      if ("bounds" in s) {
        if (!("bounds" in t))
          return false;
        sBounds = s.bounds;
        tBounds = t.bounds;
        if (sBounds.length !== tBounds.length)
          return false;
      } else if ("bounds" in t)
        return false;
      if (!H._isSubtype(s.ret, sEnv, t.ret, tEnv))
        return false;
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      for (pos = 0; pos < sParametersLen; ++pos)
        if (!H._isSubtype(tParameterTypes[pos], tEnv, sParameterTypes[pos], sEnv))
          return false;
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos)
        if (!H._isSubtype(tOptionalParameterTypes[tPos], tEnv, sOptionalParameterTypes[sPos], sEnv))
          return false;
      sNamedParameters = s.named;
      tNamedParameters = t.named;
      if (tNamedParameters == null)
        return true;
      if (sNamedParameters == null)
        return false;
      return H.namedParametersSubtypeCheck(sNamedParameters, sEnv, tNamedParameters, tEnv);
    },
    namedParametersSubtypeCheck: function(s, sEnv, t, tEnv) {
      var t1, i, $name,
        names = Object.getOwnPropertyNames(t);
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        if (!H._isSubtype(t[$name], tEnv, s[$name], sEnv))
          return false;
      }
      return true;
    },
    instantiatedGenericFunctionType: function(genericFunctionRti, parameters) {
      if (genericFunctionRti == null)
        return;
      return H.finishBindInstantiatedFunctionType(genericFunctionRti, {func: 1}, parameters, 0);
    },
    finishBindInstantiatedFunctionType: function(rti, result, parameters, depth) {
      var namedParameters, boundNamed, names, t1, _i, $name;
      if ("v" in rti)
        result.v = rti.v;
      else if ("ret" in rti)
        result.ret = H.bindInstantiatedType(rti.ret, parameters, depth);
      if ("args" in rti)
        result.args = H.bindInstantiatedTypes(rti.args, parameters, depth);
      if ("opt" in rti)
        result.opt = H.bindInstantiatedTypes(rti.opt, parameters, depth);
      if ("named" in rti) {
        namedParameters = rti.named;
        boundNamed = {};
        names = Object.keys(namedParameters);
        for (t1 = names.length, _i = 0; _i < t1; ++_i) {
          $name = H.stringTypeCheck(names[_i]);
          boundNamed[$name] = H.bindInstantiatedType(namedParameters[$name], parameters, depth);
        }
        result.named = boundNamed;
      }
      return result;
    },
    bindInstantiatedType: function(rti, parameters, depth) {
      var result, bounds;
      if (rti == null)
        return rti;
      if (rti === -1)
        return rti;
      if (typeof rti == "function")
        return rti;
      if (typeof rti === "number") {
        if (rti < depth)
          return rti;
        return parameters[rti - depth];
      }
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return H.bindInstantiatedTypes(rti, parameters, depth);
      if ('func' in rti) {
        result = {func: 1};
        if ("bounds" in rti) {
          bounds = rti.bounds;
          depth += bounds.length;
          result.bounds = H.bindInstantiatedTypes(bounds, parameters, depth);
        }
        return H.finishBindInstantiatedFunctionType(rti, result, parameters, depth);
      }
      throw H.wrapException(P.ArgumentError$("Unknown RTI format in bindInstantiatedType."));
    },
    bindInstantiatedTypes: function(rti, parameters, depth) {
      var t1, i,
        array = rti.slice();
      for (t1 = array.length, i = 0; i < t1; ++i)
        C.JSArray_methods.$indexSet(array, i, H.bindInstantiatedType(array[i], parameters, depth));
      return array;
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, H.stringTypeCheck(property), {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var interceptor, interceptorClass, mark, t1,
        tag = H.stringTypeCheck($.getTagFunction.call$1(obj)),
        record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = H.stringTypeCheck($.alternateTagFunction.call$2(obj, tag));
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var transformers, i, transformer, getTag, getUnknownTag, prototypeForTag,
        hooks = C.C_JS_CONST();
      hooks = H.applyHooksTransformer(C.C_JS_CONST0, H.applyHooksTransformer(C.C_JS_CONST1, H.applyHooksTransformer(C.C_JS_CONST2, H.applyHooksTransformer(C.C_JS_CONST2, H.applyHooksTransformer(C.C_JS_CONST3, H.applyHooksTransformer(C.C_JS_CONST4, H.applyHooksTransformer(C.C_JS_CONST5(C.C_JS_CONST6), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, unicode, dotAll, global) {
      var m = multiLine ? "m" : "",
        i = caseSensitive ? "" : "i",
        u = unicode ? "u" : "",
        s = dotAll ? "s" : "",
        g = global ? "g" : "",
        regexp = function(source, modifiers) {
          try {
            return new RegExp(source, modifiers);
          } catch (e) {
            return e;
          }
        }(source, m + i + u + s + g);
      if (regexp instanceof RegExp)
        return regexp;
      throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1;
      if (typeof other === "string")
        return receiver.indexOf(other, startIndex) >= 0;
      else {
        t1 = J.getInterceptor$(other);
        if (!!t1.$isJSSyntaxRegExp) {
          t1 = C.JSString_methods.substring$1(receiver, startIndex);
          return other._nativeRegExp.test(t1);
        } else {
          t1 = t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex));
          return !t1.get$isEmpty(t1);
        }
      }
    },
    escapeReplacement: function(replacement) {
      if (replacement.indexOf("$", 0) >= 0)
        return replacement.replace(/\$/g, "$$$$");
      return replacement;
    },
    quoteStringForRegExp: function(string) {
      if (/[[\]{}()*+?.\\^$|]/.test(string))
        return string.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
      return string;
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var nativeRegexp;
      if (typeof pattern === "string")
        return H.stringReplaceAllUncheckedString(receiver, pattern, replacement);
      if (pattern instanceof H.JSSyntaxRegExp) {
        nativeRegexp = pattern.get$_nativeGlobalVersion();
        nativeRegexp.lastIndex = 0;
        return receiver.replace(nativeRegexp, H.escapeReplacement(replacement));
      }
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    },
    stringReplaceAllUncheckedString: function(receiver, pattern, replacement) {
      var $length, t1, i, index;
      if (pattern === "") {
        if (receiver === "")
          return replacement;
        $length = receiver.length;
        for (t1 = replacement, i = 0; i < $length; ++i)
          t1 = t1 + receiver[i] + replacement;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      index = receiver.indexOf(pattern, 0);
      if (index < 0)
        return receiver;
      if (receiver.length < 500 || replacement.indexOf("$", 0) >= 0)
        return receiver.split(pattern).join(replacement);
      return receiver.replace(new RegExp(H.quoteStringForRegExp(pattern), 'g'), H.escapeReplacement(replacement));
    },
    _stringIdentity: function(string) {
      return string;
    },
    stringReplaceAllFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
      var t1, startIndex, t2, t3, t4, t5;
      if (!J.getInterceptor$(pattern).$isPattern)
        throw H.wrapException(P.ArgumentError$value(pattern, "pattern", "is not a Pattern"));
      for (t1 = pattern.allMatches$1(0, receiver), t1 = new H._AllMatchesIterator(t1._re, t1._string, t1.__js_helper$_start), startIndex = 0, t2 = ""; t1.moveNext$0(); t2 = t3) {
        t3 = t1.__js_helper$_current;
        t4 = t3._match;
        t5 = t4.index;
        t3 = t2 + H.S(H._js_helper___stringIdentity$closure().call$1(C.JSString_methods.substring$2(receiver, startIndex, t5))) + H.S(onMatch.call$1(t3));
        startIndex = t5 + t4[0].length;
      }
      t1 = t2 + H.S(H._js_helper___stringIdentity$closure().call$1(C.JSString_methods.substring$1(receiver, startIndex)));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    stringReplaceFirstUnchecked: function(receiver, pattern, replacement, startIndex) {
      var index = receiver.indexOf(pattern, startIndex);
      if (index < 0)
        return receiver;
      return H.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
    },
    stringReplaceRangeUnchecked: function(receiver, start, end, replacement) {
      var prefix = receiver.substring(0, start),
        suffix = receiver.substring(end);
      return prefix + replacement + suffix;
    },
    ConstantMapView: function ConstantMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    ConstantMap: function ConstantMap() {
    },
    ConstantMap_map_closure: function ConstantMap_map_closure(t0, t1, t2) {
      this.$this = t0;
      this.transform = t1;
      this.result = t2;
    },
    ConstantStringMap: function ConstantStringMap(t0, t1, t2, t3) {
      var _ = this;
      _._length = t0;
      _.__js_helper$_jsObject = t1;
      _.__js_helper$_keys = t2;
      _.$ti = t3;
    },
    ConstantStringMap_values_closure: function ConstantStringMap_values_closure(t0) {
      this.$this = t0;
    },
    _ConstantMapKeyIterable: function _ConstantMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    GeneralConstantMap: function GeneralConstantMap(t0, t1) {
      this._jsData = t0;
      this.$ti = t1;
    },
    Instantiation: function Instantiation() {
    },
    Instantiation1: function Instantiation1(t0, t1) {
      this._genericClosure = t0;
      this.$ti = t1;
    },
    JSInvocationMirror: function JSInvocationMirror(t0, t1, t2, t3, t4) {
      var _ = this;
      _._memberName = t0;
      _._kind = t1;
      _._arguments = t2;
      _._namedArgumentNames = t3;
      _._typeArgumentCount = t4;
    },
    Primitives_initTicker_closure: function Primitives_initTicker_closure(t0) {
      this.performance = t0;
    },
    Primitives_functionNoSuchMethod_closure: function Primitives_functionNoSuchMethod_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.namedArgumentList = t1;
      this.$arguments = t2;
    },
    TypeErrorDecoder: function TypeErrorDecoder(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._pattern = t0;
      _._arguments = t1;
      _._argumentsExpr = t2;
      _._expr = t3;
      _._method = t4;
      _._receiver = t5;
    },
    NullError: function NullError(t0, t1) {
      this._message = t0;
      this._method = t1;
    },
    JsNoSuchMethodError: function JsNoSuchMethodError(t0, t1, t2) {
      this._message = t0;
      this._method = t1;
      this._receiver = t2;
    },
    UnknownJsTypeError: function UnknownJsTypeError(t0) {
      this._message = t0;
    },
    ExceptionAndStackTrace: function ExceptionAndStackTrace(t0, t1) {
      this.dartException = t0;
      this.stackTrace = t1;
    },
    unwrapException_saveStackTrace: function unwrapException_saveStackTrace(t0) {
      this.ex = t0;
    },
    _StackTrace: function _StackTrace(t0) {
      this._exception = t0;
      this._trace = null;
    },
    Closure: function Closure() {
    },
    TearOffClosure: function TearOffClosure() {
    },
    StaticClosure: function StaticClosure() {
    },
    BoundClosure: function BoundClosure(t0, t1, t2, t3) {
      var _ = this;
      _._self = t0;
      _._target = t1;
      _._receiver = t2;
      _._name = t3;
    },
    TypeErrorImplementation: function TypeErrorImplementation(t0) {
      this.message = t0;
    },
    CastErrorImplementation: function CastErrorImplementation(t0) {
      this.message = t0;
    },
    RuntimeError: function RuntimeError(t0) {
      this.message = t0;
    },
    _AssertionError: function _AssertionError(t0) {
      this.message = t0;
    },
    TypeImpl: function TypeImpl(t0) {
      this._rti = t0;
      this.__js_helper$_hashCode = this.__typeName = null;
    },
    JsLinkedHashMap: function JsLinkedHashMap(t0) {
      var _ = this;
      _._length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    JsLinkedHashMap_values_closure: function JsLinkedHashMap_values_closure(t0) {
      this.$this = t0;
    },
    JsLinkedHashMap_addAll_closure: function JsLinkedHashMap_addAll_closure(t0) {
      this.$this = t0;
    },
    LinkedHashMapCell: function LinkedHashMapCell(t0, t1) {
      var _ = this;
      _.hashMapCellKey = t0;
      _.hashMapCellValue = t1;
      _._previous = _._next = null;
    },
    LinkedHashMapKeyIterable: function LinkedHashMapKeyIterable(t0, t1) {
      this._map = t0;
      this.$ti = t1;
    },
    LinkedHashMapKeyIterator: function LinkedHashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._map = t0;
      _._modifications = t1;
      _.__js_helper$_current = _._cell = null;
      _.$ti = t2;
    },
    initHooks_closure: function initHooks_closure(t0) {
      this.getTag = t0;
    },
    initHooks_closure0: function initHooks_closure0(t0) {
      this.getUnknownTag = t0;
    },
    initHooks_closure1: function initHooks_closure1(t0) {
      this.prototypeForTag = t0;
    },
    JSSyntaxRegExp: function JSSyntaxRegExp(t0, t1) {
      var _ = this;
      _.pattern = t0;
      _._nativeRegExp = t1;
      _._nativeAnchoredRegExp = _._nativeGlobalRegExp = null;
    },
    _MatchImplementation: function _MatchImplementation(t0) {
      this._match = t0;
    },
    _AllMatchesIterable: function _AllMatchesIterable(t0, t1, t2) {
      this._re = t0;
      this._string = t1;
      this.__js_helper$_start = t2;
    },
    _AllMatchesIterator: function _AllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._regExp = t0;
      _._string = t1;
      _._nextIndex = t2;
      _.__js_helper$_current = null;
    },
    StringMatch: function StringMatch(t0, t1) {
      this.start = t0;
      this.pattern = t1;
    },
    _StringAllMatchesIterable: function _StringAllMatchesIterable(t0, t1, t2) {
      this._input = t0;
      this._pattern = t1;
      this.__js_helper$_index = t2;
    },
    _StringAllMatchesIterator: function _StringAllMatchesIterator(t0, t1, t2) {
      var _ = this;
      _._input = t0;
      _._pattern = t1;
      _.__js_helper$_index = t2;
      _.__js_helper$_current = null;
    },
    _checkLength: function($length) {
      return $length;
    },
    _checkViewArguments: function(buffer, offsetInBytes, $length) {
    },
    _ensureNativeList: function(list) {
      var t2, result, i,
        t1 = J.getInterceptor$(list);
      if (!!t1.$isJSIndexable)
        return list;
      t2 = t1.get$length(list);
      if (typeof t2 !== "number")
        return H.iae(t2);
      result = new Array(t2);
      result.fixed$length = Array;
      i = 0;
      while (true) {
        t2 = t1.get$length(list);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        C.JSArray_methods.$indexSet(result, i, t1.$index(list, i));
        ++i;
      }
      return result;
    },
    NativeByteData_NativeByteData$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new DataView(buffer, offsetInBytes) : new DataView(buffer, offsetInBytes, $length);
    },
    NativeFloat32List__create1: function(arg) {
      return new Float32Array(arg);
    },
    NativeInt8List__create1: function(arg) {
      return new Int8Array(arg);
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      H._checkViewArguments(buffer, offsetInBytes, $length);
      return $length == null ? new Uint8Array(buffer, offsetInBytes) : new Uint8Array(buffer, offsetInBytes, $length);
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        t1 = end >>> 0 !== end || start > end || end > $length;
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      return end;
    },
    NativeByteBuffer: function NativeByteBuffer() {
    },
    NativeTypedData: function NativeTypedData() {
    },
    NativeByteData: function NativeByteData() {
    },
    NativeTypedArray: function NativeTypedArray() {
    },
    NativeTypedArrayOfDouble: function NativeTypedArrayOfDouble() {
    },
    NativeTypedArrayOfInt: function NativeTypedArrayOfInt() {
    },
    NativeFloat32List: function NativeFloat32List() {
    },
    NativeFloat64List: function NativeFloat64List() {
    },
    NativeInt16List: function NativeInt16List() {
    },
    NativeInt32List: function NativeInt32List() {
    },
    NativeInt8List: function NativeInt8List() {
    },
    NativeUint16List: function NativeUint16List() {
    },
    NativeUint32List: function NativeUint32List() {
    },
    NativeUint8ClampedList: function NativeUint8ClampedList() {
    },
    NativeUint8List: function NativeUint8List() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin() {
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: function _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin() {
    },
    isBrowserObject: function(o) {
      var t1 = J.getInterceptor$(o);
      return !!t1.$isBlob || !!t1.$isEvent || !!t1.$isKeyRange || !!t1.$isImageData || !!t1.$isNode || !!t1.$isWindow || !!t1.$isWorkerGlobalScope;
    },
    extractKeys: function(victim) {
      return J.JSArray_JSArray$markFixed(victim ? Object.keys(victim) : [], null);
    },
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  },
  J = {
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var proto, objectProto, $constructor, interceptor,
        record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    JSArray_JSArray$fixed: function($length, $E) {
      if (typeof $length !== "number" || Math.floor($length) !== $length)
        throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
      if ($length < 0 || $length > 4294967295)
        throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
      return J.JSArray_JSArray$markFixed(new Array($length), $E);
    },
    JSArray_JSArray$markFixed: function(allocation, $E) {
      return J.JSArray_markFixedList(H.setRuntimeTypeInfo(allocation, [$E]));
    },
    JSArray_markFixedList: function(list) {
      H.listTypeCheck(list);
      list.fixed$length = Array;
      return list;
    },
    JSArray_markUnmodifiableList: function(list) {
      list.fixed$length = Array;
      list.immutable$list = Array;
      return list;
    },
    JSArray__compareAny: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    JSString__isWhitespace: function(codeUnit) {
      if (codeUnit < 256)
        switch (codeUnit) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 133:
          case 160:
            return true;
          default:
            return false;
        }
      switch (codeUnit) {
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8232:
        case 8233:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    },
    JSString__skipLeadingWhitespace: function(string, index) {
      var t1, codeUnit;
      for (t1 = string.length; index < t1;) {
        codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
        ++index;
      }
      return index;
    },
    JSString__skipTrailingWhitespace: function(string, index) {
      var index0, codeUnit;
      for (; index > 0; index = index0) {
        index0 = index - 1;
        codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
        if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
          break;
      }
      return index;
    },
    getInterceptor$: function(receiver) {
      if (typeof receiver == "number") {
        if (Math.floor(receiver) == receiver)
          return J.JSInt.prototype;
        return J.JSDouble.prototype;
      }
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return J.JSNull.prototype;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ansx: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$asx: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$ax: function(receiver) {
      if (receiver == null)
        return receiver;
      if (receiver.constructor == Array)
        return J.JSArray.prototype;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$bn: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (typeof receiver == "boolean")
        return J.JSBool.prototype;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$n: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$ns: function(receiver) {
      if (typeof receiver == "number")
        return J.JSNumber.prototype;
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$s: function(receiver) {
      if (typeof receiver == "string")
        return J.JSString.prototype;
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    getInterceptor$x: function(receiver) {
      if (receiver == null)
        return receiver;
      if (typeof receiver != "object") {
        if (typeof receiver == "function")
          return J.JavaScriptFunction.prototype;
        return receiver;
      }
      if (receiver instanceof P.Object)
        return receiver;
      return J.getNativeInterceptor(receiver);
    },
    getInterceptor$z: function(receiver) {
      if (receiver == null)
        return receiver;
      if (!(receiver instanceof P.Object))
        return J.UnknownJavaScriptObject.prototype;
      return receiver;
    },
    set$hoverinfo$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$hoverinfo(receiver, value);
    },
    set$innerHtml$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$innerHtml(receiver, value);
    },
    set$length$asx: function(receiver, value) {
      return J.getInterceptor$asx(receiver).set$length(receiver, value);
    },
    set$parent$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$parent(receiver, value);
    },
    set$visible$x: function(receiver, value) {
      return J.getInterceptor$x(receiver).set$visible(receiver, value);
    },
    get$attributes$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$attributes(receiver);
    },
    get$children$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$children(receiver);
    },
    get$classes$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$classes(receiver);
    },
    get$entries$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$entries(receiver);
    },
    get$first$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$first(receiver);
    },
    get$hashCode$: function(receiver) {
      return J.getInterceptor$(receiver).get$hashCode(receiver);
    },
    get$id$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$id(receiver);
    },
    get$innerHtml$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$innerHtml(receiver);
    },
    get$isEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
    },
    get$isNegative$n: function(receiver) {
      return J.getInterceptor$n(receiver).get$isNegative(receiver);
    },
    get$isNotEmpty$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
    },
    get$iterator$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$iterator(receiver);
    },
    get$keys$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$keys(receiver);
    },
    get$kind$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$kind(receiver);
    },
    get$last$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).get$last(receiver);
    },
    get$length$asx: function(receiver) {
      return J.getInterceptor$asx(receiver).get$length(receiver);
    },
    get$level$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$level(receiver);
    },
    get$message$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$message(receiver);
    },
    get$name$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$name(receiver);
    },
    get$offset$z: function(receiver) {
      return J.getInterceptor$z(receiver).get$offset(receiver);
    },
    get$onBlur$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onBlur(receiver);
    },
    get$onChange$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onChange(receiver);
    },
    get$onClick$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onClick(receiver);
    },
    get$onDoubleClick$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onDoubleClick(receiver);
    },
    get$onFocus$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onFocus(receiver);
    },
    get$onKeyDown$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onKeyDown(receiver);
    },
    get$onKeyUp$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onKeyUp(receiver);
    },
    get$onMouseDown$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onMouseDown(receiver);
    },
    get$onMouseLeave$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onMouseLeave(receiver);
    },
    get$onMouseOver$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onMouseOver(receiver);
    },
    get$onMouseWheel$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onMouseWheel(receiver);
    },
    get$onResize$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onResize(receiver);
    },
    get$onScroll$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$onScroll(receiver);
    },
    get$points$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$points(receiver);
    },
    get$runtimeType$: function(receiver) {
      return J.getInterceptor$(receiver).get$runtimeType(receiver);
    },
    get$setRequestHeader$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$setRequestHeader(receiver);
    },
    get$shapes$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$shapes(receiver);
    },
    get$source$z: function(receiver) {
      return J.getInterceptor$z(receiver).get$source(receiver);
    },
    get$valueAsString$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$valueAsString(receiver);
    },
    get$values$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$values(receiver);
    },
    get$x$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$x(receiver);
    },
    get$y$x: function(receiver) {
      return J.getInterceptor$x(receiver).get$y(receiver);
    },
    $add$ansx: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver + a0;
      return J.getInterceptor$ansx(receiver).$add(receiver, a0);
    },
    $and$bn: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return (receiver & a0) >>> 0;
      return J.getInterceptor$bn(receiver).$and(receiver, a0);
    },
    $div$n: function(receiver, a0) {
      if (typeof receiver == "number" && typeof a0 == "number")
        return receiver / a0;
      return J.getInterceptor$n(receiver).$div(receiver, a0);
    },
    $eq$: function(receiver, a0) {
      if (receiver == null)
        return a0 == null;
      if (typeof receiver != "object")
        return a0 != null && receiver === a0;
      return J.getInterceptor$(receiver).$eq(receiver, a0);
    },
    $index$asx: function(receiver, a0) {
      if (typeof a0 === "number")
        if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
          if (a0 >>> 0 === a0 && a0 < receiver.length)
            return receiver[a0];
      return J.getInterceptor$asx(receiver).$index(receiver, a0);
    },
    $indexSet$ax: function(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
    },
    _add$1$z: function(receiver, a0) {
      return J.getInterceptor$z(receiver)._add$1(receiver, a0);
    },
    _clearChildren$0$x: function(receiver) {
      return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
    },
    _codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver)._codeUnitAt$1(receiver, a0);
    },
    _removeEventListener$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver)._removeEventListener$3(receiver, a0, a1, a2);
    },
    _replaceChild$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver)._replaceChild$2(receiver, a0, a1);
    },
    add$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).add$1(receiver, a0);
    },
    addEventListener$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
    },
    append$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).append$1(receiver, a0);
    },
    cast$1$0$ax: function(receiver, $T1) {
      return J.getInterceptor$ax(receiver).cast$1$0(receiver, $T1);
    },
    clamp$2$n: function(receiver, a0, a1) {
      return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
    },
    clear$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).clear$0(receiver);
    },
    click$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).click$1(receiver, a0);
    },
    close$0$z: function(receiver) {
      return J.getInterceptor$z(receiver).close$0(receiver);
    },
    codeUnitAt$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
    },
    compareTo$1$ns: function(receiver, a0) {
      return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
    },
    contains$1$asx: function(receiver, a0) {
      return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
    },
    contains$2$asx: function(receiver, a0, a1) {
      return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
    },
    containsKey$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).containsKey$1(receiver, a0);
    },
    destroy$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).destroy$0(receiver);
    },
    destroy$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).destroy$2(receiver, a0, a1);
    },
    elementAt$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
    },
    endsWith$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
    },
    fillRange$3$x: function(receiver, a0, a1, a2) {
      return J.getInterceptor$x(receiver).fillRange$3(receiver, a0, a1, a2);
    },
    focus$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).focus$0(receiver);
    },
    forEach$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
    },
    getSelection$3$z: function(receiver, a0, a1, a2) {
      return J.getInterceptor$z(receiver).getSelection$3(receiver, a0, a1, a2);
    },
    insert$2$ax: function(receiver, a0, a1) {
      return J.getInterceptor$ax(receiver).insert$2(receiver, a0, a1);
    },
    join$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).join$1(receiver, a0);
    },
    lastIndexOf$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).lastIndexOf$1(receiver, a0);
    },
    map$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).map$1(receiver, a0);
    },
    map$1$1$ax: function(receiver, a0, $T1) {
      return J.getInterceptor$ax(receiver).map$1$1(receiver, a0, $T1);
    },
    map$2$1$ax: function(receiver, a0, $T1, $T2) {
      return J.getInterceptor$ax(receiver).map$2$1(receiver, a0, $T1, $T2);
    },
    matchAsPrefix$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
    },
    noSuchMethod$1$: function(receiver, a0) {
      return J.getInterceptor$(receiver).noSuchMethod$1(receiver, a0);
    },
    readAsText$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).readAsText$1(receiver, a0);
    },
    remove$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).remove$0(receiver);
    },
    remove$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
    },
    removeAt$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).removeAt$1(receiver, a0);
    },
    removeWhere$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).removeWhere$1(receiver, a0);
    },
    replaceWith$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).replaceWith$1(receiver, a0);
    },
    round$0$n: function(receiver) {
      return J.getInterceptor$n(receiver).round$0(receiver);
    },
    scrollIntoView$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).scrollIntoView$0(receiver);
    },
    scrollIntoView$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).scrollIntoView$1(receiver, a0);
    },
    scrollTo$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).scrollTo$1(receiver, a0);
    },
    scrollTo$2$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).scrollTo$2(receiver, a0, a1);
    },
    send$1$x: function(receiver, a0) {
      return J.getInterceptor$x(receiver).send$1(receiver, a0);
    },
    setInnerHtml$2$treeSanitizer$x: function(receiver, a0, a1) {
      return J.getInterceptor$x(receiver).setInnerHtml$2$treeSanitizer(receiver, a0, a1);
    },
    setRange$4$ax: function(receiver, a0, a1, a2, a3) {
      return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
    },
    skip$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
    },
    sort$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).sort$1(receiver, a0);
    },
    split$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).split$1(receiver, a0);
    },
    splitMapJoin$2$onMatch$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).splitMapJoin$2$onMatch(receiver, a0, a1);
    },
    startsWith$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
    },
    startsWith$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
    },
    stop$0$z: function(receiver) {
      return J.getInterceptor$z(receiver).stop$0(receiver);
    },
    substring$1$s: function(receiver, a0) {
      return J.getInterceptor$s(receiver).substring$1(receiver, a0);
    },
    substring$2$s: function(receiver, a0, a1) {
      return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
    },
    take$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).take$1(receiver, a0);
    },
    toList$0$ax: function(receiver) {
      return J.getInterceptor$ax(receiver).toList$0(receiver);
    },
    toLowerCase$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
    },
    toString$0$: function(receiver) {
      return J.getInterceptor$(receiver).toString$0(receiver);
    },
    trim$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trim$0(receiver);
    },
    trimLeft$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimLeft$0(receiver);
    },
    trimRight$0$s: function(receiver) {
      return J.getInterceptor$s(receiver).trimRight$0(receiver);
    },
    update$0$x: function(receiver) {
      return J.getInterceptor$x(receiver).update$0(receiver);
    },
    where$1$ax: function(receiver, a0) {
      return J.getInterceptor$ax(receiver).where$1(receiver, a0);
    },
    Interceptor: function Interceptor() {
    },
    JSBool: function JSBool() {
    },
    JSNull: function JSNull() {
    },
    JSObject: function JSObject() {
    },
    JavaScriptObject: function JavaScriptObject() {
    },
    PlainJavaScriptObject: function PlainJavaScriptObject() {
    },
    UnknownJavaScriptObject: function UnknownJavaScriptObject() {
    },
    JavaScriptFunction: function JavaScriptFunction() {
    },
    JSArray: function JSArray(t0) {
      this.$ti = t0;
    },
    JSUnmodifiableArray: function JSUnmodifiableArray(t0) {
      this.$ti = t0;
    },
    ArrayIterator: function ArrayIterator(t0, t1, t2) {
      var _ = this;
      _._iterable = t0;
      _.__interceptors$_length = t1;
      _._index = 0;
      _._current = null;
      _.$ti = t2;
    },
    JSNumber: function JSNumber() {
    },
    JSInt: function JSInt() {
    },
    JSDouble: function JSDouble() {
    },
    JSString: function JSString() {
    }
  },
  P = {
    _AsyncRun__initializeScheduleImmediate: function() {
      var div, span, t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithSetImmediate: function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(H.functionTypeCheck(callback, {func: 1, ret: -1})), 0));
    },
    _AsyncRun__scheduleImmediateWithTimer: function(callback) {
      P.Timer__createTimer(C.Duration_0, H.functionTypeCheck(callback, {func: 1, ret: -1}));
    },
    Timer__createTimer: function(duration, callback) {
      var milliseconds;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    Timer__createPeriodicTimer: function(duration, callback) {
      var milliseconds;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Timer]});
      milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$periodic(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _TimerImpl$: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(true);
      t1._TimerImpl$2(milliseconds, callback);
      return t1;
    },
    _TimerImpl$periodic: function(milliseconds, callback) {
      var t1 = new P._TimerImpl(false);
      t1._TimerImpl$periodic$2(milliseconds, callback);
      return t1;
    },
    _makeAsyncAwaitCompleter: function($T) {
      return new P._AsyncAwaitCompleter(new P._SyncCompleter(new P._Future($.Zone__current, [$T]), [$T]), [$T]);
    },
    _asyncStartSync: function(bodyFunction, completer) {
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      H.interceptedTypeCheck(completer, "$is_AsyncAwaitCompleter");
      bodyFunction.call$2(0, null);
      completer.isSync = true;
      return completer._completer.future;
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]}));
    },
    _asyncReturn: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").complete$1(0, object);
    },
    _asyncRethrow: function(object, completer) {
      H.interceptedTypeCheck(completer, "$isCompleter").completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future, _null = null;
      H.functionTypeCheck(bodyFunction, {func: 1, ret: -1, args: [P.int,,]});
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor$(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$1$2(thenCallback, errorCallback, _null);
      else if (!!t1.$isFuture)
        object.then$1$2$onError(thenCallback, errorCallback, _null);
      else {
        future = new P._Future($.Zone__current, [null]);
        H.assertSubtypeOfRuntimeType(object, null);
        future._state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$1$2(thenCallback, _null, _null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$3$1(new P._wrapJsFunctionForAsync_closure($protected), P.Null, P.int, null);
    },
    _IterationMarker_yieldStar: function(values) {
      return new P._IterationMarker(values, 1);
    },
    _IterationMarker_endOfIteration: function() {
      return C._IterationMarker_null_2;
    },
    _IterationMarker_uncaughtError: function(error) {
      return new P._IterationMarker(error, 3);
    },
    _makeSyncStarIterable: function(body, $T) {
      return new P._SyncStarIterable(body, [$T]);
    },
    Future_Future: function(computation, $T) {
      var result;
      H.functionTypeCheck(computation, {func: 1, ret: {futureOr: 1, type: $T}});
      result = new P._Future($.Zone__current, [$T]);
      P.Timer_Timer(C.Duration_0, new P.Future_Future_closure(result, computation));
      return result;
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1, replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone) {
        replacement = t1.errorCallback$2(error, stackTrace);
        if (replacement != null) {
          error = replacement.error;
          if (error == null)
            error = new P.NullThrownError();
          stackTrace = replacement.stackTrace;
        }
      }
      t1 = new P._Future($.Zone__current, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_wait: function(futures, $T) {
      var result, handleError, future, pos, e, st, t1, t2, t3, exception, _box_0 = {}, cleanUp = null,
        eagerError = false;
      H.assertSubtype(futures, "$isIterable", [[P.Future, $T]], "$asIterable");
      t1 = [P.List, $T];
      t2 = [t1];
      result = new P._Future($.Zone__current, t2);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.stackTrace = _box_0.error = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, eagerError, result);
      try {
        for (t3 = J.get$iterator$ax(futures); t3.moveNext$0();) {
          future = t3.get$current(t3);
          pos = _box_0.remaining;
          future.then$1$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, eagerError, $T), handleError, null);
          ++_box_0.remaining;
        }
        t3 = _box_0.remaining;
        if (t3 === 0) {
          t2 = new P._Future($.Zone__current, t2);
          t2._asyncComplete$1(C.List_empty1);
          return t2;
        }
        t2 = new Array(t3);
        t2.fixed$length = Array;
        _box_0.values = H.setRuntimeTypeInfo(t2, [$T]);
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || H.boolConversionCheck(eagerError))
          return P.Future_Future$error(e, st, t1);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    Future_forEach: function(elements, action, $T) {
      H.assertSubtype(elements, "$isIterable", [$T], "$asIterable");
      H.functionTypeCheck(action, {func: 1, ret: {futureOr: 1}, args: [$T]});
      return P.Future_doWhile(new P.Future_forEach_closure(new J.ArrayIterator(elements, elements.length, [H.getTypeArgumentByIndex(elements, 0)]), action));
    },
    Future__kTrue: function(_) {
      return true;
    },
    Future_doWhile: function(action) {
      var t2, doneSignal, nextIteration, t1 = {};
      H.functionTypeCheck(action, {func: 1, ret: {futureOr: 1, type: P.bool}});
      t2 = $.Zone__current;
      doneSignal = new P._Future(t2, [null]);
      t1.nextIteration = null;
      nextIteration = t2.bindUnaryCallbackGuarded$1$1(new P.Future_doWhile_closure(t1, action, doneSignal), P.bool);
      t1.nextIteration = nextIteration;
      nextIteration.call$1(true);
      return doneSignal;
    },
    _completeWithErrorCallback: function(result, error, stackTrace) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      result._completeError$2(error, stackTrace);
    },
    _Future$zoneValue: function(value, _zone, $T) {
      var t1 = new P._Future(_zone, [$T]);
      H.assertSubtypeOfRuntimeType(value, $T);
      t1._state = 4;
      t1._resultOrListeners = value;
      return t1;
    },
    _Future__chainForeignFuture: function(source, target) {
      var e, s, exception;
      target._state = 1;
      try {
        source.then$1$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
      }
    },
    _Future__chainCoreFuture: function(source, target) {
      var t1, listeners;
      for (; t1 = source._state, t1 === 2;)
        source = H.interceptedTypeCheck(source._resultOrListeners, "$is_Future");
      if (t1 >= 4) {
        listeners = target._removeListeners$0();
        target._state = source._state;
        target._resultOrListeners = source._resultOrListeners;
        P._Future__propagateToListeners(target, listeners);
      } else {
        listeners = H.interceptedTypeCheck(target._resultOrListeners, "$is_FutureListener");
        target._state = 2;
        target._resultOrListeners = source;
        source._prependListeners$1(listeners);
      }
    },
    _Future__propagateToListeners: function(source, listeners) {
      var _box_0, hasError, asyncError, listeners0, sourceResult, t2, t3, zone, oldZone, current, result, _box_1 = {},
        t1 = _box_1.source = source;
      for (; true;) {
        _box_0 = {};
        hasError = t1._state === 8;
        if (listeners == null) {
          if (hasError) {
            asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t1._zone.handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
          }
          return;
        }
        for (; listeners0 = listeners._nextListener, listeners0 != null; listeners = listeners0) {
          listeners._nextListener = null;
          P._Future__propagateToListeners(_box_1.source, listeners);
        }
        t1 = _box_1.source;
        sourceResult = t1._resultOrListeners;
        _box_0.listenerHasError = hasError;
        _box_0.listenerValueOrError = sourceResult;
        t2 = !hasError;
        if (t2) {
          t3 = listeners.state;
          t3 = (t3 & 1) !== 0 || t3 === 8;
        } else
          t3 = true;
        if (t3) {
          t3 = listeners.result;
          zone = t3._zone;
          if (hasError) {
            t1 = t1._zone;
            t1.toString;
            t1 = !(t1 == zone || t1.get$errorZone() === zone.get$errorZone());
          } else
            t1 = false;
          if (t1) {
            t1 = _box_1.source;
            asyncError = H.interceptedTypeCheck(t1._resultOrListeners, "$isAsyncError");
            t1._zone.handleUncaughtError$2(asyncError.error, asyncError.stackTrace);
            return;
          }
          oldZone = $.Zone__current;
          if (oldZone != zone)
            $.Zone__current = zone;
          else
            oldZone = null;
          t1 = listeners.state;
          if (t1 === 8)
            new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
          else if (t2) {
            if ((t1 & 1) !== 0)
              new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
          } else if ((t1 & 2) !== 0)
            new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
          if (oldZone != null)
            $.Zone__current = oldZone;
          t1 = _box_0.listenerValueOrError;
          if (!!J.getInterceptor$(t1).$isFuture) {
            if (!!t1.$is_Future)
              if (t1._state >= 4) {
                current = H.interceptedTypeCheck(t3._resultOrListeners, "$is_FutureListener");
                t3._resultOrListeners = null;
                listeners = t3._reverseListeners$1(current);
                t3._state = t1._state;
                t3._resultOrListeners = t1._resultOrListeners;
                _box_1.source = t1;
                continue;
              } else
                P._Future__chainCoreFuture(t1, t3);
            else
              P._Future__chainForeignFuture(t1, t3);
            return;
          }
        }
        result = listeners.result;
        current = H.interceptedTypeCheck(result._resultOrListeners, "$is_FutureListener");
        result._resultOrListeners = null;
        listeners = result._reverseListeners$1(current);
        t1 = _box_0.listenerHasError;
        t2 = _box_0.listenerValueOrError;
        if (!t1) {
          H.assertSubtypeOfRuntimeType(t2, H.getTypeArgumentByIndex(result, 0));
          result._state = 4;
          result._resultOrListeners = t2;
        } else {
          H.interceptedTypeCheck(t2, "$isAsyncError");
          result._state = 8;
          result._resultOrListeners = t2;
        }
        _box_1.source = result;
        t1 = result;
      }
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$3$1(errorHandler, null, P.Object, P.StackTrace);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]}))
        return zone.registerUnaryCallback$2$1(errorHandler, null, P.Object);
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.next;
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.callback.call$0();
      }
    },
    _startMicrotaskLoop: function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    },
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(H.functionTypeCheck(callback, {func: 1, ret: -1}));
      if ($._nextCallback == null) {
        $._nextCallback = $._lastCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else
        $._lastCallback = $._lastCallback.next = newEntry;
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var t1, entry, t2;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._nextCallback = $._lastPriorityCallback = entry;
      } else {
        entry.next = t2.next;
        $._lastPriorityCallback = t2.next = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var currentZone, t1, _null = null;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(_null, _null, C.C__RootZone, callback);
        return;
      }
      if (C.C__RootZone === currentZone.get$_scheduleMicrotask().zone)
        t1 = C.C__RootZone.get$errorZone() === currentZone.get$errorZone();
      else
        t1 = false;
      if (t1) {
        P._rootScheduleMicrotask(_null, _null, currentZone, currentZone.registerCallback$1$1(callback, -1));
        return;
      }
      t1 = $.Zone__current;
      t1.scheduleMicrotask$1(t1.bindCallbackGuarded$1(callback));
    },
    Stream_Stream$fromIterable: function(elements, $T) {
      return new P._GeneratedStreamImpl(new P.Stream_Stream$fromIterable_closure(H.assertSubtype(elements, "$isIterable", [$T], "$asIterable"), $T), [$T]);
    },
    StreamIterator_StreamIterator: function(stream, $T) {
      if (H.assertSubtype(stream, "$isStream", [$T], "$asStream") == null)
        H.throwExpression(P.ArgumentError$notNull("stream"));
      return new P._StreamIterator([$T]);
    },
    StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
      var t1 = {func: 1, ret: -1};
      H.functionTypeCheck(onListen, t1);
      H.functionTypeCheck(onPause, t1);
      H.functionTypeCheck(onResume, t1);
      H.functionTypeCheck(onCancel, {func: 1});
      return sync ? new P._SyncStreamController(onListen, onPause, onResume, onCancel, [$T]) : new P._AsyncStreamController(onListen, onPause, onResume, onCancel, [$T]);
    },
    StreamController_StreamController$broadcast: function(onCancel, onListen, sync, $T) {
      var t1 = {func: 1, ret: -1};
      H.functionTypeCheck(onListen, t1);
      H.functionTypeCheck(onCancel, t1);
      return sync ? new P._SyncBroadcastStreamController(onListen, onCancel, [$T]) : new P._AsyncBroadcastStreamController(onListen, onCancel, [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception;
      H.functionTypeCheck(notificationHandler, {func: 1});
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        $.Zone__current.handleUncaughtError$2(e, s);
      }
    },
    _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
      var t1 = $.Zone__current,
        t2 = cancelOnError ? 1 : 0;
      t2 = new P._BufferingStreamSubscription(t1, t2, [$T]);
      t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
      return t2;
    },
    _nullDataHandler: function(value) {
    },
    _nullErrorHandler: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      $.Zone__current.handleUncaughtError$2(error, stackTrace);
    },
    _nullDoneHandler: function() {
    },
    _runUserCode: function(userCode, onSuccess, onError, $T) {
      var e, s, replacement, error, stackTrace, exception, error0;
      H.functionTypeCheck(userCode, {func: 1, ret: $T});
      H.functionTypeCheck(onSuccess, {func: 1, args: [$T]});
      H.functionTypeCheck(onError, {func: 1, args: [, P.StackTrace]});
      try {
        onSuccess.call$1(userCode.call$0());
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        replacement = $.Zone__current.errorCallback$2(e, s);
        if (replacement == null)
          onError.call$2(e, s);
        else {
          error0 = replacement.error;
          error = error0 == null ? new P.NullThrownError() : error0;
          stackTrace = replacement.stackTrace;
          onError.call$2(error, stackTrace);
        }
      }
    },
    _cancelAndError: function(subscription, future, error, stackTrace) {
      var cancelFuture = subscription.cancel$0(0);
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
      else
        future._completeError$2(error, stackTrace);
    },
    _cancelAndErrorClosure: function(subscription, future) {
      return new P._cancelAndErrorClosure_closure(subscription, future);
    },
    _cancelAndValue: function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0(0);
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    },
    _addErrorWithReplacement: function(sink, error, stackTrace) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      sink._addError$2(error, stackTrace);
    },
    Timer_Timer: function(duration, callback) {
      var t1;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return t1.createTimer$2(duration, callback);
      return t1.createTimer$2(duration, t1.bindCallbackGuarded$1(callback));
    },
    Timer_Timer$periodic: function(duration, callback) {
      var t1, boundCallback;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Timer]});
      t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return t1.createPeriodicTimer$2(duration, callback);
      boundCallback = t1.bindUnaryCallbackGuarded$1$1(callback, P.Timer);
      return $.Zone__current.createPeriodicTimer$2(duration, boundCallback);
    },
    _ZoneSpecification$: function(createPeriodicTimer, createTimer, errorCallback, fork, handleUncaughtError, $print, registerBinaryCallback, registerCallback, registerUnaryCallback, run, runBinary, runUnary, scheduleMicrotask) {
      return new P._ZoneSpecification(handleUncaughtError, run, runUnary, runBinary, registerCallback, registerUnaryCallback, registerBinaryCallback, errorCallback, scheduleMicrotask, createTimer, createPeriodicTimer, $print, fork);
    },
    _parentDelegate: function(zone) {
      if (zone.get$parent(zone) == null)
        return;
      return zone.get$parent(zone).get$_delegate();
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    _rootRun: function($self, $parent, zone, f, $R) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R});
      t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg, $R, $T) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2, $R, T1, T2) {
      var old, t1;
      H.interceptedTypeCheck($self, "$isZone");
      H.interceptedTypeCheck($parent, "$isZoneDelegate");
      H.interceptedTypeCheck(zone, "$isZone");
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      t1 = $.Zone__current;
      if (t1 == zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRegisterCallback: function($self, $parent, zone, f, $R) {
      return H.functionTypeCheck(f, {func: 1, ret: $R});
    },
    _rootRegisterUnaryCallback: function($self, $parent, zone, f, $R, $T) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
    },
    _rootRegisterBinaryCallback: function($self, $parent, zone, f, $R, T1, T2) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
    },
    _rootErrorCallback: function($self, $parent, zone, error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      return;
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      t1 = C.C__RootZone !== zone;
      if (t1)
        f = !(!t1 || C.C__RootZone.get$errorZone() === zone.get$errorZone()) ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1$1(f, -1);
      P._scheduleAsyncCallback(f);
    },
    _rootCreateTimer: function($self, $parent, zone, duration, callback) {
      H.interceptedTypeCheck(duration, "$isDuration");
      callback = zone.bindCallback$1$1(H.functionTypeCheck(callback, {func: 1, ret: -1}), -1);
      return P.Timer__createTimer(duration, callback);
    },
    _rootCreatePeriodicTimer: function($self, $parent, zone, duration, callback) {
      H.interceptedTypeCheck(duration, "$isDuration");
      callback = zone.bindUnaryCallback$2$1(H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.Timer]}), null, P.Timer);
      return P.Timer__createPeriodicTimer(duration, callback);
    },
    _rootPrint: function($self, $parent, zone, line) {
      H.printString(H.stringTypeCheck(line));
    },
    _printToZone: function(line) {
      $.Zone__current.print$1(0, line);
    },
    _rootFork: function($self, $parent, zone, specification, zoneValues) {
      var valueMap, t1, t2;
      H.interceptedTypeCheck(specification, "$isZoneSpecification");
      H.interceptedTypeCheck(zoneValues, "$isMap");
      $.printToZone = P.async___printToZone$closure();
      if (specification == null)
        specification = C._ZoneSpecification_ALf;
      valueMap = zone.get$_async$_map();
      t1 = new P._CustomZone(zone, valueMap);
      t2 = zone.get$_run();
      t1.set$_run(t2);
      t2 = zone.get$_runUnary();
      t1.set$_runUnary(t2);
      t2 = zone.get$_runBinary();
      t1.set$_runBinary(t2);
      t2 = zone.get$_registerCallback();
      t1.set$_registerCallback(t2);
      t2 = zone.get$_registerUnaryCallback();
      t1.set$_registerUnaryCallback(t2);
      t2 = zone.get$_registerBinaryCallback();
      t1.set$_registerBinaryCallback(t2);
      t2 = zone.get$_errorCallback();
      t1.set$_errorCallback(t2);
      t2 = zone.get$_scheduleMicrotask();
      t1.set$_scheduleMicrotask(t2);
      t2 = zone.get$_createTimer();
      t1.set$_createTimer(t2);
      t2 = zone.get$_createPeriodicTimer();
      t1.set$_createPeriodicTimer(t2);
      t2 = zone.get$_print();
      t1.set$_print(t2);
      t2 = zone.get$_fork();
      t1.set$_fork(t2);
      t2 = specification.handleUncaughtError;
      t1.set$_handleUncaughtError(t2 != null ? new P._ZoneFunction(t1, t2, [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]) : zone.get$_handleUncaughtError());
      return t1;
    },
    runZoned: function(body, onError, $R) {
      var e, stackTrace, errorHandler, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, exception, _null = null, t1 = {}, zoneSpecification = null, zoneValues = null;
      H.functionTypeCheck(body, {func: 1, ret: $R});
      t1.binaryOnError = t1.unaryOnError = null;
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        t1.binaryOnError = onError;
      else if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object]}))
        t1.unaryOnError = onError;
      else
        throw H.wrapException(P.ArgumentError$("onError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      errorHandler = new P.runZoned_closure(t1);
      if (zoneSpecification == null)
        zoneSpecification = P._ZoneSpecification$(_null, _null, _null, _null, errorHandler, _null, _null, _null, _null, _null, _null, _null, _null);
      else {
        t2 = zoneSpecification;
        t3 = t2.run;
        t4 = t2.runUnary;
        t5 = t2.runBinary;
        t6 = t2.registerCallback;
        t7 = t2.registerUnaryCallback;
        t8 = t2.registerBinaryCallback;
        t9 = t2.errorCallback;
        t10 = t2.scheduleMicrotask;
        t11 = t2.createTimer;
        t12 = t2.createPeriodicTimer;
        t13 = t2.print;
        t2 = t2.fork;
        zoneSpecification = P._ZoneSpecification$(t12, t11, t9, t2, errorHandler, t13, t8, t6, t7, t3, t5, t4, t10);
      }
      try {
        t2 = P._runZoned(body, zoneValues, zoneSpecification, $R);
        return t2;
      } catch (exception) {
        e = H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        t2 = t1.binaryOnError;
        if (t2 != null)
          t2.call$2(e, stackTrace);
        else
          t1.unaryOnError.call$1(e);
      }
      return;
    },
    _runZoned: function(body, zoneValues, specification, $R) {
      H.functionTypeCheck(body, {func: 1, ret: $R});
      return $.Zone__current.fork$2$specification$zoneValues(specification, zoneValues).run$1$1(body, $R);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: function _AsyncRun__initializeScheduleImmediate_internalCallback(t0) {
      this._box_0 = t0;
    },
    _AsyncRun__initializeScheduleImmediate_closure: function _AsyncRun__initializeScheduleImmediate_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.div = t1;
      this.span = t2;
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: function _AsyncRun__scheduleImmediateJsOverride_internalCallback(t0) {
      this.callback = t0;
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: function _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(t0) {
      this.callback = t0;
    },
    _TimerImpl: function _TimerImpl(t0) {
      this._once = t0;
      this._handle = null;
      this._tick = 0;
    },
    _TimerImpl_internalCallback: function _TimerImpl_internalCallback(t0, t1) {
      this.$this = t0;
      this.callback = t1;
    },
    _TimerImpl$periodic_closure: function _TimerImpl$periodic_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.milliseconds = t1;
      _.start = t2;
      _.callback = t3;
    },
    _AsyncAwaitCompleter: function _AsyncAwaitCompleter(t0, t1) {
      this._completer = t0;
      this.isSync = false;
      this.$ti = t1;
    },
    _AsyncAwaitCompleter_complete_closure: function _AsyncAwaitCompleter_complete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _AsyncAwaitCompleter_completeError_closure: function _AsyncAwaitCompleter_completeError_closure(t0, t1, t2) {
      this.$this = t0;
      this.e = t1;
      this.st = t2;
    },
    _awaitOnObject_closure: function _awaitOnObject_closure(t0) {
      this.bodyFunction = t0;
    },
    _awaitOnObject_closure0: function _awaitOnObject_closure0(t0) {
      this.bodyFunction = t0;
    },
    _wrapJsFunctionForAsync_closure: function _wrapJsFunctionForAsync_closure(t0) {
      this.$protected = t0;
    },
    _IterationMarker: function _IterationMarker(t0, t1) {
      this.value = t0;
      this.state = t1;
    },
    _SyncStarIterator: function _SyncStarIterator(t0, t1) {
      var _ = this;
      _._body = t0;
      _._suspendedBodies = _._nestedIterator = _._async$_current = null;
      _.$ti = t1;
    },
    _SyncStarIterable: function _SyncStarIterable(t0, t1) {
      this._outerHelper = t0;
      this.$ti = t1;
    },
    _BroadcastStream: function _BroadcastStream(t0, t1) {
      this._async$_controller = t0;
      this.$ti = t1;
    },
    _BroadcastSubscription: function _BroadcastSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._eventState = 0;
      _._async$_previous = _._async$_next = null;
      _._async$_controller = t0;
      _._onDone = _._onError = _._onData = null;
      _._zone = t1;
      _._state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _BroadcastStreamController: function _BroadcastStreamController() {
    },
    _SyncBroadcastStreamController: function _SyncBroadcastStreamController(t0, t1, t2) {
      var _ = this;
      _.onListen = t0;
      _.onCancel = t1;
      _._state = 0;
      _._doneFuture = _._addStreamState = _._lastSubscription = _._firstSubscription = null;
      _.$ti = t2;
    },
    _SyncBroadcastStreamController__sendData_closure: function _SyncBroadcastStreamController__sendData_closure(t0, t1) {
      this.$this = t0;
      this.data = t1;
    },
    _SyncBroadcastStreamController__sendError_closure: function _SyncBroadcastStreamController__sendError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _SyncBroadcastStreamController__sendDone_closure: function _SyncBroadcastStreamController__sendDone_closure(t0) {
      this.$this = t0;
    },
    _AsyncBroadcastStreamController: function _AsyncBroadcastStreamController(t0, t1, t2) {
      var _ = this;
      _.onListen = t0;
      _.onCancel = t1;
      _._state = 0;
      _._doneFuture = _._addStreamState = _._lastSubscription = _._firstSubscription = null;
      _.$ti = t2;
    },
    Future: function Future() {
    },
    Future_Future_closure: function Future_Future_closure(t0, t1) {
      this.result = t0;
      this.computation = t1;
    },
    Future_wait_handleError: function Future_wait_handleError(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.cleanUp = t1;
      _.eagerError = t2;
      _.result = t3;
    },
    Future_wait_closure: function Future_wait_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.pos = t1;
      _.result = t2;
      _.cleanUp = t3;
      _.eagerError = t4;
      _.T = t5;
    },
    Future_forEach_closure: function Future_forEach_closure(t0, t1) {
      this.iterator = t0;
      this.action = t1;
    },
    Future_doWhile_closure: function Future_doWhile_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.action = t1;
      this.doneSignal = t2;
    },
    Completer: function Completer() {
    },
    _Completer: function _Completer() {
    },
    _AsyncCompleter: function _AsyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _SyncCompleter: function _SyncCompleter(t0, t1) {
      this.future = t0;
      this.$ti = t1;
    },
    _FutureListener: function _FutureListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._nextListener = null;
      _.result = t0;
      _.state = t1;
      _.callback = t2;
      _.errorCallback = t3;
      _.$ti = t4;
    },
    _Future: function _Future(t0, t1) {
      var _ = this;
      _._state = 0;
      _._zone = t0;
      _._resultOrListeners = null;
      _.$ti = t1;
    },
    _Future__addListener_closure: function _Future__addListener_closure(t0, t1) {
      this.$this = t0;
      this.listener = t1;
    },
    _Future__prependListeners_closure: function _Future__prependListeners_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _Future__chainForeignFuture_closure: function _Future__chainForeignFuture_closure(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure0: function _Future__chainForeignFuture_closure0(t0) {
      this.target = t0;
    },
    _Future__chainForeignFuture_closure1: function _Future__chainForeignFuture_closure1(t0, t1, t2) {
      this.target = t0;
      this.e = t1;
      this.s = t2;
    },
    _Future__asyncComplete_closure: function _Future__asyncComplete_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__chainFuture_closure: function _Future__chainFuture_closure(t0, t1) {
      this.$this = t0;
      this.value = t1;
    },
    _Future__asyncCompleteError_closure: function _Future__asyncCompleteError_closure(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: function _Future__propagateToListeners_handleWhenCompleteCallback(t0, t1, t2, t3) {
      var _ = this;
      _._box_1 = t0;
      _._box_0 = t1;
      _.listener = t2;
      _.hasError = t3;
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: function _Future__propagateToListeners_handleWhenCompleteCallback_closure(t0) {
      this.originalSource = t0;
    },
    _Future__propagateToListeners_handleValueCallback: function _Future__propagateToListeners_handleValueCallback(t0, t1, t2) {
      this._box_0 = t0;
      this.listener = t1;
      this.sourceResult = t2;
    },
    _Future__propagateToListeners_handleError: function _Future__propagateToListeners_handleError(t0, t1, t2) {
      this._box_1 = t0;
      this._box_0 = t1;
      this.listener = t2;
    },
    _AsyncCallbackEntry: function _AsyncCallbackEntry(t0) {
      this.callback = t0;
      this.next = null;
    },
    Stream: function Stream() {
    },
    Stream_Stream$fromIterable_closure: function Stream_Stream$fromIterable_closure(t0, t1) {
      this.elements = t0;
      this.T = t1;
    },
    Stream_asyncMap_onListen: function Stream_asyncMap_onListen(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.E = t2;
      _.convert = t3;
    },
    Stream_asyncMap_onListen_closure: function Stream_asyncMap_onListen_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.convert = t2;
      _.E = t3;
      _.add = t4;
      _.addError = t5;
    },
    Stream_asyncMap_closure: function Stream_asyncMap_closure(t0) {
      this._box_0 = t0;
    },
    Stream_asyncMap_closure1: function Stream_asyncMap_closure1(t0) {
      this._box_0 = t0;
    },
    Stream_asyncMap_closure2: function Stream_asyncMap_closure2(t0) {
      this._box_0 = t0;
    },
    Stream_asyncMap_closure0: function Stream_asyncMap_closure0(t0) {
      this._box_0 = t0;
    },
    Stream_contains_closure: function Stream_contains_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.needle = t2;
      _.future = t3;
    },
    Stream_contains__closure: function Stream_contains__closure(t0, t1) {
      this.element = t0;
      this.needle = t1;
    },
    Stream_contains__closure0: function Stream_contains__closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_contains_closure0: function Stream_contains_closure0(t0) {
      this.future = t0;
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_toList_closure: function Stream_toList_closure(t0, t1) {
      this.$this = t0;
      this.result = t1;
    },
    Stream_toList_closure0: function Stream_toList_closure0(t0, t1) {
      this.future = t0;
      this.result = t1;
    },
    Stream_first_closure: function Stream_first_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.future = t2;
    },
    Stream_first_closure0: function Stream_first_closure0(t0) {
      this.future = t0;
    },
    StreamSubscription: function StreamSubscription() {
    },
    StreamView: function StreamView() {
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    StreamController: function StreamController() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _SyncStreamControllerDispatch: function _SyncStreamControllerDispatch() {
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _SyncStreamController: function _SyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._async$_controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._async$_controller = t0;
      _._onDone = _._onError = _._onData = null;
      _._zone = t1;
      _._state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._onDone = _._onError = _._onData = null;
      _._zone = t0;
      _._state = t1;
      _._pending = _._cancelFuture = null;
      _.$ti = t2;
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _GeneratedStreamImpl: function _GeneratedStreamImpl(t0, t1) {
      this._pending = t0;
      this._isUsed = false;
      this.$ti = t1;
    },
    _IterablePendingEvents: function _IterablePendingEvents(t0, t1) {
      this._async$_iterator = t0;
      this._state = 0;
      this.$ti = t1;
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents() {
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamImplEvents: function _StreamImplEvents(t0) {
      var _ = this;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _._state = 0;
      _.$ti = t0;
    },
    _DoneStreamSubscription: function _DoneStreamSubscription(t0, t1, t2) {
      var _ = this;
      _._zone = t0;
      _._state = 0;
      _._onDone = t1;
      _.$ti = t2;
    },
    _StreamIterator: function _StreamIterator(t0) {
      this.$ti = t0;
    },
    _cancelAndError_closure: function _cancelAndError_closure(t0, t1, t2) {
      this.future = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _cancelAndErrorClosure_closure: function _cancelAndErrorClosure_closure(t0, t1) {
      this.subscription = t0;
      this.future = t1;
    },
    _cancelAndValue_closure: function _cancelAndValue_closure(t0, t1) {
      this.future = t0;
      this.value = t1;
    },
    _ForwardingStream: function _ForwardingStream() {
    },
    _ForwardingStreamSubscription: function _ForwardingStreamSubscription(t0, t1, t2, t3) {
      var _ = this;
      _._stream = t0;
      _._onDone = _._onError = _._onData = _._subscription = null;
      _._zone = t1;
      _._state = t2;
      _._pending = _._cancelFuture = null;
      _.$ti = t3;
    },
    _WhereStream: function _WhereStream(t0, t1, t2) {
      this._test = t0;
      this._async$_source = t1;
      this.$ti = t2;
    },
    _MapStream: function _MapStream(t0, t1, t2) {
      this._transform = t0;
      this._async$_source = t1;
      this.$ti = t2;
    },
    _StreamSubscriptionTransformer: function _StreamSubscriptionTransformer(t0, t1) {
      this._onListen = t0;
      this.$ti = t1;
    },
    _BoundSubscriptionStream: function _BoundSubscriptionStream(t0, t1, t2) {
      this._onListen = t0;
      this._stream = t1;
      this.$ti = t2;
    },
    Timer: function Timer() {
    },
    AsyncError: function AsyncError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    _ZoneFunction: function _ZoneFunction(t0, t1, t2) {
      this.zone = t0;
      this.$function = t1;
      this.$ti = t2;
    },
    ZoneSpecification: function ZoneSpecification() {
    },
    _ZoneSpecification: function _ZoneSpecification(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.handleUncaughtError = t0;
      _.run = t1;
      _.runUnary = t2;
      _.runBinary = t3;
      _.registerCallback = t4;
      _.registerUnaryCallback = t5;
      _.registerBinaryCallback = t6;
      _.errorCallback = t7;
      _.scheduleMicrotask = t8;
      _.createTimer = t9;
      _.createPeriodicTimer = t10;
      _.print = t11;
      _.fork = t12;
    },
    ZoneDelegate: function ZoneDelegate() {
    },
    Zone: function Zone() {
    },
    _ZoneDelegate: function _ZoneDelegate(t0) {
      this._delegationTarget = t0;
    },
    _Zone: function _Zone() {
    },
    _CustomZone: function _CustomZone(t0, t1) {
      var _ = this;
      _._delegateCache = _._handleUncaughtError = _._fork = _._print = _._createPeriodicTimer = _._createTimer = _._scheduleMicrotask = _._errorCallback = _._registerBinaryCallback = _._registerUnaryCallback = _._registerCallback = _._runBinary = _._runUnary = _._run = null;
      _.parent = t0;
      _._async$_map = t1;
    },
    _CustomZone_bindCallback_closure: function _CustomZone_bindCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.registered = t1;
      this.R = t2;
    },
    _CustomZone_bindUnaryCallback_closure: function _CustomZone_bindUnaryCallback_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.registered = t1;
      _.T = t2;
      _.R = t3;
    },
    _CustomZone_bindCallbackGuarded_closure: function _CustomZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.registered = t1;
    },
    _CustomZone_bindUnaryCallbackGuarded_closure: function _CustomZone_bindUnaryCallbackGuarded_closure(t0, t1, t2) {
      this.$this = t0;
      this.registered = t1;
      this.T = t2;
    },
    _rootHandleUncaughtError_closure: function _rootHandleUncaughtError_closure(t0, t1) {
      this._box_0 = t0;
      this.stackTrace = t1;
    },
    _RootZone: function _RootZone() {
    },
    _RootZone_bindCallback_closure: function _RootZone_bindCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.R = t2;
    },
    _RootZone_bindCallbackGuarded_closure: function _RootZone_bindCallbackGuarded_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    _RootZone_bindUnaryCallbackGuarded_closure: function _RootZone_bindUnaryCallbackGuarded_closure(t0, t1, t2) {
      this.$this = t0;
      this.f = t1;
      this.T = t2;
    },
    runZoned_closure: function runZoned_closure(t0) {
      this._box_0 = t0;
    },
    HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
      H.functionTypeCheck(equals, {func: 1, ret: P.bool, args: [$K, $K]});
      H.functionTypeCheck(hashCode, {func: 1, ret: P.int, args: [$K]});
      H.functionTypeCheck(isValidKey, {func: 1, ret: P.bool, args: [,]});
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return new P._HashMap([$K, $V]);
          hashCode = P.collection___defaultHashCode$closure();
        } else {
          if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
            return new P._IdentityHashMap([$K, $V]);
          if (equals == null)
            equals = P.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = P.collection___defaultHashCode$closure();
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._CustomHashMap$(equals, hashCode, isValidKey, $K, $V);
    },
    _HashMap__getTableEntry: function(table, key) {
      var entry = table[key];
      return entry === table ? null : entry;
    },
    _HashMap__setTableEntry: function(table, key, value) {
      if (value == null)
        table[key] = table;
      else
        table[key] = value;
    },
    _HashMap__newHashTable: function() {
      var table = Object.create(null);
      P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
      delete table["<non-identifier-key>"];
      return table;
    },
    _CustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
      var t1 = validKey != null ? validKey : new P._CustomHashMap_closure($K);
      return new P._CustomHashMap(_equals, _hashCode, t1, [$K, $V]);
    },
    LinkedHashMap_LinkedHashMap: function(equals, hashCode, $K, $V) {
      H.functionTypeCheck(equals, {func: 1, ret: P.bool, args: [$K, $K]});
      H.functionTypeCheck(hashCode, {func: 1, ret: P.int, args: [$K]});
      if (hashCode == null) {
        if (equals == null)
          return new H.JsLinkedHashMap([$K, $V]);
        hashCode = P.collection___defaultHashCode$closure();
      } else {
        if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
          return new P._LinkedIdentityHashMap([$K, $V]);
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashMap$(equals, hashCode, null, $K, $V);
    },
    LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
      H.listTypeCheck(keyValuePairs);
      return H.assertSubtype(H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([$K, $V])), "$isLinkedHashMap", [$K, $V], "$asLinkedHashMap");
    },
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap([$K, $V]);
    },
    LinkedHashMap__makeEmpty: function() {
      return new H.JsLinkedHashMap([null, null]);
    },
    LinkedHashMap__makeLiteral: function(keyValuePairs) {
      return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap([null, null]));
    },
    _LinkedCustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
      return new P._LinkedCustomHashMap(_equals, _hashCode, new P._LinkedCustomHashMap_closure($K), [$K, $V]);
    },
    LinkedHashSet_LinkedHashSet: function($E) {
      return new P._LinkedHashSet([$E]);
    },
    _LinkedHashSet__newHashTable: function() {
      var table = Object.create(null);
      table["<non-identifier-key>"] = table;
      delete table["<non-identifier-key>"];
      return table;
    },
    _LinkedHashSetIterator$: function(_set, _modifications, $E) {
      var t1 = new P._LinkedHashSetIterator(_set, _modifications, [$E]);
      t1._collection$_cell = _set._collection$_first;
      return t1;
    },
    _defaultEquals: function(a, b) {
      return J.$eq$(a, b);
    },
    _defaultHashCode: function(a) {
      return J.get$hashCode$(a);
    },
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = H.setRuntimeTypeInfo([], [P.String]);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, H.listSuperNativeTypeCheck(parts, "$isIterable"), ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      C.JSArray_methods.add$1($._toStringVisiting, iterable);
      try {
        t1 = buffer;
        t1._contents = P.StringBuffer__writeAll(t1._contents, iterable, ", ");
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      buffer._contents += rightDelimiter;
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var t1, i;
      for (t1 = $._toStringVisiting.length, i = 0; i < t1; ++i)
        if (o === $._toStringVisiting[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
      H.assertSubtype(parts, "$isList", [P.String], "$asList");
      it = iterable.get$iterator(iterable);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current(it));
        C.JSArray_methods.add$1(parts, next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current(it);
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            C.JSArray_methods.add$1(parts, H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          if (0 >= parts.length)
            return H.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current(it);
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current(it);
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return H.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              C.JSArray_methods.add$1(parts, "...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        C.JSArray_methods.add$1(parts, elision);
      C.JSArray_methods.add$1(parts, penultimateString);
      C.JSArray_methods.add$1(parts, ultimateString);
    },
    LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
      var result;
      H.interceptedTypeCheck(other, "$isMap");
      result = P.LinkedHashMap_LinkedHashMap(null, null, $K, $V);
      J.forEach$1$ax(other, new P.LinkedHashMap_LinkedHashMap$from_closure(result, $K, $V));
      return result;
    },
    LinkedHashMap_LinkedHashMap$of: function(other, $K, $V) {
      var t1;
      H.assertSubtype(other, "$isMap", [$K, $V], "$asMap");
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, $K, $V);
      t1.addAll$1(0, other);
      return t1;
    },
    LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
      var t1,
        result = P.LinkedHashSet_LinkedHashSet($E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, H.assertSubtypeOfRuntimeType(t1.get$current(t1), $E));
      return result;
    },
    ListMixin__compareAny: function(a, b) {
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCheck(a, "$isComparable"), H.numberOrStringSuperNativeTypeCheck(b, "$isComparable"));
    },
    MapBase_mapToString: function(m) {
      var result, t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        C.JSArray_methods.add$1($._toStringVisiting, m);
        result._contents += "{";
        t1.first = true;
        J.forEach$1$ax(m, new P.MapBase_mapToString_closure(t1, result));
        result._contents += "}";
      } finally {
        if (0 >= $._toStringVisiting.length)
          return H.ioore($._toStringVisiting, -1);
        $._toStringVisiting.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    MapBase__fillMapWithMappedIterable: function(map, iterable, key, value) {
      var _i, element,
        t1 = {func: 1, args: [,]};
      H.functionTypeCheck(key, t1);
      H.functionTypeCheck(value, t1);
      for (_i = 0; _i < 9; ++_i) {
        element = iterable[_i];
        map.$indexSet(0, key.call$1(element), value.call$1(element));
      }
    },
    SplayTreeMap$: function(compare, $K, $V) {
      return new P.SplayTreeMap(new P._SplayTreeMapNode(null, null, [$K, $V]), compare, new P.SplayTreeMap_closure($K), [$K, $V]);
    },
    _HashMap: function _HashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _HashMap_values_closure: function _HashMap_values_closure(t0) {
      this.$this = t0;
    },
    _IdentityHashMap: function _IdentityHashMap(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t0;
    },
    _CustomHashMap: function _CustomHashMap(t0, t1, t2, t3) {
      var _ = this;
      _._equals = t0;
      _._hashCode = t1;
      _._validKey = t2;
      _._collection$_length = 0;
      _._keys = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _.$ti = t3;
    },
    _CustomHashMap_closure: function _CustomHashMap_closure(t0) {
      this.K = t0;
    },
    _HashMapKeyIterable: function _HashMapKeyIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _HashMapKeyIterator: function _HashMapKeyIterator(t0, t1, t2) {
      var _ = this;
      _._collection$_map = t0;
      _._keys = t1;
      _._offset = 0;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _LinkedIdentityHashMap: function _LinkedIdentityHashMap(t0) {
      var _ = this;
      _._length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t0;
    },
    _LinkedCustomHashMap: function _LinkedCustomHashMap(t0, t1, t2, t3) {
      var _ = this;
      _._equals = t0;
      _._hashCode = t1;
      _._validKey = t2;
      _._length = 0;
      _._last = _._first = _._rest = _._nums = _._strings = null;
      _._modifications = 0;
      _.$ti = t3;
    },
    _LinkedCustomHashMap_closure: function _LinkedCustomHashMap_closure(t0) {
      this.K = t0;
    },
    _LinkedHashSet: function _LinkedHashSet(t0) {
      var _ = this;
      _._collection$_length = 0;
      _._collection$_last = _._collection$_first = _._collection$_rest = _._collection$_nums = _._collection$_strings = null;
      _._collection$_modifications = 0;
      _.$ti = t0;
    },
    _LinkedHashSetCell: function _LinkedHashSetCell(t0) {
      this._collection$_element = t0;
      this._collection$_previous = this._collection$_next = null;
    },
    _LinkedHashSetIterator: function _LinkedHashSetIterator(t0, t1, t2) {
      var _ = this;
      _._set = t0;
      _._collection$_modifications = t1;
      _._collection$_current = _._collection$_cell = null;
      _.$ti = t2;
    },
    IterableBase: function IterableBase() {
    },
    LinkedHashMap_LinkedHashMap$from_closure: function LinkedHashMap_LinkedHashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    ListBase: function ListBase() {
    },
    ListMixin: function ListMixin() {
    },
    MapBase: function MapBase() {
    },
    MapBase_mapToString_closure: function MapBase_mapToString_closure(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    MapMixin: function MapMixin() {
    },
    MapMixin_entries_closure: function MapMixin_entries_closure(t0) {
      this.$this = t0;
    },
    _MapBaseValueIterable: function _MapBaseValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _MapBaseValueIterator: function _MapBaseValueIterator(t0, t1, t2) {
      var _ = this;
      _._keys = t0;
      _._collection$_map = t1;
      _._collection$_current = null;
      _.$ti = t2;
    },
    _UnmodifiableMapMixin: function _UnmodifiableMapMixin() {
    },
    MapView: function MapView() {
    },
    UnmodifiableMapView: function UnmodifiableMapView(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    ListQueue: function ListQueue(t0) {
      var _ = this;
      _._collection$_table = null;
      _._modificationCount = _._tail = _._head = 0;
      _.$ti = t0;
    },
    _ListQueueIterator: function _ListQueueIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._queue = t0;
      _._end = t1;
      _._modificationCount = t2;
      _._collection$_position = t3;
      _._collection$_current = null;
      _.$ti = t4;
    },
    SetMixin: function SetMixin() {
    },
    SetBase: function SetBase() {
    },
    _SetBase: function _SetBase() {
    },
    _SplayTreeNode: function _SplayTreeNode() {
    },
    _SplayTreeMapNode: function _SplayTreeMapNode(t0, t1, t2) {
      var _ = this;
      _.value = t0;
      _.key = t1;
      _.right = _.left = null;
      _.$ti = t2;
    },
    _SplayTree: function _SplayTree() {
    },
    SplayTreeMap: function SplayTreeMap(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_root = null;
      _._dummy = t0;
      _._comparator = t1;
      _._validKey = t2;
      _._splayCount = _._modificationCount = _._count = 0;
      _.$ti = t3;
    },
    SplayTreeMap_closure: function SplayTreeMap_closure(t0) {
      this.K = t0;
    },
    _SplayTreeIterator: function _SplayTreeIterator() {
    },
    _SplayTreeKeyIterable: function _SplayTreeKeyIterable(t0, t1) {
      this._tree = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterable: function _SplayTreeValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeKeyIterator: function _SplayTreeKeyIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._tree = t0;
      _._workList = t1;
      _._modificationCount = t2;
      _._splayCount = t3;
      _._currentNode = null;
      _.$ti = t4;
    },
    _SplayTreeValueIterator: function _SplayTreeValueIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._tree = t0;
      _._workList = t1;
      _._modificationCount = t2;
      _._splayCount = t3;
      _._currentNode = null;
      _.$ti = t4;
    },
    _SplayTreeNodeIterator: function _SplayTreeNodeIterator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._tree = t0;
      _._workList = t1;
      _._modificationCount = t2;
      _._splayCount = t3;
      _._currentNode = null;
      _.$ti = t4;
    },
    _ListBase_Object_ListMixin: function _ListBase_Object_ListMixin() {
    },
    _SetBase_Object_SetMixin: function _SetBase_Object_SetMixin() {
    },
    _SplayTreeMap__SplayTree_MapMixin: function _SplayTreeMap__SplayTree_MapMixin() {
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: function _UnmodifiableMapView_MapView__UnmodifiableMapMixin() {
    },
    _parseJson: function(source, reviver) {
      var parsed, e, exception, t1;
      if (typeof source !== "string")
        throw H.wrapException(H.argumentErrorValue(source));
      parsed = null;
      try {
        parsed = JSON.parse(source);
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.FormatException$(String(e), null, null);
        throw H.wrapException(t1);
      }
      t1 = P._convertJsonToDartLazy(parsed);
      return t1;
    },
    _convertJsonToDartLazy: function(object) {
      var i;
      if (object == null)
        return;
      if (typeof object != "object")
        return object;
      if (Object.getPrototypeOf(object) !== Array.prototype)
        return new P._JsonMap(object, Object.create(null));
      for (i = 0; i < object.length; ++i)
        object[i] = P._convertJsonToDartLazy(object[i]);
      return object;
    },
    Utf8Decoder__convertIntercepted: function(allowMalformed, codeUnits, start, end) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      if (codeUnits instanceof Uint8Array)
        return P.Utf8Decoder__convertInterceptedUint8List(false, codeUnits, start, end);
      return;
    },
    Utf8Decoder__convertInterceptedUint8List: function(allowMalformed, codeUnits, start, end) {
      var t1, $length,
        decoder = $.$get$Utf8Decoder__decoder();
      if (decoder == null)
        return;
      t1 = 0 === start;
      if (t1 && true)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      $length = codeUnits.length;
      end = P.RangeError_checkValidRange(start, end, $length);
      if (t1 && end === $length)
        return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
      return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
    },
    Utf8Decoder__useTextDecoderChecked: function(decoder, codeUnits) {
      if (P.Utf8Decoder__unsafe(codeUnits))
        return;
      return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
    },
    Utf8Decoder__useTextDecoderUnchecked: function(decoder, codeUnits) {
      var t1, exception;
      try {
        t1 = decoder.decode(codeUnits);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    Utf8Decoder__unsafe: function(codeUnits) {
      var i,
        limit = codeUnits.length - 2;
      for (i = 0; i < limit; ++i)
        if (codeUnits[i] === 237)
          if ((codeUnits[i + 1] & 224) === 160)
            return true;
      return false;
    },
    Utf8Decoder__makeDecoder: function() {
      var t1, exception;
      try {
        t1 = new TextDecoder("utf-8", {fatal: true});
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
      }
      return;
    },
    _scanOneByteCharacters: function(units, from, endIndex) {
      var t1, i, unit;
      H.assertSubtype(units, "$isList", [P.int], "$asList");
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      t1 = J.getInterceptor$asx(units);
      i = from;
      for (; i < endIndex; ++i) {
        unit = t1.$index(units, i);
        if (typeof unit !== "number")
          return unit.$and();
        if ((unit & 127) !== unit)
          return i - from;
      }
      return endIndex - from;
    },
    Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
      if (C.JSInt_methods.$mod($length, 4) !== 0)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + $length, source, sourceEnd));
      if (firstPadding + paddingCount !== $length)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
      if (paddingCount > 2)
        throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
    },
    _Base64Encoder_encodeChunk: function(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      var bits, expectedChars, t1, i, byteOr, byte, outputIndex0, t2, outputIndex1;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      bits = state >>> 2;
      expectedChars = 3 - (state & 3);
      for (t1 = output.length, i = start, byteOr = 0; i < end; ++i) {
        if (i >= bytes.length)
          return H.ioore(bytes, i);
        byte = bytes[i];
        byteOr |= byte;
        bits = (bits << 8 | byte) & 16777215;
        --expectedChars;
        if (expectedChars === 0) {
          outputIndex0 = outputIndex + 1;
          t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 18 & 63);
          if (outputIndex >= t1)
            return H.ioore(output, outputIndex);
          output[outputIndex] = t2;
          outputIndex = outputIndex0 + 1;
          t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 12 & 63);
          if (outputIndex0 >= t1)
            return H.ioore(output, outputIndex0);
          output[outputIndex0] = t2;
          outputIndex0 = outputIndex + 1;
          t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 6 & 63);
          if (outputIndex >= t1)
            return H.ioore(output, outputIndex);
          output[outputIndex] = t2;
          outputIndex = outputIndex0 + 1;
          t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits & 63);
          if (outputIndex0 >= t1)
            return H.ioore(output, outputIndex0);
          output[outputIndex0] = t2;
          bits = 0;
          expectedChars = 3;
        }
      }
      if (byteOr >= 0 && byteOr <= 255) {
        if (isLast && expectedChars < 3) {
          outputIndex0 = outputIndex + 1;
          outputIndex1 = outputIndex0 + 1;
          if (3 - expectedChars === 1) {
            t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 2 & 63);
            if (outputIndex >= t1)
              return H.ioore(output, outputIndex);
            output[outputIndex] = t2;
            t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 4 & 63);
            if (outputIndex0 >= t1)
              return H.ioore(output, outputIndex0);
            output[outputIndex0] = t2;
            outputIndex = outputIndex1 + 1;
            if (outputIndex1 >= t1)
              return H.ioore(output, outputIndex1);
            output[outputIndex1] = 61;
            if (outputIndex >= t1)
              return H.ioore(output, outputIndex);
            output[outputIndex] = 61;
          } else {
            t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 10 & 63);
            if (outputIndex >= t1)
              return H.ioore(output, outputIndex);
            output[outputIndex] = t2;
            t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 4 & 63);
            if (outputIndex0 >= t1)
              return H.ioore(output, outputIndex0);
            output[outputIndex0] = t2;
            outputIndex = outputIndex1 + 1;
            t2 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 2 & 63);
            if (outputIndex1 >= t1)
              return H.ioore(output, outputIndex1);
            output[outputIndex1] = t2;
            if (outputIndex >= t1)
              return H.ioore(output, outputIndex);
            output[outputIndex] = 61;
          }
          return 0;
        }
        return (bits << 2 | 3 - expectedChars) >>> 0;
      }
      for (i = start; i < end;) {
        if (i >= bytes.length)
          return H.ioore(bytes, i);
        byte = bytes[i];
        if (byte > 255)
          break;
        ++i;
      }
      t1 = "Not a byte value at index " + i + ": 0x";
      if (i >= bytes.length)
        return H.ioore(bytes, i);
      throw H.wrapException(P.ArgumentError$value(bytes, t1 + C.JSInt_methods.toRadixString$1(bytes[i], 16), null));
    },
    _Base64Decoder_decodeChunk: function(input, start, end, output, outIndex, state) {
      var i, charOr, char, t1, t2, code, outIndex0, expectedPadding,
        _s31_ = "Invalid encoding before padding",
        _s17_ = "Invalid character",
        bits = C.JSInt_methods._shrOtherPositive$1(state, 2),
        count = state & 3;
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      charOr = 0;
      for (; i < end; ++i) {
        char = C.JSString_methods._codeUnitAt$1(input, i);
        charOr |= char;
        t1 = $.$get$_Base64Decoder__inverseAlphabet();
        t2 = char & 127;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        code = t1[t2];
        if (code >= 0) {
          bits = (bits << 6 | code) & 16777215;
          count = count + 1 & 3;
          if (count === 0) {
            outIndex0 = outIndex + 1;
            t1 = output.length;
            if (outIndex >= t1)
              return H.ioore(output, outIndex);
            output[outIndex] = bits >>> 16 & 255;
            outIndex = outIndex0 + 1;
            if (outIndex0 >= t1)
              return H.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 8 & 255;
            outIndex0 = outIndex + 1;
            if (outIndex >= t1)
              return H.ioore(output, outIndex);
            output[outIndex] = bits & 255;
            outIndex = outIndex0;
            bits = 0;
          }
          continue;
        } else if (code === -1 && count > 1) {
          if (charOr > 127)
            break;
          if (count === 3) {
            if ((bits & 3) !== 0)
              throw H.wrapException(P.FormatException$(_s31_, input, i));
            outIndex0 = outIndex + 1;
            t1 = output.length;
            if (outIndex >= t1)
              return H.ioore(output, outIndex);
            output[outIndex] = bits >>> 10;
            if (outIndex0 >= t1)
              return H.ioore(output, outIndex0);
            output[outIndex0] = bits >>> 2;
          } else {
            if ((bits & 15) !== 0)
              throw H.wrapException(P.FormatException$(_s31_, input, i));
            if (outIndex >= output.length)
              return H.ioore(output, outIndex);
            output[outIndex] = bits >>> 4;
          }
          expectedPadding = (3 - count) * 3;
          if (char === 37)
            expectedPadding += 2;
          return P._Base64Decoder__checkPadding(input, i + 1, end, -expectedPadding - 1);
        }
        throw H.wrapException(P.FormatException$(_s17_, input, i));
      }
      if (charOr >= 0 && charOr <= 127)
        return (bits << 2 | count) >>> 0;
      for (i = start; i < end; ++i) {
        char = C.JSString_methods._codeUnitAt$1(input, i);
        if (char > 127)
          break;
      }
      throw H.wrapException(P.FormatException$(_s17_, input, i));
    },
    _Base64Decoder__allocateBuffer: function(input, start, end, state) {
      var $length, bufferLength, remainderLength, t1,
        paddingStart = P._Base64Decoder__trimPaddingChars(input, start, end);
      if (typeof paddingStart !== "number")
        return paddingStart.$sub();
      $length = (state & 3) + (paddingStart - start);
      bufferLength = C.JSInt_methods._shrOtherPositive$1($length, 2) * 3;
      remainderLength = $length & 3;
      if (remainderLength !== 0) {
        if (typeof end !== "number")
          return H.iae(end);
        t1 = paddingStart < end;
      } else
        t1 = false;
      if (t1)
        bufferLength += remainderLength - 1;
      if (bufferLength > 0)
        return new Uint8Array(bufferLength);
      return;
    },
    _Base64Decoder__trimPaddingChars: function(input, start, end) {
      var char,
        newEnd = end,
        index = newEnd,
        padding = 0;
      while (true) {
        if (typeof index !== "number")
          return index.$gt();
        if (!(index > start && padding < 2))
          break;
        c$0: {
          --index;
          char = C.JSString_methods.codeUnitAt$1(input, index);
          if (char === 61) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          if ((char | 32) === 100) {
            if (index === start)
              break;
            --index;
            char = C.JSString_methods.codeUnitAt$1(input, index);
          }
          if (char === 51) {
            if (index === start)
              break;
            --index;
            char = C.JSString_methods.codeUnitAt$1(input, index);
          }
          if (char === 37) {
            ++padding;
            newEnd = index;
            break c$0;
          }
          break;
        }
      }
      return newEnd;
    },
    _Base64Decoder__checkPadding: function(input, start, end, state) {
      var expectedPadding, char;
      if (start === end)
        return state;
      expectedPadding = -state - 1;
      for (; expectedPadding > 0;) {
        char = C.JSString_methods._codeUnitAt$1(input, start);
        if (expectedPadding === 3) {
          if (char === 61) {
            expectedPadding -= 3;
            ++start;
            break;
          }
          if (char === 37) {
            --expectedPadding;
            ++start;
            if (start === end)
              break;
            char = C.JSString_methods._codeUnitAt$1(input, start);
          } else
            break;
        }
        if ((expectedPadding > 3 ? expectedPadding - 3 : expectedPadding) === 2) {
          if (char !== 51)
            break;
          ++start;
          --expectedPadding;
          if (start === end)
            break;
          char = C.JSString_methods._codeUnitAt$1(input, start);
        }
        if ((char | 32) !== 100)
          break;
        ++start;
        --expectedPadding;
        if (start === end)
          break;
      }
      if (start !== end)
        throw H.wrapException(P.FormatException$("Invalid padding character", input, start));
      return -expectedPadding - 1;
    },
    Encoding_getByName: function($name) {
      if ($name == null)
        return;
      return $.Encoding__nameToEncoding.$index(0, $name.toLowerCase());
    },
    JsonUnsupportedObjectError$: function(unsupportedObject, cause, partialResult) {
      return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
    },
    _defaultToEncodable: function(object) {
      return object.toJson$0();
    },
    _JsonStringStringifier_stringify: function(object, toEncodable, indent) {
      var t1,
        output = new P.StringBuffer("");
      P._JsonStringStringifier_printOn(object, output, toEncodable, indent);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _JsonStringStringifier_printOn: function(object, output, toEncodable, indent) {
      var stringifier;
      if (indent == null)
        stringifier = new P._JsonStringStringifier(output, [], P.convert___defaultToEncodable$closure());
      else
        stringifier = new P._JsonStringStringifierPretty(indent, 0, output, [], P.convert___defaultToEncodable$closure());
      stringifier.writeObject$1(object);
    },
    _JsonMap: function _JsonMap(t0, t1) {
      this._original = t0;
      this._processed = t1;
      this._data = null;
    },
    _JsonMap_values_closure: function _JsonMap_values_closure(t0) {
      this.$this = t0;
    },
    _JsonMapKeyIterable: function _JsonMapKeyIterable(t0) {
      this._parent = t0;
    },
    AsciiCodec: function AsciiCodec() {
    },
    _UnicodeSubsetEncoder: function _UnicodeSubsetEncoder() {
    },
    AsciiEncoder: function AsciiEncoder(t0) {
      this._subsetMask = t0;
    },
    _UnicodeSubsetDecoder: function _UnicodeSubsetDecoder() {
    },
    AsciiDecoder: function AsciiDecoder(t0, t1) {
      this._allowInvalid = t0;
      this._subsetMask = t1;
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    _Base64Encoder: function _Base64Encoder(t0) {
      this._convert$_state = 0;
      this._alphabet = t0;
    },
    Base64Decoder: function Base64Decoder() {
    },
    _Base64Decoder: function _Base64Decoder() {
      this._convert$_state = 0;
    },
    ByteConversionSink: function ByteConversionSink() {
    },
    ByteConversionSinkBase: function ByteConversionSinkBase() {
    },
    _ByteCallbackSink: function _ByteCallbackSink(t0, t1) {
      this._convert$_callback = t0;
      this._convert$_buffer = t1;
      this._bufferIndex = 0;
    },
    ChunkedConversionSink: function ChunkedConversionSink() {
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    Encoding: function Encoding() {
    },
    HtmlEscapeMode: function HtmlEscapeMode(t0, t1, t2, t3, t4) {
      var _ = this;
      _._convert$_name = t0;
      _.escapeLtGt = t1;
      _.escapeQuot = t2;
      _.escapeApos = t3;
      _.escapeSlash = t4;
    },
    HtmlEscape: function HtmlEscape() {
    },
    JsonUnsupportedObjectError: function JsonUnsupportedObjectError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCyclicError: function JsonCyclicError(t0, t1) {
      this.unsupportedObject = t0;
      this.cause = t1;
    },
    JsonCodec: function JsonCodec() {
    },
    JsonEncoder: function JsonEncoder(t0, t1) {
      this.indent = t0;
      this._toEncodable = t1;
    },
    JsonDecoder: function JsonDecoder(t0) {
      this._reviver = t0;
    },
    _JsonStringifier: function _JsonStringifier() {
    },
    _JsonStringifier_writeMap_closure: function _JsonStringifier_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonPrettyPrintMixin: function _JsonPrettyPrintMixin() {
    },
    _JsonPrettyPrintMixin_writeMap_closure: function _JsonPrettyPrintMixin_writeMap_closure(t0, t1) {
      this._box_0 = t0;
      this.keyValueList = t1;
    },
    _JsonStringStringifier: function _JsonStringStringifier(t0, t1, t2) {
      this._sink = t0;
      this._seen = t1;
      this._toEncodable = t2;
    },
    _JsonStringStringifierPretty: function _JsonStringStringifierPretty(t0, t1, t2, t3, t4) {
      var _ = this;
      _._indent = t0;
      _._JsonPrettyPrintMixin__indentLevel = t1;
      _._sink = t2;
      _._seen = t3;
      _._toEncodable = t4;
    },
    Latin1Codec: function Latin1Codec() {
    },
    Latin1Encoder: function Latin1Encoder(t0) {
      this._subsetMask = t0;
    },
    Latin1Decoder: function Latin1Decoder(t0, t1) {
      this._allowInvalid = t0;
      this._subsetMask = t1;
    },
    Utf8Codec: function Utf8Codec() {
    },
    Utf8Encoder: function Utf8Encoder() {
    },
    _Utf8Encoder: function _Utf8Encoder(t0) {
      this._bufferIndex = this._carry = 0;
      this._convert$_buffer = t0;
    },
    Utf8Decoder: function Utf8Decoder(t0) {
      this._allowMalformed = t0;
    },
    _Utf8Decoder: function _Utf8Decoder(t0, t1) {
      var _ = this;
      _._allowMalformed = t0;
      _._stringSink = t1;
      _._isFirstCharacter = true;
      _._extraUnits = _._expectedUnits = _._convert$_value = 0;
    },
    __JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin: function __JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin() {
    },
    identityHashCode: function(object) {
      return H.objectHashCode(object);
    },
    Function_apply: function($function, positionalArguments) {
      return H.Primitives_applyFunction($function, positionalArguments, null);
    },
    int_parse: function(source, onError, radix) {
      var value;
      H.functionTypeCheck(onError, {func: 1, ret: P.int, args: [P.String]});
      value = H.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    },
    Error__objectToString: function(object) {
      if (object instanceof H.Closure)
        return object.toString$0(0);
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    List_List$filled: function($length, fill, $E) {
      var result, i;
      H.assertSubtypeOfRuntimeType(fill, $E);
      result = J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && true)
        for (i = 0; i < result.length; ++i)
          C.JSArray_methods.$indexSet(result, i, fill);
      return H.assertSubtype(result, "$isList", [$E], "$asList");
    },
    List_List$from: function(elements, growable, $E) {
      var t2,
        t1 = [$E],
        list = H.setRuntimeTypeInfo([], t1);
      for (t2 = J.get$iterator$ax(elements); t2.moveNext$0();)
        C.JSArray_methods.add$1(list, H.assertSubtypeOfRuntimeType(t2.get$current(t2), $E));
      if (growable)
        return list;
      return H.assertSubtype(J.JSArray_markFixedList(list), "$isList", t1, "$asList");
    },
    List_List$unmodifiable: function(elements, $E) {
      var t1 = [$E];
      return H.assertSubtype(J.JSArray_markUnmodifiableList(H.assertSubtype(P.List_List$from(elements, false, $E), "$isList", t1, "$asList")), "$isList", t1, "$asList");
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len,
        t1 = P.int;
      H.assertSubtype(charCodes, "$isIterable", [t1], "$asIterable");
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        H.assertSubtype(charCodes, "$isJSArray", [t1], "$asJSArray");
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len);
        if (start <= 0) {
          if (typeof end !== "number")
            return end.$lt();
          t1 = end < len;
        } else
          t1 = true;
        return H.Primitives_stringFromCharCodes(t1 ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor$(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    String_String$fromCharCode: function(charCode) {
      return H.Primitives_stringFromCharCode(charCode);
    },
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list, _null = null;
      H.assertSubtype(charCodes, "$isIterable", [P.int], "$asIterable");
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), _null, _null));
      t1 = end == null;
      if (!t1 && end < start)
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), _null, _null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, _null, _null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current(it));
      else
        for (i = start; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, _null, _null));
          list.push(it.get$current(it));
        }
      return H.Primitives_stringFromCharCodes(list);
    },
    RegExp_RegExp: function(source) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, false, true, false, false, false));
    },
    identical: function(a, b) {
      return a == null ? b == null : a === b;
    },
    StringBuffer$: function($content) {
      return new P.StringBuffer($content);
    },
    StringBuffer__writeAll: function(string, objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return string;
      if (separator.length === 0) {
        do
          string += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        string += H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          string = string + separator + H.S(iterator.get$current(iterator));
      }
      return string;
    },
    NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments) {
      return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments);
    },
    Uri_base: function() {
      var uri = H.Primitives_currentUri();
      if (uri != null)
        return P.Uri_parse(uri, 0, null);
      throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
    },
    _Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
      var t1, bytes, i, t2, t3, byte,
        _s16_ = "0123456789ABCDEF";
      H.assertSubtype(canonicalTable, "$isList", [P.int], "$asList");
      if (encoding === C.C_Utf8Codec) {
        t1 = $.$get$_Uri__needsNoEncoding()._nativeRegExp;
        if (typeof text !== "string")
          H.throwExpression(H.argumentErrorValue(text));
        t1 = t1.test(text);
      } else
        t1 = false;
      if (t1)
        return text;
      bytes = encoding.encode$1(text);
      t1 = J.getInterceptor$asx(bytes);
      i = 0;
      t2 = "";
      while (true) {
        t3 = t1.get$length(bytes);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        byte = t1.$index(bytes, i);
        if (typeof byte !== "number")
          return byte.$lt();
        if (byte < 128) {
          t3 = C.JSInt_methods._shrOtherPositive$1(byte, 4);
          if (t3 >= 8)
            return H.ioore(canonicalTable, t3);
          t3 = (canonicalTable[t3] & 1 << (byte & 15)) !== 0;
        } else
          t3 = false;
        if (t3)
          t2 += H.Primitives_stringFromCharCode(byte);
        else
          t2 = spaceToPlus && byte === 32 ? t2 + "+" : t2 + "%" + _s16_[C.JSInt_methods._shrOtherPositive$1(byte, 4) & 15] + _s16_[byte & 15];
        ++i;
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    StackTrace_current: function() {
      var stackTrace, exception;
      if (H.boolConversionCheck($.$get$_hasErrorStackProperty()))
        return H.getTraceFromException(new Error());
      try {
        throw H.wrapException("");
      } catch (exception) {
        H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        return stackTrace;
      }
    },
    DateTime$_withValue: function(_value, isUtc) {
      var t1;
      if (Math.abs(_value) <= 864e13)
        t1 = false;
      else
        t1 = true;
      if (t1)
        H.throwExpression(P.ArgumentError$("DateTime is outside valid range: " + _value));
      return new P.DateTime(_value, isUtc);
    },
    DateTime__fourDigits: function(n) {
      var absN = Math.abs(n),
        sign = n < 0 ? "-" : "";
      if (absN >= 1000)
        return "" + n;
      if (absN >= 100)
        return sign + "0" + absN;
      if (absN >= 10)
        return sign + "00" + absN;
      return sign + "000" + absN;
    },
    DateTime__threeDigits: function(n) {
      if (n >= 100)
        return "" + n;
      if (n >= 10)
        return "0" + n;
      return "00" + n;
    },
    DateTime__twoDigits: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    Duration$: function(microseconds, milliseconds, minutes, seconds) {
      if (typeof microseconds !== "number")
        return H.iae(microseconds);
      return new P.Duration(60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds);
    },
    Error_safeToString: function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return JSON.stringify(object);
      return P.Error__objectToString(object);
    },
    ArgumentError$: function(message) {
      return new P.ArgumentError(false, null, null, message);
    },
    ArgumentError$value: function(value, $name, message) {
      return new P.ArgumentError(true, value, $name, message);
    },
    ArgumentError$notNull: function($name) {
      return new P.ArgumentError(false, null, $name, "Must not be null");
    },
    RangeError$: function(message) {
      var _null = null;
      return new P.RangeError(_null, _null, false, _null, _null, message);
    },
    RangeError$value: function(value, $name) {
      return new P.RangeError(null, null, true, value, $name, "Value not in range");
    },
    RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
      return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
    },
    RangeError_checkValueInInterval: function(value, minValue, maxValue, $name) {
      var t1;
      if (typeof value !== "number")
        return value.$lt();
      if (value >= minValue) {
        if (typeof maxValue !== "number")
          return H.iae(maxValue);
        t1 = value > maxValue;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, null));
    },
    RangeError_checkValidRange: function(start, end, $length) {
      var t1;
      if (typeof start !== "number")
        return H.iae(start);
      if (0 <= start) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = start > $length;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$range(start, 0, $length, "start", null));
      if (end != null) {
        if (!(start > end)) {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = end > $length;
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$range(end, start, $length, "end", null));
        return end;
      }
      return $length;
    },
    RangeError_checkNotNegative: function(value, $name) {
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0)
        throw H.wrapException(P.RangeError$range(value, 0, null, $name, null));
    },
    IndexError$: function(invalidValue, indexable, $name, message, $length) {
      var t1 = H.intTypeCheck($length == null ? J.get$length$asx(indexable) : $length);
      return new P.IndexError(t1, true, invalidValue, $name, "Index out of range");
    },
    UnsupportedError$: function(message) {
      return new P.UnsupportedError(message);
    },
    UnimplementedError$: function(message) {
      return new P.UnimplementedError(message);
    },
    StateError$: function(message) {
      return new P.StateError(message);
    },
    ConcurrentModificationError$: function(modifiedObject) {
      return new P.ConcurrentModificationError(modifiedObject);
    },
    Exception_Exception: function(message) {
      return new P._Exception(message);
    },
    FormatException$: function(message, source, offset) {
      return new P.FormatException(message, source, offset);
    },
    List_List$generate: function($length, generator, growable, $E) {
      var result, i;
      H.functionTypeCheck(generator, {func: 1, ret: $E, args: [P.int]});
      result = H.setRuntimeTypeInfo([], [$E]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i)
        C.JSArray_methods.$indexSet(result, i, generator.call$1(i));
      return result;
    },
    num_parse: function(input) {
      var t1,
        source = J.trim$0$s(input),
        result = H.Primitives_parseInt(source, null);
      if (result == null)
        result = H.Primitives_parseDouble(source);
      if (result != null)
        return result;
      t1 = P.FormatException$(input, null, null);
      throw H.wrapException(t1);
    },
    print: function(object) {
      var line = H.S(object),
        t1 = $.printToZone;
      if (t1 == null)
        H.printString(line);
      else
        t1.call$1(line);
    },
    Set_castFrom: function(source, newSet, $S, $T) {
      return new H.CastSet(H.assertSubtype(source, "$isSet", [$S], "$asSet"), H.functionTypeCheck(newSet, {func: 1, bounds: [P.Object], ret: [P.Set, 0]}), [$S, $T]);
    },
    _combineSurrogatePair: function(start, end) {
      return 65536 + ((start & 1023) << 10) + (end & 1023);
    },
    Uri_parse: function(uri, start, end) {
      var t1, delta, t2, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, isSimple, scheme, t3, schemeAuth, _null = null;
      end = uri.length;
      t1 = start + 5;
      if (end >= t1) {
        delta = ((J._codeUnitAt$1$s(uri, start + 4) ^ 58) * 3 | C.JSString_methods._codeUnitAt$1(uri, start) ^ 100 | C.JSString_methods._codeUnitAt$1(uri, start + 1) ^ 97 | C.JSString_methods._codeUnitAt$1(uri, start + 2) ^ 116 | C.JSString_methods._codeUnitAt$1(uri, start + 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(start > 0 || end < end ? C.JSString_methods.substring$2(uri, start, end) : uri, 5, _null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(C.JSString_methods.substring$2(uri, t1, end), 0, _null).get$uri();
      }
      t2 = new Array(8);
      t2.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t2, [P.int]);
      C.JSArray_methods.$indexSet(indices, 0, 0);
      t2 = start - 1;
      C.JSArray_methods.$indexSet(indices, 1, t2);
      C.JSArray_methods.$indexSet(indices, 2, t2);
      C.JSArray_methods.$indexSet(indices, 7, t2);
      C.JSArray_methods.$indexSet(indices, 3, start);
      C.JSArray_methods.$indexSet(indices, 4, start);
      C.JSArray_methods.$indexSet(indices, 5, end);
      C.JSArray_methods.$indexSet(indices, 6, end);
      if (P._scan(uri, start, end, 0, indices) >= 14)
        C.JSArray_methods.$indexSet(indices, 7, end);
      schemeEnd = indices[1];
      if (typeof schemeEnd !== "number")
        return schemeEnd.$ge();
      if (schemeEnd >= start)
        if (P._scan(uri, start, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      t2 = indices[2];
      if (typeof t2 !== "number")
        return t2.$add();
      hostStart = t2 + 1;
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      if (typeof fragmentStart !== "number")
        return fragmentStart.$lt();
      if (typeof queryStart !== "number")
        return H.iae(queryStart);
      if (fragmentStart < queryStart)
        queryStart = fragmentStart;
      if (typeof pathStart !== "number")
        return pathStart.$lt();
      if (pathStart < hostStart)
        pathStart = queryStart;
      else if (pathStart <= schemeEnd)
        pathStart = schemeEnd + 1;
      if (typeof portStart !== "number")
        return portStart.$lt();
      if (portStart < hostStart)
        portStart = pathStart;
      t2 = indices[7];
      if (typeof t2 !== "number")
        return t2.$lt();
      isSimple = t2 < start;
      if (isSimple)
        if (hostStart > schemeEnd + 3) {
          scheme = _null;
          isSimple = false;
        } else {
          t2 = portStart > start;
          if (t2 && portStart + 1 === pathStart) {
            scheme = _null;
            isSimple = false;
          } else {
            if (!(queryStart < end && queryStart === pathStart + 2 && J.startsWith$2$s(uri, "..", pathStart)))
              t3 = queryStart > pathStart + 2 && J.startsWith$2$s(uri, "/..", queryStart - 3);
            else
              t3 = true;
            if (t3) {
              scheme = _null;
              isSimple = false;
            } else {
              if (schemeEnd === start + 4)
                if (J.startsWith$2$s(uri, "file", start)) {
                  if (hostStart <= start) {
                    if (!C.JSString_methods.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= start;
                    t1 = delta - start;
                    queryStart += t1;
                    fragmentStart += t1;
                    end = uri.length;
                    start = 0;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else if (pathStart === queryStart)
                    if (start === 0 && true) {
                      uri = C.JSString_methods.replaceRange$3(uri, pathStart, queryStart, "/");
                      ++queryStart;
                      ++fragmentStart;
                      ++end;
                    } else {
                      uri = C.JSString_methods.substring$2(uri, start, pathStart) + "/" + C.JSString_methods.substring$2(uri, queryStart, end);
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      pathStart -= start;
                      t1 = 1 - start;
                      queryStart += t1;
                      fragmentStart += t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "file";
                } else if (C.JSString_methods.startsWith$2(uri, "http", start)) {
                  if (t2 && portStart + 3 === pathStart && C.JSString_methods.startsWith$2(uri, "80", portStart + 1))
                    if (start === 0 && true) {
                      uri = C.JSString_methods.replaceRange$3(uri, portStart, pathStart, "");
                      pathStart -= 3;
                      queryStart -= 3;
                      fragmentStart -= 3;
                      end -= 3;
                    } else {
                      uri = C.JSString_methods.substring$2(uri, start, portStart) + C.JSString_methods.substring$2(uri, pathStart, end);
                      schemeEnd -= start;
                      hostStart -= start;
                      portStart -= start;
                      t1 = 3 + start;
                      pathStart -= t1;
                      queryStart -= t1;
                      fragmentStart -= t1;
                      end = uri.length;
                      start = 0;
                    }
                  scheme = "http";
                } else
                  scheme = _null;
              else if (schemeEnd === t1 && J.startsWith$2$s(uri, "https", start)) {
                if (t2 && portStart + 4 === pathStart && J.startsWith$2$s(uri, "443", portStart + 1)) {
                  t1 = start === 0 && true;
                  t2 = J.getInterceptor$asx(uri);
                  if (t1) {
                    uri = t2.replaceRange$3(uri, portStart, pathStart, "");
                    pathStart -= 4;
                    queryStart -= 4;
                    fragmentStart -= 4;
                    end -= 3;
                  } else {
                    uri = t2.substring$2(uri, start, portStart) + C.JSString_methods.substring$2(uri, pathStart, end);
                    schemeEnd -= start;
                    hostStart -= start;
                    portStart -= start;
                    t1 = 4 + start;
                    pathStart -= t1;
                    queryStart -= t1;
                    fragmentStart -= t1;
                    end = uri.length;
                    start = 0;
                  }
                }
                scheme = "https";
              } else
                scheme = _null;
              isSimple = true;
            }
          }
        }
      else
        scheme = _null;
      if (isSimple) {
        if (start > 0 || end < uri.length) {
          uri = J.substring$2$s(uri, start, end);
          schemeEnd -= start;
          hostStart -= start;
          portStart -= start;
          pathStart -= start;
          queryStart -= start;
          fragmentStart -= start;
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
      }
      return P._Uri__Uri$notSimple(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri_tryParse: function(uri) {
      var t1, exception, start = 0, end = null;
      try {
        t1 = P.Uri_parse(uri, start, end);
        return t1;
      } catch (exception) {
        if (!!J.getInterceptor$(H.unwrapException(exception)).$isFormatException)
          return;
        else
          throw exception;
      }
    },
    Uri_decodeComponent: function(encodedComponent) {
      H.stringTypeCheck(encodedComponent);
      return P._Uri__uriDecode(encodedComponent, 0, encodedComponent.length, C.C_Utf8Codec, false);
    },
    Uri_splitQueryString: function(query) {
      var t1 = P.String;
      return C.JSArray_methods.fold$1$2(H.setRuntimeTypeInfo(query.split("&"), [t1]), P.LinkedHashMap_LinkedHashMap$_empty(t1, t1), new P.Uri_splitQueryString_closure(C.C_Utf8Codec), [P.Map, P.String, P.String]);
    },
    Uri__parseIPv4Address: function(host, start, end) {
      var t1, i, partStart, partIndex, char, part, partIndex0, _null = null,
        _s43_ = "IPv4 address should contain exactly 4 parts",
        _s37_ = "each part must be in the range 0..255",
        error = new P.Uri__parseIPv4Address_error(host),
        result = new Uint8Array(4);
      for (t1 = result.length, i = start, partStart = i, partIndex = 0; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2(_s43_, i);
          part = P.int_parse(C.JSString_methods.substring$2(host, partStart, i), _null, _null);
          if (typeof part !== "number")
            return part.$gt();
          if (part > 255)
            error.call$2(_s37_, partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= t1)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = i + 1;
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2(_s43_, end);
      part = P.int_parse(C.JSString_methods.substring$2(host, partStart, end), _null, _null);
      if (typeof part !== "number")
        return part.$gt();
      if (part > 255)
        error.call$2(_s37_, partStart);
      if (partIndex >= t1)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var error, parseHex, parts, i, partStart, wildcardSeen, seenDot, char, atEnd, t1, last, bytes, t2, wildCardLength, index, value, j, t3;
      if (end == null)
        end = host.length;
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      if (host.length < 2)
        error.call$1("address is too short");
      parts = H.setRuntimeTypeInfo([], [P.int]);
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; i < end; ++i) {
        char = C.JSString_methods.codeUnitAt$1(host, i);
        if (char === 58) {
          if (i === start) {
            ++i;
            if (C.JSString_methods.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          if (i === partStart) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            C.JSArray_methods.add$1(parts, -1);
            wildcardSeen = true;
          } else
            C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, i));
          partStart = i + 1;
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = partStart === end;
      t1 = C.JSArray_methods.get$last(parts);
      if (atEnd && t1 !== -1)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          C.JSArray_methods.add$1(parts, parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          C.JSArray_methods.add$1(parts, (last[0] << 8 | last[1]) >>> 0);
          C.JSArray_methods.add$1(parts, (last[2] << 8 | last[3]) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (t1 = parts.length, t2 = bytes.length, wildCardLength = 9 - t1, i = 0, index = 0; i < t1; ++i) {
        value = parts[i];
        if (value === -1)
          for (j = 0; j < wildCardLength; ++j) {
            if (index < 0 || index >= t2)
              return H.ioore(bytes, index);
            bytes[index] = 0;
            t3 = index + 1;
            if (t3 >= t2)
              return H.ioore(bytes, t3);
            bytes[t3] = 0;
            index += 2;
          }
        else {
          t3 = C.JSInt_methods._shrOtherPositive$1(value, 8);
          if (index < 0 || index >= t2)
            return H.ioore(bytes, index);
          bytes[index] = t3;
          t3 = index + 1;
          if (t3 >= t2)
            return H.ioore(bytes, t3);
          bytes[t3] = value & 255;
          index += 2;
        }
      }
      return bytes;
    },
    _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
      var userInfoStart, userInfo, host, t1, port, path, query, _null = null;
      if (scheme == null)
        if (schemeEnd > start)
          scheme = P._Uri__makeScheme(uri, start, schemeEnd);
        else {
          if (schemeEnd === start)
            P._Uri__fail(uri, start, "Invalid empty scheme");
          scheme = "";
        }
      if (hostStart > start) {
        userInfoStart = schemeEnd + 3;
        userInfo = userInfoStart < hostStart ? P._Uri__makeUserInfo(uri, userInfoStart, hostStart - 1) : "";
        host = P._Uri__makeHost(uri, hostStart, portStart, false);
        if (typeof portStart !== "number")
          return portStart.$add();
        t1 = portStart + 1;
        if (typeof pathStart !== "number")
          return H.iae(pathStart);
        port = t1 < pathStart ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1, pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), _null), scheme) : _null;
      } else {
        port = _null;
        host = port;
        userInfo = "";
      }
      path = P._Uri__makePath(uri, pathStart, queryStart, _null, scheme, host != null);
      if (typeof queryStart !== "number")
        return queryStart.$lt();
      query = queryStart < fragmentStart ? P._Uri__makeQuery(uri, queryStart + 1, fragmentStart, _null) : _null;
      return new P._Uri(scheme, userInfo, host, port, path, query, fragmentStart < end ? P._Uri__makeFragment(uri, fragmentStart + 1, end) : _null);
    },
    _Uri__defaultPort: function(scheme) {
      if (scheme === "http")
        return 80;
      if (scheme === "https")
        return 443;
      return 0;
    },
    _Uri__compareScheme: function(scheme, uri) {
      var t1, i, schemeChar, uriChar, delta, lowerChar;
      for (t1 = scheme.length, i = 0; i < t1; ++i) {
        schemeChar = C.JSString_methods._codeUnitAt$1(scheme, i);
        uriChar = C.JSString_methods._codeUnitAt$1(uri, i);
        delta = schemeChar ^ uriChar;
        if (delta !== 0) {
          if (delta === 32) {
            lowerChar = uriChar | delta;
            if (97 <= lowerChar && lowerChar <= 122)
              continue;
          }
          return false;
        }
      }
      return true;
    },
    _Uri__fail: function(uri, index, message) {
      throw H.wrapException(P.FormatException$(message, uri, index));
    },
    _Uri__checkNonWindowsPathReservedCharacters: function(segments, argumentError) {
      C.JSArray_methods.forEach$1(H.assertSubtype(segments, "$isList", [P.String], "$asList"), new P._Uri__checkNonWindowsPathReservedCharacters_closure(false));
    },
    _Uri__checkWindowsPathReservedCharacters: function(segments, argumentError, firstSegment) {
      var t1, t2, t3;
      H.assertSubtype(segments, "$isList", [P.String], "$asList");
      for (t1 = H.SubListIterable$(segments, firstSegment, null, H.getTypeArgumentByIndex(segments, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current;
        t3 = P.RegExp_RegExp('["*/:<>?\\\\|]');
        t2.length;
        if (H.stringContainsUnchecked(t2, t3, 0)) {
          t1 = P.UnsupportedError$("Illegal character in path: " + H.S(t2));
          throw H.wrapException(t1);
        }
      }
    },
    _Uri__checkWindowsDriveLetter: function(charCode, argumentError) {
      var t1;
      if (!(65 <= charCode && charCode <= 90))
        t1 = 97 <= charCode && charCode <= 122;
      else
        t1 = true;
      if (t1)
        return;
      t1 = P.UnsupportedError$("Illegal drive letter " + P.String_String$fromCharCode(charCode));
      throw H.wrapException(t1);
    },
    _Uri__makePort: function(port, scheme) {
      if (port != null && port === P._Uri__defaultPort(scheme))
        return;
      return port;
    },
    _Uri__makeHost: function(host, start, end, strictIPv6) {
      var t1, i;
      if (host == null)
        return;
      if (start === end)
        return "";
      if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
        if (typeof end !== "number")
          return end.$sub();
        t1 = end - 1;
        if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
          P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
        P.Uri_parseIPv6Address(host, start + 1, t1);
        return C.JSString_methods.substring$2(host, start, end).toLowerCase();
      }
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      for (; i < end; ++i)
        if (C.JSString_methods.codeUnitAt$1(host, i) === 58) {
          P.Uri_parseIPv6Address(host, start, end);
          return "[" + host + "]";
        }
      return P._Uri__normalizeRegName(host, start, end);
    },
    _Uri__normalizeRegName: function(host, start, end) {
      var index, sectionStart, buffer, isNormalized, char, replacement, t1, slice, t2, sourceLength, tail;
      if (typeof end !== "number")
        return H.iae(end);
      index = start;
      sectionStart = index;
      buffer = null;
      isNormalized = true;
      for (; index < end;) {
        char = C.JSString_methods.codeUnitAt$1(host, index);
        if (char === 37) {
          replacement = P._Uri__normalizeEscape(host, index, true);
          t1 = replacement == null;
          if (t1 && isNormalized) {
            index += 3;
            continue;
          }
          if (buffer == null)
            buffer = new P.StringBuffer("");
          slice = C.JSString_methods.substring$2(host, sectionStart, index);
          t2 = buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          if (t1) {
            replacement = C.JSString_methods.substring$2(host, index, index + 3);
            sourceLength = 3;
          } else if (replacement === "%") {
            replacement = "%25";
            sourceLength = 1;
          } else
            sourceLength = 3;
          buffer._contents = t2 + replacement;
          index += sourceLength;
          sectionStart = index;
          isNormalized = true;
        } else {
          if (char < 127) {
            t1 = char >>> 4;
            if (t1 >= 8)
              return H.ioore(C.List_qNA, t1);
            t1 = (C.List_qNA[t1] & 1 << (char & 15)) !== 0;
          } else
            t1 = false;
          if (t1) {
            if (isNormalized && 65 <= char && 90 >= char) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              if (sectionStart < index) {
                buffer._contents += C.JSString_methods.substring$2(host, sectionStart, index);
                sectionStart = index;
              }
              isNormalized = false;
            }
            ++index;
          } else {
            if (char <= 93) {
              t1 = char >>> 4;
              if (t1 >= 8)
                return H.ioore(C.List_2Vk, t1);
              t1 = (C.List_2Vk[t1] & 1 << (char & 15)) !== 0;
            } else
              t1 = false;
            if (t1)
              P._Uri__fail(host, index, "Invalid character");
            else {
              if ((char & 64512) === 55296 && index + 1 < end) {
                tail = C.JSString_methods.codeUnitAt$1(host, index + 1);
                if ((tail & 64512) === 56320) {
                  char = 65536 | (char & 1023) << 10 | tail & 1023;
                  sourceLength = 2;
                } else
                  sourceLength = 1;
              } else
                sourceLength = 1;
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = C.JSString_methods.substring$2(host, sectionStart, index);
              buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
              buffer._contents += P._Uri__escapeChar(char);
              index += sourceLength;
              sectionStart = index;
            }
          }
        }
      }
      if (buffer == null)
        return C.JSString_methods.substring$2(host, start, end);
      if (sectionStart < end) {
        slice = C.JSString_methods.substring$2(host, sectionStart, end);
        buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
      }
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeScheme: function(scheme, start, end) {
      var i, containsUpperCase, codeUnit, t1;
      if (start === end)
        return "";
      if (!P._Uri__isAlphabeticCharacter(J.getInterceptor$s(scheme)._codeUnitAt$1(scheme, start)))
        P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
      for (i = start, containsUpperCase = false; i < end; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(scheme, i);
        if (codeUnit < 128) {
          t1 = codeUnit >>> 4;
          if (t1 >= 8)
            return H.ioore(C.List_JYB, t1);
          t1 = (C.List_JYB[t1] & 1 << (codeUnit & 15)) !== 0;
        } else
          t1 = false;
        if (!t1)
          P._Uri__fail(scheme, i, "Illegal scheme character");
        if (65 <= codeUnit && codeUnit <= 90)
          containsUpperCase = true;
      }
      scheme = C.JSString_methods.substring$2(scheme, start, end);
      return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
    },
    _Uri__canonicalizeScheme: function(scheme) {
      if (scheme === "http")
        return "http";
      if (scheme === "file")
        return "file";
      if (scheme === "https")
        return "https";
      if (scheme === "package")
        return "package";
      return scheme;
    },
    _Uri__makeUserInfo: function(userInfo, start, end) {
      if (userInfo == null)
        return "";
      return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj, false);
    },
    _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
      var result,
        isFile = scheme === "file",
        ensureLeadingSlash = isFile || hasAuthority,
        t1 = path == null;
      if (t1 && true)
        return isFile ? "/" : "";
      result = !t1 ? P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4, true) : C.JSNull_methods.map$1$1(pathSegments, new P._Uri__makePath_closure(), P.String).join$1(0, "/");
      if (result.length === 0) {
        if (isFile)
          return "/";
      } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
        result = "/" + result;
      return P._Uri__normalizePath(result, scheme, hasAuthority);
    },
    _Uri__normalizePath: function(path, scheme, hasAuthority) {
      var t1 = scheme.length === 0;
      if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
        return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
      return P._Uri__removeDotSegments(path);
    },
    _Uri__makeQuery: function(query, start, end, queryParameters) {
      var result, t1 = {};
      H.assertSubtype(queryParameters, "$isMap", [P.String, null], "$asMap");
      if (query != null) {
        if (queryParameters != null)
          throw H.wrapException(P.ArgumentError$("Both query and queryParameters specified"));
        return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk, true);
      }
      if (queryParameters == null)
        return;
      result = new P.StringBuffer("");
      t1.separator = "";
      queryParameters.forEach$1(0, new P._Uri__makeQuery_closure(new P._Uri__makeQuery_writeParameter(t1, result)));
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__makeFragment: function(fragment, start, end) {
      if (fragment == null)
        return;
      return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk, true);
    },
    _Uri__normalizeEscape: function(source, index, lowerCase) {
      var firstDigit, secondDigit, firstDigitValue, secondDigitValue, value,
        t1 = index + 2;
      if (t1 >= source.length)
        return "%";
      firstDigit = C.JSString_methods.codeUnitAt$1(source, index + 1);
      secondDigit = C.JSString_methods.codeUnitAt$1(source, t1);
      firstDigitValue = H.hexDigitValue(firstDigit);
      secondDigitValue = H.hexDigitValue(secondDigit);
      if (firstDigitValue < 0 || secondDigitValue < 0)
        return "%";
      value = firstDigitValue * 16 + secondDigitValue;
      if (value < 127) {
        t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
        if (t1 >= 8)
          return H.ioore(C.List_nxB, t1);
        t1 = (C.List_nxB[t1] & 1 << (value & 15)) !== 0;
      } else
        t1 = false;
      if (t1)
        return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
      if (firstDigit >= 97 || secondDigit >= 97)
        return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
      return;
    },
    _Uri__escapeChar: function(char) {
      var t1, codeUnits, flag, encodedBytes, index, byte,
        _s16_ = "0123456789ABCDEF";
      if (char < 128) {
        t1 = new Array(3);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        C.JSArray_methods.$indexSet(codeUnits, 0, 37);
        C.JSArray_methods.$indexSet(codeUnits, 1, C.JSString_methods._codeUnitAt$1(_s16_, char >>> 4));
        C.JSArray_methods.$indexSet(codeUnits, 2, C.JSString_methods._codeUnitAt$1(_s16_, char & 15));
      } else {
        if (char > 2047)
          if (char > 65535) {
            flag = 240;
            encodedBytes = 4;
          } else {
            flag = 224;
            encodedBytes = 3;
          }
        else {
          flag = 192;
          encodedBytes = 2;
        }
        t1 = new Array(3 * encodedBytes);
        t1.fixed$length = Array;
        codeUnits = H.setRuntimeTypeInfo(t1, [P.int]);
        for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
          byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
          C.JSArray_methods.$indexSet(codeUnits, index, 37);
          C.JSArray_methods.$indexSet(codeUnits, index + 1, C.JSString_methods._codeUnitAt$1(_s16_, byte >>> 4));
          C.JSArray_methods.$indexSet(codeUnits, index + 2, C.JSString_methods._codeUnitAt$1(_s16_, byte & 15));
          index += 3;
        }
      }
      return P.String_String$fromCharCodes(codeUnits, 0, null);
    },
    _Uri__normalizeOrSubstring: function(component, start, end, charTable, escapeDelimiters) {
      var t1 = P._Uri__normalize(component, start, end, H.assertSubtype(charTable, "$isList", [P.int], "$asList"), escapeDelimiters);
      return t1 == null ? C.JSString_methods.substring$2(component, start, end) : t1;
    },
    _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
      var t1, index, sectionStart, buffer, char, t2, replacement, sourceLength, tail;
      H.assertSubtype(charTable, "$isList", [P.int], "$asList");
      t1 = !escapeDelimiters;
      index = start;
      sectionStart = index;
      buffer = null;
      while (true) {
        if (typeof index !== "number")
          return index.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (!(index < end))
          break;
        c$0: {
          char = C.JSString_methods.codeUnitAt$1(component, index);
          if (char < 127) {
            t2 = char >>> 4;
            if (t2 >= 8)
              return H.ioore(charTable, t2);
            t2 = (charTable[t2] & 1 << (char & 15)) !== 0;
          } else
            t2 = false;
          if (t2)
            ++index;
          else {
            if (char === 37) {
              replacement = P._Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index += 3;
                break c$0;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if (t1)
                if (char <= 93) {
                  t2 = char >>> 4;
                  if (t2 >= 8)
                    return H.ioore(C.List_2Vk, t2);
                  t2 = (C.List_2Vk[t2] & 1 << (char & 15)) !== 0;
                } else
                  t2 = false;
              else
                t2 = false;
              if (t2) {
                P._Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if ((char & 64512) === 55296) {
                  t2 = index + 1;
                  if (t2 < end) {
                    tail = C.JSString_methods.codeUnitAt$1(component, t2);
                    if ((tail & 64512) === 56320) {
                      char = 65536 | (char & 1023) << 10 | tail & 1023;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                replacement = P._Uri__escapeChar(char);
              }
            }
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(component, sectionStart, index);
            buffer._contents += H.S(replacement);
            if (typeof sourceLength !== "number")
              return H.iae(sourceLength);
            index += sourceLength;
            sectionStart = index;
          }
        }
      }
      if (buffer == null)
        return;
      if (typeof sectionStart !== "number")
        return sectionStart.$lt();
      if (sectionStart < end)
        buffer._contents += C.JSString_methods.substring$2(component, sectionStart, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__mayContainDotSegments: function(path) {
      if (C.JSString_methods.startsWith$1(path, "."))
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _Uri__removeDotSegments: function(path) {
      var output, t1, t2, appendSlash, _i, segment, t3;
      if (!P._Uri__mayContainDotSegments(path))
        return path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (J.$eq$(segment, "..")) {
          t3 = output.length;
          if (t3 !== 0) {
            if (0 >= t3)
              return H.ioore(output, -1);
            output.pop();
            if (output.length === 0)
              C.JSArray_methods.add$1(output, "");
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        C.JSArray_methods.add$1(output, "");
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__normalizeRelativePath: function(path, allowScheme) {
      var output, t1, t2, appendSlash, _i, segment;
      if (!P._Uri__mayContainDotSegments(path))
        return !allowScheme ? P._Uri__escapeScheme(path) : path;
      output = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = path.split("/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t2; ++_i) {
        segment = t1[_i];
        if (".." === segment)
          if (output.length !== 0 && C.JSArray_methods.get$last(output) !== "..") {
            if (0 >= output.length)
              return H.ioore(output, -1);
            output.pop();
            appendSlash = true;
          } else {
            C.JSArray_methods.add$1(output, "..");
            appendSlash = false;
          }
        else if ("." === segment)
          appendSlash = true;
        else {
          C.JSArray_methods.add$1(output, segment);
          appendSlash = false;
        }
      }
      t1 = output.length;
      if (t1 !== 0)
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(output, 0);
          t1 = output[0].length === 0;
        } else
          t1 = false;
      else
        t1 = true;
      if (t1)
        return "./";
      if (appendSlash || C.JSArray_methods.get$last(output) === "..")
        C.JSArray_methods.add$1(output, "");
      if (!allowScheme) {
        if (0 >= output.length)
          return H.ioore(output, 0);
        C.JSArray_methods.$indexSet(output, 0, P._Uri__escapeScheme(output[0]));
      }
      return C.JSArray_methods.join$1(output, "/");
    },
    _Uri__escapeScheme: function(path) {
      var i, char, t2,
        t1 = path.length;
      if (t1 >= 2 && P._Uri__isAlphabeticCharacter(J._codeUnitAt$1$s(path, 0)))
        for (i = 1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(path, i);
          if (char === 58)
            return C.JSString_methods.substring$2(path, 0, i) + "%3A" + C.JSString_methods.substring$1(path, i + 1);
          if (char <= 127) {
            t2 = char >>> 4;
            if (t2 >= 8)
              return H.ioore(C.List_JYB, t2);
            t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
          } else
            t2 = true;
          if (t2)
            break;
        }
      return path;
    },
    _Uri__toWindowsFilePath: function(uri) {
      var hasDriveLetter, t2, host,
        segments = uri.get$pathSegments(),
        t1 = segments.length;
      if (t1 > 0 && J.get$length$asx(segments[0]) === 2 && J.codeUnitAt$1$s(segments[0], 1) === 58) {
        if (0 >= t1)
          return H.ioore(segments, 0);
        P._Uri__checkWindowsDriveLetter(J.codeUnitAt$1$s(segments[0], 0), false);
        P._Uri__checkWindowsPathReservedCharacters(segments, false, 1);
        hasDriveLetter = true;
      } else {
        P._Uri__checkWindowsPathReservedCharacters(segments, false, 0);
        hasDriveLetter = false;
      }
      t2 = uri.get$hasAbsolutePath() && !hasDriveLetter ? "\\" : "";
      if (uri.get$hasAuthority()) {
        host = uri.get$host(uri);
        if (host.length !== 0)
          t2 = t2 + "\\" + H.S(host) + "\\";
      }
      t2 = P.StringBuffer__writeAll(t2, segments, "\\");
      t1 = hasDriveLetter && t1 === 1 ? t2 + "\\" : t2;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _Uri__hexCharPairToByte: function(s, pos) {
      var byte, i, charCode;
      for (byte = 0, i = 0; i < 2; ++i) {
        charCode = C.JSString_methods._codeUnitAt$1(s, pos + i);
        if (48 <= charCode && charCode <= 57)
          byte = byte * 16 + charCode - 48;
        else {
          charCode |= 32;
          if (97 <= charCode && charCode <= 102)
            byte = byte * 16 + charCode - 87;
          else
            throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
        }
      }
      return byte;
    },
    _Uri__uriDecode: function(text, start, end, encoding, plusToSpace) {
      var simple, codeUnit, t2, bytes,
        t1 = J.getInterceptor$s(text),
        i = start;
      while (true) {
        if (!(i < end)) {
          simple = true;
          break;
        }
        codeUnit = t1._codeUnitAt$1(text, i);
        if (codeUnit <= 127)
          if (codeUnit !== 37)
            t2 = plusToSpace && codeUnit === 43;
          else
            t2 = true;
        else
          t2 = true;
        if (t2) {
          simple = false;
          break;
        }
        ++i;
      }
      if (simple) {
        if (C.C_Utf8Codec !== encoding)
          t2 = false;
        else
          t2 = true;
        if (t2)
          return t1.substring$2(text, start, end);
        else
          bytes = new H.CodeUnits(t1.substring$2(text, start, end));
      } else {
        bytes = H.setRuntimeTypeInfo([], [P.int]);
        for (i = start; i < end; ++i) {
          codeUnit = t1._codeUnitAt$1(text, i);
          if (codeUnit > 127)
            throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
          if (codeUnit === 37) {
            if (i + 3 > text.length)
              throw H.wrapException(P.ArgumentError$("Truncated URI"));
            C.JSArray_methods.add$1(bytes, P._Uri__hexCharPairToByte(text, i + 1));
            i += 2;
          } else if (plusToSpace && codeUnit === 43)
            C.JSArray_methods.add$1(bytes, 32);
          else
            C.JSArray_methods.add$1(bytes, codeUnit);
        }
      }
      return encoding.decode$1(0, bytes);
    },
    _Uri__isAlphabeticCharacter: function(codeUnit) {
      var lowerCase = codeUnit | 32;
      return 97 <= lowerCase && lowerCase <= 122;
    },
    UriData__parse: function(text, start, sourceUri) {
      var t1, i, slashIndex, char, equalsIndex, lastSeparator, t2, data,
        _s17_ = "Invalid MIME type",
        indices = H.setRuntimeTypeInfo([start - 1], [P.int]);
      for (t1 = text.length, i = start, slashIndex = -1, char = null; i < t1; ++i) {
        char = C.JSString_methods._codeUnitAt$1(text, i);
        if (char === 44 || char === 59)
          break;
        if (char === 47) {
          if (slashIndex < 0) {
            slashIndex = i;
            continue;
          }
          throw H.wrapException(P.FormatException$(_s17_, text, i));
        }
      }
      if (slashIndex < 0 && i > start)
        throw H.wrapException(P.FormatException$(_s17_, text, i));
      for (; char !== 44;) {
        C.JSArray_methods.add$1(indices, i);
        ++i;
        for (equalsIndex = -1; i < t1; ++i) {
          char = C.JSString_methods._codeUnitAt$1(text, i);
          if (char === 61) {
            if (equalsIndex < 0)
              equalsIndex = i;
          } else if (char === 59 || char === 44)
            break;
        }
        if (equalsIndex >= 0)
          C.JSArray_methods.add$1(indices, equalsIndex);
        else {
          lastSeparator = C.JSArray_methods.get$last(indices);
          if (char !== 44 || i !== lastSeparator + 7 || !C.JSString_methods.startsWith$2(text, "base64", lastSeparator + 1))
            throw H.wrapException(P.FormatException$("Expecting '='", text, i));
          break;
        }
      }
      C.JSArray_methods.add$1(indices, i);
      t2 = i + 1;
      if ((indices.length & 1) === 1)
        text = C.C_Base64Codec.normalize$3(0, text, t2, t1);
      else {
        data = P._Uri__normalize(text, t2, t1, C.List_CVk, true);
        if (data != null)
          text = C.JSString_methods.replaceRange$3(text, t2, t1, data);
      }
      return new P.UriData(text, indices, sourceUri);
    },
    _createTables: function() {
      var _s77_ = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=",
        _s1_ = ".", _s1_0 = ":", _s1_1 = "/", _s1_2 = "?", _s1_3 = "#",
        tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List),
        t1 = new P._createTables_build(tables),
        t2 = new P._createTables_setChars(),
        t3 = new P._createTables_setRange(),
        b = H.interceptedTypeCheck(t1.call$2(0, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 14);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 3);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(14, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_, 15);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(15, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(1, 225), "$isUint8List");
      t2.call$3(b, _s77_, 1);
      t2.call$3(b, _s1_0, 34);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(2, 235), "$isUint8List");
      t2.call$3(b, _s77_, 139);
      t2.call$3(b, _s1_1, 131);
      t2.call$3(b, _s1_, 146);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(3, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 68);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(4, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(5, 229), "$isUint8List");
      t2.call$3(b, _s77_, 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, _s1_0, 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(6, 231), "$isUint8List");
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(7, 231), "$isUint8List");
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, _s1_1, 138);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      t2.call$3(H.interceptedTypeCheck(t1.call$2(8, 8), "$isUint8List"), "]", 5);
      b = H.interceptedTypeCheck(t1.call$2(9, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 16);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(16, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 17);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(17, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 9);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(10, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 18);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(18, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_, 19);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(19, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 234);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(11, 235), "$isUint8List");
      t2.call$3(b, _s77_, 11);
      t2.call$3(b, _s1_1, 10);
      t2.call$3(b, _s1_2, 172);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(12, 236), "$isUint8List");
      t2.call$3(b, _s77_, 12);
      t2.call$3(b, _s1_2, 12);
      t2.call$3(b, _s1_3, 205);
      b = H.interceptedTypeCheck(t1.call$2(13, 237), "$isUint8List");
      t2.call$3(b, _s77_, 13);
      t2.call$3(b, _s1_2, 13);
      t3.call$3(H.interceptedTypeCheck(t1.call$2(20, 245), "$isUint8List"), "az", 21);
      b = H.interceptedTypeCheck(t1.call$2(21, 245), "$isUint8List");
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var tables, t1, i, table, char, transition;
      H.assertSubtype(indices, "$isList", [P.int], "$asList");
      tables = $.$get$_scannerTables();
      for (t1 = J.getInterceptor$s(uri), i = start; i < end; ++i) {
        if (state < 0 || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = t1._codeUnitAt$1(uri, i) ^ 96;
        if (char > 95)
          char = 31;
        if (char >= table.length)
          return H.ioore(table, char);
        transition = table[char];
        state = transition & 31;
        C.JSArray_methods.$indexSet(indices, transition >>> 5, i);
      }
      return state;
    },
    NoSuchMethodError_toString_closure: function NoSuchMethodError_toString_closure(t0, t1) {
      this._box_0 = t0;
      this.sb = t1;
    },
    bool: function bool() {
    },
    DateTime: function DateTime(t0, t1) {
      this._value = t0;
      this.isUtc = t1;
    },
    double: function double() {
    },
    Duration: function Duration(t0) {
      this._duration = t0;
    },
    Duration_toString_sixDigits: function Duration_toString_sixDigits() {
    },
    Duration_toString_twoDigits: function Duration_toString_twoDigits() {
    },
    Error: function Error() {
    },
    AssertionError: function AssertionError() {
    },
    NullThrownError: function NullThrownError() {
    },
    ArgumentError: function ArgumentError(t0, t1, t2, t3) {
      var _ = this;
      _._hasValue = t0;
      _.invalidValue = t1;
      _.name = t2;
      _.message = t3;
    },
    RangeError: function RangeError(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.start = t0;
      _.end = t1;
      _._hasValue = t2;
      _.invalidValue = t3;
      _.name = t4;
      _.message = t5;
    },
    IndexError: function IndexError(t0, t1, t2, t3, t4) {
      var _ = this;
      _.length = t0;
      _._hasValue = t1;
      _.invalidValue = t2;
      _.name = t3;
      _.message = t4;
    },
    NoSuchMethodError: function NoSuchMethodError(t0, t1, t2, t3) {
      var _ = this;
      _._core$_receiver = t0;
      _._core$_memberName = t1;
      _._core$_arguments = t2;
      _._namedArguments = t3;
    },
    UnsupportedError: function UnsupportedError(t0) {
      this.message = t0;
    },
    UnimplementedError: function UnimplementedError(t0) {
      this.message = t0;
    },
    StateError: function StateError(t0) {
      this.message = t0;
    },
    ConcurrentModificationError: function ConcurrentModificationError(t0) {
      this.modifiedObject = t0;
    },
    OutOfMemoryError: function OutOfMemoryError() {
    },
    StackOverflowError: function StackOverflowError() {
    },
    CyclicInitializationError: function CyclicInitializationError(t0) {
      this.variableName = t0;
    },
    _Exception: function _Exception(t0) {
      this.message = t0;
    },
    FormatException: function FormatException(t0, t1, t2) {
      this.message = t0;
      this.source = t1;
      this.offset = t2;
    },
    Expando: function Expando(t0, t1, t2) {
      this._jsWeakMapOrKey = t0;
      this.name = t1;
      this.$ti = t2;
    },
    Function: function Function() {
    },
    int: function int() {
    },
    Iterable: function Iterable() {
    },
    Iterator: function Iterator() {
    },
    List: function List() {
    },
    Map: function Map() {
    },
    MapEntry: function MapEntry(t0, t1, t2) {
      this.key = t0;
      this.value = t1;
      this.$ti = t2;
    },
    Null: function Null() {
    },
    num: function num() {
    },
    Object: function Object() {
    },
    Match: function Match() {
    },
    RegExp: function RegExp() {
    },
    RegExpMatch: function RegExpMatch() {
    },
    Set: function Set() {
    },
    StackTrace: function StackTrace() {
    },
    Stopwatch: function Stopwatch() {
      this._stop = this._core$_start = 0;
    },
    String: function String() {
    },
    Runes: function Runes(t0) {
      this.string = t0;
    },
    RuneIterator: function RuneIterator(t0) {
      var _ = this;
      _.string = t0;
      _._nextPosition = _._core$_position = 0;
      _._currentCodePoint = null;
    },
    StringBuffer: function StringBuffer(t0) {
      this._contents = t0;
    },
    Symbol0: function Symbol0() {
    },
    Type: function Type() {
    },
    Uri_splitQueryString_closure: function Uri_splitQueryString_closure(t0) {
      this.encoding = t0;
    },
    Uri__parseIPv4Address_error: function Uri__parseIPv4Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_error: function Uri_parseIPv6Address_error(t0) {
      this.host = t0;
    },
    Uri_parseIPv6Address_parseHex: function Uri_parseIPv6Address_parseHex(t0, t1) {
      this.error = t0;
      this.host = t1;
    },
    _Uri: function _Uri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._queryParameters = _._hashCodeCache = _._text = _._pathSegments = null;
    },
    _Uri__Uri$notSimple_closure: function _Uri__Uri$notSimple_closure(t0, t1) {
      this.uri = t0;
      this.portStart = t1;
    },
    _Uri__checkNonWindowsPathReservedCharacters_closure: function _Uri__checkNonWindowsPathReservedCharacters_closure(t0) {
      this.argumentError = t0;
    },
    _Uri__makePath_closure: function _Uri__makePath_closure() {
    },
    _Uri__makeQuery_writeParameter: function _Uri__makeQuery_writeParameter(t0, t1) {
      this._box_0 = t0;
      this.result = t1;
    },
    _Uri__makeQuery_closure: function _Uri__makeQuery_closure(t0) {
      this.writeParameter = t0;
    },
    UriData: function UriData(t0, t1, t2) {
      this._text = t0;
      this._separatorIndices = t1;
      this._uriCache = t2;
    },
    _createTables_closure: function _createTables_closure() {
    },
    _createTables_build: function _createTables_build(t0) {
      this.tables = t0;
    },
    _createTables_setChars: function _createTables_setChars() {
    },
    _createTables_setRange: function _createTables_setRange() {
    },
    _SimpleUri: function _SimpleUri(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _._uri = t0;
      _._schemeEnd = t1;
      _._hostStart = t2;
      _._portStart = t3;
      _._pathStart = t4;
      _._queryStart = t5;
      _._fragmentStart = t6;
      _._schemeCache = t7;
      _._hashCodeCache = null;
    },
    _DataUri: function _DataUri(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.scheme = t0;
      _._userInfo = t1;
      _._host = t2;
      _._port = t3;
      _.path = t4;
      _._query = t5;
      _._fragment = t6;
      _._queryParameters = _._hashCodeCache = _._text = _._pathSegments = null;
    },
    convertNativeToDart_Dictionary: function(object) {
      var dict, keys, t1, _i, key;
      if (object == null)
        return;
      dict = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      keys = Object.getOwnPropertyNames(object);
      for (t1 = keys.length, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
        key = H.stringTypeCheck(keys[_i]);
        dict.$indexSet(0, key, object[key]);
      }
      return dict;
    },
    convertDartToNative_Dictionary: function(dict) {
      var object = {};
      dict.forEach$1(0, new P.convertDartToNative_Dictionary_closure(object));
      return object;
    },
    convertNativePromiseToDartFuture: function(promise) {
      var t1 = new P._Future($.Zone__current, [null]),
        completer = new P._AsyncCompleter(t1, [null]);
      promise.then(H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure(completer), 1))["catch"](H.convertDartClosureToJS(new P.convertNativePromiseToDartFuture_closure0(completer), 1));
      return t1;
    },
    Device_isOpera: function() {
      var t1 = $.Device__isOpera;
      return t1 == null ? $.Device__isOpera = J.contains$2$asx(window.navigator.userAgent, "Opera", 0) : t1;
    },
    Device_isWebKit: function() {
      var t1 = $.Device__isWebKit;
      if (t1 == null)
        t1 = $.Device__isWebKit = !H.boolConversionCheck(P.Device_isOpera()) && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      return t1;
    },
    Device_cssPrefix: function() {
      var t1,
        prefix = $.Device__cachedCssPrefix;
      if (prefix != null)
        return prefix;
      t1 = $.Device__isFirefox;
      if (t1 == null ? $.Device__isFirefox = J.contains$2$asx(window.navigator.userAgent, "Firefox", 0) : t1)
        prefix = "-moz-";
      else {
        t1 = $.Device__isIE;
        if (t1 == null)
          t1 = $.Device__isIE = !H.boolConversionCheck(P.Device_isOpera()) && J.contains$2$asx(window.navigator.userAgent, "Trident/", 0);
        if (t1)
          prefix = "-ms-";
        else
          prefix = H.boolConversionCheck(P.Device_isOpera()) ? "-o-" : "-webkit-";
      }
      return $.Device__cachedCssPrefix = prefix;
    },
    _StructuredClone: function _StructuredClone() {
    },
    _StructuredClone_walk_closure: function _StructuredClone_walk_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    _AcceptStructuredClone: function _AcceptStructuredClone() {
    },
    _AcceptStructuredClone_walk_closure: function _AcceptStructuredClone_walk_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    convertDartToNative_Dictionary_closure: function convertDartToNative_Dictionary_closure(t0) {
      this.object = t0;
    },
    _StructuredCloneDart2Js: function _StructuredCloneDart2Js(t0, t1) {
      this.values = t0;
      this.copies = t1;
    },
    _AcceptStructuredCloneDart2Js: function _AcceptStructuredCloneDart2Js(t0, t1) {
      this.values = t0;
      this.copies = t1;
      this.mustCopy = false;
    },
    convertNativePromiseToDartFuture_closure: function convertNativePromiseToDartFuture_closure(t0) {
      this.completer = t0;
    },
    convertNativePromiseToDartFuture_closure0: function convertNativePromiseToDartFuture_closure0(t0) {
      this.completer = t0;
    },
    CssClassSetImpl: function CssClassSetImpl() {
    },
    CssClassSetImpl_add_closure: function CssClassSetImpl_add_closure(t0) {
      this.value = t0;
    },
    CssClassSetImpl_addAll_closure: function CssClassSetImpl_addAll_closure(t0, t1) {
      this.$this = t0;
      this.iterable = t1;
    },
    CssClassSetImpl_removeAll_closure: function CssClassSetImpl_removeAll_closure(t0) {
      this.iterable = t0;
    },
    CssClassSetImpl_removeWhere_closure: function CssClassSetImpl_removeWhere_closure(t0) {
      this.test = t0;
    },
    CssClassSetImpl_clear_closure: function CssClassSetImpl_clear_closure() {
    },
    FilteredElementList: function FilteredElementList(t0, t1) {
      this._node = t0;
      this._childNodes = t1;
    },
    FilteredElementList__iterable_closure: function FilteredElementList__iterable_closure() {
    },
    FilteredElementList__iterable_closure0: function FilteredElementList__iterable_closure0() {
    },
    FilteredElementList_removeRange_closure: function FilteredElementList_removeRange_closure() {
    },
    Cursor: function Cursor() {
    },
    CursorWithValue: function CursorWithValue() {
    },
    Database: function Database() {
    },
    Index: function Index() {
    },
    KeyRange: function KeyRange() {
    },
    ObjectStore: function ObjectStore() {
    },
    Observation: function Observation() {
    },
    _callDartFunction: function(callback, captureThis, $self, $arguments) {
      var arguments0, dartArgs;
      H.boolTypeCheck(captureThis);
      H.listTypeCheck($arguments);
      if (H.boolConversionCheck(captureThis)) {
        arguments0 = [$self];
        C.JSArray_methods.addAll$1(arguments0, $arguments);
        $arguments = arguments0;
      }
      dartArgs = P.List_List$from(J.map$1$1$ax($arguments, P.js___convertToDart$closure(), null), true, null);
      return P._convertToJS(P.Function_apply(H.interceptedTypeCheck(callback, "$isFunction"), dartArgs));
    },
    JsObject_JsObject: function($constructor, $arguments) {
      var args, t1, factoryFunction,
        constr = P._convertToJS($constructor);
      if ($arguments instanceof Array)
        switch ($arguments.length) {
          case 0:
            return H.interceptedTypeCheck(P._wrapToDart(new constr()), "$isJsObject");
          case 1:
            return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]))), "$isJsObject");
          case 2:
            return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]))), "$isJsObject");
          case 3:
            return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]), P._convertToJS($arguments[2]))), "$isJsObject");
          case 4:
            return H.interceptedTypeCheck(P._wrapToDart(new constr(P._convertToJS($arguments[0]), P._convertToJS($arguments[1]), P._convertToJS($arguments[2]), P._convertToJS($arguments[3]))), "$isJsObject");
        }
      args = [null];
      t1 = H.getTypeArgumentByIndex($arguments, 0);
      C.JSArray_methods.addAll$1(args, new H.MappedListIterable($arguments, H.functionTypeCheck(P.js___convertToJS$closure(), {func: 1, ret: null, args: [t1]}), [t1, null]));
      factoryFunction = constr.bind.apply(constr, args);
      String(factoryFunction);
      return H.interceptedTypeCheck(P._wrapToDart(new factoryFunction()), "$isJsObject");
    },
    JsObject_JsObject$jsify: function(object) {
      return H.interceptedTypeCheck(P._wrapToDart(P.JsObject__convertDataTree(object)), "$isJsObject");
    },
    JsObject__convertDataTree: function(data) {
      return new P.JsObject__convertDataTree__convert(new P._IdentityHashMap([null, null])).call$1(data);
    },
    JsArray__checkRange: function(start, end, $length) {
      var _null = null;
      if (start < 0 || start > $length)
        throw H.wrapException(P.RangeError$range(start, 0, $length, _null, _null));
      if (typeof end !== "number")
        return end.$lt();
      if (end < start || end > $length)
        throw H.wrapException(P.RangeError$range(end, start, $length, _null, _null));
    },
    _defineProperty: function(o, $name, value) {
      var exception;
      try {
        if (Object.isExtensible(o) && !Object.prototype.hasOwnProperty.call(o, $name)) {
          Object.defineProperty(o, $name, {value: value});
          return true;
        }
      } catch (exception) {
        H.unwrapException(exception);
      }
      return false;
    },
    _getOwnProperty: function(o, $name) {
      if (Object.prototype.hasOwnProperty.call(o, $name))
        return o[$name];
      return;
    },
    _convertToJS: function(o) {
      var t1;
      if (o == null || typeof o === "string" || typeof o === "number" || typeof o === "boolean")
        return o;
      t1 = J.getInterceptor$(o);
      if (!!t1.$isJsObject)
        return o._jsObject;
      if (H.isBrowserObject(o))
        return o;
      if (!!t1.$isTypedData)
        return o;
      if (!!t1.$isDateTime)
        return H.Primitives_lazyAsJsDate(o);
      if (!!t1.$isFunction)
        return P._getJsProxy(o, "$dart_jsFunction", new P._convertToJS_closure());
      return P._getJsProxy(o, "_$dart_jsObject", new P._convertToJS_closure0($.$get$_dartProxyCtor()));
    },
    _getJsProxy: function(o, propertyName, createProxy) {
      var jsProxy;
      H.functionTypeCheck(createProxy, {func: 1, args: [,]});
      jsProxy = P._getOwnProperty(o, propertyName);
      if (jsProxy == null) {
        jsProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, jsProxy);
      }
      return jsProxy;
    },
    _convertToDart: function(o) {
      var ms, t1;
      if (o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean")
        return o;
      else if (o instanceof Object && H.isBrowserObject(o))
        return o;
      else if (o instanceof Object && !!J.getInterceptor$(o).$isTypedData)
        return o;
      else if (o instanceof Date) {
        ms = H.intTypeCheck(o.getTime());
        t1 = new P.DateTime(ms, false);
        t1.DateTime$_withValue$2$isUtc(ms, false);
        return t1;
      } else if (o.constructor === $.$get$_dartProxyCtor())
        return o.o;
      else
        return P._wrapToDart(o);
    },
    _wrapToDart: function(o) {
      if (typeof o == "function")
        return P._getDartProxy(o, $.$get$DART_CLOSURE_PROPERTY_NAME(), new P._wrapToDart_closure());
      if (o instanceof Array)
        return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure0());
      return P._getDartProxy(o, $.$get$_DART_OBJECT_PROPERTY_NAME(), new P._wrapToDart_closure1());
    },
    _getDartProxy: function(o, propertyName, createProxy) {
      var dartProxy;
      H.functionTypeCheck(createProxy, {func: 1, args: [,]});
      dartProxy = P._getOwnProperty(o, propertyName);
      if (dartProxy == null || !(o instanceof Object)) {
        dartProxy = createProxy.call$1(o);
        P._defineProperty(o, propertyName, dartProxy);
      }
      return dartProxy;
    },
    _convertDartFunctionFast: function(f) {
      var ret,
        existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    },
    _callDartFunctionFast: function(callback, $arguments) {
      H.listTypeCheck($arguments);
      return P.Function_apply(H.interceptedTypeCheck(callback, "$isFunction"), $arguments);
    },
    allowInterop: function(f, $F) {
      H.assertIsSubtype($F, P.Function, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'F' in 'allowInterop'.");
      H.assertSubtypeOfRuntimeType(f, $F);
      if (typeof f == "function")
        return f;
      else
        return H.assertSubtypeOfRuntimeType(P._convertDartFunctionFast(f), $F);
    },
    JsObject: function JsObject(t0) {
      this._jsObject = t0;
    },
    JsObject__convertDataTree__convert: function JsObject__convertDataTree__convert(t0) {
      this._convertedObjects = t0;
    },
    JsFunction: function JsFunction(t0) {
      this._jsObject = t0;
    },
    JsArray: function JsArray(t0, t1) {
      this._jsObject = t0;
      this.$ti = t1;
    },
    _convertToJS_closure: function _convertToJS_closure() {
    },
    _convertToJS_closure0: function _convertToJS_closure0(t0) {
      this.ctor = t0;
    },
    _wrapToDart_closure: function _wrapToDart_closure() {
    },
    _wrapToDart_closure0: function _wrapToDart_closure0() {
    },
    _wrapToDart_closure1: function _wrapToDart_closure1() {
    },
    _JsArray_JsObject_ListMixin: function _JsArray_JsObject_ListMixin() {
    },
    jsify: function(object) {
      return P._convertDataTree(object);
    },
    _convertDataTree: function(data) {
      return new P._convertDataTree__convert(new P._IdentityHashMap([null, null])).call$1(data);
    },
    _convertDataTree__convert: function _convertDataTree__convert(t0) {
      this._convertedObjects = t0;
    },
    log: function(x) {
      return Math.log(x);
    },
    pow: function(x, exponent) {
      H.checkNum(exponent);
      return Math.pow(x, exponent);
    },
    _JenkinsSmiHash_combine0: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    Point: function Point(t0, t1, t2) {
      this.x = t0;
      this.y = t1;
      this.$ti = t2;
    },
    _RectangleBase: function _RectangleBase() {
    },
    Rectangle: function Rectangle() {
    },
    Angle: function Angle() {
    },
    Length: function Length() {
    },
    LengthList: function LengthList() {
    },
    Number: function Number() {
    },
    NumberList: function NumberList() {
    },
    PointList: function PointList() {
    },
    ScriptElement: function ScriptElement() {
    },
    StringList: function StringList() {
    },
    AttributeClassSet: function AttributeClassSet(t0) {
      this._svg$_element = t0;
    },
    SvgElement: function SvgElement() {
    },
    Transform: function Transform() {
    },
    TransformList: function TransformList() {
    },
    _LengthList_Interceptor_ListMixin: function _LengthList_Interceptor_ListMixin() {
    },
    _LengthList_Interceptor_ListMixin_ImmutableListMixin: function _LengthList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _NumberList_Interceptor_ListMixin: function _NumberList_Interceptor_ListMixin() {
    },
    _NumberList_Interceptor_ListMixin_ImmutableListMixin: function _NumberList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _StringList_Interceptor_ListMixin: function _StringList_Interceptor_ListMixin() {
    },
    _StringList_Interceptor_ListMixin_ImmutableListMixin: function _StringList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _TransformList_Interceptor_ListMixin: function _TransformList_Interceptor_ListMixin() {
    },
    _TransformList_Interceptor_ListMixin_ImmutableListMixin: function _TransformList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    ByteBuffer: function ByteBuffer() {
    },
    ByteData: function ByteData() {
    },
    Int8List: function Int8List() {
    },
    Uint8List: function Uint8List() {
    },
    Uint8ClampedList: function Uint8ClampedList() {
    },
    Int16List: function Int16List() {
    },
    Uint16List: function Uint16List() {
    },
    Int32List: function Int32List() {
    },
    Uint32List: function Uint32List() {
    },
    Float32List: function Float32List() {
    },
    Float64List: function Float64List() {
    },
    AudioBuffer: function AudioBuffer() {
    },
    AudioParam: function AudioParam() {
    },
    AudioParamMap: function AudioParamMap() {
    },
    AudioParamMap_keys_closure: function AudioParamMap_keys_closure(t0) {
      this.keys = t0;
    },
    AudioParamMap_values_closure: function AudioParamMap_values_closure(t0) {
      this.values = t0;
    },
    AudioTrack: function AudioTrack() {
    },
    AudioTrackList: function AudioTrackList() {
    },
    BaseAudioContext: function BaseAudioContext() {
    },
    OfflineAudioContext: function OfflineAudioContext() {
    },
    _AudioParamMap_Interceptor_MapMixin: function _AudioParamMap_Interceptor_MapMixin() {
    },
    ActiveInfo: function ActiveInfo() {
    },
    SqlError: function SqlError() {
    },
    SqlResultSetRowList: function SqlResultSetRowList() {
    },
    _SqlResultSetRowList_Interceptor_ListMixin: function _SqlResultSetRowList_Interceptor_ListMixin() {
    },
    _SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin: function _SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin() {
    }
  },
  W = {
    window: function() {
      return window;
    },
    promiseToFuture: function(jsPromise, $T) {
      var t1 = new P._Future($.Zone__current, [$T]),
        completer = new P._AsyncCompleter(t1, [$T]);
      jsPromise.then(H.convertDartClosureToJS(new W.promiseToFuture_closure(completer, $T), 1), H.convertDartClosureToJS(new W.promiseToFuture_closure0(completer), 1));
      return t1;
    },
    Blob_Blob: function(blobParts) {
      var t1 = new self.Blob(blobParts);
      return t1;
    },
    CanvasElement_CanvasElement: function(height, width) {
      var e = document.createElement("canvas");
      if (width != null)
        e.width = width;
      if (height != null)
        e.height = height;
      return e;
    },
    Element_Element$html: function(html, treeSanitizer, validator) {
      var t1 = document.body,
        fragment = (t1 && C.BodyElement_methods).createFragment$3$treeSanitizer$validator(t1, html, treeSanitizer, validator);
      fragment.toString;
      t1 = W.Node;
      t1 = new H.WhereIterable(new W._ChildNodeListLazy(fragment), H.functionTypeCheck(new W.Element_Element$html_closure(), {func: 1, ret: P.bool, args: [t1]}), [t1]);
      return H.interceptedTypeCheck(t1.get$single(t1), "$isElement");
    },
    Element__determineMouseWheelEventType: function(e) {
      H.interceptedTypeCheck(e, "$isEventTarget");
      return "wheel";
    },
    Element__safeTagName: function(element) {
      var t1, t2, exception,
        result = "element tag unavailable";
      try {
        t1 = J.getInterceptor$x(element);
        t2 = t1.get$tagName(element);
        if (typeof t2 === "string")
          result = t1.get$tagName(element);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return result;
    },
    _ElementFactoryProvider_createElement_tag: function(tag, typeExtension) {
      return document.createElement(tag);
    },
    Event_Event$eventType: function(type, $name, canBubble, cancelable) {
      var e = document.createEvent(type);
      e.initEvent($name, true, true);
      return e;
    },
    FontFace_FontFace: function(family, source) {
      return new FontFace(family, source);
    },
    ImageElement_ImageElement: function(src) {
      var e = document.createElement("img");
      e.src = src;
      return e;
    },
    WebSocket_WebSocket: function(url) {
      return new WebSocket(url);
    },
    _JenkinsSmiHash_combine: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _JenkinsSmiHash_hash4: function(a, b, c, d) {
      var t1 = W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, a), b), c), d),
        hash = 536870911 & t1 + ((67108863 & t1) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    _ElementCssClassSet__toggleOnOff: function(_element, value, shouldAdd) {
      var list = _element.classList;
      if (shouldAdd) {
        list.add(value);
        return true;
      } else {
        list.remove(value);
        return false;
      }
    },
    _ElementCssClassSet__addAll: function(_element, iterable) {
      var list, t1;
      H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable");
      list = _element.classList;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();)
        list.add(t1.get$current(t1));
    },
    _ElementCssClassSet__removeAll: function(_element, iterable) {
      var list, t1, _i;
      H.assertSubtype(iterable, "$isIterable", [P.Object], "$asIterable");
      list = _element.classList;
      for (t1 = iterable.length, _i = 0; _i < iterable.length; iterable.length === t1 || (0, H.throwConcurrentModificationError)(iterable), ++_i)
        list.remove(H.stringTypeCheck(iterable[_i]));
    },
    _ElementCssClassSet__removeWhere: function(_element, test, doRemove) {
      var list, i, item;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [P.String]});
      list = _element.classList;
      for (i = 0; i < list.length;) {
        item = list.item(i);
        if (true === test.call$1(item))
          list.remove(item);
        else
          ++i;
      }
    },
    _EventStreamSubscription$: function(_target, _eventType, onData, _useCapture, $T) {
      var t1 = onData == null ? null : W._wrapZone(new W._EventStreamSubscription_closure(onData), W.Event);
      t1 = new W._EventStreamSubscription(_target, _eventType, t1, false, [$T]);
      t1._tryResume$0();
      return t1;
    },
    _Html5NodeValidator$: function(uriPolicy) {
      var e = document.createElement("a"),
        t1 = new W._SameOriginUriPolicy(e, window.location);
      t1 = new W._Html5NodeValidator(t1);
      t1._Html5NodeValidator$1$uriPolicy(uriPolicy);
      return t1;
    },
    _Html5NodeValidator__standardAttributeValidator: function(element, attributeName, value, context) {
      H.interceptedTypeCheck(element, "$isElement");
      H.stringTypeCheck(attributeName);
      H.stringTypeCheck(value);
      H.interceptedTypeCheck(context, "$is_Html5NodeValidator");
      return true;
    },
    _Html5NodeValidator__uriAttributeValidator: function(element, attributeName, value, context) {
      var t1, t2, t3;
      H.interceptedTypeCheck(element, "$isElement");
      H.stringTypeCheck(attributeName);
      H.stringTypeCheck(value);
      t1 = H.interceptedTypeCheck(context, "$is_Html5NodeValidator").uriPolicy;
      t2 = t1._hiddenAnchor;
      t2.href = value;
      t3 = t2.hostname;
      t1 = t1._loc;
      if (!(t3 == t1.hostname && t2.port == t1.port && t2.protocol == t1.protocol))
        if (t3 === "")
          if (t2.port === "") {
            t1 = t2.protocol;
            t1 = t1 === ":" || t1 === "";
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = true;
      return t1;
    },
    _TemplatingNodeValidator$: function() {
      var t1 = P.String,
        t2 = P.LinkedHashSet_LinkedHashSet$from(C.List_wSV, t1),
        t3 = H.getTypeArgumentByIndex(C.List_wSV, 0),
        t4 = H.functionTypeCheck(new W._TemplatingNodeValidator_closure(), {func: 1, ret: t1, args: [t3]}),
        t5 = H.setRuntimeTypeInfo(["TEMPLATE"], [t1]);
      t2 = new W._TemplatingNodeValidator(t2, P.LinkedHashSet_LinkedHashSet(t1), P.LinkedHashSet_LinkedHashSet(t1), P.LinkedHashSet_LinkedHashSet(t1), null);
      t2._SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes(null, new H.MappedListIterable(C.List_wSV, t4, [t3, t1]), t5, null);
      return t2;
    },
    _convertNativeToDart_EventTarget: function(e) {
      var $window;
      if (e == null)
        return;
      if ("postMessage" in e) {
        $window = W._DOMWindowCrossFrame__createSafe(e);
        if (!!J.getInterceptor$($window).$isEventTarget)
          return $window;
        return;
      } else
        return H.interceptedTypeCheck(e, "$isEventTarget");
    },
    _convertNativeToDart_XHR_Response: function(o) {
      if (!!J.getInterceptor$(o).$isDocument)
        return o;
      return new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(o, true);
    },
    _DOMWindowCrossFrame__createSafe: function(w) {
      if (w === window)
        return H.interceptedTypeCheck(w, "$isWindowBase");
      else
        return new W._DOMWindowCrossFrame(w);
    },
    _wrapZone: function(callback, $T) {
      var t1;
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [$T]});
      t1 = $.Zone__current;
      if (t1 === C.C__RootZone)
        return callback;
      if (callback == null)
        return;
      return t1.bindUnaryCallbackGuarded$1$1(callback, $T);
    },
    promiseToFuture_closure: function promiseToFuture_closure(t0, t1) {
      this.completer = t0;
      this.T = t1;
    },
    promiseToFuture_closure0: function promiseToFuture_closure0(t0) {
      this.completer = t0;
    },
    HtmlElement: function HtmlElement() {
    },
    AccessibleNodeList: function AccessibleNodeList() {
    },
    AnchorElement: function AnchorElement() {
    },
    Animation: function Animation() {
    },
    ApplicationCacheErrorEvent: function ApplicationCacheErrorEvent() {
    },
    AreaElement: function AreaElement() {
    },
    BackgroundFetchEvent: function BackgroundFetchEvent() {
    },
    BackgroundFetchRegistration: function BackgroundFetchRegistration() {
    },
    BaseElement: function BaseElement() {
    },
    Blob: function Blob() {
    },
    BluetoothRemoteGattDescriptor: function BluetoothRemoteGattDescriptor() {
    },
    Body: function Body() {
    },
    BodyElement: function BodyElement() {
    },
    BroadcastChannel: function BroadcastChannel() {
    },
    ButtonElement: function ButtonElement() {
    },
    CanvasElement: function CanvasElement() {
    },
    CanvasRenderingContext2D: function CanvasRenderingContext2D() {
    },
    CharacterData: function CharacterData() {
    },
    Client0: function Client0() {
    },
    CloseEvent: function CloseEvent() {
    },
    Credential: function Credential() {
    },
    CredentialUserData: function CredentialUserData() {
    },
    CssKeyframesRule: function CssKeyframesRule() {
    },
    CssKeywordValue: function CssKeywordValue() {
    },
    CssNumericValue: function CssNumericValue() {
    },
    CssPerspective: function CssPerspective() {
    },
    CssRule: function CssRule() {
    },
    CssStyleDeclaration: function CssStyleDeclaration() {
    },
    CssStyleDeclarationBase: function CssStyleDeclarationBase() {
    },
    CssStyleValue: function CssStyleValue() {
    },
    CssTransformComponent: function CssTransformComponent() {
    },
    CssTransformValue: function CssTransformValue() {
    },
    CssUnitValue: function CssUnitValue() {
    },
    CssUnparsedValue: function CssUnparsedValue() {
    },
    DataElement: function DataElement() {
    },
    DataTransferItem: function DataTransferItem() {
    },
    DataTransferItemList: function DataTransferItemList() {
    },
    DeprecationReport: function DeprecationReport() {
    },
    DivElement: function DivElement() {
    },
    Document: function Document() {
    },
    DomError: function DomError() {
    },
    DomException: function DomException() {
    },
    DomRectList: function DomRectList() {
    },
    DomRectReadOnly: function DomRectReadOnly() {
    },
    DomStringList: function DomStringList() {
    },
    DomTokenList: function DomTokenList() {
    },
    _ChildrenElementList: function _ChildrenElementList(t0, t1) {
      this._element = t0;
      this._childElements = t1;
    },
    _FrozenElementList: function _FrozenElementList(t0, t1) {
      this._nodeList = t0;
      this.$ti = t1;
    },
    Element: function Element() {
    },
    Element_Element$html_closure: function Element_Element$html_closure() {
    },
    ScrollAlignment: function ScrollAlignment(t0) {
      this._html$_value = t0;
    },
    EmbedElement: function EmbedElement() {
    },
    Entry: function Entry() {
    },
    Entry_remove_closure: function Entry_remove_closure(t0) {
      this.completer = t0;
    },
    Entry_remove_closure0: function Entry_remove_closure0(t0) {
      this.completer = t0;
    },
    ErrorEvent: function ErrorEvent() {
    },
    Event: function Event() {
    },
    EventTarget: function EventTarget() {
    },
    ExtendableEvent: function ExtendableEvent() {
    },
    FederatedCredential: function FederatedCredential() {
    },
    FieldSetElement: function FieldSetElement() {
    },
    File: function File() {
    },
    FileList: function FileList() {
    },
    FileReader: function FileReader() {
    },
    FileSystem: function FileSystem() {
    },
    FileWriter: function FileWriter() {
    },
    FontFace: function FontFace() {
    },
    FormElement: function FormElement() {
    },
    Gamepad: function Gamepad() {
    },
    GamepadButton: function GamepadButton() {
    },
    History: function History() {
    },
    HtmlCollection: function HtmlCollection() {
    },
    HttpRequest: function HttpRequest() {
    },
    HttpRequestEventTarget: function HttpRequestEventTarget() {
    },
    IFrameElement: function IFrameElement() {
    },
    ImageData: function ImageData() {
    },
    ImageElement: function ImageElement() {
    },
    InputElement: function InputElement() {
    },
    InterventionReport: function InterventionReport() {
    },
    KeyboardEvent: function KeyboardEvent() {
    },
    LIElement: function LIElement() {
    },
    Location: function Location() {
    },
    MapElement: function MapElement() {
    },
    MediaDeviceInfo: function MediaDeviceInfo() {
    },
    MediaElement: function MediaElement() {
    },
    MediaError: function MediaError() {
    },
    MediaKeyMessageEvent: function MediaKeyMessageEvent() {
    },
    MediaKeySession: function MediaKeySession() {
    },
    MediaList: function MediaList() {
    },
    MediaStream: function MediaStream() {
    },
    MediaStreamTrack: function MediaStreamTrack() {
    },
    MessageEvent: function MessageEvent() {
    },
    MessagePort: function MessagePort() {
    },
    MetaElement: function MetaElement() {
    },
    MeterElement: function MeterElement() {
    },
    MidiInputMap: function MidiInputMap() {
    },
    MidiInputMap_keys_closure: function MidiInputMap_keys_closure(t0) {
      this.keys = t0;
    },
    MidiInputMap_values_closure: function MidiInputMap_values_closure(t0) {
      this.values = t0;
    },
    MidiOutputMap: function MidiOutputMap() {
    },
    MidiOutputMap_keys_closure: function MidiOutputMap_keys_closure(t0) {
      this.keys = t0;
    },
    MidiOutputMap_values_closure: function MidiOutputMap_values_closure(t0) {
      this.values = t0;
    },
    MidiPort: function MidiPort() {
    },
    MimeType: function MimeType() {
    },
    MimeTypeArray: function MimeTypeArray() {
    },
    MouseEvent: function MouseEvent() {
    },
    NavigatorUserMediaError: function NavigatorUserMediaError() {
    },
    _ChildNodeListLazy: function _ChildNodeListLazy(t0) {
      this._this = t0;
    },
    Node: function Node() {
    },
    NodeList: function NodeList() {
    },
    ObjectElement: function ObjectElement() {
    },
    OptionElement: function OptionElement() {
    },
    OutputElement: function OutputElement() {
    },
    OverconstrainedError: function OverconstrainedError() {
    },
    ParamElement: function ParamElement() {
    },
    PasswordCredential: function PasswordCredential() {
    },
    PaymentRequest: function PaymentRequest() {
    },
    PerformanceEntry: function PerformanceEntry() {
    },
    PerformanceServerTiming: function PerformanceServerTiming() {
    },
    Plugin: function Plugin() {
    },
    PluginArray: function PluginArray() {
    },
    PopStateEvent: function PopStateEvent() {
    },
    PositionError: function PositionError() {
    },
    PresentationAvailability: function PresentationAvailability() {
    },
    PresentationConnection: function PresentationConnection() {
    },
    PresentationConnectionCloseEvent: function PresentationConnectionCloseEvent() {
    },
    ProgressElement0: function ProgressElement0() {
    },
    ProgressEvent: function ProgressEvent() {
    },
    PushMessageData: function PushMessageData() {
    },
    RelatedApplication: function RelatedApplication() {
    },
    ReportBody: function ReportBody() {
    },
    ResizeObserver: function ResizeObserver() {
    },
    ResizeObserverEntry: function ResizeObserverEntry() {
    },
    RtcDataChannel: function RtcDataChannel() {
    },
    RtcLegacyStatsReport: function RtcLegacyStatsReport() {
    },
    RtcStatsReport: function RtcStatsReport() {
    },
    RtcStatsReport_keys_closure: function RtcStatsReport_keys_closure(t0) {
      this.keys = t0;
    },
    RtcStatsReport_values_closure: function RtcStatsReport_values_closure(t0) {
      this.values = t0;
    },
    SelectElement: function SelectElement() {
    },
    SharedWorkerGlobalScope: function SharedWorkerGlobalScope() {
    },
    SlotElement: function SlotElement() {
    },
    SourceBuffer: function SourceBuffer() {
    },
    SourceBufferList: function SourceBufferList() {
    },
    SpeechGrammar: function SpeechGrammar() {
    },
    SpeechGrammarList: function SpeechGrammarList() {
    },
    SpeechRecognitionError: function SpeechRecognitionError() {
    },
    SpeechRecognitionResult: function SpeechRecognitionResult() {
    },
    SpeechSynthesisEvent: function SpeechSynthesisEvent() {
    },
    SpeechSynthesisVoice: function SpeechSynthesisVoice() {
    },
    Storage: function Storage() {
    },
    Storage_keys_closure: function Storage_keys_closure(t0) {
      this.keys = t0;
    },
    Storage_values_closure: function Storage_values_closure(t0) {
      this.values = t0;
    },
    StorageEvent: function StorageEvent() {
    },
    StyleSheet: function StyleSheet() {
    },
    TableElement: function TableElement() {
    },
    TableRowElement: function TableRowElement() {
    },
    TableSectionElement: function TableSectionElement() {
    },
    TemplateElement: function TemplateElement() {
    },
    TextAreaElement: function TextAreaElement() {
    },
    TextTrack: function TextTrack() {
    },
    TextTrackCue: function TextTrackCue() {
    },
    TextTrackCueList: function TextTrackCueList() {
    },
    TextTrackList: function TextTrackList() {
    },
    TimeRanges: function TimeRanges() {
    },
    Touch: function Touch() {
    },
    TouchList: function TouchList() {
    },
    TrackDefaultList: function TrackDefaultList() {
    },
    TrackElement: function TrackElement() {
    },
    UIEvent: function UIEvent() {
    },
    Url: function Url() {
    },
    VideoElement: function VideoElement() {
    },
    VideoTrack: function VideoTrack() {
    },
    VideoTrackList: function VideoTrackList() {
    },
    VttRegion: function VttRegion() {
    },
    WheelEvent: function WheelEvent() {
    },
    Window: function Window() {
    },
    Window_animationFrame_closure: function Window_animationFrame_closure(t0) {
      this.completer = t0;
    },
    WorkerGlobalScope: function WorkerGlobalScope() {
    },
    _Attr: function _Attr() {
    },
    _CssRuleList: function _CssRuleList() {
    },
    _DomRect: function _DomRect() {
    },
    _GamepadList: function _GamepadList() {
    },
    _NamedNodeMap: function _NamedNodeMap() {
    },
    _SpeechRecognitionResultList: function _SpeechRecognitionResultList() {
    },
    _StyleSheetList: function _StyleSheetList() {
    },
    _AttributeMap: function _AttributeMap() {
    },
    _ElementAttributeMap: function _ElementAttributeMap(t0) {
      this._element = t0;
    },
    CanvasImageSource: function CanvasImageSource() {
    },
    _ElementCssClassSet: function _ElementCssClassSet(t0) {
      this._element = t0;
    },
    _EventStream: function _EventStream(t0, t1, t2, t3) {
      var _ = this;
      _._html$_target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _ElementEventStreamImpl: function _ElementEventStreamImpl(t0, t1, t2, t3) {
      var _ = this;
      _._html$_target = t0;
      _._eventType = t1;
      _._useCapture = t2;
      _.$ti = t3;
    },
    _EventStreamSubscription: function _EventStreamSubscription(t0, t1, t2, t3, t4) {
      var _ = this;
      _._pauseCount = 0;
      _._html$_target = t0;
      _._eventType = t1;
      _._html$_onData = t2;
      _._useCapture = t3;
      _.$ti = t4;
    },
    _EventStreamSubscription_closure: function _EventStreamSubscription_closure(t0) {
      this.onData = t0;
    },
    _Html5NodeValidator: function _Html5NodeValidator(t0) {
      this.uriPolicy = t0;
    },
    ImmutableListMixin: function ImmutableListMixin() {
    },
    NodeValidatorBuilder: function NodeValidatorBuilder(t0) {
      this._validators = t0;
    },
    NodeValidatorBuilder_allowsElement_closure: function NodeValidatorBuilder_allowsElement_closure(t0) {
      this.element = t0;
    },
    NodeValidatorBuilder_allowsAttribute_closure: function NodeValidatorBuilder_allowsAttribute_closure(t0, t1, t2) {
      this.element = t0;
      this.attributeName = t1;
      this.value = t2;
    },
    _SimpleNodeValidator: function _SimpleNodeValidator() {
    },
    _SimpleNodeValidator_closure: function _SimpleNodeValidator_closure() {
    },
    _SimpleNodeValidator_closure0: function _SimpleNodeValidator_closure0() {
    },
    _TemplatingNodeValidator: function _TemplatingNodeValidator(t0, t1, t2, t3, t4) {
      var _ = this;
      _._templateAttrs = t0;
      _.allowedElements = t1;
      _.allowedAttributes = t2;
      _.allowedUriAttributes = t3;
      _.uriPolicy = t4;
    },
    _TemplatingNodeValidator_closure: function _TemplatingNodeValidator_closure() {
    },
    _SvgNodeValidator: function _SvgNodeValidator() {
    },
    FixedSizeListIterator: function FixedSizeListIterator(t0, t1, t2) {
      var _ = this;
      _._array = t0;
      _._html$_length = t1;
      _._position = -1;
      _._html$_current = null;
      _.$ti = t2;
    },
    _DOMWindowCrossFrame: function _DOMWindowCrossFrame(t0) {
      this._window = t0;
    },
    NodeValidator: function NodeValidator() {
    },
    _SameOriginUriPolicy: function _SameOriginUriPolicy(t0, t1) {
      this._hiddenAnchor = t0;
      this._loc = t1;
    },
    _ValidatingTreeSanitizer: function _ValidatingTreeSanitizer(t0) {
      this.validator = t0;
    },
    _ValidatingTreeSanitizer_sanitizeTree_walk: function _ValidatingTreeSanitizer_sanitizeTree_walk(t0) {
      this.$this = t0;
    },
    _CssStyleDeclaration_Interceptor_CssStyleDeclarationBase: function _CssStyleDeclaration_Interceptor_CssStyleDeclarationBase() {
    },
    _DomRectList_Interceptor_ListMixin: function _DomRectList_Interceptor_ListMixin() {
    },
    _DomRectList_Interceptor_ListMixin_ImmutableListMixin: function _DomRectList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _DomStringList_Interceptor_ListMixin: function _DomStringList_Interceptor_ListMixin() {
    },
    _DomStringList_Interceptor_ListMixin_ImmutableListMixin: function _DomStringList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _FileList_Interceptor_ListMixin: function _FileList_Interceptor_ListMixin() {
    },
    _FileList_Interceptor_ListMixin_ImmutableListMixin: function _FileList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _HtmlCollection_Interceptor_ListMixin: function _HtmlCollection_Interceptor_ListMixin() {
    },
    _HtmlCollection_Interceptor_ListMixin_ImmutableListMixin: function _HtmlCollection_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _MidiInputMap_Interceptor_MapMixin: function _MidiInputMap_Interceptor_MapMixin() {
    },
    _MidiOutputMap_Interceptor_MapMixin: function _MidiOutputMap_Interceptor_MapMixin() {
    },
    _MimeTypeArray_Interceptor_ListMixin: function _MimeTypeArray_Interceptor_ListMixin() {
    },
    _MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin: function _MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _NodeList_Interceptor_ListMixin: function _NodeList_Interceptor_ListMixin() {
    },
    _NodeList_Interceptor_ListMixin_ImmutableListMixin: function _NodeList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _PluginArray_Interceptor_ListMixin: function _PluginArray_Interceptor_ListMixin() {
    },
    _PluginArray_Interceptor_ListMixin_ImmutableListMixin: function _PluginArray_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _RtcStatsReport_Interceptor_MapMixin: function _RtcStatsReport_Interceptor_MapMixin() {
    },
    _SourceBufferList_EventTarget_ListMixin: function _SourceBufferList_EventTarget_ListMixin() {
    },
    _SourceBufferList_EventTarget_ListMixin_ImmutableListMixin: function _SourceBufferList_EventTarget_ListMixin_ImmutableListMixin() {
    },
    _SpeechGrammarList_Interceptor_ListMixin: function _SpeechGrammarList_Interceptor_ListMixin() {
    },
    _SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin: function _SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _Storage_Interceptor_MapMixin: function _Storage_Interceptor_MapMixin() {
    },
    _TextTrackCueList_Interceptor_ListMixin: function _TextTrackCueList_Interceptor_ListMixin() {
    },
    _TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin: function _TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    _TextTrackList_EventTarget_ListMixin: function _TextTrackList_EventTarget_ListMixin() {
    },
    _TextTrackList_EventTarget_ListMixin_ImmutableListMixin: function _TextTrackList_EventTarget_ListMixin_ImmutableListMixin() {
    },
    _TouchList_Interceptor_ListMixin: function _TouchList_Interceptor_ListMixin() {
    },
    _TouchList_Interceptor_ListMixin_ImmutableListMixin: function _TouchList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __CssRuleList_Interceptor_ListMixin: function __CssRuleList_Interceptor_ListMixin() {
    },
    __CssRuleList_Interceptor_ListMixin_ImmutableListMixin: function __CssRuleList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __GamepadList_Interceptor_ListMixin: function __GamepadList_Interceptor_ListMixin() {
    },
    __GamepadList_Interceptor_ListMixin_ImmutableListMixin: function __GamepadList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __NamedNodeMap_Interceptor_ListMixin: function __NamedNodeMap_Interceptor_ListMixin() {
    },
    __NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin: function __NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin: function __SpeechRecognitionResultList_Interceptor_ListMixin() {
    },
    __SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin: function __SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin() {
    },
    __StyleSheetList_Interceptor_ListMixin: function __StyleSheetList_Interceptor_ListMixin() {
    },
    __StyleSheetList_Interceptor_ListMixin_ImmutableListMixin: function __StyleSheetList_Interceptor_ListMixin_ImmutableListMixin() {
    }
  },
  X = {
    CodeMirror__createFromElement: function(element, options) {
      var t1 = P.JsObject_JsObject(H.interceptedTypeCheck(H.interceptedTypeCheck($.$get$context().$index(0, "CodeMirror"), "$isJsObject"), "$isJsFunction"), [element, P.JsObject_JsObject$jsify(options)]);
      return t1;
    },
    CodeMirror$fromElement: function(element, options) {
      var t1 = X.CodeMirror__createFromElement(element, options),
        t2 = new X.CodeMirror(t1, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]));
      $.CodeMirror__instances.$indexSet(0, t1, t2);
      return t2;
    },
    CodeMirror: function CodeMirror(t0, t1) {
      this._doc = null;
      this.jsProxy = t0;
      this._events = t1;
    },
    Doc: function Doc(t0, t1) {
      this.jsProxy = t0;
      this._events = t1;
    },
    Position: function Position(t0, t1) {
      this.line = t0;
      this.ch = t1;
    },
    LineHandle: function LineHandle(t0, t1) {
      this.jsProxy = t0;
      this._events = t1;
    },
    ProxyHolder: function ProxyHolder() {
    },
    ProxyHolder_onEvent_closure: function ProxyHolder_onEvent_closure() {
    },
    ProxyHolder_onEvent_closure0: function ProxyHolder_onEvent_closure0() {
    },
    SourceEditor$: function(codeMirror, debuggerState) {
      var t1 = new X.SourceEditor(codeMirror, debuggerState, H.setRuntimeTypeInfo([], [S.Breakpoint]), P.LinkedHashMap_LinkedHashMap$_empty(P.int, [P.List, S.Breakpoint]), P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.num));
      t1.SourceEditor$2(codeMirror, debuggerState);
      return t1;
    },
    DebuggerScreen: function DebuggerScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.debuggerState = t0;
      _._initialized = false;
      _._matcher = _.consoleArea = _.popupScriptsView = _.scriptsView = _.breakpointsView = _.variablesView = _.callStackView = _.sourceEditor = _._popupView = _._popupTextfield = _._sourcePathDiv = _._breakpointsCountDiv = _.deviceStatus = null;
      _.name = t1;
      _.id = t2;
      _.iconClass = t3;
      _.helpStatus = t4;
      _.disabledTooltip = t5;
      _.disabled = t6;
      _.shortcutCallback = t7;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t8;
      _.statusItems = t9;
    },
    DebuggerScreen_createContent__updateResumeButton: function DebuggerScreen_createContent__updateResumeButton(t0) {
      this.resumeButton = t0;
    },
    DebuggerScreen_createContent__updatePauseButton: function DebuggerScreen_createContent__updatePauseButton(t0) {
      this.pauseButton = t0;
    },
    DebuggerScreen_createContent_closure: function DebuggerScreen_createContent_closure(t0, t1) {
      this.$this = t0;
      this._updateResumeButton = t1;
    },
    DebuggerScreen_createContent_closure0: function DebuggerScreen_createContent_closure0(t0, t1) {
      this.$this = t0;
      this._updatePauseButton = t1;
    },
    DebuggerScreen_createContent_closure1: function DebuggerScreen_createContent_closure1(t0, t1) {
      this._updatePauseButton = t0;
      this._updateResumeButton = t1;
    },
    DebuggerScreen_createContent_closure2: function DebuggerScreen_createContent_closure2(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure3: function DebuggerScreen_createContent_closure3(t0) {
      this.breakOnExceptionControl = t0;
    },
    DebuggerScreen_createContent_closure4: function DebuggerScreen_createContent_closure4(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure5: function DebuggerScreen_createContent_closure5(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent__closure: function DebuggerScreen_createContent__closure(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure6: function DebuggerScreen_createContent_closure6(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure7: function DebuggerScreen_createContent_closure7() {
    },
    DebuggerScreen_createContent_closure8: function DebuggerScreen_createContent_closure8(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    DebuggerScreen_createContent_closure9: function DebuggerScreen_createContent_closure9(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure10: function DebuggerScreen_createContent_closure10(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure11: function DebuggerScreen_createContent_closure11(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure12: function DebuggerScreen_createContent_closure12(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure13: function DebuggerScreen_createContent_closure13(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure14: function DebuggerScreen_createContent_closure14(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure15: function DebuggerScreen_createContent_closure15(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure16: function DebuggerScreen_createContent_closure16(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure17: function DebuggerScreen_createContent_closure17(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure18: function DebuggerScreen_createContent_closure18(t0) {
      this.$this = t0;
    },
    DebuggerScreen_createContent_closure19: function DebuggerScreen_createContent_closure19(t0) {
      this.$this = t0;
    },
    DebuggerScreen__hookupListeners_closure: function DebuggerScreen__hookupListeners_closure(t0, t1) {
      this.$this = t0;
      this.scriptsView = t1;
    },
    DebuggerScreen__buildMenuNav_closure: function DebuggerScreen__buildMenuNav_closure(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure0: function DebuggerScreen__buildMenuNav_closure0(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure1: function DebuggerScreen__buildMenuNav_closure1(t0, t1) {
      this.$this = t0;
      this.scriptCountDiv = t1;
    },
    DebuggerScreen__buildMenuNav_closure2: function DebuggerScreen__buildMenuNav_closure2(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure3: function DebuggerScreen__buildMenuNav_closure3(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure4: function DebuggerScreen__buildMenuNav_closure4(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure5: function DebuggerScreen__buildMenuNav_closure5(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure6: function DebuggerScreen__buildMenuNav_closure6(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure7: function DebuggerScreen__buildMenuNav_closure7(t0, t1) {
      this.$this = t0;
      this.textfield = t1;
    },
    DebuggerScreen__buildMenuNav_closure8: function DebuggerScreen__buildMenuNav_closure8(t0) {
      this.$this = t0;
    },
    DebuggerScreen__buildMenuNav_closure9: function DebuggerScreen__buildMenuNav_closure9(t0) {
      this.$this = t0;
    },
    DebuggerScreen__handleConnectionStart_closure: function DebuggerScreen__handleConnectionStart_closure(t0) {
      this.$this = t0;
    },
    DebuggerScreen__handleConnectionStart_closure0: function DebuggerScreen__handleConnectionStart_closure0(t0) {
      this.$this = t0;
    },
    DebuggerScreen__handleIsolateChanged_closure: function DebuggerScreen__handleIsolateChanged_closure(t0) {
      this.$this = t0;
    },
    DebuggerScreen__handleIsolateChanged_closure0: function DebuggerScreen__handleIsolateChanged_closure0(t0) {
      this.$this = t0;
    },
    SourcePosition: function SourcePosition(t0, t1) {
      this.line = t0;
      this.column = t1;
    },
    SourceEditor: function SourceEditor(t0, t1, t2, t3, t4) {
      var _ = this;
      _.codeMirror = t0;
      _.debuggerState = t1;
      _.executionPoint = _.scriptRef = _.currentScript = null;
      _.breakpoints = t2;
      _.linesToBreakpoints = t3;
      _._executionPointElement = _._currentLineClass = null;
      _._lastScrollPositions = t4;
    },
    SourceEditor_closure: function SourceEditor_closure(t0) {
      this.$this = t0;
    },
    SourceEditor__closure: function SourceEditor__closure() {
    },
    SourceEditor__closure0: function SourceEditor__closure0() {
    },
    SourceEditor__refreshMarkers_closure: function SourceEditor__refreshMarkers_closure() {
    },
    SourceEditor__refreshMarkers_closure0: function SourceEditor__refreshMarkers_closure0() {
    },
    ScriptAndPosition: function ScriptAndPosition(t0, t1) {
      this.script = t0;
      this.position = t1;
    },
    ScriptsView$: function(uriDescriber) {
      var t1 = new X.ScriptsView();
      t1.ScriptsView$1(uriDescriber);
      return t1;
    },
    ListDirection: function ListDirection(t0) {
      this._scripts_view$_name = t0;
    },
    PopupView: function PopupView(t0, t1, t2, t3, t4) {
      var _ = this;
      _._sourceArea = t0;
      _._scripts_view$_sourcePathDiv = t1;
      _._scripts_view$_popupTextfield = t2;
      _._scriptsView = t3;
      _._oldSourceNameTextColor = null;
      _._poppedUp = false;
      _.element = t4;
    },
    ScriptsView: function ScriptsView() {
      this._highlightRef = this._scripts_view$_items = this._matcherRendering = null;
    },
    ScriptsView_closure: function ScriptsView_closure(t0, t1) {
      this.$this = t0;
      this.uriDescriber = t1;
    },
    ScriptsView_showScripts_closure: function ScriptsView_showScripts_closure(t0, t1) {
      this.$this = t0;
      this.commonPrefix = t1;
    },
    ScriptsView_showScripts_closure0: function ScriptsView_showScripts_closure0(t0) {
      this.rootLib = t0;
    },
    ScriptsView_showScripts_closure1: function ScriptsView_showScripts_closure1() {
    },
    ScriptsMatcher: function ScriptsMatcher(t0, t1) {
      var _ = this;
      _._textfield = _._scriptsView = null;
      _._debuggerState = t0;
      _._originalScrollTop = _._originalScriptRef = null;
      _.matchingState = t1;
      _._selectRow = -1;
      _._finishCallback = _._keyEventSubscription = null;
    },
    ScriptsMatcher_start_closure: function ScriptsMatcher_start_closure(t0) {
      this.$this = t0;
    },
    ScriptsMatcher_reset_closure: function ScriptsMatcher_reset_closure(t0) {
      this.originalRefs = t0;
    },
    ScriptsMatcher__startMatching_closure: function ScriptsMatcher__startMatching_closure(t0) {
      this.$this = t0;
    },
    ScriptsMatcher_displayMatchingScripts_closure: function ScriptsMatcher_displayMatchingScripts_closure(t0) {
      this.charsToMatch = t0;
    },
    ScriptsMatcher_displayMatchingScripts_closure0: function ScriptsMatcher_displayMatchingScripts_closure0(t0) {
      this.matchingRefs = t0;
    },
    Message$: function(messageType, children, id, message, title) {
      var _null = null,
        t1 = new N.PFlash(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "flash", _null, _null);
      t1 = new X.Message(messageType, id, message, title, children, t1, new P._AsyncBroadcastStreamController(_null, _null, [X.Message]));
      t1._buildFlash$0();
      return t1;
    },
    MessageManager: function MessageManager(t0, t1, t2) {
      this._container = t0;
      this._messages = t1;
      this._dismissedMessageIds = t2;
    },
    MessageManager_removeAll_closure: function MessageManager_removeAll_closure() {
    },
    MessageManager_addMessage_closure: function MessageManager_addMessage_closure(t0, t1) {
      this.$this = t0;
      this.screenId = t1;
    },
    MessageManager_addMessage_closure0: function MessageManager_addMessage_closure0() {
    },
    Message: function Message(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.messageType = t0;
      _.id = t1;
      _.message = t2;
      _.title = t3;
      _.children = t4;
      _.flash = t5;
      _._dismissController = t6;
    },
    Message__buildFlash_closure: function Message__buildFlash_closure(t0) {
      this.$this = t0;
    },
    MessageType: function MessageType(t0) {
      this._message_manager$_name = t0;
    },
    TimelineScreen: function TimelineScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.timelineController = t0;
      _.debugButtonSection = _.upperButtonSection = _.exitOfflineModeButton = _.exportButton = _.clearButton = _.resumeButton = _.pauseButton = _.eventDetails = _.frameEventsChart = _.framesBarChart = null;
      _._manuallyPaused = false;
      _.splitter = null;
      _.splitterConfigured = false;
      _.name = t1;
      _.id = t2;
      _.iconClass = t3;
      _.helpStatus = t4;
      _.disabledTooltip = t5;
      _.disabled = t6;
      _.shortcutCallback = t7;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t8;
      _.statusItems = t9;
    },
    TimelineScreen__initListeners_closure: function TimelineScreen__initListeners_closure(t0) {
      this.$this = t0;
    },
    TimelineScreen__initListeners_closure0: function TimelineScreen__initListeners_closure0(t0) {
      this.$this = t0;
    },
    TreeNode0: function TreeNode0() {
    },
    TreeNavigator: function TreeNavigator() {
    },
    Tree: function Tree() {
    },
    TreeNode: function TreeNode(t0, t1, t2) {
      var _ = this;
      _.data = t0;
      _.hasChildren = _.isExpanded = false;
      _.nextSibling = _.previousSibling = _.parent = _.collapse = _.expand = null;
      _.children = t1;
      _.$ti = t2;
    },
    StreamedResponse: function StreamedResponse(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.stream = t0;
      _.request = t1;
      _.statusCode = t2;
      _.reasonPhrase = t3;
      _.contentLength = t4;
      _.headers = t5;
      _.isRedirect = t6;
      _.persistentConnection = t7;
    },
    UninitializedLocaleData$: function(message, fallbackData, $F) {
      return new X.UninitializedLocaleData(message, fallbackData, H.setRuntimeTypeInfo([], [P.String]), [$F]);
    },
    UninitializedLocaleData: function UninitializedLocaleData(t0, t1, t2, t3) {
      var _ = this;
      _.message = t0;
      _.fallbackData = t1;
      _._badMessages = t2;
      _.$ti = t3;
    },
    LocaleDataException: function LocaleDataException(t0) {
      this.message = t0;
    },
    ParsedPath_ParsedPath$parse: function(path, style) {
      var t1, parts, separators, start, i,
        root = style.getRoot$1(path);
      style.isRootRelative$1(path);
      if (root != null)
        path = J.substring$1$s(path, root.length);
      t1 = [P.String];
      parts = H.setRuntimeTypeInfo([], t1);
      separators = H.setRuntimeTypeInfo([], t1);
      t1 = path.length;
      if (t1 !== 0 && style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, 0))) {
        if (0 >= t1)
          return H.ioore(path, 0);
        C.JSArray_methods.add$1(separators, path[0]);
        start = 1;
      } else {
        C.JSArray_methods.add$1(separators, "");
        start = 0;
      }
      for (i = start; i < t1; ++i)
        if (style.isSeparator$1(C.JSString_methods._codeUnitAt$1(path, i))) {
          C.JSArray_methods.add$1(parts, C.JSString_methods.substring$2(path, start, i));
          C.JSArray_methods.add$1(separators, path[i]);
          start = i + 1;
        }
      if (start < t1) {
        C.JSArray_methods.add$1(parts, C.JSString_methods.substring$1(path, start));
        C.JSArray_methods.add$1(separators, "");
      }
      return new X.ParsedPath(style, root, parts, separators);
    },
    ParsedPath: function ParsedPath(t0, t1, t2, t3) {
      var _ = this;
      _.style = t0;
      _.root = t1;
      _.parts = t2;
      _.separators = t3;
    },
    ParsedPath_normalize_closure: function ParsedPath_normalize_closure(t0) {
      this.$this = t0;
    },
    ParsedPath__splitExtension_closure: function ParsedPath__splitExtension_closure() {
    },
    ParsedPath__splitExtension_closure0: function ParsedPath__splitExtension_closure0() {
    },
    PathException$: function(message) {
      return new X.PathException(message);
    },
    PathException: function PathException(t0) {
      this.message = t0;
    },
    Observable: function Observable(t0, t1) {
      this._observable$_stream = t0;
      this.$ti = t1;
    },
    SourceSpanWithContext$: function(start, end, text, _context) {
      var t1 = new X.SourceSpanWithContext(_context, start, end, text);
      t1.SourceSpanBase$3(start, end, text);
      if (!C.JSString_methods.contains$1(_context, text))
        H.throwExpression(P.ArgumentError$('The context line "' + _context + '" must contain "' + text + '".'));
      if (B.findLineStart(_context, text, start.get$column()) == null)
        H.throwExpression(P.ArgumentError$('The span text "' + text + '" must start at column ' + (start.get$column() + 1) + ' in a line within "' + _context + '".'));
      return t1;
    },
    SourceSpanWithContext: function SourceSpanWithContext(t0, t1, t2, t3) {
      var _ = this;
      _._span_with_context$_context = t0;
      _.start = t1;
      _.end = t2;
      _.text = t3;
    },
    StringScanner: function StringScanner(t0, t1) {
      var _ = this;
      _.sourceUrl = t0;
      _.string = t1;
      _._string_scanner$_position = 0;
      _._lastMatchPosition = _._lastMatch = null;
    }
  },
  R = {JsEventListener: function JsEventListener(t0, t1, t2, t3, t4) {
      var _ = this;
      _._proxy = t0;
      _._js_utils$_name = t1;
      _.cvtEvent = t2;
      _.argCount = t3;
      _._callback = _._js_utils$_controller = null;
      _.$ti = t4;
    }, JsEventListener_stream_closure: function JsEventListener_stream_closure(t0) {
      this.$this = t0;
    }, JsEventListener_stream__closure: function JsEventListener_stream__closure(t0) {
      this.$this = t0;
    }, JsEventListener_stream__closure0: function JsEventListener_stream__closure0(t0) {
      this.$this = t0;
    }, JsEventListener_stream__closure1: function JsEventListener_stream__closure1(t0) {
      this.$this = t0;
    }, JsEventListener_stream__closure2: function JsEventListener_stream__closure2(t0) {
      this.$this = t0;
    }, JsEventListener_stream_closure0: function JsEventListener_stream_closure0(t0) {
      this.$this = t0;
    }, App: function App(t0, t1) {
      this.framework = t0;
      this._handlers = t1;
    }, App__bind_closure: function App__bind_closure(t0) {
      this.$this = t0;
    }, App__bind__closure: function App__bind__closure(t0, t1) {
      this.$this = t0;
      this.id = t1;
    }, App__bind__closure0: function App__bind__closure0(t0, t1) {
      this.$this = t0;
      this.id = t1;
    }, App_debuggerGetBreakpoints_closure: function App_debuggerGetBreakpoints_closure() {
    }, App_debuggerGetScripts_closure: function App_debuggerGetScripts_closure() {
    }, App_debuggerGetCallStackFrames_closure: function App_debuggerGetCallStackFrames_closure() {
    }, App_debuggerGetVariables_closure: function App_debuggerGetVariables_closure() {
    },
    connect: function(uri, finishedCompleter) {
      var ws, t1, t2, connectedCompleter, t3;
      H.assertSubtype(finishedCompleter, "$isCompleter", [P.Null], "$asCompleter");
      ws = W.WebSocket_WebSocket(uri.toString$0(0));
      t1 = U.VmServiceWrapper;
      t2 = new P._Future($.Zone__current, [t1]);
      connectedCompleter = new P._AsyncCompleter(t2, [t1]);
      t1 = W.Event;
      t3 = {func: 1, ret: -1, args: [t1]};
      W._EventStreamSubscription$(ws, "open", H.functionTypeCheck(new R.connect_closure(ws, finishedCompleter, connectedCompleter), t3), false, t1);
      W._EventStreamSubscription$(ws, "error", H.functionTypeCheck(new R.connect_closure0(connectedCompleter), t3), false, t1);
      return t2;
    },
    convertBroadcastToSingleSubscriber: function(stream, $T) {
      var controller, _null = null, t1 = {};
      H.assertSubtype(stream, "$isStream", [$T], "$asStream");
      controller = P.StreamController_StreamController(_null, _null, _null, _null, false, $T);
      t1.subscription = null;
      controller.set$onListen(new R.convertBroadcastToSingleSubscriber_closure(t1, stream, controller, $T));
      controller.set$onCancel(0, new R.convertBroadcastToSingleSubscriber_closure0(t1));
      return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
    },
    connect_closure: function connect_closure(t0, t1, t2) {
      this.ws = t0;
      this.finishedCompleter = t1;
      this.connectedCompleter = t2;
    },
    connect__closure: function connect__closure() {
    },
    connect___closure: function connect___closure(t0) {
      this.fileReader = t0;
    },
    connect__closure0: function connect__closure0(t0) {
      this.ws = t0;
    },
    connect__closure1: function connect__closure1(t0, t1) {
      this.finishedCompleter = t0;
      this.service = t1;
    },
    connect_closure0: function connect_closure0(t0) {
      this.connectedCompleter = t0;
    },
    convertBroadcastToSingleSubscriber_closure: function convertBroadcastToSingleSubscriber_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.stream = t1;
      _.controller = t2;
      _.T = t3;
    },
    convertBroadcastToSingleSubscriber__closure: function convertBroadcastToSingleSubscriber__closure(t0, t1) {
      this.controller = t0;
      this.T = t1;
    },
    convertBroadcastToSingleSubscriber_closure0: function convertBroadcastToSingleSubscriber_closure0(t0) {
      this._box_0 = t0;
    },
    _getStreamController: function($name, streamControllers, onFirstListenerSubscribed, $T) {
      H.assertSubtype(streamControllers, "$isMap", [P.String, [P.StreamController, $T]], "$asMap");
      streamControllers.putIfAbsent$2(0, $name, new R._getStreamController_closure(H.functionTypeCheck(onFirstListenerSubscribed, {func: 1, ret: -1}), $T));
      return streamControllers.$index(0, $name);
    },
    ServiceConnectionManager: function ServiceConnectionManager(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._stateController = t0;
      _._connectionAvailableController = t1;
      _._connectionClosedController = t2;
      _.serviceAvailable = t3;
      _._serviceCapabilities = null;
      _._serviceRegistrationController = t4;
      _._registeredMethodsForService = t5;
      _.sdkVersion = _.service = _.connectedApp = _._serviceExtensionManager = _._isolateManager = null;
    },
    ServiceConnectionManager__getServiceRegistrationController_closure: function ServiceConnectionManager__getServiceRegistrationController_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    ServiceConnectionManager_vmServiceOpened_closure: function ServiceConnectionManager_vmServiceOpened_closure(t0) {
      this.$this = t0;
    },
    ServiceConnectionManager_vmServiceOpened_closure0: function ServiceConnectionManager_vmServiceOpened_closure0(t0) {
      this.$this = t0;
    },
    ServiceConnectionManager_vmServiceOpened_closure1: function ServiceConnectionManager_vmServiceOpened_closure1(t0) {
      this.service = t0;
    },
    IsolateManager: function IsolateManager(t0, t1, t2, t3, t4) {
      var _ = this;
      _._isolates = t0;
      _._serviceExtensionManager = _._service_manager$_service = _._selectedIsolate = null;
      _._isolateCreatedController = t1;
      _._isolateExitedController = t2;
      _._selectedIsolateController = t3;
      _.selectedIsolateAvailable = t4;
      _.selectedIsolateLibraries = null;
    },
    IsolateManager_selectIsolate_closure: function IsolateManager_selectIsolate_closure(t0) {
      this.isolateRefId = t0;
    },
    IsolateManager_selectIsolate_closure0: function IsolateManager_selectIsolate_closure0() {
    },
    IsolateManager__initSelectedIsolate_closure: function IsolateManager__initSelectedIsolate_closure() {
    },
    IsolateManager__initSelectedIsolate_closure0: function IsolateManager__initSelectedIsolate_closure0() {
    },
    ServiceExtensionManager: function ServiceExtensionManager(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._isolateManager = _._service_manager$_service = null;
      _._firstFrameEventReceived = false;
      _._serviceExtensionController = t0;
      _._serviceExtensionStateController = t1;
      _._serviceExtensions = t2;
      _._enabledServiceExtensions = t3;
      _._pendingServiceExtensions = t4;
      _.extensionStatesUpdated = t5;
    },
    ServiceExtensionManager_resetAvailableExtensions_closure: function ServiceExtensionManager_resetAvailableExtensions_closure() {
    },
    ServiceExtensionManager__getServiceExtensionController_closure: function ServiceExtensionManager__getServiceExtensionController_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    ServiceExtensionManager__getServiceExtensionStateController_closure: function ServiceExtensionManager__getServiceExtensionStateController_closure(t0, t1) {
      this.$this = t0;
      this.name = t1;
    },
    _getStreamController_closure: function _getStreamController_closure(t0, t1) {
      this.onFirstListenerSubscribed = t0;
      this.T = t1;
    },
    ServiceExtensionState: function ServiceExtensionState(t0, t1) {
      this.enabled = t0;
      this.value = t1;
    },
    VmServiceCapabilities: function VmServiceCapabilities(t0) {
      this.version = t0;
    },
    CpuFlameChart: function CpuFlameChart(t0, t1, t2) {
      var _ = this;
      _.stackFrameDetails = _.canvas = null;
      _.timelineController = t0;
      _.type = t1;
      _.viewNeedsRebuild = false;
      _.element = t2;
    },
    CpuFlameChart_rebuildView_closure: function CpuFlameChart_rebuildView_closure(t0) {
      this.$this = t0;
    },
    HtmlTreeNavigator: function HtmlTreeNavigator() {
    },
    MediaType_MediaType$parse: function(mediaType) {
      return B.wrapFormatException("media type", mediaType, new R.MediaType_MediaType$parse_closure(mediaType), R.MediaType);
    },
    MediaType$: function(type, subtype, parameters) {
      var t1 = type.toLowerCase(),
        t2 = subtype.toLowerCase(),
        t3 = P.String,
        t4 = parameters == null ? P.LinkedHashMap_LinkedHashMap$_empty(t3, t3) : Z.CaseInsensitiveMap$from(parameters, t3);
      return new R.MediaType(t1, t2, new P.UnmodifiableMapView(t4, [t3, t3]));
    },
    MediaType: function MediaType(t0, t1, t2) {
      this.type = t0;
      this.subtype = t1;
      this.parameters = t2;
    },
    MediaType_MediaType$parse_closure: function MediaType_MediaType$parse_closure(t0) {
      this.mediaType = t0;
    },
    MediaType_toString_closure: function MediaType_toString_closure(t0) {
      this.buffer = t0;
    },
    MediaType_toString__closure: function MediaType_toString__closure() {
    },
    ConcatStream__buildController: function(streams, $T) {
      var t1 = {};
      H.assertSubtype(streams, "$isIterable", [[P.Stream, $T]], "$asIterable");
      if (C.JSArray_methods.any$1(streams, new R.ConcatStream__buildController_closure($T)))
        throw H.wrapException(P.ArgumentError$("One of the provided streams is null"));
      t1.subscription = t1.controller = null;
      return t1.controller = P.StreamController_StreamController(new R.ConcatStream__buildController_closure0(t1), new R.ConcatStream__buildController_closure1(t1, streams), new R.ConcatStream__buildController_closure2(t1), new R.ConcatStream__buildController_closure3(t1), true, $T);
    },
    ConcatStream: function ConcatStream(t0, t1) {
      this.controller = t0;
      this.$ti = t1;
    },
    ConcatStream__buildController_closure: function ConcatStream__buildController_closure(t0) {
      this.T = t0;
    },
    ConcatStream__buildController_closure1: function ConcatStream__buildController_closure1(t0, t1) {
      this._box_1 = t0;
      this.streams = t1;
    },
    ConcatStream__buildController_closure_moveNext: function ConcatStream__buildController_closure_moveNext(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _._box_1 = t1;
      _.streams = t2;
      _.len = t3;
    },
    ConcatStream__buildController__moveNext_closure: function ConcatStream__buildController__moveNext_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _._box_1 = t1;
      _.len = t2;
      _.moveNext = t3;
    },
    ConcatStream__buildController_closure2: function ConcatStream__buildController_closure2(t0) {
      this._box_1 = t0;
    },
    ConcatStream__buildController_closure3: function ConcatStream__buildController_closure3(t0) {
      this._box_1 = t0;
    },
    ConcatStream__buildController_closure0: function ConcatStream__buildController_closure0(t0) {
      this._box_1 = t0;
    }
  },
  M = {
    _isToStringVisiting0: function(o) {
      return C.JSArray_methods.any$1($._toStringVisiting0, new M._isToStringVisiting_closure(o));
    },
    CanonicalizedMap: function CanonicalizedMap() {
    },
    CanonicalizedMap_addAll_closure: function CanonicalizedMap_addAll_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_entries_closure: function CanonicalizedMap_entries_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_forEach_closure: function CanonicalizedMap_forEach_closure(t0, t1) {
      this.$this = t0;
      this.f = t1;
    },
    CanonicalizedMap_keys_closure: function CanonicalizedMap_keys_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_map_closure: function CanonicalizedMap_map_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.transform = t1;
      _.K2 = t2;
      _.V2 = t3;
    },
    CanonicalizedMap_values_closure: function CanonicalizedMap_values_closure(t0) {
      this.$this = t0;
    },
    CanonicalizedMap_toString_closure: function CanonicalizedMap_toString_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.result = t2;
    },
    _isToStringVisiting_closure: function _isToStringVisiting_closure(t0) {
      this.o = t0;
    },
    _invertMap: function(inverted, $K, $V) {
      var t1;
      H.assertSubtype(inverted, "$isMap", [$V, $K], "$asMap");
      t1 = P.LinkedHashMap_LinkedHashMap$_empty($K, $V);
      t1.addEntries$1(t1, inverted.get$entries(inverted).map$1$1(0, new M._invertMap_closure($V, $K), [P.MapEntry, $K, $V]));
      return t1;
    },
    _invertMap_closure: function _invertMap_closure(t0, t1) {
      this.V = t0;
      this.K = t1;
    },
    RemoteDiagnosticsNode: function RemoteDiagnosticsNode(t0, t1, t2, t3) {
      var _ = this;
      _.parent = t0;
      _.cachedProperties = null;
      _.inspectorService = t1;
      _.json = t2;
      _._valueProperties = null;
      _.isProperty = t3;
      _._diagnostics_node$_children = _._childrenFuture = _._creationLocation = null;
    },
    InspectorSourceLocation: function InspectorSourceLocation(t0, t1) {
      this.json = t0;
      this.parent = t1;
    },
    InspectorTreeWeb: function InspectorTreeWeb() {
    },
    MemoryPlotly: function MemoryPlotly(t0, t1) {
      var _ = this;
      _._domName = t0;
      _._memoryChart = t1;
      _.eventTimeline = null;
      _.liveUpdate = true;
    },
    MemoryPlotly_getMemoryLayout_getYAxis: function MemoryPlotly_getMemoryLayout_getYAxis() {
    },
    MemoryPlotly_getMemoryLayout_getLegend: function MemoryPlotly_getMemoryLayout_getLegend() {
    },
    EventTimeline: function EventTimeline(t0, t1, t2, t3, t4) {
      var _ = this;
      _._snapshotColorCss = t0;
      _._resetColorCss = t1;
      _._eventBgColorCss = t2;
      _._domName = t3;
      _._chart = t4;
      _.snapshotTraceIndex = _.resetTraceIndex = null;
      _.lastEventType = "";
      _.lastEventTime = -1;
    },
    _parseUri: function(uri) {
      if (!!J.getInterceptor$(uri).$isUri)
        return uri;
      throw H.wrapException(P.ArgumentError$value(uri, "uri", "Value must be a String or a Uri"));
    },
    _validateArgList: function(method, args) {
      var numArgs, i, numArgs0, message, t2, t3, t4,
        t1 = P.String;
      H.assertSubtype(args, "$isList", [t1], "$asList");
      for (numArgs = args.length, i = 1; i < numArgs; ++i) {
        if (args[i] == null || args[i - 1] != null)
          continue;
        for (; numArgs >= 1; numArgs = numArgs0) {
          numArgs0 = numArgs - 1;
          if (args[numArgs0] != null)
            break;
        }
        message = new P.StringBuffer("");
        t2 = method + "(";
        message._contents = t2;
        t3 = H.SubListIterable$(args, 0, numArgs, H.getTypeArgumentByIndex(args, 0));
        t4 = H.getTypeArgumentByIndex(t3, 0);
        t1 = t2 + new H.MappedListIterable(t3, H.functionTypeCheck(new M._validateArgList_closure(), {func: 1, ret: t1, args: [t4]}), [t4, t1]).join$1(0, ", ");
        message._contents = t1;
        message._contents = t1 + ("): part " + (i - 1) + " was null, but part " + i + " was not.");
        throw H.wrapException(P.ArgumentError$(message.toString$0(0)));
      }
    },
    Context0: function Context0(t0) {
      this.style = t0;
    },
    Context_join_closure: function Context_join_closure() {
    },
    Context_joinAll_closure: function Context_joinAll_closure() {
    },
    Context_split_closure: function Context_split_closure() {
    },
    _validateArgList_closure: function _validateArgList_closure() {
    }
  },
  U = {DefaultEquality: function DefaultEquality(t0) {
      this.$ti = t0;
    }, IterableEquality: function IterableEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    }, ListEquality: function ListEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    }, _UnorderedEquality: function _UnorderedEquality() {
    }, SetEquality: function SetEquality(t0, t1) {
      this._elementEquality = t0;
      this.$ti = t1;
    }, _MapEntry: function _MapEntry(t0, t1, t2) {
      this.equality = t0;
      this.key = t1;
      this.value = t2;
    }, MapEquality: function MapEquality(t0, t1, t2) {
      this._keyEquality = t0;
      this._valueEquality = t1;
      this.$ti = t2;
    }, DeepCollectionEquality: function DeepCollectionEquality() {
    },
    TextTreeConfiguration$: function(addBlankLineIfNoChildren, afterDescriptionIfBody, afterName, afterProperties, beforeName, beforeProperties, bodyIndent, footer, isBlankLineBetweenPropertiesAndChildren, isNameOnOwnLine, lineBreak, lineBreakProperties, linkCharacter, manditoryFooter, prefixLastChildLineOne, prefixLineOne, prefixOtherLines, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, propertySeparator, showChildren, suffixLineOne) {
      return new U.TextTreeConfiguration(prefixLineOne, beforeName, suffixLineOne, prefixOtherLines, prefixLastChildLineOne, prefixOtherLinesRootNode, propertyPrefixIfChildren, propertyPrefixNoChildren, linkCharacter, C.JSString_methods.$mul(" ", linkCharacter.length), lineBreak, lineBreakProperties, afterName, afterDescriptionIfBody, beforeProperties, afterProperties, propertySeparator, bodyIndent, showChildren, addBlankLineIfNoChildren, isNameOnOwnLine, footer, manditoryFooter, isBlankLineBetweenPropertiesAndChildren);
    },
    TextRenderer_renderToString: function(node, minLevel, parentConfiguration, prefixLineOne, prefixOtherLines, wrapWidth, wrapWidthProperties) {
      var t1, config, descendants, builder, children, description, t2, properties, t3, i, property, propertyStyle, message, lines, j, line, prefixChildren, prefix, child, childConfig, lastChildPrefixLineOne, nextChildStyle, childPrefixLineOne, _s1_ = "\n", _box_0 = {};
      _box_0.prefixOtherLines = prefixOtherLines;
      if (prefixOtherLines == null) {
        _box_0.prefixOtherLines = prefixLineOne;
        t1 = prefixLineOne;
      } else
        t1 = prefixOtherLines;
      config = node.get$textTreeConfiguration();
      if (t1.length === 0)
        t1 = _box_0.prefixOtherLines = t1 + config.prefixOtherLinesRootNode;
      if (node.get$style(node) === C.DiagnosticsTreeStyle_11) {
        descendants = H.setRuntimeTypeInfo([], [P.String]);
        _box_0.lines = _box_0.depth = 0;
        new U.TextRenderer_renderToString_visitor(_box_0, 25, descendants, 5).call$1(node);
        if (_box_0.lines > 1)
          t1 = prefixLineOne + ("This " + H.S(node.name) + " had the following descendants (showing up to depth 5):\n");
        else {
          t1 = node.name;
          t1 = descendants.length === 1 ? prefixLineOne + ("This " + H.S(t1) + " had the following child:\n") : prefixLineOne + ("This " + H.S(t1) + " has no descendants.\n");
        }
        t1 = P.StringBuffer__writeAll(t1, descendants, _s1_);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      builder = new U._PrefixedStringBuilder(prefixLineOne, t1, new P.StringBuffer(""));
      children = node.getChildren$0();
      description = node.toDescription$1$parentConfiguration(parentConfiguration);
      t1 = config.beforeName;
      if (t1.length !== 0)
        builder.write$1(0, t1);
      if (description == null || description.length === 0) {
        t1 = node.name;
        if (t1 != null)
          builder.write$1(0, t1);
      } else {
        t1 = node.name;
        if (t1 != null && t1.length !== 0 && true) {
          builder.write$1(0, t1);
          builder.write$1(0, config.afterName);
          builder.write$1(0, config.isNameOnOwnLine || J.contains$1$asx(description, _s1_) ? _s1_ : " ");
          if (J.contains$1$asx(description, _s1_) && node.get$style(node) === C.DiagnosticsTreeStyle_7)
            builder.prefixOtherLines = J.$add$ansx(builder.prefixOtherLines, "  ");
        }
        t1 = builder.prefixOtherLines;
        builder.prefixOtherLines = J.$add$ansx(t1, children.length === 0 ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren);
        builder.write$1(0, description);
      }
      t1 = config.suffixLineOne;
      if (t1.length !== 0)
        builder.writeStretched$2(t1, wrapWidth);
      t1 = node.getProperties$0(0);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      properties = P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new U.TextRenderer_renderToString_closure(minLevel), {func: 1, ret: P.bool, args: [t2]}), [t2]), true, t2);
      config.toString;
      builder.write$1(0, "");
      if (properties.length === 0)
        if (children.length === 0) {
          node.get$emptyBodyDescription();
          t1 = false;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        builder.write$1(0, config.afterDescriptionIfBody);
      t1 = config.lineBreakProperties;
      if (t1)
        builder.write$1(0, config.lineBreak);
      if (properties.length !== 0)
        builder.write$1(0, config.beforeProperties);
      t2 = builder.prefixOtherLines;
      t3 = config.bodyIndent;
      builder.prefixOtherLines = J.$add$ansx(t2, t3);
      node.get$emptyBodyDescription();
      for (i = 0; t2 = properties.length, i < t2; ++i) {
        property = properties[i];
        if (i > 0)
          builder.write$1(0, config.propertySeparator);
        if (property.get$style(property) !== C.DiagnosticsTreeStyle_7) {
          propertyStyle = property.get$textTreeConfiguration();
          builder.writeRaw$1(U.TextRenderer_renderToString(property, minLevel, config, H.S(builder.prefixOtherLines) + propertyStyle.prefixLineOne, H.S(builder.prefixOtherLines) + propertyStyle.linkCharacter + propertyStyle.prefixOtherLines, wrapWidth, wrapWidthProperties));
          continue;
        }
        message = property.toString$2$minLevel$parentConfiguration(0, minLevel, config);
        if (t1)
          if (message.length >= wrapWidth) {
            property.get$allowWrap();
            t2 = false;
          } else
            t2 = true;
        else
          t2 = true;
        if (t2)
          builder.write$1(0, message);
        else {
          lines = message.split(_s1_);
          for (j = 0; j < lines.length; ++j) {
            line = lines[j];
            if (j > 0)
              builder.write$1(0, config.lineBreak);
            builder.write$1(0, U.debugWordWrap(line, wrapWidthProperties, "  ").join$1(0, _s1_));
          }
        }
        if (t1)
          builder.write$1(0, config.lineBreak);
      }
      if (t2 !== 0)
        builder.write$1(0, config.afterProperties);
      if (!t1)
        builder.write$1(0, config.lineBreak);
      prefixChildren = H.S(_box_0.prefixOtherLines) + t3;
      if (children.length === 0 && config.addBlankLineIfNoChildren && builder._hasMultipleLines) {
        prefix = C.JSString_methods.trimRight$0(prefixChildren);
        if (prefix.length !== 0)
          builder.writeRaw$1(prefix + config.lineBreak);
      }
      if (children.length !== 0 && config.showChildren) {
        if (config.isBlankLineBetweenPropertiesAndChildren && properties.length !== 0 && C.JSArray_methods.get$first(children).get$textTreeConfiguration().isBlankLineBetweenPropertiesAndChildren)
          builder.write$1(0, config.lineBreak);
        for (i = 0; i < children.length; ++i) {
          child = children[i];
          t1 = child.style;
          if (t1 == null) {
            child.get$_builder().toString;
            t1 = C.DiagnosticsTreeStyle_0;
          }
          t1 = t1 !== C.DiagnosticsTreeStyle_7;
          childConfig = t1 ? child.get$textTreeConfiguration() : config;
          t1 = children.length;
          if (i === t1 - 1) {
            lastChildPrefixLineOne = prefixChildren + childConfig.prefixLastChildLineOne;
            t1 = childConfig.childLinkSpace;
            builder.writeRawLine$1(U.TextRenderer_renderToString(child, minLevel, config, lastChildPrefixLineOne, prefixChildren + t1 + childConfig.prefixOtherLines, wrapWidth, wrapWidthProperties));
            t2 = childConfig.footer;
            if (t2.length !== 0) {
              builder.writeRaw$1(prefixChildren + t1 + t2);
              if (childConfig.manditoryFooter.length !== 0)
                builder.writeStretched$2(config.manditoryFooter, wrapWidth);
              builder.write$1(0, config.lineBreak);
            }
          } else {
            t2 = i + 1;
            if (t2 >= t1)
              return H.ioore(children, t2);
            t2 = children[t2];
            t1 = t2.style;
            if (t1 == null) {
              t2.get$_builder().toString;
              t1 = C.DiagnosticsTreeStyle_0;
            }
            t1 = t1 !== C.DiagnosticsTreeStyle_7;
            nextChildStyle = t1 ? t2.get$textTreeConfiguration() : config;
            childPrefixLineOne = prefixChildren + childConfig.prefixLineOne;
            t1 = nextChildStyle.linkCharacter;
            builder.writeRawLine$1(U.TextRenderer_renderToString(child, minLevel, config, childPrefixLineOne, prefixChildren + t1 + childConfig.prefixOtherLines, wrapWidth, wrapWidthProperties));
            t2 = childConfig.footer;
            if (t2.length !== 0) {
              builder.writeRaw$1(prefixChildren + t1 + t2);
              if (childConfig.manditoryFooter.length !== 0)
                builder.writeStretched$2(config.manditoryFooter, wrapWidth);
              builder.write$1(0, config.lineBreak);
            }
          }
        }
      }
      if (parentConfiguration == null && config.manditoryFooter.length !== 0)
        builder.writeStretched$2(config.manditoryFooter, wrapWidth);
      t1 = builder._fake_flutter$_buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    debugWordWrap: function($async$message, $async$width, $async$wrapIndent) {
      return P._makeSyncStarIterable(function() {
        var message = $async$message,
          width = $async$width,
          wrapIndent = $async$wrapIndent;
        var $async$goto = 0, $async$handler = 2, $async$currentError, t2, prefix, index, index0, start, startForLengthCalculations, addPrefix, mode, lastWordStart, lastWordEnd, t3, t1;
        return function $async$debugWordWrap($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = message.length;
                  if (t1 >= width) {
                    t2 = J.trimLeft$0$s(message);
                    if (0 >= t2.length) {
                      H.ioore(t2, 0);
                      // goto return
                      $async$goto = 1;
                      break;
                    }
                    t2 = t2[0] === "#";
                  } else
                    t2 = true;
                  $async$goto = t2 ? 3 : 4;
                  break;
                case 3:
                  // then
                  $async$goto = 5;
                  return message;
                case 5:
                  // after yield
                  // goto return
                  $async$goto = 1;
                  break;
                case 4:
                  // join
                  t2 = $.$get$_indentPattern().matchAsPrefix$1(0, message)._match;
                  if (0 >= t2.length) {
                    H.ioore(t2, 0);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  prefix = wrapIndent + C.JSString_methods.$mul(" ", t2[0].length);
                  index = prefix.length;
                  t2 = J.getInterceptor$s(message), index0 = index, start = 0, startForLengthCalculations = 0, addPrefix = false, mode = C._WordWrapParseMode_0, lastWordStart = null, lastWordEnd = null;
                case 6:
                  // for condition
                  // trivial condition
                case 8:
                  // switch
                  switch (mode) {
                    case C._WordWrapParseMode_0:
                      // goto case
                      $async$goto = 10;
                      break;
                    case C._WordWrapParseMode_1:
                      // goto case
                      $async$goto = 11;
                      break;
                    case C._WordWrapParseMode_2:
                      // goto case
                      $async$goto = 12;
                      break;
                    default:
                      // goto after switch
                      $async$goto = 9;
                      break;
                  }
                  break;
                case 10:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t3 = message[index0] === " ";
                    } else
                      t3 = false;
                    if (!t3)
                      break;
                    ++index0;
                  }
                  lastWordStart = index0;
                  mode = C._WordWrapParseMode_1;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 11:
                  // case
                  while (true) {
                    if (index0 < t1) {
                      if (index0 < 0) {
                        H.ioore(message, index0);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t3 = message[index0] !== " ";
                    } else
                      t3 = false;
                    if (!t3)
                      break;
                    ++index0;
                  }
                  mode = C._WordWrapParseMode_2;
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 12:
                  // case
                  t3 = index0 - startForLengthCalculations;
                  $async$goto = t3 > width || index0 === t1 ? 13 : 15;
                  break;
                case 13:
                  // then
                  if (t3 <= width || lastWordEnd == null)
                    lastWordEnd = index0;
                  $async$goto = addPrefix ? 16 : 18;
                  break;
                case 16:
                  // then
                  $async$goto = 19;
                  return prefix + t2.substring$2(message, start, lastWordEnd);
                case 19:
                  // after yield
                  // goto join
                  $async$goto = 17;
                  break;
                case 18:
                  // else
                  $async$goto = 20;
                  return t2.substring$2(message, start, lastWordEnd);
                case 20:
                  // after yield
                  addPrefix = true;
                case 17:
                  // join
                  if (lastWordEnd >= t1) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (lastWordEnd === index0) {
                    while (true) {
                      if (index0 < t1) {
                        if (index0 < 0) {
                          H.ioore(message, index0);
                          // goto return
                          $async$goto = 1;
                          break $async$outer;
                        }
                        t3 = message[index0] === " ";
                      } else
                        t3 = false;
                      if (!t3)
                        break;
                      ++index0;
                    }
                    start = index0;
                    mode = C._WordWrapParseMode_1;
                  } else {
                    start = lastWordStart;
                    mode = C._WordWrapParseMode_2;
                  }
                  if (typeof start !== "number") {
                    start.$sub();
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  startForLengthCalculations = start - index;
                  lastWordEnd = null;
                  // goto join
                  $async$goto = 14;
                  break;
                case 15:
                  // else
                  lastWordEnd = index0;
                  mode = C._WordWrapParseMode_0;
                case 14:
                  // join
                  // goto after switch
                  $async$goto = 9;
                  break;
                case 9:
                  // after switch
                  // goto for condition
                  $async$goto = 6;
                  break;
                case 7:
                  // after for
                case 1:
                  // return
                  return P._IterationMarker_endOfIteration();
                case 2:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
        };
      }, P.String);
    },
    TextStyle$: function(color, debugLabel, decoration, decorationColor, decorationStyle, fontFamily, fontSize, fontStyle, fontWeight, height, inherit, letterSpacing, textBaseline, wordSpacing) {
      return new U.TextStyle(true, color, fontFamily, fontSize, fontWeight, fontStyle, letterSpacing, wordSpacing, textBaseline, height, decoration, decorationColor, decorationStyle, debugLabel);
    },
    DiagnosticLevel: function DiagnosticLevel(t0, t1) {
      this.index = t0;
      this._fake_flutter$_name = t1;
    },
    DiagnosticsTreeStyle: function DiagnosticsTreeStyle(t0) {
      this._fake_flutter$_name = t0;
    },
    TextTreeConfiguration: function TextTreeConfiguration(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23) {
      var _ = this;
      _.prefixLineOne = t0;
      _.beforeName = t1;
      _.suffixLineOne = t2;
      _.prefixOtherLines = t3;
      _.prefixLastChildLineOne = t4;
      _.prefixOtherLinesRootNode = t5;
      _.propertyPrefixIfChildren = t6;
      _.propertyPrefixNoChildren = t7;
      _.linkCharacter = t8;
      _.childLinkSpace = t9;
      _.lineBreak = t10;
      _.lineBreakProperties = t11;
      _.afterName = t12;
      _.afterDescriptionIfBody = t13;
      _.beforeProperties = t14;
      _.afterProperties = t15;
      _.propertySeparator = t16;
      _.bodyIndent = t17;
      _.showChildren = t18;
      _.addBlankLineIfNoChildren = t19;
      _.isNameOnOwnLine = t20;
      _.footer = t21;
      _.manditoryFooter = t22;
      _.isBlankLineBetweenPropertiesAndChildren = t23;
    },
    _PrefixedStringBuilder: function _PrefixedStringBuilder(t0, t1, t2) {
      var _ = this;
      _.prefixLineOne = t0;
      _.prefixOtherLines = t1;
      _._fake_flutter$_buffer = t2;
      _._hasMultipleLines = false;
      _._lineIndex = 0;
    },
    _NoDefaultValue: function _NoDefaultValue() {
    },
    TextRenderer_renderToString_visitor: function TextRenderer_renderToString_visitor(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.maxLines = t1;
      _.descendants = t2;
      _.maxDepth = t3;
    },
    TextRenderer_renderToString_closure: function TextRenderer_renderToString_closure(t0) {
      this.minLevel = t0;
    },
    DiagnosticsNode: function DiagnosticsNode() {
    },
    DiagnosticsProperty: function DiagnosticsProperty(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.ifNull = t0;
      _._fake_flutter$_value = t1;
      _._valueComputed = true;
      _._fake_flutter$_exception = null;
      _.name = t2;
      _.showSeparator = t3;
      _.showName = t4;
      _.linePrefix = t5;
      _.style = t6;
      _.$ti = t7;
    },
    DiagnosticableNode: function DiagnosticableNode() {
    },
    _DiagnosticableTreeNode: function _DiagnosticableTreeNode(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.value = t0;
      _._cachedBuilder = null;
      _.name = t1;
      _.showSeparator = t2;
      _.showName = t3;
      _.linePrefix = t4;
      _.style = t5;
    },
    DiagnosticPropertiesBuilder: function DiagnosticPropertiesBuilder(t0) {
      this.properties = t0;
    },
    Diagnosticable: function Diagnosticable() {
    },
    DiagnosticableTree: function DiagnosticableTree() {
    },
    _WordWrapParseMode: function _WordWrapParseMode(t0) {
      this._fake_flutter$_name = t0;
    },
    TextStyle: function TextStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.inherit = t0;
      _.color = t1;
      _.fontFamily = t2;
      _.fontSize = t3;
      _.fontWeight = t4;
      _.fontStyle = t5;
      _.letterSpacing = t6;
      _.wordSpacing = t7;
      _.textBaseline = t8;
      _.height = t9;
      _.decoration = t10;
      _.decorationColor = t11;
      _.decorationStyle = t12;
      _.debugLabel = t13;
    },
    VmServiceWrapper: function VmServiceWrapper(t0, t1, t2) {
      var _ = this;
      _._protocolVersion = _._vmService = null;
      _._activeStreams = t0;
      _.activeFutures = t1;
      _._allFuturesCompleter = t2;
    },
    TrackedFuture: function TrackedFuture() {
    },
    Client: function Client() {
    },
    Response_fromStream: function(response) {
      H.interceptedTypeCheck(response, "$isStreamedResponse");
      return response.stream.toBytes$0().then$1$1(new U.Response_fromStream_closure(response), U.Response0);
    },
    _contentTypeForHeaders: function(headers) {
      var t1 = P.String,
        contentType = H.assertSubtype(headers, "$isMap", [t1, t1], "$asMap").$index(0, "content-type");
      if (contentType != null)
        return R.MediaType_MediaType$parse(contentType);
      return R.MediaType$("application", "octet-stream", null);
    },
    Response0: function Response0(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.bodyBytes = t0;
      _.request = t1;
      _.statusCode = t2;
      _.reasonPhrase = t3;
      _.contentLength = t4;
      _.headers = t5;
      _.isRedirect = t6;
      _.persistentConnection = t7;
    },
    Response_fromStream_closure: function Response_fromStream_closure(t0) {
      this.response = t0;
    },
    BehaviorSubject_BehaviorSubject: function($T) {
      var controller = new P._AsyncBroadcastStreamController(null, null, [$T]),
        wrapper = new U._Wrapper(null, false, [$T]);
      return new U.BehaviorSubject(wrapper, controller, new X.Observable(new D.DeferStream(new U.BehaviorSubject_BehaviorSubject_closure(wrapper, controller, $T), true, [$T]), [$T]), [$T]);
    },
    BehaviorSubject_BehaviorSubject$seeded: function(seedValue, $T) {
      var controller, wrapper;
      H.assertSubtypeOfRuntimeType(seedValue, $T);
      controller = new P._AsyncBroadcastStreamController(null, null, [$T]);
      wrapper = new U._Wrapper(seedValue, true, [$T]);
      return new U.BehaviorSubject(wrapper, controller, new X.Observable(new D.DeferStream(new U.BehaviorSubject_BehaviorSubject$seeded_closure(wrapper, controller, $T), true, [$T]), [$T]), [$T]);
    },
    BehaviorSubject: function BehaviorSubject(t0, t1, t2, t3) {
      var _ = this;
      _._wrapper = t0;
      _.controller = t1;
      _._observable$_stream = t2;
      _.$ti = t3;
    },
    BehaviorSubject_BehaviorSubject_closure: function BehaviorSubject_BehaviorSubject_closure(t0, t1, t2) {
      this.wrapper = t0;
      this.controller = t1;
      this.T = t2;
    },
    BehaviorSubject_BehaviorSubject__closure: function BehaviorSubject_BehaviorSubject__closure(t0, t1) {
      this.controller = t0;
      this.wrapper = t1;
    },
    BehaviorSubject_BehaviorSubject$seeded_closure: function BehaviorSubject_BehaviorSubject$seeded_closure(t0, t1, t2) {
      this.wrapper = t0;
      this.controller = t1;
      this.T = t2;
    },
    BehaviorSubject_BehaviorSubject$seeded__closure: function BehaviorSubject_BehaviorSubject$seeded__closure(t0, t1) {
      this.controller = t0;
      this.wrapper = t1;
    },
    _Wrapper: function _Wrapper(t0, t1, t2) {
      var _ = this;
      _.latestValue = t0;
      _.latestStackTrace = _.latestError = null;
      _.latestIsValue = t1;
      _.latestIsError = false;
      _.$ti = t2;
    },
    Highlighter__normalizeNewlines: function(span) {
      var t1, endOffset, i, t2, t3, t4,
        text = span.get$text(span);
      if (!C.JSString_methods.contains$1(text, "\r\n"))
        return span;
      t1 = span.get$end(span);
      endOffset = t1.get$offset(t1);
      for (t1 = text.length - 1, i = 0; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1(text, i) === 13 && C.JSString_methods._codeUnitAt$1(text, i + 1) === 10)
          --endOffset;
      t1 = span.get$start(span);
      t2 = span.get$sourceUrl();
      t3 = span.get$end(span);
      t3 = t3.get$line(t3);
      t2 = V.SourceLocation$(endOffset, span.get$end(span).get$column(), t3, t2);
      t3 = H.stringReplaceAllUnchecked(text, "\r\n", "\n");
      t4 = span.get$context(span);
      return X.SourceSpanWithContext$(t1, t2, t3, H.stringReplaceAllUnchecked(t4, "\r\n", "\n"));
    },
    Highlighter__normalizeTrailingNewline: function(span) {
      var context, text, start, end, t1, t2, t3;
      if (!C.JSString_methods.endsWith$1(span.get$context(span), "\n"))
        return span;
      if (C.JSString_methods.endsWith$1(span.get$text(span), "\n\n"))
        return span;
      context = C.JSString_methods.substring$2(span.get$context(span), 0, span.get$context(span).length - 1);
      text = span.get$text(span);
      start = span.get$start(span);
      end = span.get$end(span);
      if (C.JSString_methods.endsWith$1(span.get$text(span), "\n")) {
        t1 = B.findLineStart(span.get$context(span), span.get$text(span), span.get$start(span).get$column());
        t2 = span.get$start(span).get$column();
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = t1 + t2 + span.get$length(span) === span.get$context(span).length;
        t1 = t2;
      } else
        t1 = false;
      if (t1) {
        text = C.JSString_methods.substring$2(span.get$text(span), 0, span.get$text(span).length - 1);
        t1 = span.get$end(span);
        t1 = t1.get$offset(t1);
        t2 = span.get$sourceUrl();
        t3 = span.get$end(span);
        t3 = t3.get$line(t3);
        if (typeof t3 !== "number")
          return t3.$sub();
        end = V.SourceLocation$(t1 - 1, U.Highlighter__lastLineLength(text), t3 - 1, t2);
        t1 = span.get$start(span);
        t1 = t1.get$offset(t1);
        t2 = span.get$end(span);
        start = t1 === t2.get$offset(t2) ? end : span.get$start(span);
      }
      return X.SourceSpanWithContext$(start, end, text, context);
    },
    Highlighter__normalizeEndOfLine: function(span) {
      var t1, t2, text, t3, t4;
      if (span.get$end(span).get$column() !== 0)
        return span;
      t1 = span.get$end(span);
      t1 = t1.get$line(t1);
      t2 = span.get$start(span);
      if (t1 == t2.get$line(t2))
        return span;
      text = C.JSString_methods.substring$2(span.get$text(span), 0, span.get$text(span).length - 1);
      t1 = span.get$start(span);
      t2 = span.get$end(span);
      t2 = t2.get$offset(t2);
      t3 = span.get$sourceUrl();
      t4 = span.get$end(span);
      t4 = t4.get$line(t4);
      if (typeof t4 !== "number")
        return t4.$sub();
      return X.SourceSpanWithContext$(t1, V.SourceLocation$(t2 - 1, U.Highlighter__lastLineLength(text), t4 - 1, t3), text, span.get$context(span));
    },
    Highlighter__lastLineLength: function(text) {
      var t1 = text.length;
      if (t1 === 0)
        return 0;
      if (C.JSString_methods.codeUnitAt$1(text, t1 - 1) === 10)
        return t1 === 1 ? 0 : t1 - C.JSString_methods.lastIndexOf$2(text, "\n", t1 - 2) - 1;
      else
        return t1 - C.JSString_methods.lastIndexOf$1(text, "\n") - 1;
    },
    Highlighter: function Highlighter(t0, t1, t2, t3, t4) {
      var _ = this;
      _._highlighter$_span = t0;
      _._color = t1;
      _._multiline = t2;
      _._paddingBeforeSidebar = t3;
      _._highlighter$_buffer = t4;
    },
    Highlighter__writeFirstLine_closure: function Highlighter__writeFirstLine_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeFirstLine_closure0: function Highlighter__writeFirstLine_closure0(t0, t1) {
      this.$this = t0;
      this.textInside = t1;
    },
    Highlighter__writeFirstLine_closure1: function Highlighter__writeFirstLine_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeFirstLine_closure2: function Highlighter__writeFirstLine_closure2(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeIntermediateLines_closure: function Highlighter__writeIntermediateLines_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeLastLine_closure: function Highlighter__writeLastLine_closure(t0, t1) {
      this.$this = t0;
      this.line = t1;
    },
    Highlighter__writeLastLine_closure0: function Highlighter__writeLastLine_closure0(t0, t1) {
      this.$this = t0;
      this.textInside = t1;
    },
    Highlighter__writeLastLine_closure1: function Highlighter__writeLastLine_closure1(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Highlighter__writeSidebar_closure: function Highlighter__writeSidebar_closure(t0, t1, t2) {
      this.$this = t0;
      this.line = t1;
      this.end = t2;
    }
  },
  Y = {HeapPriorityQueue: function HeapPriorityQueue(t0, t1, t2) {
      var _ = this;
      _.comparison = t0;
      _._priority_queue$_queue = t1;
      _._priority_queue$_length = 0;
      _.$ti = t2;
    },
    _isNotNull: function(serviceRef) {
      return serviceRef != null && serviceRef.kind !== "Null";
    },
    _valueAsString: function(ref) {
      var t1;
      if (ref == null)
        return;
      t1 = ref.valueAsString;
      if (t1 == null)
        return t1;
      if (ref.valueAsStringIsTruncated)
        return t1 + "...";
      else
        return t1;
    },
    LogData$: function(kind, _details, timestamp, detailsComputer, isError, node, summary, summaryHtml) {
      return new Y.LogData(kind, timestamp, isError, summary, summaryHtml, node, _details, detailsComputer);
    },
    LoggingScreen: function LoggingScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.logCountStatus = _.logDetailsUI = _.loggingTable = null;
      _.loggingStateMixin = t0;
      _.hasPendingDomUpdates = false;
      _.objectGroup = null;
      _.data = t1;
      _._lastScrollTime = null;
      _.name = t2;
      _.id = t3;
      _.iconClass = t4;
      _.helpStatus = t5;
      _.disabledTooltip = t6;
      _.disabled = t7;
      _.shortcutCallback = t8;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t9;
      _.statusItems = t10;
    },
    LoggingScreen_createContent_closure: function LoggingScreen_createContent_closure(t0) {
      this.$this = t0;
    },
    LoggingScreen_createContent_closure0: function LoggingScreen_createContent_closure0(t0) {
      this.$this = t0;
    },
    LoggingScreen_createContent_closure1: function LoggingScreen_createContent_closure1(t0) {
      this.$this = t0;
    },
    LoggingScreen_createContent_closure2: function LoggingScreen_createContent_closure2(t0) {
      this.$this = t0;
    },
    LoggingScreen__handleConnectionStart_closure: function LoggingScreen__handleConnectionStart_closure() {
    },
    LoggingScreen__handleConnectionStart_closure0: function LoggingScreen__handleConnectionStart_closure0() {
    },
    LoggingScreen__handleDeveloperLogEvent_closure: function LoggingScreen__handleDeveloperLogEvent_closure(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.$this = t0;
      _.service = t1;
      _.e = t2;
      _.messageRef = t3;
      _.error = t4;
      _.stackTrace = t5;
    },
    _StdoutEventHandler: function _StdoutEventHandler(t0, t1, t2) {
      var _ = this;
      _.loggingScreen = t0;
      _.name = t1;
      _.isError = t2;
      _.timer = _.buffer = null;
    },
    _StdoutEventHandler_handle_closure: function _StdoutEventHandler_handle_closure(t0) {
      this.$this = t0;
    },
    LogData: function LogData(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.kind = t0;
      _.timestamp = t1;
      _.isError = t2;
      _.summary = t3;
      _.summaryHtml = t4;
      _.node = t5;
      _._details = t6;
      _.detailsComputer = t7;
    },
    LogKindColumn: function LogKindColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    LogWhenColumn: function LogWhenColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    LogMessageColumn: function LogMessageColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    LogDetailsUI: function LogDetailsUI(t0) {
      var _ = this;
      _.tree = _.message = _.content = _.data = null;
      _.element = t0;
    },
    LogDetailsUI_setData_closure: function LogDetailsUI_setData_closure(t0) {
      this.$this = t0;
    },
    LogDetailsUI_setData_closure0: function LogDetailsUI_setData_closure0(t0, t1) {
      this.$this = t0;
      this.data = t1;
    },
    CpuCallTree: function CpuCallTree(t0, t1, t2) {
      var _ = this;
      _.callTreeTable = null;
      _.timelineController = t0;
      _.type = t1;
      _.viewNeedsRebuild = false;
      _.element = t2;
    },
    CpuCallTree__init_closure: function CpuCallTree__init_closure(t0) {
      this.$this = t0;
    },
    CpuCallTree__init_closure0: function CpuCallTree__init_closure0(t0) {
      this.$this = t0;
    },
    CpuBottomUp: function CpuBottomUp(t0, t1, t2) {
      var _ = this;
      _.bottomUpTable = null;
      _.timelineController = t0;
      _.type = t1;
      _.viewNeedsRebuild = false;
      _.element = t2;
    },
    CpuBottomUp__init_closure: function CpuBottomUp__init_closure(t0) {
      this.$this = t0;
    },
    CpuBottomUp__init_closure0: function CpuBottomUp__init_closure0(t0) {
      this.$this = t0;
    },
    SelfTimeColumn: function SelfTimeColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    TotalTimeColumn: function TotalTimeColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    MethodNameColumn: function MethodNameColumn(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._nodeExpandedController = t0;
      _._nodeCollapsedController = t1;
      _.title = t2;
      _.fixedWidthPx = t3;
      _.percentWidth = t4;
      _._alignment = t5;
      _.usesHtml = t6;
      _.cssClass = t7;
      _.hover = t8;
    },
    SourceColumn: function SourceColumn(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    FramesBarPlotly: function FramesBarPlotly(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._frames_bar_plotly$_domName = t0;
      _._frames_bar_plotly$_chart = t1;
      _.useLogScale = t2;
      _.showRangeSlider = t3;
      _._yAxisLogScale = t4;
      _._yAxisLinearScale = t5;
    },
    SelectTrace: function SelectTrace(t0, t1, t2, t3) {
      var _ = this;
      _.traceIndex = t0;
      _.ptNumber = t1;
      _.xValue = t2;
      _.yValue = t3;
    },
    Selection: function Selection(t0, t1, t2) {
      this._frames_bar_plotly$_domName = t0;
      this._frames_bar_plotly$_data = t1;
      this.selectInfo = t2;
    },
    TimelineController: function TimelineController(t0, t1, t2, t3, t4) {
      var _ = this;
      _.frameAddedController = t0;
      _._selectedFrameController = t1;
      _._selectedTimelineEventController = t2;
      _._loadOfflineDataController = t3;
      _.timelineProtocol = _.timelineService = _.offlineTimelineData = _.timelineData = null;
      _.cpuProfileProtocol = t4;
      _._timeline_controller$_paused = false;
    },
    TimelineController_loadOfflineData_closure: function TimelineController_loadOfflineData_closure() {
    },
    _UrlIconRenderer__maybeRewriteIconUrl: function(url) {
      var t1 = $.$get$_devicePixelRatio();
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 > 1 && C.JSString_methods.endsWith$1(url, ".png") && !C.JSString_methods.endsWith$1(url, "@2x.png"))
        return C.JSString_methods.substring$2(url, 0, url.length - 4) + "@2x.png";
      return url;
    },
    getIconRenderer: function(icon) {
      var t2, values,
        _s14_ = "expando$values",
        t1 = $.$get$rendererExpando(),
        renderer = t1.$index(0, icon);
      if (renderer != null)
        return renderer;
      t2 = J.getInterceptor$(icon);
      if (!!t2.$isUrlIcon)
        renderer = new Y._UrlIconRenderer(Y._UrlIconRenderer__maybeRewriteIconUrl(icon.src), icon);
      else if (!!t2.$isColorIcon)
        renderer = new Y._ColorIconRenderer(icon);
      else if (!!t2.$isCustomIcon) {
        t2 = icon.kind.icon;
        renderer = new Y._CustomIconRenderer(Y.getIconRenderer(t2), icon);
      } else if (!!t2.$isMaterialIcon)
        renderer = new Y._MaterialIconRenderer(icon);
      else
        throw H.wrapException(P.UnimplementedError$("No icon renderer defined for " + H.S(icon) + " of type " + t2.get$runtimeType(icon).toString$0(0)));
      H.assertSubtypeOfRuntimeType(renderer, H.getTypeArgumentByIndex(t1, 0));
      t1 = t1._jsWeakMapOrKey;
      if (typeof t1 !== "string")
        t1.set(icon, renderer);
      else {
        values = H.Primitives_getProperty(icon, _s14_);
        if (values == null) {
          values = new P.Object();
          H.Primitives_setProperty(icon, _s14_, values);
        }
        H.Primitives_setProperty(values, t1, renderer);
      }
      return renderer;
    },
    HtmlIconRenderer: function HtmlIconRenderer() {
    },
    _UrlIconRenderer: function _UrlIconRenderer(t0, t1) {
      var _ = this;
      _.src = t0;
      _._imageFuture = _._image = null;
      _.icon = t1;
    },
    _UrlIconRenderer_loadImage_closure: function _UrlIconRenderer_loadImage_closure(t0, t1, t2) {
      this.$this = t0;
      this.imageElement = t1;
      this.completer = t2;
    },
    _ColorIconRenderer: function _ColorIconRenderer(t0) {
      this._image = null;
      this.icon = t0;
    },
    _CustomIconRenderer: function _CustomIconRenderer(t0, t1) {
      this.baseIconRenderer = t0;
      this._image = null;
      this.icon = t1;
    },
    _CustomIconRenderer__buildImageAsync_closure: function _CustomIconRenderer__buildImageAsync_closure(t0, t1) {
      this.$this = t0;
      this.canvas = t1;
    },
    _MaterialIconRenderer: function _MaterialIconRenderer(t0) {
      this._image = null;
      this.icon = t0;
    },
    _MaterialIconRenderer_loadImage_closure: function _MaterialIconRenderer_loadImage_closure() {
    },
    _MaterialIconRenderer_loadImage_closure0: function _MaterialIconRenderer_loadImage_closure0(t0, t1) {
      this.$this = t0;
      this.imageCompleter = t1;
    },
    _MaterialIconRenderer_createCanvasSource__drawIcon: function _MaterialIconRenderer_createCanvasSource__drawIcon(t0, t1) {
      this.$this = t0;
      this.context2D = t1;
    },
    _MaterialIconRenderer_createCanvasSource_closure: function _MaterialIconRenderer_createCanvasSource_closure(t0) {
      this._drawIcon = t0;
    },
    createLinkStatusItem: function(textElement, href, title) {
      var element0, _null = null,
        element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0),
        t1 = element.style;
      t1.verticalAlign = "text-bottom";
      t1.marginBottom = "0";
      element0 = A.CoreElement$("a", _null, _null, _null, _null);
      element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), textElement], [A.CoreElement]));
      t1 = element0.element;
      t1.setAttribute("href", href);
      t1.setAttribute("target", "_blank");
      t1.title = title;
      t1 = A.CoreElement$("span", _null, _null, _null, _null);
      t1.add$1(0, element0);
      return new N.StatusItem(t1);
    },
    maybeAddDebugMessage: function(framework, screenId) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$temp1;
      var $async$maybeAddDebugMessage = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = !$.offlineMode;
              if ($async$temp1) {
                // goto then
                $async$goto = 2;
                break;
              } else
                $async$result = $async$temp1;
              // goto join
              $async$goto = 3;
              break;
            case 2:
              // then
              $async$temp1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp != null;
              if ($async$temp1) {
                // goto then
                $async$goto = 4;
                break;
              } else
                $async$result = $async$temp1;
              // goto join
              $async$goto = 5;
              break;
            case 4:
              // then
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isProfileBuild(), $async$maybeAddDebugMessage);
            case 6:
              // returning from await.
              $async$result = !$async$temp1.boolConversionCheck($async$result);
            case 5:
              // join
            case 3:
              // join
              if ($async$result)
                framework.messageManager.addMessage$2($.$get$debugWarning(), screenId);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$maybeAddDebugMessage, $async$completer);
    },
    ServiceExtensionButton$: function(extensionDescription) {
      var t1 = new Y.ServiceExtensionButton(extensionDescription);
      t1.ServiceExtensionButton$1(extensionDescription);
      return t1;
    },
    hiddenPages: function() {
      var t1 = $._hiddenPages;
      return t1 == null ? $._hiddenPages = Y._lookupHiddenPages() : t1;
    },
    _lookupHiddenPages: function() {
      var t1,
        queryString = window.location.search;
      if (queryString == null || queryString.length <= 1)
        return P.LinkedHashSet_LinkedHashSet(P.String);
      t1 = J.$index$asx(P.Uri_splitQueryString(J.substring$1$s(queryString, 1)), "hide");
      t1 = J.split$1$s(t1 == null ? "" : t1, ",");
      return P.LinkedHashSet_LinkedHashSet$from(t1, H.getTypeArgumentByIndex(t1, 0));
    },
    createHighDpiCanvas: function(width, height) {
      var scaledWidth, scaledHeight, canvas, t2,
        t1 = $.$get$_devicePixelRatio();
      if (typeof t1 !== "number")
        return H.iae(t1);
      scaledWidth = C.JSNumber_methods.ceil$0(width * t1);
      t1 = $.$get$_devicePixelRatio();
      if (typeof t1 !== "number")
        return H.iae(t1);
      scaledHeight = C.JSNumber_methods.ceil$0(height * t1);
      canvas = W.CanvasElement_CanvasElement(scaledHeight, scaledWidth);
      t1 = canvas.style;
      t2 = "" + width + "px";
      t1.width = t2;
      t2 = "" + height + "px";
      t1.height = t2;
      canvas.getContext("2d").scale(scaledWidth / width, scaledHeight / height);
      return canvas;
    },
    downloadFile: function(src, filename) {
      var t2,
        t1 = document,
        element = t1.createElement("a");
      element.setAttribute("href", (self.URL || self.webkitURL).createObjectURL(W.Blob_Blob([src])));
      element.setAttribute("download", filename);
      t2 = element.style;
      t2.display = "none";
      t1.body.appendChild(element);
      t1 = J.getInterceptor$x(element);
      t1.click$0(element);
      t1.remove$0(element);
    },
    ServiceExtensionButton: function ServiceExtensionButton(t0) {
      this.extensionDescription = t0;
      this.button = null;
    },
    ServiceExtensionButton_closure: function ServiceExtensionButton_closure(t0) {
      this.$this = t0;
    },
    ServiceExtensionButton_closure0: function ServiceExtensionButton_closure0(t0) {
      this.$this = t0;
    },
    ServiceExtensionButton__updateState_closure: function ServiceExtensionButton__updateState_closure(t0) {
      this.$this = t0;
    },
    FileLocation$_: function(file, offset) {
      if (offset < 0)
        H.throwExpression(P.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > file._decodedChars.length)
        H.throwExpression(P.RangeError$("Offset " + offset + " must not be greater than the number of characters in the file, " + file.get$length(file) + "."));
      return new Y.FileLocation(file, offset);
    },
    SourceFile: function SourceFile(t0, t1, t2) {
      var _ = this;
      _.url = t0;
      _._lineStarts = t1;
      _._decodedChars = t2;
      _._cachedLine = null;
    },
    FileLocation: function FileLocation(t0, t1) {
      this.file = t0;
      this.offset = t1;
    },
    _FileSpan: function _FileSpan(t0, t1, t2) {
      this.file = t0;
      this._file$_start = t1;
      this._file$_end = t2;
    },
    SourceSpanMixin: function SourceSpanMixin() {
    },
    fontStyleToCss: function(textStyle) {
      var t1 = textStyle.fontStyle === C.FontStyle_1 ? "italic " : "",
        t2 = textStyle.fontWeight;
      if (t2 != null)
        t1 += "" + (t2.index + 1) * 100 + " ";
      t2 = textStyle.fontSize;
      t1 += "" + (t2 == null ? 14 : t2) + "px ";
      t2 = textStyle.fontFamily;
      t1 += (t2 == null ? "Arial" : t2) + " ";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    colorToCss: function(color) {
      var cssColor = $._cssColors.$index(0, color);
      if (cssColor != null)
        return cssColor;
      cssColor = "#" + C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(((color.get$value(color) & 16777215) << 8 | color.get$alpha(color)) >>> 0, 16), 8, "0");
      $._cssColors.$indexSet(0, color, cssColor);
      return cssColor;
    }
  },
  B = {
    defaultCompare: function($T) {
      return new B.defaultCompare_closure($T);
    },
    Pair: function Pair(t0, t1, t2) {
      this.first = t0;
      this.last = t1;
      this.$ti = t2;
    },
    defaultCompare_closure: function defaultCompare_closure(t0) {
      this.T = t0;
    },
    EvalOnDartLibrary$: function(candidateLibraryNames, service) {
      var t1 = new B.EvalOnDartLibrary(P.LinkedHashSet_LinkedHashSet$from(candidateLibraryNames, P.String), service);
      t1.EvalOnDartLibrary$3$isolateId(candidateLibraryNames, service, null);
      return t1;
    },
    EvalOnDartLibrary: function EvalOnDartLibrary(t0, t1) {
      var _ = this;
      _._candidateLibraryNames = t0;
      _.service = t1;
      _.allPendingRequestsDone = _._isolateId = _._initializeComplete = _._libraryRef = null;
    },
    EvalOnDartLibrary_closure: function EvalOnDartLibrary_closure(t0) {
      this.$this = t0;
    },
    EvalOnDartLibrary_eval_closure: function EvalOnDartLibrary_eval_closure(t0, t1, t2) {
      this.$this = t0;
      this.expression = t1;
      this.scope = t2;
    },
    EvalOnDartLibrary_addRequest_wrappedRequest: function EvalOnDartLibrary_addRequest_wrappedRequest(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.isAlive = t1;
      _.response = t2;
      _.request = t3;
      _.T = t4;
    },
    EvalOnDartLibrary_getObjHelper_closure: function EvalOnDartLibrary_getObjHelper_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.instance = t1;
      _.offset = t2;
      _.count = t3;
      _.T = t4;
    },
    LibraryNotFound: function LibraryNotFound(t0) {
      this.candidateNames = t0;
    },
    printMb: function(bytes) {
      return C.JSDouble_methods.toStringAsFixed$1(bytes / 1048576, 1);
    },
    msText: function(dur, fractionDigits) {
      var t1 = C.JSDouble_methods.toStringAsFixed$1(dur._duration / 1000, fractionDigits);
      return t1 + " ms";
    },
    nullSafeMin: function(a, b, $T) {
      var t1;
      H.assertIsSubtype($T, P.num, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'nullSafeMin'.");
      H.assertSubtypeOfRuntimeType(a, $T);
      H.assertSubtypeOfRuntimeType(b, $T);
      t1 = a == null;
      if (t1 || b == null)
        return t1 ? b : a;
      return Math.min(H.checkNum(a), b);
    },
    nullSafeMax: function(a, b, $T) {
      var t1;
      H.assertIsSubtype($T, P.num, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'nullSafeMax'.");
      H.assertSubtypeOfRuntimeType(a, $T);
      H.assertSubtypeOfRuntimeType(b, $T);
      t1 = a == null;
      if (t1 || b == null)
        return t1 ? b : a;
      return Math.max(H.checkNum(a), b);
    },
    funcRefName: function(ref) {
      var t1 = ref.owner,
        t2 = J.getInterceptor$(t1);
      if (!!t2.$isLibraryRef)
        return ref.name;
      else if (!!t2.$isClassRef)
        return H.S(t1.name) + "." + H.S(ref.name);
      else if (!!t2.$isFuncRef)
        return H.S(B.funcRefName(t1)) + "." + H.S(ref.name);
      else
        return ref.name;
    },
    executeWithDelay: function(delay, callback, executeNow) {
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      if (executeNow || C.JSInt_methods._tdivFast$1(delay._duration, 1000) <= 0)
        callback.call$0();
      else
        P.Timer_Timer(delay, new B.executeWithDelay_closure(callback));
    },
    longestFittingSubstring: function(originalText, maxWidth, asciiMeasurements, slowMeasureFallback) {
      var runes, currentWidth, i, rune, charWidth;
      H.assertSubtype(asciiMeasurements, "$isList", [P.num], "$asList");
      H.functionTypeCheck(slowMeasureFallback, {func: 1, ret: P.num, args: [P.int]});
      if (originalText.length === 0)
        return originalText;
      runes = P.List_List$from(new P.Runes(originalText), true, P.int);
      for (currentWidth = 0, i = 0; i < runes.length;) {
        rune = runes[i];
        if (typeof rune !== "number")
          return rune.$lt();
        if (rune < 128) {
          if (rune < 0 || rune >= asciiMeasurements.length)
            return H.ioore(asciiMeasurements, rune);
          charWidth = asciiMeasurements[rune];
        } else
          charWidth = slowMeasureFallback.call$1(rune);
        if (typeof charWidth !== "number")
          return H.iae(charWidth);
        currentWidth += charWidth;
        if (currentWidth > maxWidth)
          break;
        ++i;
      }
      return C.JSString_methods.substring$2(originalText, 0, i);
    },
    getSimpleStackFrameName: function($name) {
      var simpleName,
        t1 = C.JSArray_methods.get$last($name.split("&"));
      t1.toString;
      simpleName = H.stringReplaceAllUnchecked(t1, "<anonymous closure>", "<closure>");
      if (C.JSString_methods.contains$1(simpleName, " "))
        return $name;
      return simpleName;
    },
    JsonUtils_getIntMember: function(json, memberName) {
      var t1 = J.$index$asx(H.assertSubtype(json, "$isMap", [P.String, P.Object], "$asMap"), memberName);
      return H.intTypeCheck(t1 == null ? -1 : t1);
    },
    executeWithDelay_closure: function executeWithDelay_closure(t0) {
      this.callback = t0;
    },
    Property: function Property(t0, t1, t2) {
      this._changeController = t0;
      this._utils$_value = t1;
      this.$ti = t2;
    },
    DelayedTimer: function DelayedTimer(t0, t1) {
      var _ = this;
      _.minDelay = t0;
      _.maxDelay = t1;
      _._maxTimer = _._minTimer = _._closure = null;
    },
    RateLimiter: function RateLimiter(t0, t1) {
      var _ = this;
      _.callback = t0;
      _._pendingRequest = null;
      _.requestScheduledButNotStarted = false;
      _._lastRequestTime = null;
      _.delayBetweenRequests = t1;
    },
    RateLimiter_scheduleRequest_closure: function RateLimiter_scheduleRequest_closure(t0) {
      this.$this = t0;
    },
    RateLimiter_scheduleRequest_closure0: function RateLimiter_scheduleRequest_closure0(t0) {
      this.$this = t0;
    },
    TimeUnit: function TimeUnit(t0) {
      this._utils$_name = t0;
    },
    TimeRange: function TimeRange(t0) {
      this.singleAssignment = t0;
      this._utils$_end = this._utils$_start = null;
    },
    DateSymbols: function DateSymbols(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.NAME = t0;
      _.ERAS = t1;
      _.ERANAMES = t2;
      _.NARROWMONTHS = t3;
      _.STANDALONENARROWMONTHS = t4;
      _.MONTHS = t5;
      _.STANDALONEMONTHS = t6;
      _.SHORTMONTHS = t7;
      _.STANDALONESHORTMONTHS = t8;
      _.WEEKDAYS = t9;
      _.STANDALONEWEEKDAYS = t10;
      _.SHORTWEEKDAYS = t11;
      _.STANDALONESHORTWEEKDAYS = t12;
      _.STANDALONENARROWWEEKDAYS = t13;
      _.SHORTQUARTERS = t14;
      _.QUARTERS = t15;
      _.AMPMS = t16;
    },
    NumberSymbols$: function(CURRENCY_PATTERN, DECIMAL_PATTERN, DECIMAL_SEP, DEF_CURRENCY_CODE, EXP_SYMBOL, GROUP_SEP, INFINITY, MINUS_SIGN, NAME, NAN, PERCENT, PERCENT_PATTERN, PERMILL, PLUS_SIGN, SCIENTIFIC_PATTERN, ZERO_DIGIT) {
      return new B.NumberSymbols(NAME, DECIMAL_SEP, GROUP_SEP, PERCENT, ZERO_DIGIT, PLUS_SIGN, MINUS_SIGN, EXP_SYMBOL, PERMILL, INFINITY, NAN, DECIMAL_PATTERN, DEF_CURRENCY_CODE);
    },
    NumberSymbols: function NumberSymbols(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.NAME = t0;
      _.DECIMAL_SEP = t1;
      _.GROUP_SEP = t2;
      _.PERCENT = t3;
      _.ZERO_DIGIT = t4;
      _.PLUS_SIGN = t5;
      _.MINUS_SIGN = t6;
      _.EXP_SYMBOL = t7;
      _.PERMILL = t8;
      _.INFINITY = t9;
      _.NAN = t10;
      _.DECIMAL_PATTERN = t11;
      _.DEF_CURRENCY_CODE = t12;
    },
    InternalStyle: function InternalStyle() {
    },
    WrappedFuture: function WrappedFuture() {
    },
    encodingForCharset: function(charset) {
      var encoding;
      if (charset == null)
        return C.C_Latin1Codec;
      encoding = P.Encoding_getByName(charset);
      return encoding == null ? C.C_Latin1Codec : encoding;
    },
    toUint8List: function(input) {
      var t1;
      H.assertSubtype(input, "$isList", [P.int], "$asList");
      t1 = J.getInterceptor$(input);
      if (!!t1.$isUint8List)
        return input;
      if (!!t1.$isTypedData) {
        t1 = input.buffer;
        t1.toString;
        return H.NativeUint8List_NativeUint8List$view(t1, 0, null);
      }
      return new Uint8Array(H._ensureNativeList(input));
    },
    toByteStream: function(stream) {
      H.assertSubtype(stream, "$isStream", [[P.List, P.int]], "$asStream");
      return stream;
    },
    wrapFormatException: function($name, value, body, $T) {
      var error, error0, t1, exception, t2;
      H.functionTypeCheck(body, {func: 1, ret: $T});
      try {
        t1 = body.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        t2 = J.getInterceptor$(t1);
        if (!!t2.$isSourceSpanFormatException) {
          error = t1;
          throw H.wrapException(G.SourceSpanFormatException$("Invalid " + $name + ": " + error._span_exception$_message, error._span, J.get$source$z(error)));
        } else if (!!t2.$isFormatException) {
          error0 = t1;
          throw H.wrapException(P.FormatException$("Invalid " + $name + ' "' + value + '": ' + H.S(J.get$message$x(error0)), J.get$source$z(error0), J.get$offset$z(error0)));
        } else
          throw exception;
      }
    },
    isAlphabetic: function(char) {
      var t1;
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    },
    isDriveLetter: function(path, index) {
      var t1 = path.length,
        t2 = index + 2;
      if (t1 < t2)
        return false;
      if (!B.isAlphabetic(C.JSString_methods.codeUnitAt$1(path, index)))
        return false;
      if (C.JSString_methods.codeUnitAt$1(path, index + 1) !== 58)
        return false;
      if (t1 === t2)
        return true;
      return C.JSString_methods.codeUnitAt$1(path, t2) === 47;
    },
    countCodeUnits: function(string, codeUnit) {
      var t1, count;
      for (t1 = new H.CodeUnits(string), t1 = new H.ListIterator(t1, t1.get$length(t1), [P.int]), count = 0; t1.moveNext$0();)
        if (t1.__internal$_current === codeUnit)
          ++count;
      return count;
    },
    findLineStart: function(context, text, column) {
      var beginningOfLine, index, lineStart;
      if (text.length === 0)
        for (beginningOfLine = 0; true;) {
          index = C.JSString_methods.indexOf$2(context, "\n", beginningOfLine);
          if (index === -1)
            return context.length - beginningOfLine >= column ? beginningOfLine : null;
          if (index - beginningOfLine >= column)
            return beginningOfLine;
          beginningOfLine = index + 1;
        }
      index = C.JSString_methods.indexOf$1(context, text);
      for (; index !== -1;) {
        lineStart = index === 0 ? 0 : C.JSString_methods.lastIndexOf$2(context, "\n", index - 1) + 1;
        if (column === index - lineStart)
          return lineStart;
        index = C.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return;
    }
  },
  O = {LineChart: function LineChart() {
    }, LineChart_closure: function LineChart_closure(t0) {
      this.$this = t0;
    }, LineChart__updateSize_closure: function LineChart__updateSize_closure(t0) {
      this.$this = t0;
    }, ConsoleArea: function ConsoleArea(t0, t1) {
      var _ = this;
      _._timer = t0;
      _._bufferedText = t1;
      _._editor = _._console_area$_container = null;
    }, ConsoleArea_appendText_closure: function ConsoleArea_appendText_closure(t0) {
      this.$this = t0;
    },
    evaluate: function(objectRef, expression) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.InstanceRef),
        $async$returnValue, result, t1;
      var $async$evaluate = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.evaluate$3(0, H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id, objectRef, expression), $async$evaluate);
              case 3:
                // returning from await.
                result = $async$result;
                t1 = J.getInterceptor$(result);
                switch (t1.get$runtimeType(result)) {
                  case C.Type_InstanceRef_4dw:
                    t1 = H.assertSubtype(t1.get$json(result), "$isMap", [P.String, null], "$asMap");
                    $async$returnValue = t1 == null ? null : S.InstanceRef$_fromJson(t1);
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  case C.Type_ErrorRef_oM2:
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  default:
                    P.print("ERROR Memory evaluate: Unknown type " + t1.get$runtimeType(result).toString$0(0) + ".");
                }
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$evaluate, $async$completer);
    },
    getInboundReferences: function(objectRef, maxInstances) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(O.InboundReferences),
        $async$returnValue, params, response;
      var $async$getInboundReferences = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              params = P.LinkedHashMap__makeLiteral(["targetId", objectRef, "limit", maxInstances]);
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.callMethod$3$args$isolateId("_getInboundReferences", params, H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id), $async$getInboundReferences);
            case 3:
              // returning from await.
              response = $async$result;
              if (response.type === "Sentinel") {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = O.InboundReferences$(response.json);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getInboundReferences, $async$completer);
    },
    InboundReferences$: function(json) {
      var t1 = new O.InboundReferences(null);
      t1.InboundReferences$1(json);
      return t1;
    },
    _searchClass: function(allClasses, className) {
      H.assertSubtype(allClasses, "$isList", [T.ClassHeapDetailStats], "$asList");
      return (allClasses && C.JSArray_methods).firstWhere$2$orElse(allClasses, new O._searchClass_closure(className), new O._searchClass_closure0());
    },
    computeInboundRefs: function(allClasses, refs, buildCallback) {
      var t1, t2, _i, element, t3, t4, t5, owningAllocator, owningAllocatorIsAbstract, referenceName, fieldRef, classRef, library, line, _null = null,
        _s43_ = "Error(hoverInstanceAllocations): Unhandled ";
      H.assertSubtype(allClasses, "$isList", [T.ClassHeapDetailStats], "$asList");
      H.functionTypeCheck(buildCallback, {func: 1, ret: -1, args: [P.String, P.String, P.bool]});
      for (t1 = refs.elements, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        element = t1[_i];
        t3 = element.parentField;
        if (t3 == null && element.json == null)
          continue;
        if (t3.get$owner() != null) {
          t3 = J.get$name$x(element.parentField.get$owner());
          t4 = J.getInterceptor$asx(t3);
          t5 = t4.get$length(t3);
          if (0 > t5)
            H.throwExpression(P.RangeError$range(0, 0, t4.get$length(t3), _null, _null));
          t3 = H.stringContainsUnchecked(t3, "&", 0);
        } else
          t3 = false;
        if (t3)
          continue;
        t3 = J.get$runtimeType$(element.parentField);
        t4 = t3.__typeName;
        switch (t4 == null ? t3.__typeName = H.runtimeTypeToString(t3._rti) : t4) {
          case "ClassRef":
            owningAllocator = (J.get$runtimeType$(element.parentField).$eq(0, C.Type_FieldRef_EkK) ? H.interceptedTypeCast(element.parentField, "$isClassRef") : _null).name;
            owningAllocatorIsAbstract = O._searchClass(allClasses, owningAllocator) == null;
            referenceName = _null;
            break;
          case "FieldRef":
            fieldRef = J.get$runtimeType$(element.parentField).$eq(0, C.Type_FieldRef_EkK) ? H.interceptedTypeCast(element.parentField, "$isFieldRef") : _null;
            referenceName = fieldRef.name;
            t3 = J.get$runtimeType$(fieldRef.owner);
            t4 = t3.__typeName;
            switch (t4 == null ? t3.__typeName = H.runtimeTypeToString(t3._rti) : t4) {
              case "ClassRef":
                t3 = fieldRef.owner.json;
                if (t3 == null)
                  classRef = _null;
                else {
                  classRef = new S.ClassRef(t3);
                  classRef.type = H.stringTypeCheck(J.$index$asx(t3, "type"));
                  t4 = J.getInterceptor$asx(t3);
                  classRef.id = H.stringTypeCheck(t4.$index(t3, "id"));
                  classRef.fixedId = H.boolTypeCheck(t4.$index(t3, "fixedId"));
                  classRef.name = H.stringTypeCheck(t4.$index(t3, "name"));
                }
                owningAllocator = classRef.name;
                owningAllocatorIsAbstract = O._searchClass(allClasses, owningAllocator) == null;
                break;
              case "Library":
              case "LibraryRef":
                t3 = fieldRef.owner.json;
                library = t3 == null ? _null : S.Library$_fromJson(t3);
                t3 = library == null ? _null : library.name;
                owningAllocator = "Library " + (t3 == null ? "" : t3);
                owningAllocatorIsAbstract = _null;
                break;
              default:
                owningAllocatorIsAbstract = _null;
                owningAllocator = owningAllocatorIsAbstract;
            }
            break;
          case "FuncRef":
            line = _s43_ + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          case "Instance":
            line = "Error(hoverInstanceAllocations):  Unhandled " + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          case "InstanceRef":
            line = _s43_ + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          case "Library":
          case "LibraryRef":
            line = _s43_ + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          case "NullVal":
          case "NullValRef":
            line = _s43_ + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          case "Obj":
          case "ObjRef":
            line = _s43_ + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
            break;
          default:
            line = "Error(hoverInstanceAllocations): Unhandled inbound " + J.get$runtimeType$(element.parentField).toString$0(0);
            t3 = $.printToZone;
            if (t3 == null)
              H.printString(line);
            else
              t3.call$1(line);
            owningAllocatorIsAbstract = _null;
            owningAllocator = owningAllocatorIsAbstract;
            referenceName = owningAllocator;
        }
        buildCallback.call$3(referenceName, owningAllocator, owningAllocatorIsAbstract);
      }
    },
    InboundReferences: function InboundReferences(t0) {
      this.elements = null;
      this.json = t0;
      this.type = null;
    },
    InboundReferences_closure: function InboundReferences_closure() {
    },
    InboundReference: function InboundReference(t0) {
      this.parentField = null;
      this.json = t0;
      this.type = null;
    },
    _searchClass_closure: function _searchClass_closure(t0) {
      this.className = t0;
    },
    _searchClass_closure0: function _searchClass_closure0() {
    },
    TimelineProtocol: function TimelineProtocol(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.uiThreadId = t0;
      _.gpuThreadId = t1;
      _.timelineController = t2;
      _.pendingFrames = t3;
      _.pendingEvents = t4;
      _.currentEventNodes = t5;
      _.previousDurationEndEvents = t6;
      _.heaps = t7;
    },
    TimelineProtocol_closure: function TimelineProtocol_closure() {
    },
    TimelineProtocol_processTraceEvent_closure: function TimelineProtocol_processTraceEvent_closure(t0, t1) {
      this.$this = t0;
      this.heap = t1;
    },
    TimelineProtocol__handleFrameStartEvent_closure: function TimelineProtocol__handleFrameStartEvent_closure(t0) {
      this.id = t0;
    },
    TimelineProtocol__handleFrameEndEvent_closure: function TimelineProtocol__handleFrameEndEvent_closure(t0) {
      this.id = t0;
    },
    TimelineProtocol__handleDurationCompleteEvent_closure: function TimelineProtocol__handleDurationCompleteEvent_closure(t0) {
      this.timelineEvent = t0;
    },
    TimelineProtocol_maybeAddPendingEvents_closure: function TimelineProtocol_maybeAddPendingEvents_closure() {
    },
    TimelineProtocol_eventOccursWithinFrameBounds_satisfiesUiGpuOrder: function TimelineProtocol_eventOccursWithinFrameBounds_satisfiesUiGpuOrder(t0, t1) {
      this.e = t0;
      this.f = t1;
    },
    TimelineProtocol__getAndSortWellFormedFrames_closure: function TimelineProtocol__getAndSortWellFormedFrames_closure() {
    },
    TimelineProtocol__getAndSortWellFormedFrames_closure0: function TimelineProtocol__getAndSortWellFormedFrames_closure0() {
    },
    Plotly: function Plotly() {
    },
    TraceData: function TraceData() {
    },
    Data: function Data() {
    },
    Marker: function Marker() {
    },
    Line: function Line() {
    },
    Transform0: function Transform0() {
    },
    Title: function Title() {
    },
    Layout: function Layout() {
    },
    Shape: function Shape() {
    },
    Legend: function Legend() {
    },
    HoverLabel: function HoverLabel() {
    },
    Font: function Font() {
    },
    AxisLayout: function AxisLayout() {
    },
    RangeSelector: function RangeSelector() {
    },
    Button: function Button() {
    },
    Margin: function Margin() {
    },
    RangeSlider: function RangeSlider() {
    },
    Configuration: function Configuration() {
    },
    DataEvent: function DataEvent() {
    },
    LegendDataEvent: function LegendDataEvent() {
    },
    Point1: function Point1() {
    },
    HoverFX: function HoverFX() {
    },
    BrowserClient: function BrowserClient(t0) {
      this._xhrs = t0;
    },
    BrowserClient_send_closure: function BrowserClient_send_closure(t0, t1, t2) {
      this.xhr = t0;
      this.completer = t1;
      this.request = t2;
    },
    BrowserClient_send__closure: function BrowserClient_send__closure(t0, t1, t2, t3) {
      var _ = this;
      _.reader = t0;
      _.completer = t1;
      _.xhr = t2;
      _.request = t3;
    },
    BrowserClient_send__closure0: function BrowserClient_send__closure0(t0, t1) {
      this.completer = t0;
      this.request = t1;
    },
    BrowserClient_send_closure0: function BrowserClient_send_closure0(t0, t1) {
      this.completer = t0;
      this.request = t1;
    },
    Request: function Request(t0, t1, t2, t3, t4) {
      var _ = this;
      _._defaultEncoding = t0;
      _._bodyBytes = t1;
      _.method = t2;
      _.url = t3;
      _.headers = t4;
      _._finalized = false;
    },
    Style__getPlatformStyle: function() {
      var t1, scheme, userInfo, host, query, fragment, port, isFile, hasAuthority, path, t2, _null = null;
      if (P.Uri_base().get$scheme() !== "file")
        return $.$get$Style_url();
      t1 = P.Uri_base();
      if (!C.JSString_methods.endsWith$1(t1.get$path(t1), "/"))
        return $.$get$Style_url();
      scheme = P._Uri__makeScheme(_null, 0, 0);
      userInfo = P._Uri__makeUserInfo(_null, 0, 0);
      host = P._Uri__makeHost(_null, 0, 0, false);
      query = P._Uri__makeQuery(_null, 0, 0, _null);
      fragment = P._Uri__makeFragment(_null, 0, 0);
      port = P._Uri__makePort(_null, scheme);
      isFile = scheme === "file";
      if (host == null)
        t1 = userInfo.length !== 0 || port != null || isFile;
      else
        t1 = false;
      if (t1)
        host = "";
      t1 = host == null;
      hasAuthority = !t1;
      path = P._Uri__makePath("a/b", 0, 3, _null, scheme, hasAuthority);
      t2 = scheme.length === 0;
      if (t2 && t1 && !C.JSString_methods.startsWith$1(path, "/"))
        path = P._Uri__normalizeRelativePath(path, !t2 || hasAuthority);
      else
        path = P._Uri__removeDotSegments(path);
      if (new P._Uri(scheme, userInfo, t1 && C.JSString_methods.startsWith$1(path, "//") ? "" : host, port, path, query, fragment).toFilePath$0() === "a\\b")
        return $.$get$Style_windows();
      return $.$get$Style_posix();
    },
    Style: function Style() {
    }
  },
  L = {ConnectedApp: function ConnectedApp() {
    }, ConnectedApp__libraryUriAvailable_closure: function ConnectedApp__libraryUriAvailable_closure() {
    }, WindowsStyle: function WindowsStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    Browser_getCurrentBrowser: function() {
      return C.JSArray_methods.firstWhere$2$orElse($.$get$Browser__knownBrowsers(), new L.Browser_getCurrentBrowser_closure(), new L.Browser_getCurrentBrowser_closure0());
    },
    Browser$: function($name, matchesNavigator, parseVersion, className) {
      return new L.Browser($name, matchesNavigator);
    },
    _Chrome__isChrome: function($navigator) {
      var vendor;
      H.interceptedTypeCheck($navigator, "$isNavigatorProvider").toString;
      vendor = window.navigator.vendor;
      return vendor != null && C.JSString_methods.contains$1(vendor, "Google");
    },
    _Firefox__isFirefox: function($navigator) {
      H.interceptedTypeCheck($navigator, "$isNavigatorProvider").toString;
      return J.contains$1$asx(window.navigator.userAgent, "Firefox");
    },
    _Safari__isSafari: function($navigator) {
      var vendor;
      H.interceptedTypeCheck($navigator, "$isNavigatorProvider").toString;
      vendor = window.navigator.vendor;
      return vendor != null && C.JSString_methods.contains$1(vendor, "Apple") && J.contains$1$asx(window.navigator.appVersion, "Version");
    },
    _WKWebView__isWKWebView: function($navigator) {
      var vendor;
      H.interceptedTypeCheck($navigator, "$isNavigatorProvider").toString;
      vendor = window.navigator.vendor;
      return vendor != null && C.JSString_methods.contains$1(vendor, "Apple") && !J.contains$1$asx(window.navigator.appVersion, "Version");
    },
    _InternetExplorer__isInternetExplorer: function($navigator) {
      H.interceptedTypeCheck($navigator, "$isNavigatorProvider").toString;
      return J.contains$1$asx(window.navigator.appName, "Microsoft") || J.contains$1$asx(window.navigator.appVersion, "Trident") || J.contains$1$asx(window.navigator.appVersion, "Edge");
    },
    Browser: function Browser(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    },
    Browser_getCurrentBrowser_closure: function Browser_getCurrentBrowser_closure() {
    },
    Browser_getCurrentBrowser_closure0: function Browser_getCurrentBrowser_closure0() {
    },
    _Chrome: function _Chrome(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    },
    _Firefox: function _Firefox(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    },
    _Safari: function _Safari(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    },
    _WKWebView: function _WKWebView(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    },
    _InternetExplorer: function _InternetExplorer(t0, t1) {
      this.name = t0;
      this._matchesNavigator = t1;
    }
  },
  A = {BusEvent: function BusEvent(t0, t1) {
      this.type = t0;
      this.data = t1;
    }, MessageBus: function MessageBus() {
      this._controller = null;
    }, MessageBus_onEvent_closure: function MessageBus_onEvent_closure(t0) {
      this.type = t0;
    },
    MemoryChart$: function(_memoryController) {
      var _null = null,
        t1 = new A.MemoryChart(_memoryController, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "section section-border", _null, _null);
      t1.MemoryChart$1(_memoryController);
      return t1;
    },
    MemoryChart: function MemoryChart(t0, t1) {
      var _ = this;
      _._memoryController = t0;
      _._chartCreated = false;
      _._plotlyChart = null;
      _.lastGcTimestamp = 0;
      _.element = t1;
    },
    MemoryChart_closure: function MemoryChart_closure(t0) {
      this.$this = t0;
    },
    MemoryDataView$: function(_memoryController, variableDescriber) {
      var t1 = new A.MemoryDataView(_memoryController);
      t1.MemoryDataView$2(_memoryController, variableDescriber);
      return t1;
    },
    MemoryDataView: function MemoryDataView(t0) {
      this._memory_data_view$_memoryController = t0;
      this._memory_data_view$_items = null;
    },
    MemoryDataView_closure: function MemoryDataView_closure(t0) {
      this.variableDescriber = t0;
    },
    MemoryDataView__closure: function MemoryDataView__closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.variableDescriber = t1;
      _.field = t2;
      _.element = t3;
    },
    MemoryDataView___closure: function MemoryDataView___closure(t0) {
      this.element = t0;
    },
    MemoryDataChildProvider: function MemoryDataChildProvider(t0) {
      this._memory_data_view$_memoryController = t0;
    },
    FramesBarChart$: function(timelineController) {
      var _null = null,
        t1 = new A.FramesBarChart(timelineController, new P._AsyncBroadcastStreamController(_null, _null, [Q.TimelineFrame]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "timeline-frames", _null, _null);
      t1.FramesBarChart$1(timelineController);
      return t1;
    },
    FramesBarChart: function FramesBarChart(t0, t1, t2) {
      var _ = this;
      _.timelineController = t0;
      _.frameUIgraph = null;
      _._createdPlot = false;
      _._frames_bar_chart$_selectedFrameController = t1;
      _.element = t2;
    },
    FramesBarChart_closure: function FramesBarChart_closure(t0) {
      this.$this = t0;
    },
    FramesBarChart_closure0: function FramesBarChart_closure0(t0) {
      this.$this = t0;
    },
    PlotlyDivGraph: function PlotlyDivGraph(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.timelineController = t0;
      _._frames = t1;
      _.dataIndexes = t2;
      _.uiDurations = t3;
      _.gpuDurations = t4;
      _.plotlyChart = null;
      _._frameIndex = 0;
      _._lastPlottedFrameIndex = -1;
      _.currentSelection = null;
      _.element = t5;
    },
    PlotlyDivGraph_createPlot_closure: function PlotlyDivGraph_createPlot_closure(t0) {
      this.$this = t0;
    },
    _FramesBarChart_CoreElement_SetStateMixin: function _FramesBarChart_CoreElement_SetStateMixin() {
    },
    a: function(href, target, text) {
      var t1 = A.CoreElement$("a", null, null, null, text),
        t2 = t1.element;
      t2.setAttribute("href", href);
      t2.setAttribute("target", target);
      return t1;
    },
    label: function(text) {
      return A.CoreElement$("label", null, null, null, text);
    },
    div: function(a, c, text) {
      return A.CoreElement$("div", a, c, null, text);
    },
    span: function(a, c, text) {
      return A.CoreElement$("span", a, c, null, text);
    },
    h2: function(text) {
      return A.CoreElement$("h2", null, null, null, text);
    },
    ul: function(c) {
      return A.CoreElement$("ul", null, c, null, null);
    },
    CoreElement$: function(tag, attributes, classes, html, text) {
      var t1 = new A.CoreElement(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(tag, null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text(tag, attributes, classes, html, text);
      return t1;
    },
    CoreElement: function CoreElement(t0) {
      this.element = t0;
    },
    CoreElement_add_closure: function CoreElement_add_closure(t0) {
      this.$this = t0;
    },
    CoreElement_replace_closure: function CoreElement_replace_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    CoreElement_onClick_closure: function CoreElement_onClick_closure(t0) {
      this.$this = t0;
    },
    CoreElement_onFocus_closure: function CoreElement_onFocus_closure(t0) {
      this.$this = t0;
    },
    CoreElement_onBlur_closure: function CoreElement_onBlur_closure(t0) {
      this.$this = t0;
    },
    CoreElement_onMouseOver_closure: function CoreElement_onMouseOver_closure(t0) {
      this.$this = t0;
    },
    CoreElement_onMouseLeave_closure: function CoreElement_onMouseLeave_closure(t0) {
      this.$this = t0;
    },
    CoreElement_click_closure: function CoreElement_click_closure(t0, t1) {
      this.shiftHandle = t0;
      this.handle = t1;
    },
    CoreElement_dblclick_closure: function CoreElement_dblclick_closure(t0) {
      this.handle = t0;
    },
    CoreElement_focus_closure: function CoreElement_focus_closure(t0) {
      this.handle = t0;
    },
    CoreElement_blur_closure: function CoreElement_blur_closure(t0) {
      this.handle = t0;
    },
    CoreElement_over_closure: function CoreElement_over_closure(t0) {
      this.handle = t0;
    },
    CoreElement_leave_closure: function CoreElement_leave_closure(t0) {
      this.handle = t0;
    },
    TrustedHtmlTreeSanitizer: function TrustedHtmlTreeSanitizer() {
    },
    flexSplit: function(parts, gutterSize, horizontal, minSize, sizes) {
      var t2, t3, t4,
        t1 = [P.num];
      H.assertSubtype(sizes, "$isList", t1, "$asList");
      H.assertSubtype(minSize, "$isList", t1, "$asList");
      t1 = H.setRuntimeTypeInfo(parts.slice(0), [H.getTypeArgumentByIndex(parts, 0)]);
      t2 = P.allowInterop(new A.flexSplit_closure(), {func: 1, args: [P.Object, P.Object, P.num, P.int]});
      t3 = P.allowInterop(new A.flexSplit_closure0(), {func: 1, args: [P.Object, P.num, P.int]});
      t4 = H.boolConversionCheck(horizontal) ? "horizontal" : "vertical";
      t4 = {elementStyle: t2, gutterStyle: t3, direction: t4, gutterSize: gutterSize, sizes: sizes, minSize: minSize};
      return self.Split(t1, t4);
    },
    flexSplitBidirectional: function(parts, gutterSize, horizontalSizes, verticalSizes) {
      var mediaQueryList, t3, t1 = {},
        t2 = [P.num];
      H.assertSubtype(verticalSizes, "$isList", t2, "$asList");
      H.assertSubtype(horizontalSizes, "$isList", t2, "$asList");
      mediaQueryList = window.matchMedia("(min-aspect-ratio: 1/1)");
      t1.splitter = null;
      t2 = new A.flexSplitBidirectional_createSplitter(t1, mediaQueryList, parts, gutterSize, null, horizontalSizes, verticalSizes);
      t2.call$0();
      mediaQueryList.toString;
      t3 = W.Event;
      return W._EventStreamSubscription$(mediaQueryList, "change", H.functionTypeCheck(new A.flexSplitBidirectional_closure(t1, t2), {func: 1, ret: -1, args: [t3]}), false, t3);
    },
    _SplitOptions: function _SplitOptions() {
    },
    Splitter: function Splitter() {
    },
    flexSplit_closure: function flexSplit_closure() {
    },
    flexSplit_closure0: function flexSplit_closure0() {
    },
    flexSplitBidirectional_createSplitter: function flexSplitBidirectional_createSplitter(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._box_0 = t0;
      _.mediaQueryList = t1;
      _.parts = t2;
      _.gutterSize = t3;
      _.minSize = t4;
      _.horizontalSizes = t5;
      _.verticalSizes = t6;
    },
    flexSplitBidirectional_closure: function flexSplitBidirectional_closure(t0, t1) {
      this._box_0 = t0;
      this.createSplitter = t1;
    }
  },
  F = {
    _breakpointComparator: function(a, b) {
      var t1, t2, aRef, bRef, compare;
      H.interceptedTypeCheck(a, "$isBreakpoint");
      H.interceptedTypeCheck(b, "$isBreakpoint");
      t1 = new F._breakpointComparator_getRef();
      t2 = new F._breakpointComparator_getPos();
      aRef = t1.call$1(a.location);
      bRef = t1.call$1(b.location);
      compare = J.compareTo$1$ns(aRef.uri, bRef.uri);
      if (compare !== 0)
        return compare;
      t1 = t2.call$1(a.location);
      t2 = t2.call$1(b.location);
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 - t2;
    },
    BreakpointsView$: function(_breakpointsCountDiv, debuggerState, uriDescriber) {
      var t1 = new F.BreakpointsView(_breakpointsCountDiv);
      t1.BreakpointsView$3(_breakpointsCountDiv, debuggerState, uriDescriber);
      return t1;
    },
    BreakOnExceptionControl$: function() {
      var _null = null,
        t1 = new F.BreakOnExceptionControl(new P._AsyncBroadcastStreamController(_null, _null, [P.String]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "break-on-exceptions flex-no-wrap", _null, _null);
      t1.BreakOnExceptionControl$0();
      return t1;
    },
    _breakpointComparator_getRef: function _breakpointComparator_getRef() {
    },
    _breakpointComparator_getPos: function _breakpointComparator_getPos() {
    },
    BreakpointsView: function BreakpointsView(t0) {
      this._breakpoints_view$_breakpointsCountDiv = t0;
      this._breakpoints_view$_items = null;
    },
    BreakpointsView_closure: function BreakpointsView_closure(t0, t1) {
      this.uriDescriber = t0;
      this.debuggerState = t1;
    },
    BreakpointsView__closure: function BreakpointsView__closure(t0, t1, t2) {
      this.debuggerState = t0;
      this.location = t1;
      this.element = t2;
    },
    BreakOnExceptionControl: function BreakOnExceptionControl(t0, t1) {
      var _ = this;
      _._allElement = _._unhandledElement = null;
      _._pauseModeController = t0;
      _.element = t1;
    },
    BreakOnExceptionControl_closure: function BreakOnExceptionControl_closure(t0) {
      this.$this = t0;
    },
    BreakOnExceptionControl_closure0: function BreakOnExceptionControl_closure0(t0, t1) {
      this.$this = t0;
      this.unhandledExceptionsElement = t1;
    },
    Status$: function(statusLine, initialMessage) {
      var _null = null,
        t1 = new F.Status(statusLine),
        t2 = A.CoreElement$("span", _null, _null, _null, _null),
        t3 = new N.StatusItem(t2);
      t1.item = t3;
      t2.element.textContent = initialMessage;
      C.JSArray_methods.add$1(statusLine._framework$_items, t3);
      statusLine._rebuild$0();
      return t1;
    },
    _renderDuration: function(duration) {
      var t1 = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
      if (t1 < 1000)
        return $.$get$nf().format$1(t1) + "ms";
      else
        return C.JSDouble_methods.toStringAsFixed$1(t1 / 1000, 1) + "s";
    },
    PerfToolFramework: function PerfToolFramework(t0, t1, t2, t3) {
      var _ = this;
      _.reloadStatus = _.connectionStatus = _.isolateSelect = _.isolateSelectStatus = null;
      _.screens = t0;
      _._screenContents = t1;
      _.screensReady = t2;
      _.messageManager = t3;
      _.analyticsDialog = _.snapshotMessage = _.connectDialog = _.globalActions = _.auxiliaryStatus = _.pageStatus = _.globalStatus = _._framework$_previous = _.current = null;
    },
    PerfToolFramework_initGlobalUI_closure: function PerfToolFramework_initGlobalUI_closure() {
    },
    PerfToolFramework_initGlobalUI_closure0: function PerfToolFramework_initGlobalUI_closure0(t0, t1) {
      this.$this = t0;
      this.link = t1;
    },
    PerfToolFramework_initGlobalUI_closure1: function PerfToolFramework_initGlobalUI_closure1(t0, t1) {
      this.$this = t0;
      this.screen = t1;
    },
    PerfToolFramework_initGlobalUI_closure2: function PerfToolFramework_initGlobalUI_closure2(t0) {
      this.$this = t0;
    },
    PerfToolFramework_disableAppWithError_closure: function PerfToolFramework_disableAppWithError_closure() {
    },
    PerfToolFramework_addScreens_getDebuggerDisabledTooltip: function PerfToolFramework_addScreens_getDebuggerDisabledTooltip(t0, t1) {
      this._isFlutterWebApp = t0;
      this._isProfileBuild = t1;
    },
    PerfToolFramework__initHotReloadRestartServiceListeners_closure: function PerfToolFramework__initHotReloadRestartServiceListeners_closure(t0) {
      this.$this = t0;
    },
    PerfToolFramework__initHotReloadRestartServiceListeners_closure0: function PerfToolFramework__initHotReloadRestartServiceListeners_closure0(t0) {
      this.$this = t0;
    },
    PerfToolFramework__buildReloadButton_closure: function PerfToolFramework__buildReloadButton_closure(t0, t1) {
      this.$this = t0;
      this.reloadAction = t1;
    },
    PerfToolFramework__buildRestartButton_closure: function PerfToolFramework__buildRestartButton_closure(t0, t1) {
      this.$this = t0;
      this.restartAction = t1;
    },
    NotFoundScreen: function NotFoundScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.name = t0;
      _.id = t1;
      _.iconClass = t2;
      _.helpStatus = t3;
      _.disabledTooltip = t4;
      _.disabled = t5;
      _.shortcutCallback = t6;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t7;
      _.statusItems = t8;
    },
    Status: function Status(t0) {
      this.statusLine = t0;
      this.item = null;
    },
    EventDetails$: function(timelineController) {
      var _null = null,
        t1 = new F.EventDetails(timelineController, C.ThemedColor_Color_4294375158_Color_4281151025, C.ThemedColor_Color_4278190080_Color_4293980400, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.EventDetails$1(timelineController);
      return t1;
    },
    EventDetails: function EventDetails(t0, t1, t2, t3) {
      var _ = this;
      _.timelineController = t0;
      _.gpuEventDetails = _.cpuProfiler = _._title = _.content = _._selectedTab = _.tabNav = null;
      _.titleBackgroundColor = t1;
      _.titleTextColor = t2;
      _.element = t3;
    },
    EventDetails_closure: function EventDetails_closure(t0) {
      this.$this = t0;
    },
    EventDetails__initTabNav_closure: function EventDetails__initTabNav_closure(t0) {
      this.$this = t0;
    },
    EventDetails__initListeners_closure: function EventDetails__initListeners_closure(t0) {
      this.$this = t0;
    },
    EventDetails__initListeners_closure0: function EventDetails__initListeners_closure0(t0) {
      this.$this = t0;
    },
    EventDetails__initListeners_closure1: function EventDetails__initListeners_closure1(t0) {
      this.$this = t0;
    },
    EventDetails__initListeners_closure2: function EventDetails__initListeners_closure2(t0) {
      this.$this = t0;
    },
    _CpuProfiler: function _CpuProfiler(t0, t1, t2) {
      var _ = this;
      _._timelineController = t0;
      _.views = _.callTree = _.bottomUp = _.flameChart = null;
      _._selectedViewType = t1;
      _.showingMessage = false;
      _.element = t2;
    },
    _CpuProfiler_update_closure: function _CpuProfiler_update_closure(t0) {
      this.$this = t0;
    },
    _CpuProfiler__removeMessage_closure: function _CpuProfiler__removeMessage_closure() {
    },
    CpuProfilerTab: function CpuProfilerTab(t0, t1) {
      this.type = t0;
      this.element = t1;
    },
    FlameChartCanvas$: function(data, flameChartHeight, flameChartWidth) {
      var t1 = H.setRuntimeTypeInfo([], [F.FlameChartRow]),
        t2 = data.time,
        t3 = t2._utils$_end;
      t2 = t2._utils$_start;
      t2 = new F.FlameChartCanvas(new F.DragScroll(), data, flameChartWidth, flameChartHeight, new P._AsyncBroadcastStreamController(null, null, [E.CpuStackFrame]), t1, new F.TimelineGrid0(new P.Duration(t3._duration - t2._duration), flameChartWidth));
      t2._initRows$0();
      t2.FlameChartCanvas$3$data$flameChartHeight$flameChartWidth(data, flameChartHeight, flameChartWidth);
      return t2;
    },
    FlameChart: function FlameChart() {
    },
    FlameChart__initRows_calculateLeftForStackFrame: function FlameChart__initRows_calculateLeftForStackFrame(t0, t1) {
      this.stackFrameLefts = t0;
      this.totalWidth = t1;
    },
    FlameChart__initRows_createChartNodes: function FlameChart__initRows_createChartNodes(t0, t1, t2) {
      this.$this = t0;
      this.totalWidth = t1;
      this.calculateLeftForStackFrame = t2;
    },
    FlameChart_getNodeInRow_binarySearchForNode: function FlameChart_getNodeInRow_binarySearchForNode(t0, t1) {
      this.nodes = t0;
      this.x = t1;
    },
    FlameChartCanvas: function FlameChartCanvas(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._dragScroll = t0;
      _._viewportCanvas = null;
      _.data = t1;
      _.flameChartWidth = t2;
      _.flameChartHeight = t3;
      _._stackFrameSelectedController = t4;
      _.selectedNode = null;
      _.rows = t5;
      _.timelineGrid = t6;
      _.zoomLevel = 1;
      _._colorOffset = _.floatingPointScrollLeft = 0;
    },
    FlameChartCanvas_closure: function FlameChartCanvas_closure(t0) {
      this.$this = t0;
    },
    FlameChartCanvas__initAsciiMeasurements_closure: function FlameChartCanvas__initAsciiMeasurements_closure(t0) {
      this.measurementCanvas = t0;
    },
    FlameChartRow: function FlameChartRow(t0) {
      this.nodes = t0;
    },
    FlameChartNode: function FlameChartNode(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.startingLeft = t0;
      _.startingWidth = t1;
      _.backgroundColor = t2;
      _.textColor = t3;
      _.selectedTextColor = t4;
      _.stackFrame = t5;
      _.textMeasurements = t6;
      _.rect = t7;
      _.selected = false;
    },
    FlameChartNode_paint_closure: function FlameChartNode_paint_closure(t0) {
      this.canvas = t0;
    },
    TimelineGrid0: function TimelineGrid0(t0, t1) {
      var _ = this;
      _._flame_chart_canvas$_duration = t0;
      _.currentInterval = 150;
      _._flameChartWidth = t1;
      _._zoomLevel = 1;
    },
    screen: function(screenName) {
      var t1 = {event_category: "screen", value: 0, user_app: $._userAppType, user_build: $._userBuildType, user_platform: $._userPlatformType, devtools_platform: $._devtoolsPlatformType, devtools_chrome: $._devtoolsChrome, devtools_version: "0.1.2", ide_launched: $._ideLaunched};
      if (H.boolConversionCheck(self.gaCollectionAllowed()))
        self.gtag("event", screenName, t1);
    },
    select: function(screenName, selectedItem, value) {
      var t1 = {event_category: "select", event_label: selectedItem, value: value, user_app: $._userAppType, user_build: $._userBuildType, user_platform: $._userPlatformType, devtools_platform: $._devtoolsPlatformType, devtools_chrome: $._devtoolsChrome, devtools_version: "0.1.2", ide_launched: $._ideLaunched};
      if (H.boolConversionCheck(self.gaCollectionAllowed()))
        self.gtag("event", screenName, t1);
    },
    error: function(errorMessage, fatal) {
      var t1;
      if ($._lastGaError === errorMessage)
        return;
      $._lastGaError = errorMessage;
      t1 = {description: errorMessage, fatal: fatal, user_app: $._userAppType, user_build: $._userBuildType, user_platform: $._userPlatformType, devtools_platform: $._devtoolsPlatformType, devtools_chrome: $._devtoolsChrome, devtools_version: "0.1.2", ide_launched: $._ideLaunched};
      if (H.boolConversionCheck(self.gaCollectionAllowed()))
        self.gtag("event", "exception", t1);
    },
    computeUserApplicationCustomGTagData: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, isFlutter, isWebApp, isProfile, isAnyFlutterApp, vmService, io, android, iOS, fuchsia, linux, macOS, windows;
      var $async$computeUserApplicationCustomGTagData = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($._analyticsComputed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isFlutterApp(), $async$computeUserApplicationCustomGTagData);
            case 3:
              // returning from await.
              isFlutter = $async$result;
              $async$goto = 4;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isFlutterWebApp(), $async$computeUserApplicationCustomGTagData);
            case 4:
              // returning from await.
              isWebApp = $async$result;
              $async$goto = 5;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isProfileBuild(), $async$computeUserApplicationCustomGTagData);
            case 5:
              // returning from await.
              isProfile = $async$result;
              $async$goto = 6;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isAnyFlutterApp(), $async$computeUserApplicationCustomGTagData);
            case 6:
              // returning from await.
              isAnyFlutterApp = $async$result;
              H.boolConversionCheck(isFlutter);
              $async$goto = isFlutter ? 7 : 8;
              break;
            case 7:
              // then
              vmService = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              io = B.EvalOnDartLibrary$(H.setRuntimeTypeInfo(["dart:io"], [P.String]), vmService);
              $async$goto = 9;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isAndroid", null), $async$computeUserApplicationCustomGTagData);
            case 9:
              // returning from await.
              android = $async$result;
              $async$goto = 10;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isIOS", null), $async$computeUserApplicationCustomGTagData);
            case 10:
              // returning from await.
              iOS = $async$result;
              $async$goto = 11;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isFuchsia", null), $async$computeUserApplicationCustomGTagData);
            case 11:
              // returning from await.
              fuchsia = $async$result;
              $async$goto = 12;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isLinux", null), $async$computeUserApplicationCustomGTagData);
            case 12:
              // returning from await.
              linux = $async$result;
              $async$goto = 13;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isMacOS", null), $async$computeUserApplicationCustomGTagData);
            case 13:
              // returning from await.
              macOS = $async$result;
              $async$goto = 14;
              return P._asyncAwait(io.eval$2$isAlive("Platform.isWindows", null), $async$computeUserApplicationCustomGTagData);
            case 14:
              // returning from await.
              windows = $async$result;
              if (android.valueAsString === "true")
                $._userPlatformType = "android_flutter";
              else if (iOS.valueAsString === "true")
                $._userPlatformType = "ios_flutter";
              else if (fuchsia.valueAsString === "true")
                $._userPlatformType = "fuchsia";
              else if (linux.valueAsString === "true")
                $._userPlatformType = "linux";
              else if (macOS.valueAsString === "true")
                $._userPlatformType = "mac";
              else if (windows.valueAsString === "true")
                $._userPlatformType = "windows";
            case 8:
              // join
              if (H.boolConversionCheck(isAnyFlutterApp)) {
                if (isFlutter)
                  $._userAppType = "flutter";
                if (H.boolConversionCheck(isWebApp))
                  $._userAppType = "web";
              }
              $._userBuildType = H.boolConversionCheck(isProfile) ? "profile" : "debug";
              $._analyticsComputed = true;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$computeUserApplicationCustomGTagData, $async$completer);
    },
    GtagEventDevTools: function GtagEventDevTools() {
    },
    GtagExceptionDevTools: function GtagExceptionDevTools() {
    },
    DragScroll$: function() {
      return new F.DragScroll();
    },
    DragScroll: function DragScroll() {
      this.wasDragged = false;
      this._onVerticalScroll = null;
    },
    DragScroll_enableDragScrolling_closure: function DragScroll_enableDragScrolling_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    DragScroll_enableDragScrolling_closure0: function DragScroll_enableDragScrolling_closure0(t0) {
      this._box_0 = t0;
    },
    DragScroll_enableDragScrolling_closure1: function DragScroll_enableDragScrolling_closure1(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.dragged = t2;
    },
    GtagEvent: function GtagEvent() {
    },
    GtagException: function GtagException() {
    },
    UrlStyle: function UrlStyle(t0, t1, t2, t3) {
      var _ = this;
      _.separatorPattern = t0;
      _.needsSeparatorPattern = t1;
      _.rootPattern = t2;
      _.relativeRootPattern = t3;
    },
    Subject: function Subject() {
    },
    main: function() {
      P.runZoned(new F.main_closure(), new F.main_closure0(), P.Null);
    },
    main_closure: function main_closure() {
    },
    main__closure: function main__closure(t0) {
      this.framework = t0;
    },
    main__closure0: function main__closure0(t0) {
      this.framework = t0;
    },
    main_closure0: function main_closure0() {
    },
    getSimplePackageUrl: function(url) {
      var flutterPrefixIndex = J.getInterceptor$asx(url).indexOf$1(url, "packages/flutter/"),
        flutterWebPrefixIndex = C.JSString_methods.indexOf$1(url, "packages/flutter_web/");
      if (flutterPrefixIndex !== -1)
        return "package:" + C.JSString_methods.substring$1(url, flutterPrefixIndex + 9);
      else if (flutterWebPrefixIndex !== -1)
        return "package:" + C.JSString_methods.substring$1(url, flutterWebPrefixIndex + 9);
      return url;
    },
    getNormalizedTrimmedUri: function(value) {
      var uri = P.Uri_parse(C.JSString_methods.trim$0(value), 0, null).removeFragment$0();
      if (C.JSString_methods.endsWith$1(uri.get$path(uri), "/"))
        return uri;
      return uri.replace$1$path(0, uri.get$path(uri));
    }
  },
  S = {
    CallStackView$: function() {
      var t1 = new S.CallStackView();
      t1.CallStackView$0();
      return t1;
    },
    CallStackView: function CallStackView() {
      this._callstack_view$_items = null;
    },
    CallStackView_closure: function CallStackView_closure() {
    },
    DebuggerState: function DebuggerState(t0, t1, t2, t3, t4) {
      var _ = this;
      _.scripts = _.isolateRef = _._debugSubscription = _._service = null;
      _._scriptCache = t0;
      _._paused = t1;
      _._supportsStepping = t2;
      _.lastEvent = null;
      _._breakpoints = t3;
      _._exceptionPauseMode = t4;
      _.rootLib = _.commonScriptPrefix = _._reportedException = null;
    },
    DebuggerState_clearBreakpoints_closure: function DebuggerState_clearBreakpoints_closure(t0) {
      this.$this = t0;
    },
    DebuggerState_addBreakpointByPathFragment_closure: function DebuggerState_addBreakpointByPathFragment_closure(t0) {
      this.path = t0;
    },
    DebuggerState_addBreakpointByPathFragment_closure0: function DebuggerState_addBreakpointByPathFragment_closure0() {
    },
    Category_forLabel: function(label) {
      var _i, category;
      if ($.Category__categories == null) {
        $.Category__categories = P.LinkedHashMap_LinkedHashMap$_empty(P.String, S.Category);
        for (_i = 0; _i < 12; ++_i) {
          category = C.List_mya[_i];
          $.Category__categories.$indexSet(0, category.label, category);
        }
      }
      return $.Category__categories.$index(0, label);
    },
    FlutterWidget_initIcon: function(json) {
      var category, icon,
        t1 = P.Object,
        categories = H.assertSubtype(J.$index$asx(H.assertSubtype(json, "$isMap", [P.String, t1], "$asMap"), "categories"), "$isList", [t1], "$asList");
      if (categories != null)
        for (t1 = J.get$iterator$ax(categories); t1.moveNext$0();) {
          category = S.Category_forLabel(H.stringTypeCheck(t1.get$current(t1)));
          if (category != null) {
            icon = category.icon;
            if (icon != null)
              return icon;
          }
        }
      return;
    },
    Catalog__loadHelper: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Catalog),
        $async$returnValue, response;
      var $async$Catalog__loadHelper = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(G.get("widgets.json"), $async$Catalog__loadHelper);
            case 3:
              // returning from await.
              response = $async$result;
              $async$returnValue = $.Catalog__instance = S.Catalog_decode(B.encodingForCharset(J.$index$asx(U._contentTypeForHeaders(response.headers).parameters._collection$_map, "charset")).decode$1(0, response.bodyBytes));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$Catalog__loadHelper, $async$completer);
    },
    Catalog_decode: function(source) {
      var t3, element,
        t1 = P.Object,
        t2 = P.String,
        widgets = P.LinkedHashMap_LinkedHashMap$_empty(t2, S.FlutterWidget);
      for (t3 = J.get$iterator$ax(H.assertSubtype(C.C_JsonCodec.decode$2$reviver(0, source, null), "$isList", [t1], "$asList")), t1 = [t2, t1]; t3.moveNext$0();) {
        element = H.assertSubtype(t3.get$current(t3), "$isMap", t1, "$asMap");
        t2 = S.FlutterWidget_initIcon(element);
        widgets.$indexSet(0, H.stringTypeCheck(J.$index$asx(element, "name")), new S.FlutterWidget(element, t2));
      }
      return new S.Catalog(widgets);
    },
    Category: function Category(t0, t1) {
      this.label = t0;
      this.icon = t1;
    },
    FlutterWidget: function FlutterWidget(t0, t1) {
      this.json = t0;
      this.icon = t1;
    },
    Catalog: function Catalog(t0) {
      this.widgets = t0;
    },
    Color$fromARGB: function(a, r, g, b) {
      return new S.Color((((a & 255) << 24 | (r & 255) << 16 | (g & 255) << 8 | (b & 255) << 0) & 4294967295) >>> 0);
    },
    Rect$fromLTRB: function(left, $top, right, bottom) {
      var t1 = new Float32Array(4);
      C.NativeFloat32List_methods.$indexSet(t1, 0, left);
      t1[1] = $top;
      t1[2] = right;
      t1[3] = bottom;
      return new S.Rect(t1);
    },
    Rect$fromLTWH: function(left, $top, width, height) {
      var t1 = new Float32Array(4);
      C.NativeFloat32List_methods.$indexSet(t1, 0, left);
      C.NativeFloat32List_methods.$indexSet(t1, 1, $top);
      if (typeof left !== "number")
        return left.$add();
      if (typeof width !== "number")
        return H.iae(width);
      t1[2] = left + width;
      if (typeof $top !== "number")
        return $top.$add();
      if (typeof height !== "number")
        return H.iae(height);
      t1[3] = $top + height;
      return new S.Rect(t1);
    },
    _Jenkins_combine: function(hash, o) {
      hash = 536870911 & hash + J.get$hashCode$(o);
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    },
    _Jenkins_finish: function(hash) {
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    hashValues: function(arg01, arg02, arg03, arg04, arg05, arg06, arg07, arg08, arg09, arg10, arg11, arg12, arg13) {
      var result = S._Jenkins_combine(S._Jenkins_combine(0, arg01), arg02);
      if (arg03 !== C.C__HashEnd) {
        result = S._Jenkins_combine(result, arg03);
        if (arg04 !== C.C__HashEnd) {
          result = S._Jenkins_combine(result, arg04);
          if (arg05 !== C.C__HashEnd) {
            result = S._Jenkins_combine(result, arg05);
            if (arg06 !== C.C__HashEnd) {
              result = S._Jenkins_combine(result, arg06);
              if (arg07 !== C.C__HashEnd) {
                result = S._Jenkins_combine(result, arg07);
                if (arg08 !== C.C__HashEnd) {
                  result = S._Jenkins_combine(result, arg08);
                  if (arg09 !== C.C__HashEnd) {
                    result = S._Jenkins_combine(result, arg09);
                    if (arg10 !== C.C__HashEnd) {
                      result = S._Jenkins_combine(result, arg10);
                      if (!J.$eq$(arg11, C.C__HashEnd)) {
                        result = S._Jenkins_combine(result, arg11);
                        if (arg12 !== C.C__HashEnd) {
                          result = S._Jenkins_combine(result, arg12);
                          if (arg13 !== C.C__HashEnd)
                            result = S._Jenkins_combine(result, arg13);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return S._Jenkins_finish(result);
    },
    hashList: function($arguments) {
      var result, _i;
      H.assertSubtype($arguments, "$isIterable", [P.Object], "$asIterable");
      for (result = 0, _i = 0; _i < 4; ++_i)
        result = S._Jenkins_combine(result, $arguments[_i]);
      return S._Jenkins_finish(result);
    },
    Color: function Color(t0) {
      this.value = t0;
    },
    MaterialColor: function MaterialColor(t0, t1) {
      this._swatch = t0;
      this.value = t1;
    },
    MaterialAccentColor: function MaterialAccentColor(t0, t1) {
      this._swatch = t0;
      this.value = t1;
    },
    ColorSwatch: function ColorSwatch() {
    },
    OffsetBase: function OffsetBase() {
    },
    Offset: function Offset(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Size: function Size(t0, t1) {
      this._dx = t0;
      this._dy = t1;
    },
    Rect: function Rect(t0) {
      this._dart_ui$_value = t0;
    },
    _HashEnd: function _HashEnd() {
    },
    FontStyle: function FontStyle(t0) {
      this._dart_ui$_name = t0;
    },
    FontWeight: function FontWeight(t0) {
      this.index = t0;
    },
    CustomIconMaker$: function() {
      return new S.CustomIconMaker(P.LinkedHashMap_LinkedHashMap$_empty(P.String, S.CustomIcon));
    },
    Icon: function Icon() {
    },
    UrlIcon: function UrlIcon(t0, t1) {
      this.src = t0;
      this.invertDark = t1;
    },
    CustomIcon: function CustomIcon(t0, t1, t2) {
      this.kind = t0;
      this.text = t1;
      this.isAbstract = t2;
    },
    CustomIconMaker: function CustomIconMaker(t0) {
      this.iconCache = t0;
    },
    CustomIconMaker_getCustomIcon_closure: function CustomIconMaker_getCustomIcon_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.text = t1;
      this.isAbstract = t2;
    },
    IconKind: function IconKind(t0, t1, t2) {
      this.name = t0;
      this.icon = t1;
      this.abstractIcon = t2;
    },
    ColorIcon: function ColorIcon(t0) {
      this.color = t0;
    },
    ColorIconMaker: function ColorIconMaker(t0) {
      this.iconCache = t0;
    },
    ColorIconMaker_getCustomIcon_closure: function ColorIconMaker_getCustomIcon_closure(t0) {
      this.color = t0;
    },
    createServiceObject: function(json) {
      var t1, type;
      if (json == null)
        return;
      t1 = J.getInterceptor$(json);
      if (!!t1.$isList)
        return t1.map$1$1(json, new S.createServiceObject_closure(), P.Object).toList$0(0);
      else if (!!t1.$isMap) {
        type = H.stringTypeCheck(t1.$index(json, "type"));
        if ($._typeFactories.$index(0, type) == null)
          return;
        else
          return $._typeFactories.$index(0, type).call$1(json);
      } else
        return json;
    },
    _createSpecificObject: function(json, creator) {
      var t1, map, t2, key;
      H.functionTypeCheck(creator, {func: 1, args: [[P.Map, P.String,,]]});
      if (json == null)
        return;
      t1 = J.getInterceptor$(json);
      if (!!t1.$isList)
        return t1.map$1$1(json, new S._createSpecificObject_closure(creator), null).toList$0(0);
      else if (!!t1.$isMap) {
        map = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
        for (t2 = J.get$iterator$ax(t1.get$keys(json)); t2.moveNext$0();) {
          key = H.stringTypeCast(t2.get$current(t2));
          map.$indexSet(0, key, t1.$index(json, key));
        }
        return creator.call$1(map);
      } else
        return json;
    },
    _setIfNotNull: function(json, key, value) {
      H.assertSubtype(json, "$isMap", [P.String, P.Object], "$asMap");
      if (value == null)
        return;
      json.$indexSet(0, key, value);
    },
    ExtensionData_parse: function(json) {
      return json == null ? null : new S.ExtensionData(json);
    },
    AllocationProfile_parse: function(json) {
      var t1, t2, t3, _null = null,
        _s24_ = "dateLastAccumulatorReset",
        _s17_ = "dateLastServiceGC";
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = _null;
      else {
        t1 = new S.AllocationProfile(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t2 = J.getInterceptor$asx(json);
        t1.memoryUsage = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "memoryUsage")), "$isMemoryUsage");
        t3 = t2.$index(json, _s24_);
        t1.dateLastAccumulatorReset = H.intTypeCheck(typeof t3 === "string" ? P.int_parse(H.stringTypeCheck(t2.$index(json, _s24_)), _null, _null) : t2.$index(json, _s24_));
        t3 = t2.$index(json, _s17_);
        t1.dateLastServiceGC = H.intTypeCheck(typeof t3 === "string" ? P.int_parse(H.stringTypeCheck(t2.$index(json, _s17_)), _null, _null) : t2.$index(json, _s17_));
        t1.set$members(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "members")), "$isIterable"), true, S.ClassHeapStats));
      }
      return t1;
    },
    AllocationProfile$_fromJson: function(json) {
      var t2, t3, _null = null,
        _s24_ = "dateLastAccumulatorReset",
        _s17_ = "dateLastServiceGC",
        t1 = new S.AllocationProfile(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.memoryUsage = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "memoryUsage")), "$isMemoryUsage");
      t3 = t2.$index(json, _s24_);
      t1.dateLastAccumulatorReset = H.intTypeCheck(typeof t3 === "string" ? P.int_parse(H.stringTypeCheck(t2.$index(json, _s24_)), _null, _null) : t2.$index(json, _s24_));
      t3 = t2.$index(json, _s17_);
      t1.dateLastServiceGC = H.intTypeCheck(typeof t3 === "string" ? P.int_parse(H.stringTypeCheck(t2.$index(json, _s17_)), _null, _null) : t2.$index(json, _s17_));
      t1.set$members(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "members")), "$isIterable"), true, S.ClassHeapStats));
      return t1;
    },
    BoundField_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.BoundField();
      t2 = J.getInterceptor$asx(json);
      t1.decl = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "decl")), "$isFieldRef");
      t1.value = S.createServiceObject(t2.$index(json, "value"));
      return t1;
    },
    BoundVariable_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.BoundVariable(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.value = S.createServiceObject(t2.$index(json, "value"));
      t1.declarationTokenPos = H.intTypeCheck(t2.$index(json, "declarationTokenPos"));
      t1.scopeStartTokenPos = H.intTypeCheck(t2.$index(json, "scopeStartTokenPos"));
      t1.scopeEndTokenPos = H.intTypeCheck(t2.$index(json, "scopeEndTokenPos"));
      return t1;
    },
    Breakpoint_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Breakpoint(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.breakpointNumber = H.intTypeCheck(t2.$index(json, "breakpointNumber"));
      t1.resolved = H.boolTypeCheck(t2.$index(json, "resolved"));
      t1.isSyntheticAsyncContinuation = H.boolTypeCheck(t2.$index(json, "isSyntheticAsyncContinuation"));
      t1.location = S.createServiceObject(t2.$index(json, "location"));
      return t1;
    },
    ClassRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.ClassRef(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t1.ObjRef$_fromJson$1(json);
        t1.name = H.stringTypeCheck(J.$index$asx(json, "name"));
      }
      return t1;
    },
    ClassRef$_fromJson: function(json) {
      var t1 = new S.ClassRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.name = H.stringTypeCheck(J.$index$asx(json, "name"));
      return t1;
    },
    Class_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Class(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.error = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "error")), "$isErrorRef");
      t1.isAbstract = H.boolTypeCheck(t2.$index(json, "abstract"));
      t1.isConst = H.boolTypeCheck(t2.$index(json, "const"));
      t1.library = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "library")), "$isObjRef");
      t1.location = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "location")), "$isSourceLocation");
      t1.superClass = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "super")), "$isClassRef");
      t1.superType = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "superType")), "$isInstanceRef");
      t1.set$interfaces(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "interfaces")), "$isIterable"), true, S.InstanceRef));
      t1.mixin = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "mixin")), "$isInstanceRef");
      t1.set$fields(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "fields")), "$isIterable"), true, S.FieldRef));
      t1.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "functions")), "$isIterable"), true, S.FuncRef));
      t1.set$subclasses(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "subclasses")), "$isIterable"), true, S.ClassRef));
      return t1;
    },
    ClassHeapStats_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ClassHeapStats(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.accumulatedSize = H.intTypeCheck(t2.$index(json, "accumulatedSize"));
      t1.bytesCurrent = H.intTypeCheck(t2.$index(json, "bytesCurrent"));
      t1.instancesAccumulated = H.intTypeCheck(t2.$index(json, "instancesAccumulated"));
      t1.instancesCurrent = H.intTypeCheck(t2.$index(json, "instancesCurrent"));
      t1.classRef = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "class")), "$isClassRef");
      t1.set$new_(t2.$index(json, "new") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "new"), "$isIterable"), true, P.int));
      t1.set$old(t2.$index(json, "old") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "old"), "$isIterable"), true, P.int));
      t1.promotedBytes = H.intTypeCheck(t2.$index(json, "promotedBytes"));
      t1.promotedInstances = H.intTypeCheck(t2.$index(json, "promotedInstances"));
      return t1;
    },
    ClassList_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ClassList(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.set$classes(0, P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(J.$index$asx(json, "classes")), "$isIterable"), true, S.ClassRef));
      return t1;
    },
    CodeRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.CodeRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      return t1;
    },
    Code_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Code(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      return t1;
    },
    ContextRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ContextRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.length = H.intTypeCheck(J.$index$asx(json, "length"));
      return t1;
    },
    Context_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Context(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.length = H.intTypeCheck(t2.$index(json, "length"));
      t1.parent = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "parent")), "$isContext");
      t1.set$variables(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "variables")), "$isIterable"), true, S.ContextElement));
      return t1;
    },
    ContextElement_parse: function(json) {
      var t1 = new S.ContextElement();
      t1.value = S.createServiceObject(J.$index$asx(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"), "value"));
      return t1;
    },
    ErrorRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ErrorRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      t1.message = H.stringTypeCheck(t2.$index(json, "message"));
      return t1;
    },
    Error_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Error0(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      t1.message = H.stringTypeCheck(t2.$index(json, "message"));
      t1.exception = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "exception")), "$isInstanceRef");
      t1.stacktrace = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "stacktrace")), "$isInstanceRef");
      return t1;
    },
    Event_parse: function(json) {
      var t1, t2, t3,
        _s16_ = "pauseBreakpoints",
        _s14_ = "timelineEvents";
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Event0(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      t1.isolate = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "isolate")), "$isIsolateRef");
      t1.vm = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "vm")), "$isVMRef");
      t1.timestamp = H.intTypeCheck(t2.$index(json, "timestamp"));
      t1.breakpoint = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "breakpoint")), "$isBreakpoint");
      t1.set$pauseBreakpoints(t2.$index(json, _s16_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, _s16_)), "$isIterable"), true, S.Breakpoint));
      t1.topFrame = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "topFrame")), "$isFrame");
      t1.exception = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "exception")), "$isInstanceRef");
      t1.bytes = H.stringTypeCheck(t2.$index(json, "bytes"));
      t1.inspectee = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "inspectee")), "$isInstanceRef");
      t1.extensionRPC = H.stringTypeCheck(t2.$index(json, "extensionRPC"));
      t1.extensionKind = H.stringTypeCheck(t2.$index(json, "extensionKind"));
      t3 = H.interceptedTypeCheck(t2.$index(json, "extensionData"), "$isMap");
      t1.extensionData = t3 == null ? null : new S.ExtensionData(t3);
      t1.set$timelineEvents(t2.$index(json, _s14_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, _s14_)), "$isIterable"), true, S.TimelineEvent));
      t1.atAsyncSuspension = H.boolTypeCheck(t2.$index(json, "atAsyncSuspension"));
      t1.status = H.stringTypeCheck(t2.$index(json, "status"));
      t1.logRecord = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "logRecord")), "$isLogRecord");
      t1.service = H.stringTypeCheck(t2.$index(json, "service"));
      t1.method = H.stringTypeCheck(t2.$index(json, "method"));
      t1.alias = H.stringTypeCheck(t2.$index(json, "alias"));
      return t1;
    },
    FieldRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.FieldRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.owner = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "owner")), "$isObjRef");
      t1.declaredType = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "declaredType")), "$isInstanceRef");
      t1.isConst = H.boolTypeCheck(t2.$index(json, "const"));
      t1.isFinal = H.boolTypeCheck(t2.$index(json, "final"));
      t1.isStatic = H.boolTypeCheck(t2.$index(json, "static"));
      return t1;
    },
    Field_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Field(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.owner = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "owner")), "$isObjRef");
      t1.declaredType = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "declaredType")), "$isInstanceRef");
      t1.isConst = H.boolTypeCheck(t2.$index(json, "const"));
      t1.isFinal = H.boolTypeCheck(t2.$index(json, "final"));
      t1.isStatic = H.boolTypeCheck(t2.$index(json, "static"));
      t1.staticValue = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "staticValue")), "$isInstanceRef");
      t1.location = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "location")), "$isSourceLocation");
      return t1;
    },
    Flag_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Flag();
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.comment = H.stringTypeCheck(t2.$index(json, "comment"));
      t1.modified = H.boolTypeCheck(t2.$index(json, "modified"));
      t1.valueAsString = H.stringTypeCheck(t2.$index(json, "valueAsString"));
      return t1;
    },
    FlagList_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.FlagList(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.set$flags(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(J.$index$asx(json, "flags")), "$isIterable"), true, S.Flag));
      return t1;
    },
    Frame_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Frame(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.index = H.intTypeCheck(t2.$index(json, "index"));
      t1.$function = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "function")), "$isFuncRef");
      t1.code = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "code")), "$isCodeRef");
      t1.location = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "location")), "$isSourceLocation");
      t1.set$vars(t2.$index(json, "vars") == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "vars")), "$isIterable"), true, S.BoundVariable));
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      return t1;
    },
    FuncRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.FuncRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.owner = S.createServiceObject(t2.$index(json, "owner"));
      t1.isStatic = H.boolTypeCheck(t2.$index(json, "static"));
      t1.isConst = H.boolTypeCheck(t2.$index(json, "const"));
      return t1;
    },
    Func_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Func(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.owner = S.createServiceObject(t2.$index(json, "owner"));
      t1.location = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "location")), "$isSourceLocation");
      t1.code = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "code")), "$isCodeRef");
      return t1;
    },
    InstanceRef_parse: function(json) {
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      return json == null ? null : S.InstanceRef$_fromJson(json);
    },
    InstanceRef$_fromJson: function(json) {
      var t1 = new S.InstanceRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.InstanceRef$_fromJson$1(json);
      return t1;
    },
    Instance_parse: function(json) {
      var t1 = S.Instance$_fromJson(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      return t1;
    },
    Instance$_fromJson: function(json) {
      var t1 = new S.Instance(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t1.Instance$_fromJson$1(json);
      return t1;
    },
    IsolateRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.IsolateRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.id = H.stringTypeCheck(t2.$index(json, "id"));
      t1.number = H.stringTypeCheck(t2.$index(json, "number"));
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      return t1;
    },
    Isolate_parse: function(json) {
      var t2, t3,
        _s13_ = "extensionRPCs",
        t1 = P.String;
      H.assertSubtype(json, "$isMap", [t1, null], "$asMap");
      t2 = new S.Isolate(json);
      t2.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t3 = J.getInterceptor$asx(json);
      t2.id = H.stringTypeCheck(t3.$index(json, "id"));
      t2.number = H.stringTypeCheck(t3.$index(json, "number"));
      t2.name = H.stringTypeCheck(t3.$index(json, "name"));
      t2.startTime = H.intTypeCheck(t3.$index(json, "startTime"));
      t2.runnable = H.boolTypeCheck(t3.$index(json, "runnable"));
      t2.livePorts = H.intTypeCheck(t3.$index(json, "livePorts"));
      t2.pauseOnExit = H.boolTypeCheck(t3.$index(json, "pauseOnExit"));
      t2.pauseEvent = H.interceptedTypeCheck(S.createServiceObject(t3.$index(json, "pauseEvent")), "$isEvent0");
      t2.rootLib = H.interceptedTypeCheck(S.createServiceObject(t3.$index(json, "rootLib")), "$isLibraryRef");
      t2.set$libraries(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t3.$index(json, "libraries")), "$isIterable"), true, S.LibraryRef));
      t2.set$breakpoints(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t3.$index(json, "breakpoints")), "$isIterable"), true, S.Breakpoint));
      t2.error = H.interceptedTypeCheck(S.createServiceObject(t3.$index(json, "error")), "$isError0");
      t2.exceptionPauseMode = H.stringTypeCheck(t3.$index(json, "exceptionPauseMode"));
      t2.set$extensionRPCs(t3.$index(json, _s13_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(t3.$index(json, _s13_), "$isIterable"), true, t1));
      return t2;
    },
    InstanceSet_parse: function(json) {
      var t1, t2, t3;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.InstanceSet(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t2 = J.getInterceptor$asx(json);
        t1.totalCount = H.intTypeCheck(t2.$index(json, "totalCount"));
        t3 = t2.$index(json, "instances");
        t1.set$instances(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t3 == null ? t2.$index(json, "samples") : t3), "$isIterable"), true, S.ObjRef));
      }
      return t1;
    },
    InstanceSet$_fromJson: function(json) {
      var t2, t3,
        t1 = new S.InstanceSet(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.totalCount = H.intTypeCheck(t2.$index(json, "totalCount"));
      t3 = t2.$index(json, "instances");
      t1.set$instances(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t3 == null ? t2.$index(json, "samples") : t3), "$isIterable"), true, S.ObjRef));
      return t1;
    },
    LibraryRef_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.LibraryRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.uri = H.stringTypeCheck(t2.$index(json, "uri"));
      return t1;
    },
    Library_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.Library(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t1.Obj$_fromJson$1(json);
        t2 = J.getInterceptor$asx(json);
        t1.name = H.stringTypeCheck(t2.$index(json, "name"));
        t1.uri = H.stringTypeCheck(t2.$index(json, "uri"));
        t1.debuggable = H.boolTypeCheck(t2.$index(json, "debuggable"));
        t1.set$dependencies(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t2.$index(json, "dependencies"), S.vm_service_lib_LibraryDependency_parse$closure()), "$isIterable"), true, S.LibraryDependency));
        t1.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "scripts")), "$isIterable"), true, S.ScriptRef));
        t1.set$variables(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "variables")), "$isIterable"), true, S.FieldRef));
        t1.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "functions")), "$isIterable"), true, S.FuncRef));
        t1.set$classes(0, P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "classes")), "$isIterable"), true, S.ClassRef));
      }
      return t1;
    },
    Library$_fromJson: function(json) {
      var t2,
        t1 = new S.Library(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.uri = H.stringTypeCheck(t2.$index(json, "uri"));
      t1.debuggable = H.boolTypeCheck(t2.$index(json, "debuggable"));
      t1.set$dependencies(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t2.$index(json, "dependencies"), S.vm_service_lib_LibraryDependency_parse$closure()), "$isIterable"), true, S.LibraryDependency));
      t1.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "scripts")), "$isIterable"), true, S.ScriptRef));
      t1.set$variables(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "variables")), "$isIterable"), true, S.FieldRef));
      t1.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "functions")), "$isIterable"), true, S.FuncRef));
      t1.set$classes(0, P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "classes")), "$isIterable"), true, S.ClassRef));
      return t1;
    },
    LibraryDependency_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.LibraryDependency();
        t2 = J.getInterceptor$asx(json);
        t1.isImport = H.boolTypeCheck(t2.$index(json, "isImport"));
        t1.isDeferred = H.boolTypeCheck(t2.$index(json, "isDeferred"));
        t1.prefix = H.stringTypeCheck(t2.$index(json, "prefix"));
        t1.target = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "target")), "$isLibraryRef");
      }
      return t1;
    },
    LogRecord_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.LogRecord(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.message = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "message")), "$isInstanceRef");
      t1.time = H.intTypeCheck(t2.$index(json, "time"));
      t1.level = H.intTypeCheck(t2.$index(json, "level"));
      t1.sequenceNumber = H.intTypeCheck(t2.$index(json, "sequenceNumber"));
      t1.loggerName = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "loggerName")), "$isInstanceRef");
      t1.zone = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "zone")), "$isInstanceRef");
      t1.error = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "error")), "$isInstanceRef");
      t1.stackTrace = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "stackTrace")), "$isInstanceRef");
      return t1;
    },
    MapAssociation_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.MapAssociation();
        t2 = J.getInterceptor$asx(json);
        t1.key = S.createServiceObject(t2.$index(json, "key"));
        t1.value = S.createServiceObject(t2.$index(json, "value"));
      }
      return t1;
    },
    MemoryUsage_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.MemoryUsage(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.externalUsage = H.intTypeCheck(t2.$index(json, "externalUsage"));
      t1.heapCapacity = H.intTypeCheck(t2.$index(json, "heapCapacity"));
      t1.heapUsage = H.intTypeCheck(t2.$index(json, "heapUsage"));
      return t1;
    },
    Message_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Message0(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.index = H.intTypeCheck(t2.$index(json, "index"));
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.messageObjectId = H.stringTypeCheck(t2.$index(json, "messageObjectId"));
      t1.size = H.intTypeCheck(t2.$index(json, "size"));
      t1.handler = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "handler")), "$isFuncRef");
      t1.location = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "location")), "$isSourceLocation");
      return t1;
    },
    NullValRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.NullValRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.InstanceRef$_fromJson$1(json);
      return t1;
    },
    NullVal_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.NullVal(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t1.Instance$_fromJson$1(json);
      return t1;
    },
    ObjRef_parse: function(json) {
      var t1 = S.ObjRef$_fromJson(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      return t1;
    },
    ObjRef$_fromJson: function(json) {
      var t1 = new S.ObjRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      return t1;
    },
    Obj_parse: function(json) {
      var t1 = S.Obj$_fromJson(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      return t1;
    },
    Obj$_fromJson: function(json) {
      var t1 = new S.Obj(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      return t1;
    },
    ReloadReport_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ReloadReport(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.success = H.boolTypeCheck(J.$index$asx(json, "success"));
      return t1;
    },
    Response_parse: function(json) {
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      return json == null ? null : S.Response$_fromJson(json);
    },
    Response$_fromJson: function(json) {
      var t1 = new S.Response(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      return t1;
    },
    Sentinel_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Sentinel(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
      t1.valueAsString = H.stringTypeCheck(t2.$index(json, "valueAsString"));
      return t1;
    },
    ScriptRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ScriptRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.uri = H.stringTypeCheck(J.$index$asx(json, "uri"));
      return t1;
    },
    Script_parse: function(json) {
      var t1 = S.Script$_fromJson(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
      return t1;
    },
    Script$_fromJson: function(json) {
      var t1 = new S.Script(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t1.Script$_fromJson$1(json);
      return t1;
    },
    ScriptList_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.ScriptList(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(J.$index$asx(json, "scripts")), "$isIterable"), true, S.ScriptRef));
      return t1;
    },
    SourceLocation_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.SourceLocation(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.script = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "script")), "$isScriptRef");
      t1.tokenPos = H.intTypeCheck(t2.$index(json, "tokenPos"));
      t1.endTokenPos = H.intTypeCheck(t2.$index(json, "endTokenPos"));
      return t1;
    },
    SourceReport_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.SourceReport(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.set$ranges(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t2.$index(json, "ranges"), S.vm_service_lib_SourceReportRange_parse$closure()), "$isIterable"), true, S.SourceReportRange));
      t1.set$scripts(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "scripts")), "$isIterable"), true, S.ScriptRef));
      return t1;
    },
    SourceReportCoverage_parse: function(json) {
      var t1, t2, t3;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.SourceReportCoverage();
        t2 = J.getInterceptor$asx(json);
        t3 = P.int;
        t1.set$hits(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "hits"), "$isIterable"), true, t3));
        t1.set$misses(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "misses"), "$isIterable"), true, t3));
      }
      return t1;
    },
    SourceReportRange_parse: function(json) {
      var t1, t2,
        _s19_ = "possibleBreakpoints";
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.SourceReportRange();
        t2 = J.getInterceptor$asx(json);
        t1.scriptIndex = H.intTypeCheck(t2.$index(json, "scriptIndex"));
        t1.startPos = H.intTypeCheck(t2.$index(json, "startPos"));
        t1.endPos = H.intTypeCheck(t2.$index(json, "endPos"));
        t1.compiled = H.boolTypeCheck(t2.$index(json, "compiled"));
        t1.error = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "error")), "$isErrorRef");
        t1.coverage = H.interceptedTypeCheck(S._createSpecificObject(t2.$index(json, "coverage"), S.vm_service_lib_SourceReportCoverage_parse$closure()), "$isSourceReportCoverage");
        t1.set$possibleBreakpoints(t2.$index(json, _s19_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, _s19_), "$isIterable"), true, P.int));
      }
      return t1;
    },
    Stack_parse: function(json) {
      var t1, t2, t3,
        _s17_ = "asyncCausalFrames",
        _s13_ = "awaiterFrames";
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Stack(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t3 = S.Frame;
      t1.set$frames(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "frames")), "$isIterable"), true, t3));
      t1.set$asyncCausalFrames(t2.$index(json, _s17_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, _s17_)), "$isIterable"), true, t3));
      t1.set$awaiterFrames(t2.$index(json, _s13_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, _s13_)), "$isIterable"), true, t3));
      t1.set$messages(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "messages")), "$isIterable"), true, S.Message0));
      return t1;
    },
    Success_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Success(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      return t1;
    },
    Timeline_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.Timeline(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t2 = J.getInterceptor$asx(json);
        t1.set$traceEvents(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "traceEvents")), "$isIterable"), true, S.TimelineEvent));
        t1.timeOriginMicros = H.intTypeCheck(t2.$index(json, "timeOriginMicros"));
        t1.timeExtentMicros = H.intTypeCheck(t2.$index(json, "timeExtentMicros"));
      }
      return t1;
    },
    Timeline$_fromJson: function(json) {
      var t2,
        t1 = new S.Timeline(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.set$traceEvents(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "traceEvents")), "$isIterable"), true, S.TimelineEvent));
      t1.timeOriginMicros = H.intTypeCheck(t2.$index(json, "timeOriginMicros"));
      t1.timeExtentMicros = H.intTypeCheck(t2.$index(json, "timeExtentMicros"));
      return t1;
    },
    TimelineEvent_parse: function(json) {
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      return new S.TimelineEvent();
    },
    TimelineFlags_parse: function(json) {
      var t2, t3,
        t1 = P.String;
      H.assertSubtype(json, "$isMap", [t1, null], "$asMap");
      t2 = new S.TimelineFlags(json);
      t2.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t3 = J.getInterceptor$asx(json);
      t2.recorderName = H.stringTypeCheck(t3.$index(json, "recorderName"));
      t2.set$availableStreams(P.List_List$from(H.listSuperNativeTypeCheck(t3.$index(json, "availableStreams"), "$isIterable"), true, t1));
      t2.set$recordedStreams(P.List_List$from(H.listSuperNativeTypeCheck(t3.$index(json, "recordedStreams"), "$isIterable"), true, t1));
      return t2;
    },
    Timestamp_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Timestamp(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.timestamp = H.intTypeCheck(J.$index$asx(json, "timestamp"));
      return t1;
    },
    TypeArgumentsRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.TypeArgumentsRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.ObjRef$_fromJson$1(json);
      t1.name = H.stringTypeCheck(J.$index$asx(json, "name"));
      return t1;
    },
    TypeArguments_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.TypeArguments(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.Obj$_fromJson$1(json);
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.set$types(0, P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "types")), "$isIterable"), true, S.InstanceRef));
      return t1;
    },
    UnresolvedSourceLocation_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.UnresolvedSourceLocation(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.script = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "script")), "$isScriptRef");
      t1.scriptUri = H.stringTypeCheck(t2.$index(json, "scriptUri"));
      t1.tokenPos = H.intTypeCheck(t2.$index(json, "tokenPos"));
      t1.line = H.intTypeCheck(t2.$index(json, "line"));
      t1.column = H.intTypeCheck(t2.$index(json, "column"));
      return t1;
    },
    Version_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.Version(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.major = H.intTypeCheck(t2.$index(json, "major"));
      t1.minor = H.intTypeCheck(t2.$index(json, "minor"));
      return t1;
    },
    VMRef_parse: function(json) {
      var t1;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.VMRef(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t1.name = H.stringTypeCheck(J.$index$asx(json, "name"));
      return t1;
    },
    VM_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.VM(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.architectureBits = H.intTypeCheck(t2.$index(json, "architectureBits"));
      t1.targetCPU = H.stringTypeCheck(t2.$index(json, "targetCPU"));
      t1.hostCPU = H.stringTypeCheck(t2.$index(json, "hostCPU"));
      t1.version = H.stringTypeCheck(t2.$index(json, "version"));
      t1.pid = H.intTypeCheck(t2.$index(json, "pid"));
      t1.startTime = H.intTypeCheck(t2.$index(json, "startTime"));
      t1.set$isolates(P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t2.$index(json, "isolates")), "$isIterable"), true, S.IsolateRef));
      return t1;
    },
    CpuProfile_parse: function(json) {
      var t1, t2, t3;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      t1 = new S.CpuProfile(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.sampleCount = H.intTypeCheck(t2.$index(json, "sampleCount"));
      t1.samplePeriod = H.intTypeCheck(t2.$index(json, "samplePeriod"));
      t1.stackDepth = H.intTypeCheck(t2.$index(json, "stackDepth"));
      t1.timeSpan = H.doubleTypeCheck(t2.$index(json, "timeSpan"));
      t1.timeOriginMicros = H.intTypeCheck(t2.$index(json, "timeOriginMicros"));
      t1.timeExtentMicros = H.intTypeCheck(t2.$index(json, "timeExtentMicros"));
      t1.set$codes(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t2.$index(json, "codes"), S.vm_service_lib_CodeRegion_parse$closure()), "$isIterable"), true, S.CodeRegion));
      t1.set$functions(P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t2.$index(json, "functions"), S.vm_service_lib_ProfileFunction_parse$closure()), "$isIterable"), true, S.ProfileFunction));
      t3 = P.int;
      t1.set$exclusiveCodeTrie(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "exclusiveCodeTrie"), "$isIterable"), true, t3));
      t1.set$inclusiveCodeTrie(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "inclusiveCodeTrie"), "$isIterable"), true, t3));
      t1.set$exclusiveFunctionTrie(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "exclusiveFunctionTrie"), "$isIterable"), true, t3));
      t1.set$inclusiveFunctionTrie(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "inclusiveFunctionTrie"), "$isIterable"), true, t3));
      return t1;
    },
    CodeRegion_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.CodeRegion();
        t2 = J.getInterceptor$asx(json);
        t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
        t1.inclusiveTicks = H.intTypeCheck(t2.$index(json, "inclusiveTicks"));
        t1.exclusiveTicks = H.intTypeCheck(t2.$index(json, "exclusiveTicks"));
        t1.code = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "code")), "$isCodeRef");
      }
      return t1;
    },
    ProfileFunction_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.ProfileFunction();
        t2 = J.getInterceptor$asx(json);
        t1.kind = H.stringTypeCheck(t2.$index(json, "kind"));
        t1.inclusiveTicks = H.intTypeCheck(t2.$index(json, "inclusiveTicks"));
        t1.exclusiveTicks = H.intTypeCheck(t2.$index(json, "exclusiveTicks"));
        t1.$function = H.interceptedTypeCheck(S.createServiceObject(t2.$index(json, "function")), "$isFuncRef");
        t1.set$codes(P.List_List$from(H.listSuperNativeTypeCheck(t2.$index(json, "codes"), "$isIterable"), true, P.int));
      }
      return t1;
    },
    HeapSpace_parse: function(json) {
      var t1, t2;
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      if (json == null)
        t1 = null;
      else {
        t1 = new S.HeapSpace(json);
        t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
        t2 = J.getInterceptor$asx(json);
        t1.avgCollectionPeriodMillis = H.doubleTypeCheck(t2.$index(json, "avgCollectionPeriodMillis"));
        t1.capacity = H.intTypeCheck(t2.$index(json, "capacity"));
        t1.collections = H.intTypeCheck(t2.$index(json, "collections"));
        t1.external = H.intTypeCheck(t2.$index(json, "external"));
        t1.name = H.stringTypeCheck(t2.$index(json, "name"));
        t1.time = H.doubleTypeCheck(t2.$index(json, "time"));
        t1.used = H.intTypeCheck(t2.$index(json, "used"));
      }
      return t1;
    },
    HeapSpace$_fromJson: function(json) {
      var t2,
        t1 = new S.HeapSpace(json);
      t1.type = H.stringTypeCheck(J.$index$asx(json, "type"));
      t2 = J.getInterceptor$asx(json);
      t1.avgCollectionPeriodMillis = H.doubleTypeCheck(t2.$index(json, "avgCollectionPeriodMillis"));
      t1.capacity = H.intTypeCheck(t2.$index(json, "capacity"));
      t1.collections = H.intTypeCheck(t2.$index(json, "collections"));
      t1.external = H.intTypeCheck(t2.$index(json, "external"));
      t1.name = H.stringTypeCheck(t2.$index(json, "name"));
      t1.time = H.doubleTypeCheck(t2.$index(json, "time"));
      t1.used = H.intTypeCheck(t2.$index(json, "used"));
      return t1;
    },
    createServiceObject_closure: function createServiceObject_closure() {
    },
    _createSpecificObject_closure: function _createSpecificObject_closure(t0) {
      this.creator = t0;
    },
    VmService: function VmService(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._writeMessage = _._streamSub = null;
      _._id = 0;
      _._completers = t0;
      _._methodCalls = t1;
      _._services = t2;
      _._log = null;
      _._onSend = t3;
      _._onReceive = t4;
      _._eventControllers = t5;
      _._disposeHandler = null;
    },
    VmService_dispose_closure: function VmService_dispose_closure() {
    },
    RPCError: function RPCError(t0, t1, t2, t3) {
      var _ = this;
      _.callingMethod = t0;
      _.code = t1;
      _.message = t2;
      _.data = t3;
    },
    ExtensionData: function ExtensionData(t0) {
      this.data = t0;
    },
    _NullLog: function _NullLog() {
    },
    AllocationProfile: function AllocationProfile(t0) {
      var _ = this;
      _.members = _.dateLastServiceGC = _.dateLastAccumulatorReset = _.memoryUsage = null;
      _.json = t0;
      _.type = null;
    },
    AllocationProfile_toJson_closure: function AllocationProfile_toJson_closure() {
    },
    BoundField: function BoundField() {
      this.value = this.decl = null;
    },
    BoundVariable: function BoundVariable(t0) {
      var _ = this;
      _.scopeEndTokenPos = _.scopeStartTokenPos = _.declarationTokenPos = _.value = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Breakpoint: function Breakpoint(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.location = _.isSyntheticAsyncContinuation = _.resolved = _.breakpointNumber = null;
      _.json = t0;
      _.type = null;
    },
    ClassRef: function ClassRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Class: function Class(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.subclasses = _.functions = _.fields = _.mixin = _.interfaces = _.superType = _.superClass = _.location = _.library = _.isConst = _.isAbstract = _.error = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Class_toJson_closure: function Class_toJson_closure() {
    },
    Class_toJson_closure0: function Class_toJson_closure0() {
    },
    Class_toJson_closure1: function Class_toJson_closure1() {
    },
    Class_toJson_closure2: function Class_toJson_closure2() {
    },
    ClassHeapStats: function ClassHeapStats(t0) {
      var _ = this;
      _.promotedInstances = _.promotedBytes = _.old = _.new_ = _.classRef = _.instancesCurrent = _.instancesAccumulated = _.bytesCurrent = _.accumulatedSize = null;
      _.json = t0;
      _.type = null;
    },
    ClassHeapStats_toJson_closure: function ClassHeapStats_toJson_closure() {
    },
    ClassHeapStats_toJson_closure0: function ClassHeapStats_toJson_closure0() {
    },
    ClassList: function ClassList(t0) {
      this.classes = null;
      this.json = t0;
      this.type = null;
    },
    ClassList_toJson_closure: function ClassList_toJson_closure() {
    },
    CodeRef: function CodeRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.kind = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Code: function Code(t0) {
      var _ = this;
      _.fixedId = _.id = _.kind = _.name = null;
      _.json = t0;
      _.type = null;
    },
    ContextRef: function ContextRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.length = null;
      _.json = t0;
      _.type = null;
    },
    Context: function Context(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.variables = _.parent = _.length = null;
      _.json = t0;
      _.type = null;
    },
    Context_toJson_closure: function Context_toJson_closure() {
    },
    ContextElement: function ContextElement() {
      this.value = null;
    },
    ErrorRef: function ErrorRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.message = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    Error0: function Error0(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.stacktrace = _.exception = _.message = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    Event0: function Event0(t0) {
      var _ = this;
      _.alias = _.method = _.service = _.logRecord = _.status = _.atAsyncSuspension = _.timelineEvents = _.extensionData = _.extensionKind = _.extensionRPC = _.inspectee = _.bytes = _.exception = _.topFrame = _.pauseBreakpoints = _.breakpoint = _.timestamp = _.vm = _.isolate = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    Event_toJson_closure: function Event_toJson_closure() {
    },
    Event_toJson_closure0: function Event_toJson_closure0() {
    },
    FieldRef: function FieldRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.isStatic = _.isFinal = _.isConst = _.declaredType = _.owner = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Field: function Field(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.location = _.staticValue = _.isStatic = _.isFinal = _.isConst = _.declaredType = _.owner = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Flag: function Flag() {
      var _ = this;
      _.valueAsString = _.modified = _.comment = _.name = null;
    },
    FlagList: function FlagList(t0) {
      this.flags = null;
      this.json = t0;
      this.type = null;
    },
    FlagList_toJson_closure: function FlagList_toJson_closure() {
    },
    Frame: function Frame(t0) {
      var _ = this;
      _.kind = _.vars = _.location = _.code = _.$function = _.index = null;
      _.json = t0;
      _.type = null;
    },
    Frame_toJson_closure: function Frame_toJson_closure() {
    },
    FuncRef: function FuncRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.isConst = _.isStatic = _.owner = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Func: function Func(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.code = _.location = _.owner = _.name = null;
      _.json = t0;
      _.type = null;
    },
    InstanceRef: function InstanceRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.pattern = _.parameterizedClass = _.typeClass = _.name = _.length = _.valueAsStringIsTruncated = _.valueAsString = _.classRef = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    Instance: function Instance(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.bound = _.targetType = _.parameterIndex = _.typeArguments = _.propertyValue = _.propertyKey = _.isMultiLine = _.isCaseSensitive = _.pattern = _.mirrorReferent = _.closureFunction = _.bytes = _.associations = _.elements = _.fields = _.parameterizedClass = _.typeClass = _.name = _.count = _.offset = _.length = _.valueAsStringIsTruncated = _.valueAsString = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    Instance_toJson_closure: function Instance_toJson_closure() {
    },
    Instance_toJson_closure0: function Instance_toJson_closure0() {
    },
    Instance_toJson_closure1: function Instance_toJson_closure1() {
    },
    IsolateRef: function IsolateRef(t0) {
      var _ = this;
      _.name = _.number = _.id = null;
      _.json = t0;
      _.type = null;
    },
    Isolate: function Isolate(t0) {
      var _ = this;
      _.extensionRPCs = _.exceptionPauseMode = _.error = _.breakpoints = _.libraries = _.rootLib = _.pauseEvent = _.pauseOnExit = _.livePorts = _.runnable = _.startTime = _.name = _.number = _.id = null;
      _.json = t0;
      _.type = null;
    },
    Isolate_toJson_closure: function Isolate_toJson_closure() {
    },
    Isolate_toJson_closure0: function Isolate_toJson_closure0() {
    },
    Isolate_toJson_closure1: function Isolate_toJson_closure1() {
    },
    InstanceSet: function InstanceSet(t0) {
      var _ = this;
      _.instances = _.totalCount = null;
      _.json = t0;
      _.type = null;
    },
    InstanceSet_toJson_closure: function InstanceSet_toJson_closure() {
    },
    LibraryRef: function LibraryRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.uri = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Library: function Library(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.classes = _.functions = _.variables = _.scripts = _.dependencies = _.debuggable = _.uri = _.name = null;
      _.json = t0;
      _.type = null;
    },
    Library_toJson_closure: function Library_toJson_closure() {
    },
    Library_toJson_closure0: function Library_toJson_closure0() {
    },
    Library_toJson_closure1: function Library_toJson_closure1() {
    },
    Library_toJson_closure2: function Library_toJson_closure2() {
    },
    Library_toJson_closure3: function Library_toJson_closure3() {
    },
    LibraryDependency: function LibraryDependency() {
      var _ = this;
      _.target = _.prefix = _.isDeferred = _.isImport = null;
    },
    LogRecord: function LogRecord(t0) {
      var _ = this;
      _.stackTrace = _.error = _.zone = _.loggerName = _.sequenceNumber = _.level = _.time = _.message = null;
      _.json = t0;
      _.type = null;
    },
    MapAssociation: function MapAssociation() {
      this.value = this.key = null;
    },
    MemoryUsage: function MemoryUsage(t0) {
      var _ = this;
      _.heapUsage = _.heapCapacity = _.externalUsage = null;
      _.json = t0;
      _.type = null;
    },
    Message0: function Message0(t0) {
      var _ = this;
      _.location = _.handler = _.size = _.messageObjectId = _.name = _.index = null;
      _.json = t0;
      _.type = null;
    },
    NullValRef: function NullValRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.pattern = _.parameterizedClass = _.typeClass = _.name = _.length = _.valueAsStringIsTruncated = _.valueAsString = _.classRef = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    NullVal: function NullVal(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.bound = _.targetType = _.parameterIndex = _.typeArguments = _.propertyValue = _.propertyKey = _.isMultiLine = _.isCaseSensitive = _.pattern = _.mirrorReferent = _.closureFunction = _.bytes = _.associations = _.elements = _.fields = _.parameterizedClass = _.typeClass = _.name = _.count = _.offset = _.length = _.valueAsStringIsTruncated = _.valueAsString = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    ObjRef: function ObjRef(t0) {
      var _ = this;
      _.fixedId = _.id = null;
      _.json = t0;
      _.type = null;
    },
    Obj: function Obj(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = null;
      _.json = t0;
      _.type = null;
    },
    ReloadReport: function ReloadReport(t0) {
      this.success = null;
      this.json = t0;
      this.type = null;
    },
    Response: function Response(t0) {
      this.json = t0;
      this.type = null;
    },
    Sentinel: function Sentinel(t0) {
      var _ = this;
      _.valueAsString = _.kind = null;
      _.json = t0;
      _.type = null;
    },
    ScriptRef: function ScriptRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.uri = null;
      _.json = t0;
      _.type = null;
    },
    Script: function Script(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.tokenPosTable = _.source = _.columnOffset = _.lineOffset = _.library = _.uri = null;
      _.json = t0;
      _.type = null;
    },
    Script$_fromJson_closure: function Script$_fromJson_closure() {
    },
    Script_toJson_closure: function Script_toJson_closure() {
    },
    ScriptList: function ScriptList(t0) {
      this.scripts = null;
      this.json = t0;
      this.type = null;
    },
    ScriptList_toJson_closure: function ScriptList_toJson_closure() {
    },
    SourceLocation: function SourceLocation(t0) {
      var _ = this;
      _.endTokenPos = _.tokenPos = _.script = null;
      _.json = t0;
      _.type = null;
    },
    SourceReport: function SourceReport(t0) {
      var _ = this;
      _.scripts = _.ranges = null;
      _.json = t0;
      _.type = null;
    },
    SourceReport_toJson_closure: function SourceReport_toJson_closure() {
    },
    SourceReport_toJson_closure0: function SourceReport_toJson_closure0() {
    },
    SourceReportCoverage: function SourceReportCoverage() {
      this.misses = this.hits = null;
    },
    SourceReportCoverage_toJson_closure: function SourceReportCoverage_toJson_closure() {
    },
    SourceReportCoverage_toJson_closure0: function SourceReportCoverage_toJson_closure0() {
    },
    SourceReportRange: function SourceReportRange() {
      var _ = this;
      _.possibleBreakpoints = _.coverage = _.error = _.compiled = _.endPos = _.startPos = _.scriptIndex = null;
    },
    SourceReportRange_toJson_closure: function SourceReportRange_toJson_closure() {
    },
    Stack: function Stack(t0) {
      var _ = this;
      _.messages = _.awaiterFrames = _.asyncCausalFrames = _.frames = null;
      _.json = t0;
      _.type = null;
    },
    Stack_toJson_closure: function Stack_toJson_closure() {
    },
    Stack_toJson_closure0: function Stack_toJson_closure0() {
    },
    Stack_toJson_closure1: function Stack_toJson_closure1() {
    },
    Stack_toJson_closure2: function Stack_toJson_closure2() {
    },
    Success: function Success(t0) {
      this.json = t0;
      this.type = null;
    },
    Timeline: function Timeline(t0) {
      var _ = this;
      _.timeExtentMicros = _.timeOriginMicros = _.traceEvents = null;
      _.json = t0;
      _.type = null;
    },
    Timeline_toJson_closure: function Timeline_toJson_closure() {
    },
    TimelineEvent: function TimelineEvent() {
    },
    TimelineFlags: function TimelineFlags(t0) {
      var _ = this;
      _.recordedStreams = _.availableStreams = _.recorderName = null;
      _.json = t0;
      _.type = null;
    },
    TimelineFlags_toJson_closure: function TimelineFlags_toJson_closure() {
    },
    TimelineFlags_toJson_closure0: function TimelineFlags_toJson_closure0() {
    },
    Timestamp: function Timestamp(t0) {
      this.timestamp = null;
      this.json = t0;
      this.type = null;
    },
    TypeArgumentsRef: function TypeArgumentsRef(t0) {
      var _ = this;
      _.fixedId = _.id = _.name = null;
      _.json = t0;
      _.type = null;
    },
    TypeArguments: function TypeArguments(t0) {
      var _ = this;
      _.size = _.classRef = _.fixedId = _.id = _.types = _.name = null;
      _.json = t0;
      _.type = null;
    },
    TypeArguments_toJson_closure: function TypeArguments_toJson_closure() {
    },
    UnresolvedSourceLocation: function UnresolvedSourceLocation(t0) {
      var _ = this;
      _.column = _.line = _.tokenPos = _.scriptUri = _.script = null;
      _.json = t0;
      _.type = null;
    },
    Version: function Version(t0) {
      var _ = this;
      _.minor = _.major = null;
      _.json = t0;
      _.type = null;
    },
    VMRef: function VMRef(t0) {
      this.name = null;
      this.json = t0;
      this.type = null;
    },
    VM: function VM(t0) {
      var _ = this;
      _.isolates = _.startTime = _.pid = _.version = _.hostCPU = _.targetCPU = _.architectureBits = _.name = null;
      _.json = t0;
      _.type = null;
    },
    VM_toJson_closure: function VM_toJson_closure() {
    },
    CpuProfile: function CpuProfile(t0) {
      var _ = this;
      _.inclusiveFunctionTrie = _.exclusiveFunctionTrie = _.inclusiveCodeTrie = _.exclusiveCodeTrie = _.functions = _.codes = _.timeExtentMicros = _.timeOriginMicros = _.timeSpan = _.stackDepth = _.samplePeriod = _.sampleCount = null;
      _.json = t0;
      _.type = null;
    },
    CpuProfile_toJson_closure: function CpuProfile_toJson_closure() {
    },
    CpuProfile_toJson_closure0: function CpuProfile_toJson_closure0() {
    },
    CpuProfile_toJson_closure1: function CpuProfile_toJson_closure1() {
    },
    CpuProfile_toJson_closure2: function CpuProfile_toJson_closure2() {
    },
    CpuProfile_toJson_closure3: function CpuProfile_toJson_closure3() {
    },
    CpuProfile_toJson_closure4: function CpuProfile_toJson_closure4() {
    },
    CodeRegion: function CodeRegion() {
      var _ = this;
      _.code = _.exclusiveTicks = _.inclusiveTicks = _.kind = null;
    },
    ProfileFunction: function ProfileFunction() {
      var _ = this;
      _.codes = _.$function = _.exclusiveTicks = _.inclusiveTicks = _.kind = null;
    },
    ProfileFunction_toJson_closure: function ProfileFunction_toJson_closure() {
    },
    HeapSpace: function HeapSpace(t0) {
      var _ = this;
      _.used = _.time = _.name = _.external = _.collections = _.capacity = _.avgCollectionPeriodMillis = null;
      _.json = t0;
      _.type = null;
    }
  },
  V = {
    VariablesView$: function(debuggerState, variableDescriber) {
      var t1 = new V.VariablesView();
      t1.VariablesView$2(debuggerState, variableDescriber);
      return t1;
    },
    VariablesView: function VariablesView() {
      this._items = null;
    },
    VariablesView_closure: function VariablesView_closure(t0) {
      this.variableDescriber = t0;
    },
    VariablesView__closure: function VariablesView__closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.variableDescriber = t1;
      _.variable = t2;
      _.element = t3;
    },
    VariablesView___closure: function VariablesView___closure(t0) {
      this.element = t0;
    },
    VariablesChildProvider: function VariablesChildProvider(t0) {
      this.debuggerState = t0;
    },
    VariablesChildProvider_getChildren_closure: function VariablesChildProvider_getChildren_closure() {
    },
    VariablesChildProvider_getChildren_closure0: function VariablesChildProvider_getChildren_closure0() {
    },
    MemoryScreen: function MemoryScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13) {
      var _ = this;
      _.memoryController = t0;
      _.heapAutoCompletePopup = _.heapPopupList = _.vmSearchField = _.resumeButton = _.pauseButton = _.objectCountStatus = _.classCountStatus = null;
      _.hoverPopup = t1;
      _.gcNowButton = _.filterLibrariesButton = _.resetAccumulatorsButton = _.vmMemorySnapshotButton = _.vmMemorySearchButton = null;
      _.tableStack = t2;
      _.history = _.tableContainer = _.memoryChart = null;
      _.memoryPath = t3;
      _.fromMemoryHover = false;
      _.memoryDataView = null;
      _._knownSnapshotClasses = t4;
      _._currentHoverSummary = _._tdCellHover = null;
      _.name = t5;
      _.id = t6;
      _.iconClass = t7;
      _.helpStatus = t8;
      _.disabledTooltip = t9;
      _.disabled = t10;
      _.shortcutCallback = t11;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t12;
      _.statusItems = t13;
    },
    MemoryScreen_createContent_closure: function MemoryScreen_createContent_closure(t0) {
      this.$this = t0;
    },
    MemoryScreen_createContent_closure0: function MemoryScreen_createContent_closure0(t0) {
      this.$this = t0;
    },
    MemoryScreen_createContent_closure1: function MemoryScreen_createContent_closure1(t0) {
      this.$this = t0;
    },
    MemoryScreen_createContent_closure2: function MemoryScreen_createContent_closure2(t0) {
      this.$this = t0;
    },
    MemoryScreen_createContent_closure3: function MemoryScreen_createContent_closure3(t0) {
      this.$this = t0;
    },
    MemoryScreen_selectClassInstance_closure: function MemoryScreen_selectClassInstance_closure(t0) {
      this.$this = t0;
    },
    MemoryScreen_selectClassInstance_closure0: function MemoryScreen_selectClassInstance_closure0(t0, t1) {
      this.$this = t0;
      this.instanceHashCode = t1;
    },
    MemoryScreen_selectClassAndInstanceInField_closure: function MemoryScreen_selectClassAndInstanceInField_closure(t0) {
      this.$this = t0;
    },
    MemoryScreen_selectClassAndInstanceInField_closure0: function MemoryScreen_selectClassAndInstanceInField_closure0(t0, t1, t2) {
      this.$this = t0;
      this.field = t1;
      this.instanceHashCode = t2;
    },
    MemoryScreen_selectClassAndInstanceInField__closure: function MemoryScreen_selectClassAndInstanceInField__closure(t0) {
      this.$this = t0;
    },
    MemoryScreen__createHeapStatsTableView_closure: function MemoryScreen__createHeapStatsTableView_closure(t0, t1) {
      this.$this = t0;
      this.table = t1;
    },
    MemoryScreen__createInstanceListTableView_closure: function MemoryScreen__createInstanceListTableView_closure() {
    },
    MemoryScreen__createInstanceListTableView_closure0: function MemoryScreen__createInstanceListTableView_closure0() {
    },
    MemoryScreen__handleHistoryClicks_closure: function MemoryScreen__handleHistoryClicks_closure(t0) {
      this.$this = t0;
    },
    MemoryScreen__maybeCloseHover_closure: function MemoryScreen__maybeCloseHover_closure(t0, t1) {
      this.$this = t0;
      this.hoverToClose = t1;
    },
    MemoryScreen_hoverInstanceAllocations_closure: function MemoryScreen_hoverInstanceAllocations_closure(t0, t1, t2) {
      this.$this = t0;
      this.hover = t1;
      this.ulElem = t2;
    },
    MemoryScreen_hoverInstanceAllocations__closure: function MemoryScreen_hoverInstanceAllocations__closure(t0) {
      this.$this = t0;
    },
    MemoryScreen__createInstanceView_closure: function MemoryScreen__createInstanceView_closure(t0) {
      this.objectRef = t0;
    },
    NavigationState: function NavigationState(t0, t1) {
      this.field = "";
      this._className = t0;
      this._memory$_hashCode = t1;
    },
    NavigationPath: function NavigationPath(t0) {
      this._path = t0;
      this._inboundFieldName = "";
    },
    NavigationPath_displayPathsAsLinks_closure: function NavigationPath_displayPathsAsLinks_closure(t0, t1) {
      this.link = t0;
      this.clickHandler = t1;
    },
    _MemoryScreen_Screen_SetStateMixin: function _MemoryScreen_Screen_SetStateMixin() {
    },
    PerformanceScreen: function PerformanceScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.cpuChart = _.perfTable = _.progressElement = _.resetButton = _.loadSnapshotButton = _.sampleFreqStatus = _.sampleCountStatus = null;
      _.cpuChartStateMixin = t0;
      _.cpuTracker = null;
      _.name = t1;
      _.id = t2;
      _.iconClass = t3;
      _.helpStatus = t4;
      _.disabledTooltip = t5;
      _.disabled = t6;
      _.shortcutCallback = t7;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t8;
      _.statusItems = t9;
    },
    PerformanceScreen_createContent_closure: function PerformanceScreen_createContent_closure(t0) {
      this.$this = t0;
    },
    PerformanceScreen__loadSnapshot_closure: function PerformanceScreen__loadSnapshot_closure(t0) {
      this.$this = t0;
    },
    PerformanceScreen__loadSnapshot_closure0: function PerformanceScreen__loadSnapshot_closure0(t0) {
      this.$this = t0;
    },
    PerformanceScreen__loadSnapshot_closure1: function PerformanceScreen__loadSnapshot_closure1(t0) {
      this.$this = t0;
    },
    PerformanceScreen__reset_closure: function PerformanceScreen__reset_closure(t0) {
      this.$this = t0;
    },
    PerformanceScreen__reset_closure0: function PerformanceScreen__reset_closure0(t0) {
      this.$this = t0;
    },
    PerformanceScreen__reset_closure1: function PerformanceScreen__reset_closure1(t0) {
      this.$this = t0;
    },
    PerformanceScreen__createTableView_closure: function PerformanceScreen__createTableView_closure() {
    },
    PerformanceScreen__process_closure: function PerformanceScreen__process_closure() {
    },
    PerformanceScreen__process_closure0: function PerformanceScreen__process_closure0(t0) {
      this.profile = t0;
    },
    PerformanceScreen__handleConnectionStart_closure: function PerformanceScreen__handleConnectionStart_closure(t0) {
      this.$this = t0;
    },
    PerformanceScreen__handleConnectionStart__closure: function PerformanceScreen__handleConnectionStart__closure(t0) {
      this.$this = t0;
    },
    CpuChart: function CpuChart(t0, t1) {
      var _ = this;
      _.usageLabel = null;
      _.parent = t0;
      _.dim = _.chartElement = null;
      _._charts$_state = t1;
      _.data = null;
    },
    CpuTracker: function CpuTracker(t0, t1, t2) {
      var _ = this;
      _.service = t0;
      _._pollingTimer = null;
      _._performance$_changeController = t1;
      _.samples = t2;
    },
    PerfData: function PerfData(t0, t1, t2, t3) {
      var _ = this;
      _.kind = t0;
      _.name = t1;
      _.self = t2;
      _.inclusive = t3;
    },
    PerfColumnInclusive: function PerfColumnInclusive(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    PerfColumnSelf: function PerfColumnSelf(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    PerfColumnMethodName: function PerfColumnMethodName(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    _CalcProfile: function _CalcProfile() {
    },
    SourceLocation$: function(offset, column, line, sourceUrl) {
      var t1 = line == null,
        t2 = t1 ? 0 : line;
      if (offset < 0)
        H.throwExpression(P.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (!t1 && line < 0)
        H.throwExpression(P.RangeError$("Line may not be negative, was " + H.S(line) + "."));
      else if (column < 0)
        H.throwExpression(P.RangeError$("Column may not be negative, was " + column + "."));
      return new V.SourceLocation0(sourceUrl, offset, t2, column);
    },
    SourceLocation0: function SourceLocation0(t0, t1, t2, t3) {
      var _ = this;
      _.sourceUrl = t0;
      _.offset = t1;
      _.line = t2;
      _.column = t3;
    },
    SourceSpan: function SourceSpan() {
    },
    SourceSpanBase: function SourceSpanBase() {
    }
  },
  N = {
    ConnectDialog$: function(framework) {
      var t1 = new N.ConnectDialog(framework);
      t1.ConnectDialog$1(framework);
      return t1;
    },
    AnalyticsOptInDialog$: function(framework) {
      var t1 = new N.AnalyticsOptInDialog();
      t1.AnalyticsOptInDialog$1(framework);
      return t1;
    },
    Framework: function Framework() {
    },
    Framework__initDragDrop_closure: function Framework__initDragDrop_closure(t0) {
      this.$this = t0;
    },
    Framework__initDragDrop_closure0: function Framework__initDragDrop_closure0(t0) {
      this.$this = t0;
    },
    Framework__onDrop_closure: function Framework__onDrop_closure(t0, t1) {
      this.$this = t0;
      this.reader = t1;
    },
    Framework__importTimeline_closure: function Framework__importTimeline_closure() {
    },
    Framework__importTimeline_closure0: function Framework__importTimeline_closure0() {
    },
    Framework_exitOfflineMode_closure: function Framework_exitOfflineMode_closure() {
    },
    Framework__hookupShortcuts_closure: function Framework__hookupShortcuts_closure(t0) {
      this.$this = t0;
    },
    Framework_loadScreenFromLocation_closure: function Framework_loadScreenFromLocation_closure(t0) {
      this.$this = t0;
    },
    Framework_loadScreenFromLocation__closure: function Framework_loadScreenFromLocation__closure() {
    },
    Framework_loadScreenFromLocation__closure0: function Framework_loadScreenFromLocation__closure0(t0) {
      this.$this = t0;
    },
    Framework_getScreen_closure: function Framework_getScreen_closure(t0, t1) {
      this.id = t0;
      this.onlyEnabled = t1;
    },
    Framework_getScreen_closure0: function Framework_getScreen_closure0() {
    },
    Framework_load_closure: function Framework_load_closure(t0) {
      this.$this = t0;
    },
    Framework_load__closure: function Framework_load__closure(t0) {
      this.$this = t0;
    },
    StatusLine: function StatusLine(t0, t1, t2) {
      this.element = t0;
      this._framework$_items = t1;
      this._defaultStatusItems = t2;
    },
    ActionsContainer: function ActionsContainer(t0, t1) {
      this.element = t0;
      this._actions = t1;
    },
    ActionsContainer_removeAction_closure: function ActionsContainer_removeAction_closure(t0) {
      this.id = t0;
    },
    Screen: function Screen() {
    },
    SetStateMixin: function SetStateMixin() {
    },
    SetStateMixin_setState_closure: function SetStateMixin_setState_closure(t0) {
      this.rebuild = t0;
    },
    StatusItem: function StatusItem(t0) {
      this.element = t0;
    },
    Toast: function Toast(t0, t1, t2) {
      this.title = t0;
      this.message = t1;
      this.element = t2;
    },
    Toast_show_closure: function Toast_show_closure(t0, t1) {
      this.$this = t0;
      this.hideDelay = t1;
    },
    ConnectDialog: function ConnectDialog(t0) {
      var _ = this;
      _.framework = t0;
      _.connectButton = _.textfield = _.parent = null;
    },
    ConnectDialog_closure: function ConnectDialog_closure(t0) {
      this.$this = t0;
    },
    ConnectDialog_closure0: function ConnectDialog_closure0(t0) {
      this.$this = t0;
    },
    ConnectDialog__tryConnect_handleConnectError: function ConnectDialog__tryConnect_handleConnectError(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    ConnectDialog__tryConnect_closure: function ConnectDialog__tryConnect_closure(t0) {
      this.handleConnectError = t0;
    },
    ConnectDialog__tryConnect_closure0: function ConnectDialog__tryConnect_closure0(t0) {
      this.handleConnectError = t0;
    },
    ConnectDialog__connect_closure: function ConnectDialog__connect_closure() {
    },
    SnapshotMessage: function SnapshotMessage() {
      this.parent = null;
    },
    AnalyticsOptInDialog: function AnalyticsOptInDialog() {
      this.dontAcceptButton = this.acceptButton = this.parent = null;
    },
    AnalyticsOptInDialog_closure: function AnalyticsOptInDialog_closure(t0) {
      this.$this = t0;
    },
    AnalyticsOptInDialog_closure0: function AnalyticsOptInDialog_closure0(t0) {
      this.$this = t0;
    },
    CpuProfileProtocol: function CpuProfileProtocol() {
    },
    CpuProfileProtocol_processData_closure: function CpuProfileProtocol_processData_closure(t0, t1) {
      this.$this = t0;
      this.cpuProfileData = t1;
    },
    BottomUpProfileProcessor: function BottomUpProfileProcessor() {
    },
    BottomUpProfileProcessor_mergeRoots_closure: function BottomUpProfileProcessor_mergeRoots_closure(t0) {
      this.root = t0;
    },
    TimelineService: function TimelineService(t0) {
      this.timelineController = t0;
    },
    TimelineService__handleConnectionStart_closure: function TimelineService__handleConnectionStart_closure(t0) {
      this.$this = t0;
    },
    TimelineService_startTimeline_closure: function TimelineService_startTimeline_closure() {
    },
    TimelineService_startTimeline_closure0: function TimelineService_startTimeline_closure0() {
    },
    Spinner$_: function(classes) {
      var _null = null,
        t1 = new N.Spinner(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.clazz$1("spinner");
      C.JSArray_methods.forEach$1(classes, t1.get$clazz());
      return t1;
    },
    SelectableTree$: function($T) {
      var _null = null,
        t1 = H.setRuntimeTypeInfo([], [$T]),
        t2 = H.setRuntimeTypeInfo([], [[X.TreeNode, [N.SelectableTreeNodeItem, $T]]]),
        t3 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("ul", _null), "$isElement");
      t2 = new N.SelectableTree(t1, t2, new P._AsyncBroadcastStreamController(_null, _null, [$T]), t3, [$T]);
      t2.CoreElement$5$attributes$classes$html$text("ul", _null, _null, _null, _null);
      t3.tabIndex = 0;
      t3 = J.get$onKeyDown$x(t3);
      t1 = H.getTypeArgumentByIndex(t3, 0);
      W._EventStreamSubscription$(t3._html$_target, t3._eventType, H.functionTypeCheck(t2.get$handleKeyPress(), {func: 1, ret: -1, args: [t1]}), false, t1);
      return t2;
    },
    TreeToggle$: function(empty, forceOpen) {
      var _null = null,
        t1 = new N.TreeToggle(new P._AsyncBroadcastStreamController(_null, _null, [P.bool]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "tree-toggle octicon", _null, _null);
      if (!empty) {
        t1.click$1(0, t1.get$toggle(t1));
        if (H.boolConversionCheck(forceOpen)) {
          t1._isOpen = true;
          t1.clazz$1("octicon-triangle-down");
        } else
          t1.clazz$1("octicon-triangle-right");
      }
      return t1;
    },
    _defaultRenderer: function(item, $T) {
      return A.CoreElement$("li", null, "list-item", null, J.toString$0$(H.assertSubtypeOfRuntimeType(item, $T)));
    },
    ActionButton$: function(id, icon, tooltip) {
      var t1 = new N.ActionButton(id, icon, tooltip),
        t2 = A.CoreElement$("div", null, "masthead-item action-button", null, null);
      t2.element.title = tooltip;
      t2.add$1(0, new A.CoreElement(Y.getIconRenderer(icon).createElement$0(0)));
      t1._custom$_element = t2;
      return t1;
    },
    ProgressElement: function ProgressElement(t0) {
      this.element = t0;
    },
    Spinner: function Spinner(t0) {
      this.element = t0;
    },
    SelectableList: function SelectableList(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.items = t0;
      _._selectedElement = _.renderer = null;
      _._hadClicked = false;
      _._selectionController = t1;
      _._doubleClickController = t2;
      _._itemsChangedController = t3;
      _.element = t4;
      _.$ti = t5;
    },
    SelectableList_setItems_closure: function SelectableList_setItems_closure(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.renderer = t1;
      _.selection = t2;
      _.scrollSelectionIntoView = t3;
    },
    SelectableList__hookup_closure: function SelectableList__hookup_closure(t0, t1, t2) {
      this.$this = t0;
      this.element = t1;
      this.item = t2;
    },
    SelectableList__hookup_closure0: function SelectableList__hookup_closure0(t0, t1) {
      this.$this = t0;
      this.item = t1;
    },
    ChildProvider: function ChildProvider() {
    },
    SelectableTreeNodeItem: function SelectableTreeNodeItem(t0, t1, t2) {
      this.element = t0;
      this.item = t1;
      this.$ti = t2;
    },
    SelectableTree: function SelectableTree(t0, t1, t2, t3, t4) {
      var _ = this;
      _.items = t0;
      _.treeNodes = t1;
      _._selectedItem = _.childProvider = _.renderer = null;
      _._selectionController = t2;
      _.element = t3;
      _.$ti = t4;
    },
    SelectableTree__addItemToTree_closure: function SelectableTree__addItemToTree_closure(t0, t1) {
      this.$this = t0;
      this.obj = t1;
    },
    SelectableTree__addItemToTree_closure0: function SelectableTree__addItemToTree_closure0(t0) {
      this.toggle = t0;
    },
    SelectableTree__addItemToTree_closure1: function SelectableTree__addItemToTree_closure1(t0) {
      this.toggle = t0;
    },
    SelectableTree__addItemToTree_closure2: function SelectableTree__addItemToTree_closure2(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.obj = t2;
      _.childContainer = t3;
      _.item = t4;
    },
    SelectableTree__addItemToTree__closure: function SelectableTree__addItemToTree__closure(t0, t1, t2) {
      this.$this = t0;
      this.childContainer = t1;
      this.obj = t2;
    },
    SelectableTree__addItemToTree__closure0: function SelectableTree__addItemToTree__closure0() {
    },
    SelectableTree__buildTree_closure: function SelectableTree__buildTree_closure(t0, t1) {
      this.$this = t0;
      this.container = t1;
    },
    SelectableTree__buildTree_closure0: function SelectableTree__buildTree_closure0(t0) {
      this.$this = t0;
    },
    TreeToggle: function TreeToggle(t0, t1) {
      this._isOpen = false;
      this._openController = t0;
      this.element = t1;
    },
    ActionButton: function ActionButton(t0, t1, t2) {
      var _ = this;
      _.id = t0;
      _.icon = t1;
      _.tooltip = t2;
      _._custom$_element = null;
    },
    _SelectableTree_CoreElement_Tree: function _SelectableTree_CoreElement_Tree() {
    },
    _SelectableTree_CoreElement_Tree_TreeNavigator: function _SelectableTree_CoreElement_Tree_TreeNavigator() {
    },
    _SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator: function _SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator() {
    },
    PButton$octicon: function(text, icon) {
      var _null = null,
        t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("button", _null), "$isElement"),
        t2 = new N.PButton(t1);
      t2.CoreElement$5$attributes$classes$html$text("button", _null, "btn optional-text", _null, _null);
      t1.title = text;
      t2.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", _null, "octicon octicon-" + icon, _null, _null), A.CoreElement$("span", _null, "optional-text", _null, text)], [A.CoreElement]));
      t2.clazz$1("btn-sm");
      return t2;
    },
    PButton$icon: function(text, icon, title) {
      var _null = null, _s6_ = "button",
        t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_, _null), "$isElement"),
        t2 = new N.PButton(t1);
      t2.CoreElement$5$attributes$classes$html$text(_s6_, _null, "btn optional-text", _null, _null);
      t1.setAttribute("type", _s6_);
      t1.setAttribute("title", title == null ? text : title);
      t2.add$1(0, new A.CoreElement(Y.getIconRenderer(icon).createElement$0(0)));
      t2.add$1(0, A.CoreElement$("span", _null, _null, _null, text));
      return t2;
    },
    PTabNav$: function(tabs) {
      var _null = null,
        t1 = new N.PTabNav(new P._AsyncBroadcastStreamController(_null, _null, [N.PTabNavTab]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("div", _null, "tabnav", _null, _null);
      t1.PTabNav$1(tabs);
      return t1;
    },
    PNavMenu$: function(items, supportsSelection) {
      var _null = null,
        t1 = new N.PNavMenu(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("nav", _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text("nav", _null, "menu", _null, _null);
      t1.PNavMenu$2$supportsSelection(items, false);
      return t1;
    },
    PSelect: function PSelect(t0) {
      this.element = t0;
    },
    PSelect_onChange_closure: function PSelect_onChange_closure(t0) {
      this.$this = t0;
    },
    PSelect_change_closure: function PSelect_change_closure(t0) {
      this.handle = t0;
    },
    PButton: function PButton(t0) {
      this.element = t0;
    },
    PFlash: function PFlash(t0) {
      this.element = t0;
    },
    PTabNav: function PTabNav(t0, t1) {
      this._selectedTabController = t0;
      this.selectedTab = null;
      this.element = t1;
    },
    PTabNav_closure: function PTabNav_closure(t0, t1) {
      this.$this = t0;
      this.tab = t1;
    },
    PTabNavTab: function PTabNavTab() {
    },
    PNavMenu: function PNavMenu(t0) {
      this.selectedItem = null;
      this.element = t0;
    },
    PNavMenuItem: function PNavMenuItem(t0) {
      this.element = t0;
    },
    expectQuotedString: function(scanner) {
      var string;
      scanner.expect$2$name($.$get$_quotedString(), "quoted string");
      string = scanner.get$lastMatch().$index(0, 0);
      return C.JSString_methods.splitMapJoin$2$onMatch(J.substring$2$s(string, 1, string.length - 1), $.$get$_quotedPair(), H.functionTypeCheck(new N.expectQuotedString_closure(), {func: 1, ret: P.String, args: [P.Match]}));
    },
    expectQuotedString_closure: function expectQuotedString_closure() {
    }
  },
  D = {InspectorScreen: function InspectorScreen(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.refreshTreeButton = null;
      _.inspectorStateMixin = t0;
      _.splitterSubscription = _.inspectorContainer = _.inspectorController = _.inspectorService = null;
      _.displayedWidgetTrackingNotice = false;
      _.name = t1;
      _.id = t2;
      _.iconClass = t3;
      _.helpStatus = t4;
      _.disabledTooltip = t5;
      _.disabled = t6;
      _.shortcutCallback = t7;
      _.needsResizing = false;
      _.framework = null;
      _._visible = t8;
      _.statusItems = t9;
    }, InspectorScreen__handleConnectionStart_closure: function InspectorScreen__handleConnectionStart_closure() {
    }, InspectorScreen__handleConnectionStart_closure0: function InspectorScreen__handleConnectionStart_closure0() {
    }, InspectorScreen__handleConnectionStart_closure1: function InspectorScreen__handleConnectionStart_closure1(t0) {
      this.$this = t0;
    }, DeferStream: function DeferStream(t0, t1, t2) {
      var _ = this;
      _._streamFactory = t0;
      _._isReusable = t1;
      _._defer$_isUsed = false;
      _.$ti = t2;
    }, SourceLocationMixin: function SourceLocationMixin() {
    },
    current: function() {
      var path, lastIndex,
        uri = P.Uri_base();
      if (J.$eq$(uri, $._currentUriBase))
        return $._current;
      $._currentUriBase = uri;
      if ($.$get$Style_platform() == $.$get$Style_url())
        return $._current = uri.resolve$1(".").toString$0(0);
      else {
        path = uri.toFilePath$0();
        lastIndex = path.length - 1;
        return $._current = lastIndex === 0 ? path : C.JSString_methods.substring$2(path, 0, lastIndex);
      }
    }
  },
  Z = {
    textStyleForLevel: function(level) {
      switch (level) {
        case C.DiagnosticLevel_0:
          return $.$get$unimportant();
        case C.DiagnosticLevel_4:
          return $.$get$warning();
        case C.DiagnosticLevel_9:
          return $.$get$error();
        case C.DiagnosticLevel_2:
        case C.DiagnosticLevel_3:
        case C.DiagnosticLevel_1:
        default:
          return C.TextStyle_Ure;
      }
    },
    InspectorController$: function(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType) {
      var t1 = new Z.InspectorController(isSummaryTree, $parent, treeType, inspectorService, new E.InspectorObjectGroupManager(inspectorService, "tree"), new E.InspectorObjectGroupManager(inspectorService, "selection"), P.LinkedHashMap_LinkedHashMap$_empty(E.InspectorInstanceRef, K.InspectorTreeNode));
      t1.InspectorController$5$inspectorService$inspectorTreeFactory$isSummaryTree$parent$treeType(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType);
      return t1;
    },
    InspectorController: function InspectorController(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.isSummaryTree = t0;
      _.parent = t1;
      _.inspectorTree = _.details = null;
      _.treeType = t2;
      _.inspectorService = t3;
      _.flutterIsolateSubscription = null;
      _._disposed = false;
      _._refreshRateLimiter = null;
      _._treeGroups = t4;
      _._selectionGroups = t5;
      _.treeLoadStarted = _.flutterAppFrameReady = false;
      _.subtreeRoot = null;
      _.programaticSelectionChangeInProgress = false;
      _.selectedNode = null;
      _.isActive = false;
      _.valueToInspectorTreeNode = t6;
      _.visibleToUser = false;
    },
    InspectorController_closure: function InspectorController_closure(t0) {
      this.$this = t0;
    },
    MemoryColumnSimple$: function($name, getter, cssClass, hover, usesHtml, $T) {
      var _null = null,
        t1 = new Z.MemoryColumnSimple(getter, $name, _null, _null, C.ColumnAlignment_0, usesHtml, cssClass, hover, [$T]);
      t1.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml($name, C.ColumnAlignment_0, cssClass, _null, hover, _null, usesHtml, $T);
      return t1;
    },
    MemoryColumnClassName: function MemoryColumnClassName(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    MemoryColumnSize: function MemoryColumnSize(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    MemoryColumnInstanceCount: function MemoryColumnInstanceCount(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    MemoryColumnInstanceAccumulatedCount: function MemoryColumnInstanceAccumulatedCount(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.title = t0;
      _.fixedWidthPx = t1;
      _.percentWidth = t2;
      _._alignment = t3;
      _.usesHtml = t4;
      _.cssClass = t5;
      _.hover = t6;
    },
    MemoryColumnSimple: function MemoryColumnSimple(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.getter = t0;
      _.title = t1;
      _.fixedWidthPx = t2;
      _.percentWidth = t3;
      _._alignment = t4;
      _.usesHtml = t5;
      _.cssClass = t6;
      _.hover = t7;
      _.$ti = t8;
    },
    CpuProfilerView: function CpuProfilerView() {
    },
    CpuProfilerViewType: function CpuProfilerViewType(t0) {
      this._cpu_profiler_view$_name = t0;
    },
    ByteStream: function ByteStream(t0) {
      this._stream = t0;
    },
    ByteStream_toBytes_closure: function ByteStream_toBytes_closure(t0) {
      this.completer = t0;
    },
    CaseInsensitiveMap$from: function(other, $V) {
      var t1 = P.String;
      t1 = new Z.CaseInsensitiveMap(new Z.CaseInsensitiveMap$from_closure(), new Z.CaseInsensitiveMap$from_closure0(), new H.JsLinkedHashMap([t1, [B.Pair, t1, $V]]), [$V]);
      t1.addAll$1(0, other);
      return t1;
    },
    CaseInsensitiveMap: function CaseInsensitiveMap(t0, t1, t2, t3) {
      var _ = this;
      _._canonicalize = t0;
      _._isValidKeyFn = t1;
      _._base = t2;
      _.$ti = t3;
    },
    CaseInsensitiveMap$from_closure: function CaseInsensitiveMap$from_closure() {
    },
    CaseInsensitiveMap$from_closure0: function CaseInsensitiveMap$from_closure0() {
    }
  },
  E = {
    ensureInspectorServiceDependencies: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, t1;
      var $async$ensureInspectorServiceDependencies = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($._inspectorDependenciesLoaded) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $.Catalog__cachedCatalog;
              $async$goto = 3;
              return P._asyncAwait(t1 == null ? $.Catalog__cachedCatalog = S.Catalog__loadHelper() : t1, $async$ensureInspectorServiceDependencies);
            case 3:
              // returning from await.
              $._inspectorDependenciesLoaded = true;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$ensureInspectorServiceDependencies, $async$completer);
    },
    InspectorService_createGroup: function(vmService, groupName) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E.ObjectGroup),
        $async$returnValue, t2, t1;
      var $async$InspectorService_createGroup = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(E.InspectorService_create(vmService), $async$InspectorService_createGroup);
            case 3:
              // returning from await.
              t1 = $async$result;
              t1.toString;
              t2 = groupName + "_" + $.InspectorService_nextGroupId;
              $.InspectorService_nextGroupId = $.InspectorService_nextGroupId + 1;
              $async$returnValue = new E.ObjectGroup(t2, t1);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$InspectorService_createGroup, $async$completer);
    },
    InspectorService_create: function(vmService) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E.InspectorService),
        $async$returnValue, inspectorLibrary, t1, $async$temp1, $async$temp2;
      var $async$InspectorService_create = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.interceptedTypeCheck(vmService, "$isVmServiceWrapper");
              inspectorLibrary = B.EvalOnDartLibrary$(C.List_BmV, vmService);
              $async$temp1 = E;
              $async$temp2 = inspectorLibrary;
              $async$goto = 5;
              return P._asyncAwait(inspectorLibrary._libraryRef.future.catchError$2$test(new E.InspectorService_create_closure(), new E.InspectorService_create_closure0()), $async$InspectorService_create);
            case 5:
              // returning from await.
              $async$goto = 4;
              return P._asyncAwait($async$temp2.getObjHelper$1$2($async$result, null, S.Library), $async$InspectorService_create);
            case 4:
              // returning from await.
              $async$goto = 3;
              return P._asyncAwait(new $async$temp1.InspectorService_create_lookupFunctionNames($async$result, inspectorLibrary).call$0(), $async$InspectorService_create);
            case 3:
              // returning from await.
              if ($async$result == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = new E.InspectorService(vmService, P.LinkedHashSet_LinkedHashSet(E.InspectorServiceClient), inspectorLibrary);
              vmService.get$onExtensionEvent().listen$1(t1.get$onExtensionVmServiceRecieved());
              vmService.get$onDebugEvent().listen$1(t1.get$onDebugVmServiceReceived());
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$InspectorService_create, $async$completer);
    },
    InspectorService: function InspectorService(t0, t1, t2) {
      this.vmService = t0;
      this.clients = t1;
      this.inspectorLibrary = t2;
    },
    InspectorService_create_closure: function InspectorService_create_closure() {
    },
    InspectorService_create_closure0: function InspectorService_create_closure0() {
    },
    InspectorService_create_lookupFunctionNames: function InspectorService_create_lookupFunctionNames(t0, t1) {
      this.library = t0;
      this.inspectorLibrary = t1;
    },
    ObjectGroup: function ObjectGroup(t0, t1) {
      this.groupName = t0;
      this.inspectorService = t1;
      this.disposed = false;
    },
    ObjectGroup__callServiceExtension_closure: function ObjectGroup__callServiceExtension_closure(t0, t1, t2) {
      this.$this = t0;
      this.extension = t1;
      this.args = t2;
    },
    ObjectGroup_getDartObjectProperties_closure: function ObjectGroup_getDartObjectProperties_closure(t0) {
      this.objectName = t0;
    },
    FlutterTreeType: function FlutterTreeType(t0) {
      this._inspector_service$_name = t0;
    },
    InspectorServiceClient: function InspectorServiceClient() {
    },
    InspectorInstanceRef: function InspectorInstanceRef(t0) {
      this.id = t0;
    },
    InspectorObjectGroupManager: function InspectorObjectGroupManager(t0, t1) {
      var _ = this;
      _.inspectorService = t0;
      _.debugName = t1;
      _._pendingNext = _._inspector_service$_next = _._inspector_service$_current = null;
    },
    FlutterInspectorLibraryNotFound: function FlutterInspectorLibraryNotFound(t0) {
      this.candidateNames = t0;
    },
    CanvasPaintEntry: function CanvasPaintEntry() {
    },
    IconPaintEntry0: function IconPaintEntry0(t0, t1) {
      this.iconRenderer = t0;
      this.x = t1;
    },
    IconPaintEntry_attach_closure: function IconPaintEntry_attach_closure(t0) {
      this.owner = t0;
    },
    IconPaintEntry_attach__closure: function IconPaintEntry_attach__closure() {
    },
    TextPaintEntry: function TextPaintEntry(t0, t1, t2, t3, t4) {
      var _ = this;
      _.width = t0;
      _.text = t1;
      _.color = t2;
      _.font = t3;
      _.x = t4;
    },
    InspectorTreeNodeRenderCanvasBuilder: function InspectorTreeNodeRenderCanvasBuilder(t0, t1, t2) {
      var _ = this;
      _.x = 0;
      _.color = _.font = _.lastStyle = null;
      _._inspector_tree_canvas$_entries = t0;
      _.level = t1;
      _.treeStyle = t2;
    },
    InspectorTreeNodeCanvasRender: function InspectorTreeNodeCanvasRender(t0, t1) {
      var _ = this;
      _.entries = t0;
      _.size = t1;
      _._owner = _._inspector_tree$_offset = null;
    },
    InspectorTreeNodeCanvas: function InspectorTreeNodeCanvas(t0) {
      var _ = this;
      _._diagnostic = _._renderObject = null;
      _._children = t0;
      _.allowExpandCollapse = _._isExpanded = true;
      _._childrenCount = _._inspector_tree$_parent = null;
    },
    InspectorTreeCanvas: function InspectorTreeCanvas(t0, t1, t2, t3) {
      var _ = this;
      _._inspector_tree_canvas$_recomputeRows = false;
      _._inspector_tree_canvas$_viewportCanvas = null;
      _._onHoverCallback = t0;
      _.onExpand = t1;
      _._onSelectionChange = t2;
      _._onNodeAdded = t3;
      _._currentHoverDiagnostic = _._hover = _._selection = _._root = null;
      _._computingHover = false;
    },
    InspectorTreeCanvas_setState_closure: function InspectorTreeCanvas_setState_closure(t0) {
      this.$this = t0;
    },
    InspectorTreeCanvas_paintRow_isVisible: function InspectorTreeCanvas_paintRow_isVisible(t0, t1) {
      this._box_0 = t0;
      this.visible = t1;
    },
    InspectorTreeCanvas_paintRow__endPath: function InspectorTreeCanvas_paintRow__endPath(t0, t1) {
      this._box_0 = t0;
      this.canvas = t1;
    },
    InspectorTreeCanvas_paintRow__maybeStart: function InspectorTreeCanvas_paintRow__maybeStart(t0, t1, t2) {
      this._box_0 = t0;
      this._endPath = t1;
      this.canvas = t2;
    },
    PopupListView$: function($T) {
      var t1 = new E.PopupListView([$T]);
      t1.PopupListView$0($T);
      return t1;
    },
    ListDirection0: function ListDirection0(t0) {
      this._popup$_name = t0;
    },
    PopupListView: function PopupListView(t0) {
      var _ = this;
      _.highlightedItem = _.items = _._popupAutoCompleteView = null;
      _.$ti = t0;
    },
    PopupListView_closure: function PopupListView_closure(t0, t1) {
      this.$this = t0;
      this.T = t1;
    },
    PopupListView_setList_closure: function PopupListView_setList_closure(t0) {
      this.$this = t0;
    },
    PopupAutoCompleteView: function PopupAutoCompleteView(t0, t1, t2, t3, t4) {
      var _ = this;
      _._listView = t0;
      _._containerElement = t1;
      _._popup$_popupTextfield = t2;
      _._popup$_matcher = null;
      _._completeAction = t3;
      _.element = t4;
    },
    PopupAutoCompleteView__initialize_closure: function PopupAutoCompleteView__initialize_closure(t0) {
      this.$this = t0;
    },
    PopupAutoCompleteView__initialize_closure0: function PopupAutoCompleteView__initialize_closure0(t0) {
      this.$this = t0;
    },
    PopupAutoCompleteView__initialize__closure: function PopupAutoCompleteView__initialize__closure(t0) {
      this.$this = t0;
    },
    PopupAutoCompleteView__initialize_closure1: function PopupAutoCompleteView__initialize_closure1(t0) {
      this.$this = t0;
    },
    PopupAutoCompleteView__hookupListeners_closure: function PopupAutoCompleteView__hookupListeners_closure(t0) {
      this.$this = t0;
    },
    AutoCompleteMatcher: function AutoCompleteMatcher(t0, t1) {
      var _ = this;
      _._popup$_originalScrollTop = _._popup$_original = _._textField = _._listView = null;
      _.matchingState = t0;
      _._popup$_selectRow = -1;
      _._popup$_finishCallback = _._popup$_subscription = null;
      _.$ti = t1;
    },
    AutoCompleteMatcher_start_closure: function AutoCompleteMatcher_start_closure(t0, t1) {
      this.$this = t0;
      this.listView = t1;
    },
    AutoCompleteMatcher_reset_closure: function AutoCompleteMatcher_reset_closure(t0, t1) {
      this.$this = t0;
      this.originals = t1;
    },
    AutoCompleteMatcher__startMatching_closure: function AutoCompleteMatcher__startMatching_closure(t0) {
      this.$this = t0;
    },
    AutoCompleteMatcher_displayMatchingItems_closure: function AutoCompleteMatcher_displayMatchingItems_closure(t0, t1) {
      this.$this = t0;
      this.charsToMatch = t1;
    },
    AutoCompleteMatcher_displayMatchingItems_closure0: function AutoCompleteMatcher_displayMatchingItems_closure0(t0, t1) {
      this.$this = t0;
      this.matchingItems = t1;
    },
    ToggleableServiceExtensionDescription: function ToggleableServiceExtensionDescription(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.extension = t0;
      _.description = t1;
      _.icon = t2;
      _.enabledValue = t3;
      _.disabledValue = t4;
      _.enabledTooltip = t5;
      _.disabledTooltip = t6;
      _.gaScreenName = t7;
      _.gaItem = t8;
      _.$ti = t9;
    },
    closure: function closure() {
    },
    closure0: function closure0() {
    },
    CpuProfileData$_: function(sampleCount, samplePeriod, stackFramesJson, stackTraceEvents, time) {
      var t1 = new E.CpuProfileData(stackFramesJson, stackTraceEvents, sampleCount, samplePeriod, time, P.LinkedHashMap_LinkedHashMap$_empty(P.String, E.CpuStackFrame));
      t1._cpuProfileRoot = E.CpuStackFrame$("Dart", "cpuProfile", "all", sampleCount, time, "");
      return t1;
    },
    CpuProfileData_parse: function(json) {
      var t2, t3, t4, t5, t6, t7,
        _s16_ = "timeOriginMicros",
        _s16_0 = "timeExtentMicros",
        t1 = [P.String, null];
      H.assertSubtype(json, "$isMap", t1, "$asMap");
      t2 = J.getInterceptor$asx(json);
      t3 = t2.$index(json, "stackFrames");
      t1 = H.assertSubtype(C.C_JsonCodec.decode$2$reviver(0, C.C_JsonCodec.encode$2$toEncodable(t3 == null ? P.LinkedHashMap__makeEmpty() : t3, null), null), "$isMap", t1, "$asMap");
      t3 = t2.$index(json, "traceEvents");
      if (t3 == null)
        t3 = [];
      t4 = [P.Map, P.String,,];
      t4 = H.assertSubtype(J.cast$1$0$ax(t3, t4), "$isList", [t4], "$asList");
      t3 = H.intTypeCheck(t2.$index(json, "sampleCount"));
      t5 = H.intTypeCheck(t2.$index(json, "samplePeriod"));
      if (t2.$index(json, _s16_) != null && t2.$index(json, _s16_0) != null) {
        t6 = new B.TimeRange(true);
        t7 = P.Duration$(H.intTypeCheck(t2.$index(json, _s16_)), 0, 0, 0);
        t6._utils$_start = t7;
        t2 = P.Duration$(H.intTypeCheck(J.$add$ansx(t2.$index(json, _s16_), t2.$index(json, _s16_0))), 0, 0, 0);
        t6._utils$_end = t2;
        t2 = t6;
      } else
        t2 = null;
      return E.CpuProfileData$_(t3, t5, t1, t4, t2);
    },
    CpuProfileData_subProfile: function(superProfile, subTimeRange) {
      var subStackFramesJson, t2, _i, t3, leafId, t4, leafFrameJson, parentId, t5,
        t1 = J.where$1$ax(superProfile.stackTraceEvents, new E.CpuProfileData_subProfile_closure(subTimeRange)),
        subTraceEvents = P.List_List$from(t1, true, H.getTypeArgumentByIndex(t1, 0));
      t1 = P.String;
      subStackFramesJson = P.SplayTreeMap$(E.cpu_profile_model__stackFrameIdCompare$closure(), t1, [P.Map, P.String,,]);
      for (t2 = subTraceEvents.length, t1 = [t1, null], _i = 0; t3 = subTraceEvents.length, _i < t3; subTraceEvents.length === t2 || (0, H.throwConcurrentModificationError)(subTraceEvents), ++_i) {
        leafId = H.stringTypeCheck(J.$index$asx(subTraceEvents[_i], "sf"));
        t3 = superProfile.stackFramesJson;
        t4 = J.getInterceptor$asx(t3);
        leafFrameJson = H.assertSubtype(t4.$index(t3, leafId), "$isMap", t1, "$asMap");
        subStackFramesJson.$indexSet(0, leafId, leafFrameJson);
        parentId = H.stringTypeCheck(J.$index$asx(leafFrameJson, "parent"));
        for (; parentId != null;) {
          t5 = H.assertSubtype(t4.$index(t3, parentId), "$isMap", t1, "$asMap");
          subStackFramesJson.$indexSet(0, parentId, t5);
          parentId = H.stringTypeCheck(J.$index$asx(t5, "parent"));
        }
      }
      return E.CpuProfileData$_(t3, superProfile.samplePeriod, subStackFramesJson, subTraceEvents, subTimeRange);
    },
    CpuStackFrame$: function(category, id, $name, profileSampleCount, profileTime, url) {
      return new E.CpuStackFrame(id, $name, category, url, profileTime, profileSampleCount, H.setRuntimeTypeInfo([], [E.CpuStackFrame]));
    },
    stackFrameIdCompare: function(a, b) {
      var aDashIndex, bDashIndex, aId, bId, error, t1, exception, _null = null;
      H.stringTypeCheck(a);
      H.stringTypeCheck(b);
      aDashIndex = J.lastIndexOf$1$s(a, "-");
      bDashIndex = J.lastIndexOf$1$s(b, "-");
      try {
        t1 = aDashIndex;
        if (typeof t1 !== "number")
          return t1.$add();
        aId = P.int_parse(J.substring$1$s(a, t1 + 1), _null, _null);
        t1 = bDashIndex;
        if (typeof t1 !== "number")
          return t1.$add();
        bId = P.int_parse(J.substring$1$s(b, t1 + 1), _null, _null);
        t1 = J.compareTo$1$ns(aId, bId);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        error = "invalid stack frame ";
        if (J.$eq$(aDashIndex, -1) && !J.$eq$(bDashIndex, -1))
          error = J.$add$ansx(error, "id [" + H.S(a) + "]");
        else if (!J.$eq$(aDashIndex, -1) && J.$eq$(bDashIndex, -1))
          error = J.$add$ansx(error, "id [" + H.S(b) + "]");
        else
          error = J.$add$ansx(error, "ids [" + H.S(a) + ", " + H.S(b) + "]");
        throw H.wrapException(error);
      }
    },
    CpuProfileData: function CpuProfileData(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.processed = false;
      _.stackFramesJson = t0;
      _.stackTraceEvents = t1;
      _.sampleCount = t2;
      _.samplePeriod = t3;
      _.time = t4;
      _._cpuProfileRoot = null;
      _.stackFrames = t5;
    },
    CpuProfileData_subProfile_closure: function CpuProfileData_subProfile_closure(t0) {
      this.subTimeRange = t0;
    },
    CpuStackFrame: function CpuStackFrame(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.id = t0;
      _.name = t1;
      _.category = t2;
      _.url = t3;
      _.profileTime = t4;
      _.profileSampleCount = t5;
      _.exclusiveSampleCount = 0;
      _.parent = _._selfTime = _._selfTimeRatio = _._totalTime = _._totalTimeRatio = _._inclusiveSampleCount = null;
      _.children = t6;
      _.index = -1;
      _._depth = 0;
      _._level = _._trees$_root = null;
      _.isExpanded = false;
    },
    computeDevToolsCustomGTagsData: function() {
      var splits, len, index, value, t1,
        platform = window.navigator.platform;
      platform.toString;
      H.stringReplaceAllUnchecked(platform, " ", "_");
      $._devtoolsPlatformType = platform;
      splits = window.navigator.appVersion.split(" ");
      len = splits.length;
      for (index = 0; index < len; ++index) {
        value = splits[index];
        if (J.getInterceptor$s(value).startsWith$1(value, "Chrome/") || C.JSString_methods.startsWith$1(value, "Crios/"))
          $._devtoolsChrome = value;
        else if (C.JSString_methods.startsWith$1(value, "Android")) {
          t1 = index + 1;
          if (t1 >= len)
            return H.ioore(splits, t1);
          $._devtoolsPlatformType = "Android_" + H.S(splits[t1]);
        } else if (value === "CrOS")
          $._devtoolsPlatformType = "CrOS_" + H.S(platform);
      }
    },
    waitForDimensionsComputed: function(screenName) {
      P.Timer_Timer(C.Duration_100000, new E.waitForDimensionsComputed_closure(screenName));
    },
    setupAndGaScreen: function(screenName) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null);
      var $async$setupAndGaScreen = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (H.boolConversionCheck(self.gtagsEnabled()))
                if (!$._analyticsComputed) {
                  $._stillWaiting = $._stillWaiting + 1;
                  E.waitForDimensionsComputed(screenName);
                } else
                  F.screen(screenName);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$setupAndGaScreen, $async$completer);
    },
    setupDimensions: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        ideValue;
      var $async$setupDimensions = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp != null && H.boolConversionCheck(self.gtagsEnabled()) && !$._analyticsComputed && !$._computing ? 2 : 3;
              break;
            case 2:
              // then
              $._computing = true;
              $async$goto = 4;
              return P._asyncAwait(F.computeUserApplicationCustomGTagData(), $async$setupDimensions);
            case 4:
              // returning from await.
              E.computeDevToolsCustomGTagsData();
              $._ideLaunched = "CLI";
              ideValue = P.Uri_parse(J.toString$0$(window.location), 0, null).get$queryParameters().$index(0, "ide");
              if (ideValue != null)
                $._ideLaunched = ideValue;
              $._analyticsComputed = true;
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$setupDimensions, $async$completer);
    },
    waitForDimensionsComputed_closure: function waitForDimensionsComputed_closure(t0) {
      this.screenName = t0;
    },
    BaseClient: function BaseClient() {
    },
    ClientException: function ClientException(t0) {
      this.message = t0;
    },
    PosixStyle: function PosixStyle(t0, t1, t2) {
      this.separatorPattern = t0;
      this.needsSeparatorPattern = t1;
      this.rootPattern = t2;
    },
    StringScannerException: function StringScannerException(t0, t1, t2) {
      this._span_exception$_source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    },
    FrameworkCore_initVmService: function(errorReporter, explicitUri) {
      H.functionTypeCheck(errorReporter, {func: 1, ret: -1, args: [P.String,,]});
      return E.FrameworkCore_initVmService$body(errorReporter, explicitUri);
    },
    FrameworkCore_initVmService$body: function(errorReporter, explicitUri) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], finishedCompleter, service, e, t1, scheme, path, exception, uri, $async$exception;
      var $async$FrameworkCore_initVmService = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              uri = explicitUri == null ? E.FrameworkCore__getUriFromQuerystring() : explicitUri;
              $async$goto = uri != null ? 3 : 5;
              break;
            case 3:
              // then
              t1 = P.Null;
              finishedCompleter = new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]);
              t1 = uri;
              scheme = t1.isScheme$1("wss") || t1.isScheme$1("https") ? "wss" : "ws";
              if (C.JSString_methods.endsWith$1(t1.get$path(t1), "/ws"))
                path = t1.get$path(t1);
              else
                path = C.JSString_methods.endsWith$1(t1.get$path(t1), "/") ? t1.get$path(t1) + "ws" : t1.get$path(t1) + "/ws";
              uri = t1.replace$2$path$scheme(0, path, scheme);
              $async$handler = 7;
              $async$goto = 10;
              return P._asyncAwait(R.connect(uri, finishedCompleter), $async$FrameworkCore_initVmService);
            case 10:
              // returning from await.
              service = $async$result;
              $async$goto = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager") != null ? 11 : 13;
              break;
            case 11:
              // then
              $async$goto = 14;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").vmServiceOpened$2$onClosed(service, finishedCompleter.future), $async$FrameworkCore_initVmService);
            case 14:
              // returning from await.
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 12;
              break;
            case 13:
              // else
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
            case 12:
              // join
              $async$handler = 2;
              // goto after finally
              $async$goto = 9;
              break;
            case 7:
              // catch
              $async$handler = 6;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              errorReporter.call$2("Unable to connect to VM service at " + H.S(uri), e);
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 9;
              break;
            case 6:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 9:
              // after finally
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$FrameworkCore_initVmService, $async$completer);
    },
    FrameworkCore__getUriFromQuerystring: function() {
      var queryParams, uri, t1, port;
      if (window.location.search.length === 0)
        return;
      queryParams = P.Uri_parse(J.toString$0$(window.location), 0, null).get$queryParameters();
      if (queryParams.$index(0, "uri") != null) {
        uri = P.Uri_tryParse(queryParams.$index(0, "uri"));
        if (uri != null)
          if (uri.get$isAbsolute())
            t1 = uri.isScheme$1("ws") || uri.isScheme$1("wss") || uri.isScheme$1("http") || uri.isScheme$1("https");
          else
            t1 = false;
        else
          t1 = false;
        if (t1)
          return uri;
      }
      t1 = queryParams.$index(0, "port");
      port = H.Primitives_parseInt(t1 == null ? "" : t1, null);
      if (port != null)
        return P.Uri_parse("ws://localhost:" + H.S(port) + "/ws", 0, null);
      return;
    }
  },
  K = {PaintEntry: function PaintEntry() {
    }, InspectorTreeNodeRenderBuilder: function InspectorTreeNodeRenderBuilder() {
    }, InspectorTreeNodeRender: function InspectorTreeNodeRender() {
    }, InspectorTreeNode: function InspectorTreeNode() {
    }, InspectorTreeNode_renderObject_radix: function InspectorTreeNode_renderObject_radix() {
    }, InspectorTreeRow: function InspectorTreeRow(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.node = t0;
      _.ticks = t1;
      _.depth = t2;
      _.index = t3;
      _.lineToParent = t4;
      _.isSelected = t5;
      _.highlightDepth = t6;
    }, InspectorTree: function InspectorTree() {
    }, InspectorTree_root_closure: function InspectorTree_root_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    }, InspectorTree_selection_closure: function InspectorTree_selection_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    }, InspectorTree_hover_closure: function InspectorTree_hover_closure(t0, t1) {
      this.$this = t0;
      this.node = t1;
    }, InspectorTree_nodeChanged_closure: function InspectorTree_nodeChanged_closure(t0) {
      this.node = t0;
    }, InspectorTree_removeNodeFromParent_closure: function InspectorTree_removeNodeFromParent_closure(t0) {
      this.node = t0;
    }, InspectorTree_appendChild_closure: function InspectorTree_appendChild_closure(t0, t1) {
      this.node = t0;
      this.child = t1;
    }, InspectorTree_expandPath_closure: function InspectorTree_expandPath_closure(t0) {
      this._box_0 = t0;
    }, InspectorTree_onTapIcon_closure: function InspectorTree_onTapIcon_closure(t0, t1) {
      this.$this = t0;
      this.row = t1;
    }, InspectorTree_onTapIcon_closure0: function InspectorTree_onTapIcon_closure0(t0) {
      this.row = t0;
    }, InspectorTreeFixedRowHeight: function InspectorTreeFixedRowHeight() {
    },
    InspectorTreeHtml$: function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
      var t3, t4, t5,
        t1 = A.CoreElement$("div", null, "inspector-tree-html", null, null),
        t2 = new K.InspectorTreeHtml(t1, onHover, onExpand, onSelectionChange, onNodeAdded);
      t1.get$onClick(t1).listen$1(t2.get$onMouseClick());
      t1 = t1.element;
      t3 = J.getInterceptor$x(t1);
      t4 = t3.get$onMouseMove(t1);
      t5 = H.getTypeArgumentByIndex(t4, 0);
      W._EventStreamSubscription$(t4._html$_target, t4._eventType, H.functionTypeCheck(t2.get$onMouseMove(t2), {func: 1, ret: -1, args: [t5]}), false, t5);
      t1 = t3.get$onMouseLeave(t1);
      t3 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(t2.get$onMouseLeave(t2), {func: 1, ret: -1, args: [t3]}), false, t3);
      return t2;
    },
    HtmlPaintEntry: function HtmlPaintEntry() {
    },
    IconPaintEntry: function IconPaintEntry(t0) {
      this.iconRenderer = t0;
      this.element = null;
    },
    HtmlTextPaintEntry: function HtmlTextPaintEntry(t0, t1, t2) {
      var _ = this;
      _.text = t0;
      _.color = t1;
      _.font = t2;
      _.element = null;
    },
    InspectorTreeNodeRenderHtmlBuilder: function InspectorTreeNodeRenderHtmlBuilder(t0, t1, t2, t3) {
      var _ = this;
      _.color = _.font = _.lastStyle = null;
      _.allowWrap = t0;
      _._entries = t1;
      _.level = t2;
      _.treeStyle = t3;
    },
    InspectorTreeNodeHtmlRender: function InspectorTreeNodeHtmlRender(t0, t1, t2) {
      var _ = this;
      _.cssClasses = t0;
      _.element = null;
      _.entries = t1;
      _.size = t2;
      _._owner = _._inspector_tree$_offset = null;
    },
    InspectorTreeNodeHtml: function InspectorTreeNodeHtml(t0) {
      var _ = this;
      _._diagnostic = _._renderObject = null;
      _._children = t0;
      _.allowExpandCollapse = _._isExpanded = true;
      _._childrenCount = _._inspector_tree$_parent = null;
    },
    InspectorTreeHtml: function InspectorTreeHtml(t0, t1, t2, t3, t4) {
      var _ = this;
      _._inspector_tree_html$_container = t0;
      _._recomputeRows = false;
      _._onHoverCallback = t1;
      _.onExpand = t2;
      _._onSelectionChange = t3;
      _._onNodeAdded = t4;
      _._currentHoverDiagnostic = _._hover = _._selection = _._root = null;
      _._computingHover = false;
    },
    InspectorTreeHtml_setState_closure: function InspectorTreeHtml_setState_closure(t0) {
      this.$this = t0;
    },
    InspectorTreeHtml_animateToTargets_closure: function InspectorTreeHtml_animateToTargets_closure(t0) {
      this.targets = t0;
    },
    FrameEventsChart: function FrameEventsChart(t0, t1, t2) {
      var _ = this;
      _.timelineController = t0;
      _.chartItems = t1;
      _.zoomLevel = 1;
      _._gpuColorOffset = _._uiColorOffset = _.floatingPointScrollLeft = 0;
      _._gpuSection = _._uiSection = _._timelineBackground = _._flameChart = _._timelineGrid = _.selectedItem = null;
      _.element = t2;
    },
    FrameEventsChart__initListeners_closure: function FrameEventsChart__initListeners_closure(t0) {
      this.$this = t0;
    },
    FrameEventsChart__render_drawSubtree: function FrameEventsChart__render_drawSubtree(t0, t1, t2) {
      this.$this = t0;
      this.frameStartOffset = t1;
      this.pxPerMicro = t2;
    },
    FrameEventsChart__render_drawTimelineBackground: function FrameEventsChart__render_drawTimelineBackground(t0) {
      this.$this = t0;
    },
    FrameEventsChart__render_drawUiEvents: function FrameEventsChart__render_drawUiEvents(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.uiSectionHeight = t1;
      _.drawSubtree = t2;
      _.frame = t3;
    },
    FrameEventsChart__render_drawGpuEvents: function FrameEventsChart__render_drawGpuEvents(t0, t1, t2, t3, t4) {
      var _ = this;
      _.$this = t0;
      _.gpuSectionHeight = t1;
      _.uiSectionHeight = t2;
      _.drawSubtree = t3;
      _.frame = t4;
    },
    FrameEventsChart__render_drawTimelineGrid: function FrameEventsChart__render_drawTimelineGrid(t0, t1, t2) {
      this.$this = t0;
      this.frame = t1;
      this.flameChartHeight = t2;
    },
    FrameFlameChartItem: function FrameFlameChartItem(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._event = t0;
      _.includeDuration = t1;
      _.timelineController = t2;
      _.startingLeft = t3;
      _.startingWidth = t4;
      _.top = t5;
      _.backgroundColor = t6;
      _.defaultTextColor = t7;
      _.selectedTextColor = t8;
      _.currentWidth = _.currentLeft = _._labelWrapper = _.itemLabel = _.element = null;
    },
    FrameFlameChartItem_setOnClick_closure: function FrameFlameChartItem_setOnClick_closure(t0) {
      this.$this = t0;
    },
    TimelineGrid: function TimelineGrid(t0, t1, t2, t3) {
      var _ = this;
      _._frameDuration = t0;
      _._frame_events_chart$_zoomLevel = 1;
      _._frame_events_chart$_flameChartWidth = t1;
      _._gridItems = t2;
      _.element = t3;
    },
    TimelineGridItem: function TimelineGridItem(t0, t1, t2, t3) {
      var _ = this;
      _.timestamp = t0;
      _.currentLeft = t1;
      _.currentWidth = t2;
      _.gridLine = _.timestampLabel = null;
      _.element = t3;
    },
    MaterialIcon$: function(text, color, angle, fontSize, iconWidth) {
      return new K.MaterialIcon(text, color, fontSize, angle, iconWidth);
    },
    FlutterMaterialIcons_getIconForCodePoint: function(charCode) {
      var code = H.Primitives_stringFromCharCode(charCode);
      return $.FlutterMaterialIcons__iconCache.putIfAbsent$2(0, code, new K.FlutterMaterialIcons_getIconForCodePoint_closure(code));
    },
    MaterialIcon: function MaterialIcon(t0, t1, t2, t3, t4) {
      var _ = this;
      _.text = t0;
      _.color = t1;
      _.fontSize = t2;
      _.angle = t3;
      _.iconWidth = t4;
    },
    FlutterMaterialIcons_getIconForCodePoint_closure: function FlutterMaterialIcons_getIconForCodePoint_closure(t0) {
      this.code = t0;
    },
    ThemedColor$: function(_light, _dark) {
      return new K.ThemedColor(_light, _dark);
    },
    ThemedColor: function ThemedColor(t0, t1) {
      this._light = t0;
      this._dark = t1;
    },
    AsObservableFuture: function AsObservableFuture(t0, t1) {
      this.wrapped = t0;
      this.$ti = t1;
    }
  },
  T = {MemoryController: function MemoryController(t0, t1) {
      this._memoryTrackerController = t0;
      this._disconnectController = t1;
      this._memoryTracker = null;
    }, MemoryController__handleConnectionStart_closure: function MemoryController__handleConnectionStart_closure(t0) {
      this.$this = t0;
    }, MemoryController_startTimeline_closure: function MemoryController_startTimeline_closure(t0) {
      this.$this = t0;
    }, MemoryController_getAllocationProfile_closure: function MemoryController_getAllocationProfile_closure() {
    }, MemoryController_getAllocationProfile_closure0: function MemoryController_getAllocationProfile_closure0() {
    }, MemoryController_getInstances_closure: function MemoryController_getInstances_closure(t0, t1) {
      this.classRef = t0;
      this.className = t1;
    },
    MemoryTracker_getHeaps: function(isolate) {
      return J.map$1$1$ax(J.get$values$x(H.assertSubtype(J.$index$asx(isolate.json, "_heaps"), "$isMap", [P.String, null], "$asMap")), new T.MemoryTracker_getHeaps_closure(), S.HeapSpace);
    },
    MemoryTracker: function MemoryTracker(t0, t1, t2, t3) {
      var _ = this;
      _.service = t0;
      _._memory_protocol$_pollingTimer = null;
      _._memory_protocol$_changeController = t1;
      _.samples = t2;
      _.isolateHeaps = t3;
      _.processRss = null;
    },
    MemoryTracker__pollMemory_closure: function MemoryTracker__pollMemory_closure(t0) {
      this.$this = t0;
    },
    MemoryTracker__recalculate_closure: function MemoryTracker__recalculate_closure() {
    },
    MemoryTracker__recalculate_closure0: function MemoryTracker__recalculate_closure0() {
    },
    MemoryTracker__recalculate_closure1: function MemoryTracker__recalculate_closure1() {
    },
    MemoryTracker__recalculate_closure2: function MemoryTracker__recalculate_closure2() {
    },
    MemoryTracker_getHeaps_closure: function MemoryTracker_getHeaps_closure() {
    },
    HeapSample: function HeapSample(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.timestamp = t0;
      _.rss = t1;
      _.capacity = t2;
      _.used = t3;
      _.external = t4;
      _.isGC = t5;
    },
    ClassHeapDetailStats: function ClassHeapDetailStats(t0) {
      var _ = this;
      _.json = t0;
      _.bytesAccumulated = _.bytesCurrent = _.instancesAccumulated = _.instancesCurrent = 0;
      _.classRef = null;
    },
    InstanceSummary: function InstanceSummary(t0, t1, t2) {
      this._classRef = t0;
      this._objectRef = t1;
      this._memory_protocol$_className = t2;
    },
    ViewportCanvas$: function(classes, onMouseLeave, onMouseMove, onSizeChange, onTap, paintCallback) {
      var _null = null,
        t1 = $.$get$Rect_zero();
      t1 = new T.ViewportCanvas(paintCallback, onTap, onMouseMove, onMouseLeave, onSizeChange, P.LinkedHashMap_LinkedHashMap$_empty(T._ChunkPosition, T._CanvasChunk), A.CoreElement$("div", "flex", classes, _null, _null), A.CoreElement$("div", _null, _null, _null, _null), t1);
      t1.ViewportCanvas$7$addBuffer$classes$onMouseLeave$onMouseMove$onSizeChange$onTap$paintCallback(true, classes, onMouseLeave, onMouseMove, onSizeChange, onTap, paintCallback);
      return t1;
    },
    _CanvasChunk: function _CanvasChunk(t0) {
      var _ = this;
      _.canvas = t0;
      _._context = null;
      _._empty = true;
      _._dirty = null;
      _.attached = false;
      _._lastFrameRendered = -1;
      _._viewport_canvas$_position = _.rect = null;
    },
    _ChunkPosition: function _ChunkPosition(t0, t1) {
      this.x = t0;
      this.y = t1;
    },
    ViewportCanvas: function ViewportCanvas(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _._currentMouseHover = null;
      _._frameId = 0;
      _._viewport_canvas$_paintCallback = t0;
      _._viewport_canvas$_onTap = t1;
      _._onMouseMove = t2;
      _._onMouseLeave = t3;
      _._onSizeChange = t4;
      _._chunks = t5;
      _._resizeObserver = null;
      _._viewport_canvas$_element = t6;
      _._content = t7;
      _._contentHeight = _._contentWidth = 0;
      _._contentSizeChanged = true;
      _._viewport_canvas$_hasPendingRebuild = false;
      _._renderedViewport = null;
      _._viewport = t8;
    },
    ViewportCanvas_closure: function ViewportCanvas_closure(t0) {
      this.$this = t0;
    },
    ViewportCanvas_closure0: function ViewportCanvas_closure0(t0) {
      this.$this = t0;
    },
    ViewportCanvas_closure1: function ViewportCanvas_closure1(t0) {
      this.$this = t0;
    },
    ViewportCanvas_closure2: function ViewportCanvas_closure2(t0) {
      this.$this = t0;
    },
    ViewportCanvas_closure3: function ViewportCanvas_closure3(t0) {
      this.$this = t0;
    },
    ViewportCanvas__scheduleRebuild_closure: function ViewportCanvas__scheduleRebuild_closure(t0) {
      this.$this = t0;
    },
    ViewportCanvas_scrollToRect_closure: function ViewportCanvas_scrollToRect_closure(t0, t1) {
      this.$this = t0;
      this.target = t1;
    },
    _ViewportCanvas_Object_SetStateMixin: function _ViewportCanvas_Object_SetStateMixin() {
    },
    BaseResponse: function BaseResponse() {
    },
    Intl_defaultLocale: function() {
      var zoneLocale = $.Zone__current.$index(0, C.Symbol_89P);
      return H.stringTypeCheck(zoneLocale == null ? $.Intl__defaultLocale : zoneLocale);
    },
    Intl_verifiedLocale: function(newLocale, localeExists, onFailure) {
      var t1, _i, each;
      if (newLocale == null) {
        if (T.Intl_defaultLocale() == null)
          $.Intl__defaultLocale = "en_US";
        return T.Intl_verifiedLocale(T.Intl_defaultLocale(), localeExists, onFailure);
      }
      if (H.boolConversionCheck(H.boolTypeCheck(localeExists.call$1(newLocale))))
        return newLocale;
      for (t1 = [T.Intl_canonicalizedLocale(newLocale), T.Intl_shortLocale(newLocale), "fallback"], _i = 0; _i < 3; ++_i) {
        each = t1[_i];
        if (H.boolConversionCheck(H.boolTypeCheck(localeExists.call$1(each))))
          return each;
      }
      return H.stringTypeCheck(onFailure.call$1(newLocale));
    },
    Intl__throwLocaleError: function(localeName) {
      throw H.wrapException(P.ArgumentError$("Invalid locale '" + localeName + "'"));
    },
    Intl_shortLocale: function(aLocale) {
      if (aLocale.length < 2)
        return aLocale;
      return C.JSString_methods.substring$2(aLocale, 0, 2).toLowerCase();
    },
    Intl_canonicalizedLocale: function(aLocale) {
      var t1, region;
      if (aLocale === "C")
        return "en_ISO";
      if (aLocale.length < 5)
        return aLocale;
      t1 = aLocale[2];
      if (t1 !== "-" && t1 !== "_")
        return aLocale;
      region = C.JSString_methods.substring$1(aLocale, 3);
      if (region.length <= 3)
        region = region.toUpperCase();
      return aLocale[0] + aLocale[1] + "_" + region;
    },
    DateFormat_localeExists: function(localeName) {
      var t1;
      if (localeName == null)
        return false;
      t1 = $.$get$_dateTimeSymbols();
      t1.toString;
      return localeName === "en_US" ? true : t1._throwException$0();
    },
    DateFormat__fieldConstructors: function() {
      return [new T.DateFormat__fieldConstructors_closure(), new T.DateFormat__fieldConstructors_closure0(), new T.DateFormat__fieldConstructors_closure1()];
    },
    _DateFormatQuotedField__patchQuotes: function(pattern) {
      var t1, t2;
      if (pattern === "''")
        return "'";
      else {
        t1 = J.substring$2$s(pattern, 1, pattern.length - 1);
        t2 = $.$get$_DateFormatQuotedField__twoEscapedQuotes();
        return H.stringReplaceAllUnchecked(t1, t2, "'");
      }
    },
    _dayOfYear: function(month, day, leapYear) {
      var t1, t2;
      if (month === 1)
        return day;
      if (month === 2)
        return day + 31;
      t1 = C.JSDouble_methods.floor$0(30.6 * month - 91.4);
      t2 = leapYear ? 1 : 0;
      return t1 + day + 59 + t2;
    },
    NumberFormat$decimalPattern: function() {
      var t3,
        t1 = T.Intl_verifiedLocale(null, T.intl_NumberFormat_localeExists$closure(), T.intl_Intl__throwLocaleError$closure()),
        t2 = new T.NumberFormat(t1, new P.StringBuffer(""));
      t1 = t2._symbols = $.$get$numberFormatSymbols().$index(0, t1);
      t3 = C.JSString_methods._codeUnitAt$1(t1.ZERO_DIGIT, 0);
      t2._localeZero = t3;
      t2._zeroOffset = t3 - 48;
      t2._negativePrefix = t1.MINUS_SIGN;
      t3 = t1.DEF_CURRENCY_CODE;
      t2.currencyName = t3;
      t2._setPattern$1(new T.NumberFormat$decimalPattern_closure().call$1(t1));
      return t2;
    },
    NumberFormat_localeExists: function(localeName) {
      if (localeName == null)
        return false;
      return $.$get$numberFormatSymbols().containsKey$1(0, localeName);
    },
    DateFormat: function DateFormat() {
      var _ = this;
      _._localeZero = _._localeZeroCodeUnit = _._useNativeDigits = _._formatFieldsPrivate = _._intl$_pattern = _._locale = null;
    },
    DateFormat_format_closure: function DateFormat_format_closure(t0, t1) {
      this.result = t0;
      this.date = t1;
    },
    DateFormat__fieldConstructors_closure: function DateFormat__fieldConstructors_closure() {
    },
    DateFormat__fieldConstructors_closure0: function DateFormat__fieldConstructors_closure0() {
    },
    DateFormat__fieldConstructors_closure1: function DateFormat__fieldConstructors_closure1() {
    },
    _DateFormatField: function _DateFormatField() {
    },
    _DateFormatLiteralField: function _DateFormatLiteralField(t0, t1) {
      this.pattern = t0;
      this.parent = t1;
    },
    _DateFormatQuotedField: function _DateFormatQuotedField(t0, t1) {
      this._fullPattern = null;
      this.pattern = t0;
      this.parent = t1;
    },
    _DateFormatPatternField: function _DateFormatPatternField(t0, t1) {
      this.pattern = t0;
      this.parent = t1;
    },
    NumberFormat: function NumberFormat(t0, t1) {
      var _ = this;
      _._negativePrefix = "-";
      _._positiveSuffix = _._negativeSuffix = _._positivePrefix = "";
      _._finalGroupingSize = _._groupingSize = 3;
      _._useExponentialNotation = _._useSignForPositiveExponent = _._decimalSeparatorAlwaysShown = _._groupingSizeSetExplicitly = false;
      _.maximumIntegerDigits = 40;
      _.minimumIntegerDigits = 1;
      _.maximumFractionDigits = 3;
      _.minimumExponentDigits = _.minimumFractionDigits = 0;
      _._internalMultiplier = 1;
      _._multiplierDigits = 0;
      _._intl$_pattern = null;
      _._locale = t0;
      _._decimalDigits = _._currencySymbol = _.currencyName = _._symbols = null;
      _._buffer = t1;
      _._zeroOffset = _._localeZero = 0;
    },
    NumberFormat$decimalPattern_closure: function NumberFormat$decimalPattern_closure() {
    },
    _NumberFormatParser: function _NumberFormatParser(t0, t1, t2) {
      var _ = this;
      _.format = t0;
      _.pattern = t1;
      _.currencySymbol = t2;
      _.inQuote = false;
      _.decimalPos = -1;
      _.digitRightCount = _.zeroDigitCount = _.digitLeftCount = 0;
      _.groupingCount = -1;
    },
    _StringIterable: function _StringIterable(t0) {
      this.iterator = t0;
    },
    _StringIterator: function _StringIterator(t0) {
      this.input = t0;
      this.nextIndex = 0;
      this._intl$_current = null;
    }
  },
  Q = {
    Table$virtual: function(overflowAuto, rowHeight, $T) {
      var t4, t5, _null = null,
        t1 = [Q.Column, $T],
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = A.CoreElement$("table", _null, _null, _null, _null);
      t3.clazz$1("full-width");
      t3.element.setAttribute("tabIndex", "0");
      t4 = A.CoreElement$("tr", _null, _null, _null, _null);
      t5 = t4.element.style;
      t5.display = "none";
      t5 = A.CoreElement;
      t1 = new Q.Table(A.CoreElement$("div", "flex", (overflowAuto ? "overflow-auto" : "overflow-y") + " table-border table-virtual", _null, _null), rowHeight, t2, t3, t4, P.LinkedHashMap_LinkedHashMap$_empty(t1, t5), P.LinkedHashMap_LinkedHashMap$_empty(W.Element, $T), P.LinkedHashMap_LinkedHashMap$_empty(P.int, t5), new P._AsyncBroadcastStreamController(_null, _null, [$T]), new P._AsyncBroadcastStreamController(_null, _null, [P.Null]), new P._AsyncBroadcastStreamController(_null, _null, [[Q.HoverCellData, $T]]), [$T]);
      t1.Table$virtual$2$overflowAuto$rowHeight(overflowAuto, rowHeight, $T);
      return t1;
    },
    Column_fastIntl: function(value) {
      if (typeof value === "number" && Math.floor(value) === value && value < 1000)
        return J.toString$0$(value);
      else
        return $.$get$nf().format$1(value);
    },
    HoverCellData: function HoverCellData(t0, t1, t2) {
      this.cell = t0;
      this.data = t1;
      this.$ti = t2;
    },
    Table: function Table(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.element = t0;
      _.rowHeight = t1;
      _._hasPendingRebuild = false;
      _.columns = t2;
      _._sortDirection = _._sortColumn = _.data = null;
      _._table = t3;
      _._spacerAfterVisibleRows = _._spacerBeforeVisibleRows = _._tbody = _._thead = null;
      _._dummyRowToForceAlternatingColor = t4;
      _._spanForColumn = t5;
      _._dataForRow = t6;
      _._rowForIndex = t7;
      _._selectController = t8;
      _._rowsChangedController = t9;
      _._selectElementController = t10;
      _._selectedObjectIndex = _._selectedObject = null;
      _.$ti = t11;
    },
    Table$virtual_closure: function Table$virtual_closure(t0) {
      this.$this = t0;
    },
    Table__init_closure: function Table__init_closure(t0) {
      this.$this = t0;
    },
    Table_setRows_closure: function Table_setRows_closure(t0) {
      this.$this = t0;
    },
    Table_setRows__closure: function Table_setRows__closure(t0, t1) {
      this.$this = t0;
      this.column = t1;
    },
    Table_setRows_closure0: function Table_setRows_closure0(t0) {
      this.$this = t0;
    },
    Table_setRows_closure1: function Table_setRows_closure1() {
    },
    Table_scrollTo_closure: function Table_scrollTo_closure(t0, t1, t2) {
      this.$this = t0;
      this.index = t1;
      this.scrollBehavior = t2;
    },
    Table__scheduleRebuild_closure: function Table__scheduleRebuild_closure(t0) {
      this.$this = t0;
    },
    Table__sortData_closure: function Table__sortData_closure(t0, t1, t2) {
      this.$this = t0;
      this.column = t1;
      this.direction = t2;
    },
    Table__rebuildVirtualTable_closure: function Table__rebuildVirtualTable_closure(t0) {
      this.$this = t0;
    },
    Table__rebuildVirtualTable__closure: function Table__rebuildVirtualTable__closure() {
    },
    Table__buildTableRows_selectRow: function Table__buildTableRows_selectRow(t0) {
      this.$this = t0;
    },
    Table__buildTableRows_hoverCell: function Table__buildTableRows_hoverCell(t0) {
      this.$this = t0;
    },
    Table__buildTableRows_closure: function Table__buildTableRows_closure(t0, t1, t2) {
      this.selectRow = t0;
      this.tableRow = t1;
      this.index = t2;
    },
    Table__buildTableRows_closure0: function Table__buildTableRows_closure0(t0, t1, t2, t3) {
      var _ = this;
      _.hoverCell = t0;
      _.tableRow = t1;
      _.tableCell = t2;
      _.index = t3;
    },
    Table__buildTableRows_closure1: function Table__buildTableRows_closure1(t0, t1, t2) {
      this.hoverCell = t0;
      this.tableRow = t1;
      this.index = t2;
    },
    TreeTable: function TreeTable(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.element = t0;
      _.rowHeight = t1;
      _._hasPendingRebuild = false;
      _.columns = t2;
      _._sortDirection = _._sortColumn = _.data = null;
      _._table = t3;
      _._spacerAfterVisibleRows = _._spacerBeforeVisibleRows = _._tbody = _._thead = null;
      _._dummyRowToForceAlternatingColor = t4;
      _._spanForColumn = t5;
      _._dataForRow = t6;
      _._rowForIndex = t7;
      _._selectController = t8;
      _._rowsChangedController = t9;
      _._selectElementController = t10;
      _._selectedObjectIndex = _._selectedObject = null;
      _.$ti = t11;
    },
    TreeTable__sortData__addToSortedData: function TreeTable__sortData__addToSortedData(t0, t1, t2, t3) {
      var _ = this;
      _.$this = t0;
      _.sortedData = t1;
      _.column = t2;
      _.direction = t3;
    },
    TreeTable__sortData__addToSortedData_closure: function TreeTable__sortData__addToSortedData_closure(t0, t1, t2) {
      this.$this = t0;
      this.column = t1;
      this.direction = t2;
    },
    TreeTable__sortData_closure: function TreeTable__sortData_closure(t0) {
      this.$this = t0;
    },
    TreeTable__sortData_closure0: function TreeTable__sortData_closure0(t0, t1, t2) {
      this.$this = t0;
      this.column = t1;
      this.direction = t2;
    },
    TreeTable_collapseNode_cascadingRemove: function TreeTable_collapseNode_cascadingRemove(t0) {
      this.$this = t0;
    },
    TreeTable_expandNode_expand: function TreeTable_expandNode_expand(t0) {
      this.$this = t0;
    },
    Column: function Column() {
    },
    TreeColumn: function TreeColumn() {
    },
    TreeColumn_renderToElement_closure: function TreeColumn_renderToElement_closure(t0, t1) {
      this.$this = t0;
      this.dataObject = t1;
    },
    ColumnAlignment: function ColumnAlignment(t0) {
      this._tables$_name = t0;
    },
    SortOrder: function SortOrder(t0) {
      this._tables$_name = t0;
    },
    _Table_Object_SetStateMixin: function _Table_Object_SetStateMixin() {
    },
    TimelineData$: function(cpuProfileData, $frames, selectedEvent, selectedFrame, traceEvents) {
      var t1 = traceEvents == null ? H.setRuntimeTypeInfo([], [[P.Map, P.String,,]]) : traceEvents;
      return new Q.TimelineData(t1, $frames == null ? H.setRuntimeTypeInfo([], [Q.TimelineFrame]) : $frames, selectedFrame, selectedEvent, cpuProfileData);
    },
    OfflineTimelineData$_: function(cpuProfileData, $frames, selectedEvent, selectedFrame, traceEvents) {
      return new Q.OfflineTimelineData(traceEvents, $frames == null ? H.setRuntimeTypeInfo([], [Q.TimelineFrame]) : $frames, selectedFrame, selectedEvent, cpuProfileData);
    },
    TimelineEvent$: function(firstTraceEvent) {
      var t1 = new B.TimeRange(true),
        t2 = H.setRuntimeTypeInfo([firstTraceEvent], [Q.TraceEventWrapper]),
        t3 = firstTraceEvent.event,
        t4 = t3.get$type(t3),
        t5 = H.setRuntimeTypeInfo([], [Q.TimelineEvent0]);
      t3 = P.Duration$(t3.timestampMicros, 0, 0, 0);
      t1._utils$_start = t3;
      return new Q.TimelineEvent0(t2, t4, t1, t5);
    },
    TraceEvent$: function(json) {
      var t1 = J.getInterceptor$asx(json),
        t2 = H.stringTypeCheck(t1.$index(json, "name")),
        t3 = H.stringTypeCheck(t1.$index(json, "cat")),
        t4 = H.stringTypeCheck(t1.$index(json, "ph"));
      H.intTypeCheck(t1.$index(json, "pid"));
      return new Q.TraceEvent(json, t2, t3, t4, H.intTypeCheck(t1.$index(json, "tid")), H.intTypeCheck(t1.$index(json, "dur")), H.intTypeCheck(t1.$index(json, "ts")), H.assertSubtype(t1.$index(json, "args"), "$isMap", [P.String, null], "$asMap"));
    },
    TraceEventWrapper$: function($event, timeReceived) {
      var t1 = $._traceEventWrapperId;
      $._traceEventWrapperId = t1 + 1;
      return new Q.TraceEventWrapper($event, timeReceived, t1);
    },
    TimelineData: function TimelineData(t0, t1, t2, t3, t4) {
      var _ = this;
      _.traceEvents = t0;
      _.frames = t1;
      _.selectedFrame = t2;
      _.selectedEvent = t3;
      _.cpuProfileData = t4;
    },
    OfflineTimelineData: function OfflineTimelineData(t0, t1, t2, t3, t4) {
      var _ = this;
      _.traceEvents = t0;
      _.frames = t1;
      _.selectedFrame = t2;
      _.selectedEvent = t3;
      _.cpuProfileData = t4;
    },
    OfflineTimelineEvent: function OfflineTimelineEvent(t0, t1, t2, t3) {
      var _ = this;
      _.traceEvents = t0;
      _.type = t1;
      _.time = t2;
      _.parent = _._timeline_model$_frameId = null;
      _.children = t3;
      _.index = -1;
      _._depth = 0;
      _._level = _._trees$_root = null;
      _.isExpanded = false;
    },
    TimelineFrame: function TimelineFrame(t0, t1, t2, t3, t4) {
      var _ = this;
      _.id = t0;
      _._addedToTimeline = null;
      _.eventFlows = t1;
      _.time = t2;
      _.cpuProfileReady = t3;
      _.pipelineItemTime = t4;
      _.cpuProfileData = _.pipelineItemEndTrace = _.pipelineItemStartTrace = null;
    },
    TimelineFrame_closure: function TimelineFrame_closure() {
    },
    TimelineEventType: function TimelineEventType(t0, t1) {
      this.index = t0;
      this._timeline_model$_name = t1;
    },
    TimelineEvent0: function TimelineEvent0(t0, t1, t2, t3) {
      var _ = this;
      _.traceEvents = t0;
      _.type = t1;
      _.time = t2;
      _.parent = _._timeline_model$_frameId = null;
      _.children = t3;
      _.index = -1;
      _._depth = 0;
      _._level = _._trees$_root = null;
      _.isExpanded = false;
    },
    TimelineEvent_isUiEventFlow_closure: function TimelineEvent_isUiEventFlow_closure() {
    },
    TimelineEvent_isGpuEventFlow_closure: function TimelineEvent_isGpuEventFlow_closure() {
    },
    TimelineEvent_maybeRemoveDuplicate__maybeRemoveDuplicate: function TimelineEvent_maybeRemoveDuplicate__maybeRemoveDuplicate(t0) {
      this.$this = t0;
    },
    TimelineEvent_addChild__putChildInTree: function TimelineEvent_addChild__putChildInTree(t0) {
      this.child = t0;
    },
    TraceEvent: function TraceEvent(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.json = t0;
      _.name = t1;
      _.category = t2;
      _.phase = t3;
      _.threadId = t4;
      _.duration = t5;
      _.timestampMicros = t6;
      _.args = t7;
      _._type = null;
    },
    TraceEventWrapper: function TraceEventWrapper(t0, t1, t2) {
      this.event = t0;
      this.timeReceived = t1;
      this.id = t2;
    }
  },
  G = {
    get: function(url) {
      return G._withClient(new G.get_closure(url, null), U.Response0);
    },
    _withClient: function(fn, $T) {
      H.functionTypeCheck(fn, {func: 1, ret: [P.Future, $T], args: [U.Client]});
      return G._withClient$body(fn, $T, $T);
    },
    _withClient$body: function(fn, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], t1, client;
      var $async$_withClient = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              client = new O.BrowserClient(P.LinkedHashSet_LinkedHashSet(W.HttpRequest));
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait(fn.call$1(client), $async$_withClient);
            case 6:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              J.close$0$z(client);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_withClient, $async$completer);
    },
    get_closure: function get_closure(t0, t1) {
      this.url = t0;
      this.headers = t1;
    },
    BaseRequest: function BaseRequest() {
    },
    BaseRequest_closure: function BaseRequest_closure() {
    },
    BaseRequest_closure0: function BaseRequest_closure0() {
    },
    browser: function() {
      var t1 = $._browser;
      if (t1 == null) {
        $.Browser_navigator = new G._HtmlNavigator();
        t1 = $._browser = L.Browser_getCurrentBrowser();
      }
      return t1;
    },
    _HtmlNavigator: function _HtmlNavigator() {
    },
    NavigatorProvider: function NavigatorProvider() {
    },
    StartWithStreamTransformer__buildTransformer: function(startValue, $T) {
      return new P._StreamSubscriptionTransformer(new G.StartWithStreamTransformer__buildTransformer_closure(H.assertSubtypeOfRuntimeType(startValue, $T), $T), [$T, $T]);
    },
    StartWithStreamTransformer: function StartWithStreamTransformer(t0, t1) {
      this.transformer = t0;
      this.$ti = t1;
    },
    StartWithStreamTransformer__buildTransformer_closure: function StartWithStreamTransformer__buildTransformer_closure(t0, t1) {
      this.startValue = t0;
      this.T = t1;
    },
    StartWithStreamTransformer__buildTransformer__closure0: function StartWithStreamTransformer__buildTransformer__closure0(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.startValue = t1;
      _.input = t2;
      _.cancelOnError = t3;
    },
    StartWithStreamTransformer__buildTransformer__closure1: function StartWithStreamTransformer__buildTransformer__closure1(t0) {
      this._box_0 = t0;
    },
    StartWithStreamTransformer__buildTransformer__closure2: function StartWithStreamTransformer__buildTransformer__closure2(t0) {
      this._box_0 = t0;
    },
    StartWithStreamTransformer__buildTransformer__closure: function StartWithStreamTransformer__buildTransformer__closure(t0) {
      this._box_0 = t0;
    },
    SourceSpanFormatException$: function(message, span, _source) {
      return new G.SourceSpanFormatException(_source, message, span);
    },
    SourceSpanException: function SourceSpanException() {
    },
    SourceSpanFormatException: function SourceSpanFormatException(t0, t1, t2) {
      this._span_exception$_source = t0;
      this._span_exception$_message = t1;
      this._span = t2;
    }
  };
  var holders = [C, H, J, P, W, X, R, M, U, Y, B, O, L, A, F, S, V, N, D, Z, E, K, T, Q, G];
  hunkHelpers.setFunctionNamesIfNecessary(holders);
  var $ = {};
  H.JS_CONST.prototype = {};
  J.Interceptor.prototype = {
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return "Instance of '" + H.Primitives_objectTypeName(receiver) + "'";
    },
    noSuchMethod$1: function(receiver, invocation) {
      H.interceptedTypeCheck(invocation, "$isInvocation");
      throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    },
    get$runtimeType: function(receiver) {
      return H.getRuntimeType(receiver);
    }
  };
  J.JSBool.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $and: function(receiver, other) {
      return other && receiver;
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    get$runtimeType: function(receiver) {
      return C.Type_bool_lhE;
    },
    $isbool: 1
  };
  J.JSNull.prototype = {
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_Null_Yyn;
    },
    noSuchMethod$1: function(receiver, invocation) {
      return this.super$Interceptor$noSuchMethod(receiver, H.interceptedTypeCheck(invocation, "$isInvocation"));
    },
    $isNull: 1
  };
  J.JSObject.prototype = {};
  J.JavaScriptObject.prototype = {
    get$hashCode: function(receiver) {
      return 0;
    },
    get$runtimeType: function(receiver) {
      return C.Type_JSObject_8k0;
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isData: 1,
    $isLayout: 1,
    $isShape: 1,
    $isLegend: 1,
    $isAxisLayout: 1,
    $isDataEvent: 1,
    $isHoverFX: 1,
    $isSplitter: 1,
    get$value: function(obj) {
      return obj.value;
    },
    get$x: function(obj) {
      return obj.x;
    },
    get$y: function(obj) {
      return obj.y;
    },
    get$name: function(obj) {
      return obj.name;
    },
    set$visible: function(obj, v) {
      return obj.visible = v;
    },
    set$hoverinfo: function(obj, v) {
      return obj.hoverinfo = v;
    },
    get$shapes: function(obj) {
      return obj.shapes;
    },
    get$points: function(obj) {
      return obj.points;
    },
    get$curveNumber: function(obj) {
      return obj.curveNumber;
    },
    get$data: function(obj) {
      return obj.data;
    },
    get$pointNumber: function(obj) {
      return obj.pointNumber;
    },
    destroy$2: function(receiver, p0, p1) {
      return receiver.destroy(p0, p1);
    },
    destroy$0: function(receiver) {
      return receiver.destroy();
    }
  };
  J.PlainJavaScriptObject.prototype = {};
  J.UnknownJavaScriptObject.prototype = {};
  J.JavaScriptFunction.prototype = {
    toString$0: function(receiver) {
      var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
      if (dartClosure == null)
        return this.super$JavaScriptObject$toString(receiver);
      return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
    },
    $signature: function() {
      return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
    },
    $isFunction: 1
  };
  J.JSArray.prototype = {
    cast$1$0: function(receiver, $R) {
      return new H.CastList(receiver, [H.getTypeArgumentByIndex(receiver, 0), $R]);
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    },
    removeAt$1: function(receiver, index) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeAt"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.argumentErrorValue(index));
      if (index < 0 || index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index, null));
      return receiver.splice(index, 1)[0];
    },
    insert$2: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.argumentErrorValue(index));
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$value(index, null));
      receiver.splice(index, 0, value);
    },
    insertAll$2: function(receiver, index, iterable) {
      var t1, insertionLength, end;
      H.assertSubtype(iterable, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insertAll"));
      P.RangeError_checkValueInInterval(index, 0, receiver.length, "index");
      t1 = J.getInterceptor$(iterable);
      if (!t1.$isEfficientLengthIterable)
        iterable = t1.toList$0(iterable);
      insertionLength = J.get$length$asx(iterable);
      t1 = receiver.length;
      if (typeof insertionLength !== "number")
        return H.iae(insertionLength);
      this.set$length(receiver, t1 + insertionLength);
      end = index + insertionLength;
      this.setRange$4(receiver, end, receiver.length, receiver, index);
      this.setRange$3(receiver, index, end, iterable);
    },
    removeLast$0: function(receiver) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, -1));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    _removeWhere$2: function(receiver, test, removeMatching) {
      var retained, end, i, element, t1;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      retained = [];
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (!H.boolConversionCheck(test.call$1(element)))
          retained.push(element);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      t1 = retained.length;
      if (t1 === end)
        return;
      this.set$length(receiver, t1);
      for (i = 0; i < retained.length; ++i)
        receiver[i] = retained[i];
    },
    where$1: function(receiver, f) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      return new H.WhereIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: P.bool, args: [t1]}), [t1]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      H.assertSubtype(collection, "$isIterable", [H.getTypeArgumentByIndex(receiver, 0)], "$asIterable");
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("addAll"));
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        receiver.push(t1.get$current(t1));
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    forEach$1: function(receiver, f) {
      var end, i;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        f.call$1(receiver[i]);
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    join$1: function(receiver, separator) {
      var i,
        list = new Array(receiver.length);
      list.fixed$length = Array;
      for (i = 0; i < receiver.length; ++i)
        this.$indexSet(list, i, H.S(receiver[i]));
      return list.join(separator);
    },
    take$1: function(receiver, n) {
      return H.SubListIterable$(receiver, 0, n, H.getTypeArgumentByIndex(receiver, 0));
    },
    skip$1: function(receiver, n) {
      return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(receiver, 0));
    },
    fold$1$2: function(receiver, initialValue, combine, $T) {
      var $length, value, i;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getTypeArgumentByIndex(receiver, 0)]});
      $length = receiver.length;
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, receiver[i]);
        if (receiver.length !== $length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    firstWhere$2$orElse: function(receiver, test, orElse) {
      var end, i, element,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        element = receiver[i];
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return orElse.call$0();
    },
    lastWhere$2$orElse: function(receiver, test, orElse) {
      var $length, i, element,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      $length = receiver.length;
      for (i = $length - 1; i >= 0; --i) {
        element = receiver[i];
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
        if ($length !== receiver.length)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      if (orElse != null)
        return orElse.call$0();
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    sublist$2: function(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(H.IterableElementError_noElement());
    },
    removeRange$2: function(receiver, start, end) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      receiver.splice(start, end - start);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t2, otherStart, otherList, i,
        t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("setRange"));
      P.RangeError_checkValidRange(start, end, receiver.length);
      if (typeof end !== "number")
        return end.$sub();
      if (typeof start !== "number")
        return H.iae(start);
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      t2 = J.getInterceptor$(iterable);
      if (!!t2.$isList) {
        H.assertSubtype(iterable, "$isList", [t1], "$asList");
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = t2.skip$1(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      t2 = t1.get$length(otherList);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (otherStart + $length > t2)
        throw H.wrapException(H.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
      else
        for (i = 0; i < $length; ++i)
          receiver[start + i] = t1.$index(otherList, otherStart + i);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    any$1: function(receiver, test) {
      var end, i;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(receiver, 0)]});
      end = receiver.length;
      for (i = 0; i < end; ++i) {
        if (H.boolConversionCheck(test.call$1(receiver[i])))
          return true;
        if (receiver.length !== end)
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getTypeArgumentByIndex(receiver, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare, t1);
    },
    indexOf$1: function(receiver, element) {
      var i;
      if (0 >= receiver.length)
        return -1;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], element))
          return i;
      return -1;
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq$(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1 = H.setRuntimeTypeInfo(receiver.slice(0), [H.getTypeArgumentByIndex(receiver, 0)]);
      return t1;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$iterator: function(receiver) {
      return new J.ArrayIterator(receiver, receiver.length, [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      var _s9_ = "newLength";
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$value(newLength, _s9_, null));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$range(newLength, 0, null, _s9_, null));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(receiver, 0));
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      receiver[index] = value;
    },
    $add: function(receiver, other) {
      var t2, t3, totalLength,
        t1 = [H.getTypeArgumentByIndex(receiver, 0)];
      H.assertSubtype(other, "$isList", t1, "$asList");
      t2 = receiver.length;
      t3 = J.get$length$asx(other);
      if (typeof t3 !== "number")
        return H.iae(t3);
      totalLength = t2 + t3;
      t1 = H.setRuntimeTypeInfo([], t1);
      this.set$length(t1, totalLength);
      this.setRange$3(t1, 0, receiver.length, receiver);
      this.setRange$3(t1, receiver.length, totalLength, other);
      return t1;
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  J.JSUnmodifiableArray.prototype = {};
  J.ArrayIterator.prototype = {
    get$current: function(_) {
      return this._current;
    },
    moveNext$0: function() {
      var t2, _this = this,
        t1 = _this._iterable,
        $length = t1.length;
      if (_this.__interceptors$_length !== $length)
        throw H.wrapException(H.throwConcurrentModificationError(t1));
      t2 = _this._index;
      if (t2 >= $length) {
        _this.set$_current(null);
        return false;
      }
      _this.set$_current(t1[t2]);
      ++_this._index;
      return true;
    },
    set$_current: function(_current) {
      this._current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  J.JSNumber.prototype = {
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      H.numTypeCheck(b);
      if (typeof b !== "number")
        throw H.wrapException(H.argumentErrorValue(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".toInt()"));
    },
    ceil$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated + 1;
        }
      } else if (receiver >= -2147483648)
        return receiver | 0;
      d = Math.ceil(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".ceil()"));
    },
    floor$0: function(receiver) {
      var truncated, d;
      if (receiver >= 0) {
        if (receiver <= 2147483647)
          return receiver | 0;
      } else if (receiver >= -2147483648) {
        truncated = receiver | 0;
        return receiver === truncated ? truncated : truncated - 1;
      }
      d = Math.floor(receiver);
      if (isFinite(d))
        return d;
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
    },
    round$0: function(receiver) {
      if (receiver > 0) {
        if (receiver !== 1 / 0)
          return Math.round(receiver);
      } else if (receiver > -1 / 0)
        return 0 - Math.round(0 - receiver);
      throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
    },
    clamp$2: function(receiver, lowerLimit, upperLimit) {
      if (C.JSInt_methods.compareTo$1(lowerLimit, upperLimit) > 0)
        throw H.wrapException(H.argumentErrorValue(lowerLimit));
      if (this.compareTo$1(receiver, lowerLimit) < 0)
        return lowerLimit;
      if (this.compareTo$1(receiver, upperLimit) > 0)
        return upperLimit;
      return receiver;
    },
    toStringAsFixed$1: function(receiver, fractionDigits) {
      var result;
      if (fractionDigits > 20)
        throw H.wrapException(P.RangeError$range(fractionDigits, 0, 20, "fractionDigits", null));
      result = receiver.toFixed(fractionDigits);
      if (receiver === 0 && this.get$isNegative(receiver))
        return "-" + result;
      return result;
    },
    toRadixString$1: function(receiver, radix) {
      var result, match, t1, exponent;
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      result = receiver.toString(radix);
      if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
        return result;
      match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
      if (match == null)
        H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
      t1 = match.length;
      if (1 >= t1)
        return H.ioore(match, 1);
      result = match[1];
      if (3 >= t1)
        return H.ioore(match, 3);
      exponent = +match[3];
      t1 = match[2];
      if (t1 != null) {
        result += t1;
        exponent -= t1.length;
      }
      return result + C.JSString_methods.$mul("0", exponent);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      var absolute, floorLog2, factor, scaled,
        intValue = receiver | 0;
      if (receiver === intValue)
        return 536870911 & intValue;
      absolute = Math.abs(receiver);
      floorLog2 = Math.log(absolute) / 0.6931471805599453 | 0;
      factor = Math.pow(2, floorLog2);
      scaled = absolute < 1 ? absolute / factor : factor / absolute;
      return 536870911 & ((scaled * 9007199254740992 | 0) + (scaled * 3542243181176521 | 0)) * 599197 + floorLog2 * 1259;
    },
    $add: function(receiver, other) {
      H.numTypeCheck(other);
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver + other;
    },
    $div: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver / other;
    },
    $mod: function(receiver, other) {
      var result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver)
        if (other >= 1 || other < -1)
          return receiver / other | 0;
      return this._tdivSlow$1(receiver, other);
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
    },
    _tdivSlow$1: function(receiver, other) {
      var quotient = receiver / other;
      if (quotient >= -2147483648 && quotient <= 2147483647)
        return quotient | 0;
      if (quotient > 0) {
        if (quotient !== 1 / 0)
          return Math.floor(quotient);
      } else if (quotient > -1 / 0)
        return Math.ceil(quotient);
      throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + H.S(other)));
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = this._shrBothPositive$1(receiver, other);
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(H.argumentErrorValue(other));
      return this._shrBothPositive$1(receiver, other);
    },
    _shrBothPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver >>> other;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(H.argumentErrorValue(other));
      return receiver < other;
    },
    get$runtimeType: function(receiver) {
      return C.Type_num_cv7;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.num];
    },
    $isdouble: 1,
    $isnum: 1
  };
  J.JSInt.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_int_tHn;
    },
    $isint: 1
  };
  J.JSDouble.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_double_K1J;
    }
  };
  J.JSString.prototype = {
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      if (index >= receiver.length)
        H.throwExpression(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    _codeUnitAt$1: function(receiver, index) {
      if (index >= receiver.length)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return new H._StringAllMatchesIterable(string, receiver, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, i;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      t1 = receiver.length;
      if (start + t1 > string.length)
        return;
      for (i = 0; i < t1; ++i)
        if (this.codeUnitAt$1(string, start + i) !== this._codeUnitAt$1(receiver, i))
          return;
      return new H.StringMatch(start, receiver);
    },
    $add: function(receiver, other) {
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$value(other, null, null));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      if (typeof other !== "string")
        H.throwExpression(H.argumentErrorValue(other));
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    splitMapJoin$2$onMatch: function(receiver, from, onMatch) {
      return H.stringReplaceAllFuncUnchecked(receiver, from, H.functionTypeCheck(onMatch, {func: 1, ret: P.String, args: [P.Match]}), null);
    },
    replaceFirst$2: function(receiver, from, to) {
      P.RangeError_checkValueInInterval(0, 0, receiver.length, "startIndex");
      return H.stringReplaceFirstUnchecked(receiver, from, to, 0);
    },
    split$1: function(receiver, pattern) {
      var t1 = H.setRuntimeTypeInfo(receiver.split(pattern), [P.String]);
      return t1;
    },
    replaceRange$3: function(receiver, start, end, replacement) {
      end = P.RangeError_checkValidRange(start, end, receiver.length);
      if (typeof end !== "number" || Math.floor(end) !== end)
        H.throwExpression(H.argumentErrorValue(end));
      return H.stringReplaceRangeUnchecked(receiver, start, end, replacement);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (typeof index !== "number" || Math.floor(index) !== index)
        H.throwExpression(H.argumentErrorValue(index));
      if (typeof index !== "number")
        return index.$lt();
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
        H.throwExpression(H.argumentErrorValue(startIndex));
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof startIndex !== "number")
        return startIndex.$lt();
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex, null));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex, null));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var startIndex, t1, endIndex0,
        result = receiver.trim(),
        endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this._codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    trimLeft$0: function(receiver) {
      var result, startIndex;
      if (typeof receiver.trimLeft != "undefined") {
        result = receiver.trimLeft();
        if (result.length === 0)
          return result;
        startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
      } else {
        startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
        result = receiver;
      }
      if (startIndex === 0)
        return result;
      if (startIndex === result.length)
        return "";
      return result.substring(startIndex);
    },
    trimRight$0: function(receiver) {
      var result, endIndex, t1;
      if (typeof receiver.trimRight != "undefined") {
        result = receiver.trimRight();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        t1 = endIndex - 1;
        if (this.codeUnitAt$1(result, t1) === 133)
          endIndex = J.JSString__skipTrailingWhitespace(result, t1);
      } else {
        endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
        result = receiver;
      }
      if (endIndex === result.length)
        return result;
      if (endIndex === 0)
        return "";
      return result.substring(0, endIndex);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    padLeft$2: function(receiver, width, padding) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return this.$mul(padding, delta) + receiver;
    },
    padLeft$1: function($receiver, width) {
      return this.padLeft$2($receiver, width, " ");
    },
    padRight$1: function(receiver, width) {
      var delta = width - receiver.length;
      if (delta <= 0)
        return receiver;
      return receiver + this.$mul(" ", delta);
    },
    indexOf$2: function(receiver, pattern, start) {
      var t1;
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      t1 = receiver.indexOf(pattern, start);
      return t1;
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$2: function(receiver, pattern, start) {
      var t1, t2, i;
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      if (start == null)
        start = receiver.length;
      else if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
      if (typeof pattern === "string") {
        t1 = pattern.length;
        t2 = receiver.length;
        if (start + t1 > t2)
          start = t2 - t1;
        return receiver.lastIndexOf(pattern, start);
      }
      for (t1 = J.getInterceptor$s(pattern), i = start; i >= 0; --i)
        if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
          return i;
      return -1;
    },
    lastIndexOf$1: function($receiver, pattern) {
      return this.lastIndexOf$2($receiver, pattern, null);
    },
    contains$2: function(receiver, other, startIndex) {
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    compareTo$1: function(receiver, other) {
      var t1;
      H.stringTypeCheck(other);
      if (typeof other !== "string")
        throw H.wrapException(H.argumentErrorValue(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    get$runtimeType: function(receiver) {
      return C.Type_String_k8F;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >= receiver.length || index < 0)
        throw H.wrapException(H.diagnoseIndexError(receiver, index));
      return receiver[index];
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1,
    $isString: 1
  };
  H.CastStream.prototype = {
    get$isBroadcast: function() {
      return this._source.get$isBroadcast();
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2;
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 1)]});
      t1 = this._source.listen$3$cancelOnError$onDone(null, cancelOnError, H.functionTypeCheck(onDone, {func: 1, ret: -1}));
      t2 = new H.CastStreamSubscription(t1, $.Zone__current, this.$ti);
      t1.onData$1(t2.get$__internal$_onData());
      t2.onData$1(onData);
      t2.onError$1(0, onError);
      return t2;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    cast$1$0: function(_, $R) {
      return new H.CastStream(this._source, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  };
  H.CastStreamSubscription.prototype = {
    cancel$0: function(_) {
      return this._source.cancel$0(0);
    },
    onData$1: function(handleData) {
      var t1 = H.getTypeArgumentByIndex(this, 1);
      H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [t1]});
      this.set$__internal$_handleData(handleData == null ? null : this.__internal$_zone.registerUnaryCallback$2$1(handleData, null, t1));
    },
    onError$1: function(_, handleError) {
      var t1, t2, _this = this;
      _this._source.onError$1(0, handleError);
      if (handleError == null)
        _this.__internal$_handleError = null;
      else {
        t1 = P.Object;
        t2 = _this.__internal$_zone;
        if (H.functionTypeTest(handleError, {func: 1, args: [P.Null, P.Null]}))
          _this.__internal$_handleError = t2.registerBinaryCallback$3$1(H.functionTypeCheck(handleError, {func: 1, args: [P.Object, P.StackTrace]}), null, t1, P.StackTrace);
        else
          _this.__internal$_handleError = t2.registerUnaryCallback$2$1(H.functionTypeCheck(handleError, {func: 1, args: [P.Object]}), null, t1);
      }
    },
    onDone$1: function(handleDone) {
      this._source.onDone$1(H.functionTypeCheck(handleDone, {func: 1, ret: -1}));
    },
    __internal$_onData$1: function(data) {
      var targetData, error, stack, t1, exception, t2, t3, t4, _this = this;
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this.__internal$_handleData;
      if (t1 == null)
        return;
      targetData = null;
      try {
        targetData = H.subtypeOfRuntimeTypeCast(data, H.getTypeArgumentByIndex(_this, 1));
      } catch (exception) {
        error = H.unwrapException(exception);
        stack = H.getTraceFromException(exception);
        t1 = _this.__internal$_handleError;
        if (t1 == null)
          _this.__internal$_zone.handleUncaughtError$2(error, stack);
        else {
          t2 = H.functionTypeTest(t1, {func: 1, args: [P.Null, P.Null]});
          t3 = _this.__internal$_zone;
          t4 = _this.__internal$_handleError;
          if (t2)
            t3.runBinaryGuarded$2$3(H.functionTypeCheck(t4, {func: 1, ret: -1, args: [, P.StackTrace]}), error, stack, null, P.StackTrace);
          else
            t3.runUnaryGuarded$1$2(H.functionTypeCheck(t4, {func: 1, ret: -1, args: [,]}), error, null);
        }
        return;
      }
      _this.__internal$_zone.runUnaryGuarded$1$2(t1, targetData, H.getTypeArgumentByIndex(_this, 1));
    },
    pause$1: function(_, resumeSignal) {
      this._source.pause$1(0, resumeSignal);
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function(_) {
      this._source.resume$0(0);
    },
    set$__internal$_handleData: function(_handleData) {
      this.__internal$_handleData = H.functionTypeCheck(_handleData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 1)]});
    },
    $isStreamSubscription: 1,
    $asStreamSubscription: function($S, $T) {
      return [$T];
    }
  };
  H._CastIterableBase.prototype = {
    get$iterator: function(_) {
      return new H.CastIterator(J.get$iterator$ax(this.get$_source()), this.$ti);
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$_source());
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.get$_source());
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this.get$_source());
    },
    skip$1: function(_, count) {
      return H.CastIterable_CastIterable(J.skip$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    take$1: function(_, count) {
      return H.CastIterable_CastIterable(J.take$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    elementAt$1: function(_, index) {
      return H.subtypeOfRuntimeTypeCast(J.elementAt$1$ax(this.get$_source(), index), H.getTypeArgumentByIndex(this, 1));
    },
    get$first: function(_) {
      return H.subtypeOfRuntimeTypeCast(J.get$first$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
    },
    get$last: function(_) {
      return H.subtypeOfRuntimeTypeCast(J.get$last$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
    },
    contains$1: function(_, other) {
      return J.contains$1$asx(this.get$_source(), other);
    },
    toString$0: function(_) {
      return J.toString$0$(this.get$_source());
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.CastIterator.prototype = {
    moveNext$0: function() {
      return this._source.moveNext$0();
    },
    get$current: function(_) {
      var t1 = this._source;
      return H.subtypeOfRuntimeTypeCast(t1.get$current(t1), H.getTypeArgumentByIndex(this, 1));
    },
    $isIterator: 1,
    $asIterator: function($S, $T) {
      return [$T];
    }
  };
  H.CastIterable.prototype = {
    cast$1$0: function(_, $R) {
      return H.CastIterable_CastIterable(this._source, H.getTypeArgumentByIndex(this, 0), $R);
    },
    get$_source: function() {
      return this._source;
    }
  };
  H._EfficientLengthCastIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H._CastListBase.prototype = {
    $index: function(_, index) {
      return H.subtypeOfRuntimeTypeCast(J.$index$asx(this._source, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 1));
    },
    $indexSet: function(_, index, value) {
      J.$indexSet$ax(this._source, H.intTypeCheck(index), H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
    },
    set$length: function(_, $length) {
      J.set$length$asx(this._source, $length);
    },
    add$1: function(_, value) {
      J.add$1$ax(this._source, H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
    },
    sort$1: function(_, compare) {
      var t1 = H.getTypeArgumentByIndex(this, 1);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      t1 = compare == null ? null : new H._CastListBase_sort_closure(this, compare);
      J.sort$1$ax(this._source, t1);
    },
    insert$2: function(_, index, element) {
      J.insert$2$ax(this._source, index, H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
    },
    remove$1: function(_, value) {
      return J.remove$1$ax(this._source, value);
    },
    removeAt$1: function(_, index) {
      return H.subtypeOfRuntimeTypeCast(J.removeAt$1$ax(this._source, index), H.getTypeArgumentByIndex(this, 1));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      var t1 = H.getTypeArgumentByIndex(this, 1);
      J.setRange$4$ax(this._source, start, end, H.CastIterable_CastIterable(H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable"), t1, H.getTypeArgumentByIndex(this, 0)), skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListMixin: function($S, $T) {
      return [$T];
    },
    $isList: 1,
    $asList: function($S, $T) {
      return [$T];
    }
  };
  H._CastListBase_sort_closure.prototype = {
    call$2: function(v1, v2) {
      var t1 = this.$this,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      H.assertSubtypeOfRuntimeType(v1, t2);
      H.assertSubtypeOfRuntimeType(v2, t2);
      t1 = H.getTypeArgumentByIndex(t1, 1);
      return this.compare.call$2(H.subtypeOfRuntimeTypeCast(v1, t1), H.subtypeOfRuntimeTypeCast(v2, t1));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  H.CastList.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastList(this._source, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CastSet.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastSet(this._source, this._emptySet, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    add$1: function(_, value) {
      return this._source.add$1(0, H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)), H.getTypeArgumentByIndex(this, 0)));
    },
    remove$1: function(_, object) {
      return this._source.remove$1(0, object);
    },
    removeWhere$1: function(_, test) {
      this._source.removeWhere$1(0, new H.CastSet_removeWhere_closure(this, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this, 1)]})));
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $isSet: 1,
    $asSet: function($S, $T) {
      return [$T];
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CastSet_removeWhere_closure.prototype = {
    call$1: function(element) {
      var t1 = this.$this;
      return this.test.call$1(H.subtypeOfRuntimeTypeCast(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(t1, 0)), H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  H.CastQueue.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastQueue(this._source, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $isQueue: 1,
    $asQueue: function($S, $T) {
      return [$T];
    },
    get$_source: function() {
      return this._source;
    }
  };
  H.CodeUnits.prototype = {
    get$length: function(_) {
      return this.__internal$_string.length;
    },
    $index: function(_, i) {
      return C.JSString_methods.codeUnitAt$1(this.__internal$_string, H.intTypeCheck(i));
    },
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asUnmodifiableListMixin: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $asIterable: function() {
      return [P.int];
    },
    $asList: function() {
      return [P.int];
    }
  };
  H.EfficientLengthIterable.prototype = {};
  H.ListIterable.prototype = {
    get$iterator: function(_) {
      var _this = this;
      return new H.ListIterator(_this, _this.get$length(_this), [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$first: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last: function(_) {
      var t1, _this = this;
      if (_this.get$length(_this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = _this.get$length(_this);
      if (typeof t1 !== "number")
        return t1.$sub();
      return _this.elementAt$1(0, t1 - 1);
    },
    contains$1: function(_, element) {
      var i, _this = this,
        $length = _this.get$length(_this);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq$(_this.elementAt$1(0, i), element))
          return true;
        if ($length !== _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return false;
    },
    join$1: function(_, separator) {
      var first, t1, i, _this = this,
        $length = _this.get$length(_this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(_this.elementAt$1(0, 0));
        if ($length != _this.get$length(_this))
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = first;
        i = 1;
        for (; i < $length; ++i) {
          t1 = t1 + separator + H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      } else {
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        t1 = "";
        for (; i < $length; ++i) {
          t1 += H.S(_this.elementAt$1(0, i));
          if ($length !== _this.get$length(_this))
            throw H.wrapException(P.ConcurrentModificationError$(_this));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    where$1: function(_, test) {
      return this.super$Iterable$where(0, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "ListIterable", 0)]}));
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
      return new H.MappedListIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    skip$1: function(_, count) {
      return H.SubListIterable$(this, count, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    take$1: function(_, count) {
      return H.SubListIterable$(this, 0, count, H.getRuntimeTypeArgument(this, "ListIterable", 0));
    },
    toList$1$growable: function(_, growable) {
      var i, t1, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(_this, "ListIterable", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      i = 0;
      while (true) {
        t1 = _this.get$length(_this);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        C.JSArray_methods.$indexSet(result, i, _this.elementAt$1(0, i));
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.SubListIterable.prototype = {
    get$_endIndex: function() {
      var t2,
        $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._endOrLength;
      if (t1 != null) {
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = t1 > $length;
      } else
        t2 = true;
      if (t2)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var t2,
        $length = J.get$length$asx(this.__internal$_iterable),
        t1 = this._start;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 == null || t2 >= $length)
        return $length - t1;
      if (typeof t2 !== "number")
        return t2.$sub();
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var realIndex, _this = this,
        t1 = _this.get$_startIndex();
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof index !== "number")
        return H.iae(index);
      realIndex = t1 + index;
      if (index >= 0) {
        t1 = _this.get$_endIndex();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = realIndex >= t1;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.IndexError$(index, _this, "index", null, null));
      return J.elementAt$1$ax(_this.__internal$_iterable, realIndex);
    },
    skip$1: function(_, count) {
      var newStart, t1, _this = this;
      P.RangeError_checkNotNegative(count, "count");
      newStart = _this._start + count;
      t1 = _this._endOrLength;
      if (t1 != null && newStart >= t1)
        return new H.EmptyIterable(_this.$ti);
      return H.SubListIterable$(_this.__internal$_iterable, newStart, t1, H.getTypeArgumentByIndex(_this, 0));
    },
    take$1: function(_, count) {
      var t1, t2, newEnd, _this = this;
      P.RangeError_checkNotNegative(count, "count");
      t1 = _this._endOrLength;
      t2 = _this._start;
      newEnd = t2 + count;
      if (t1 == null)
        return H.SubListIterable$(_this.__internal$_iterable, t2, newEnd, H.getTypeArgumentByIndex(_this, 0));
      else {
        if (t1 < newEnd)
          return _this;
        return H.SubListIterable$(_this.__internal$_iterable, t2, newEnd, H.getTypeArgumentByIndex(_this, 0));
      }
    },
    toList$1$growable: function(_, growable) {
      var t3, $length, result, t4, i, _this = this,
        start = _this._start,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        end = t2.get$length(t1),
        end0 = _this._endOrLength;
      if (end0 != null) {
        if (typeof end !== "number")
          return H.iae(end);
        t3 = end0 < end;
      } else
        t3 = false;
      if (t3)
        end = end0;
      if (typeof end !== "number")
        return end.$sub();
      $length = end - start;
      if ($length < 0)
        $length = 0;
      t3 = _this.$ti;
      if (growable) {
        result = H.setRuntimeTypeInfo([], t3);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t4 = new Array($length);
        t4.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t4, t3);
      }
      for (i = 0; i < $length; ++i) {
        C.JSArray_methods.$indexSet(result, i, t2.elementAt$1(t1, start + i));
        t3 = t2.get$length(t1);
        if (typeof t3 !== "number")
          return t3.$lt();
        if (t3 < end)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.ListIterator.prototype = {
    get$current: function(_) {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t3, _this = this,
        t1 = _this.__internal$_iterable,
        t2 = J.getInterceptor$asx(t1),
        $length = t2.get$length(t1);
      if (_this.__internal$_length != $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = _this.__internal$_index;
      if (typeof $length !== "number")
        return H.iae($length);
      if (t3 >= $length) {
        _this.set$__internal$_current(null);
        return false;
      }
      _this.set$__internal$_current(t2.elementAt$1(t1, t3));
      ++_this.__internal$_index;
      return true;
    },
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.MappedIterable.prototype = {
    get$iterator: function(_) {
      return new H.MappedIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti);
    },
    get$length: function(_) {
      return J.get$length$asx(this.__internal$_iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this.__internal$_iterable);
    },
    get$first: function(_) {
      return this._f.call$1(J.get$first$ax(this.__internal$_iterable));
    },
    get$last: function(_) {
      return this._f.call$1(J.get$last$ax(this.__internal$_iterable));
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, index));
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.EfficientLengthMappedIterable.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    }
  };
  H.MappedIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._iterator;
      if (t1.moveNext$0()) {
        _this.set$__internal$_current(_this._f.call$1(t1.get$current(t1)));
        return true;
      }
      _this.set$__internal$_current(null);
      return false;
    },
    get$current: function(_) {
      return this.__internal$_current;
    },
    set$__internal$_current: function(_current) {
      this.__internal$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  };
  H.MappedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f.call$1(J.elementAt$1$ax(this._source, index));
    },
    $asEfficientLengthIterable: function($S, $T) {
      return [$T];
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  };
  H.WhereIterable.prototype = {
    get$iterator: function(_) {
      return new H.WhereIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    }
  };
  H.WhereIterator.prototype = {
    moveNext$0: function() {
      var t1, t2;
      for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
        if (H.boolConversionCheck(t2.call$1(t1.get$current(t1))))
          return true;
      return false;
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.TakeIterable.prototype = {
    get$iterator: function(_) {
      return new H.TakeIterator(J.get$iterator$ax(this.__internal$_iterable), this._takeCount, this.$ti);
    }
  };
  H.EfficientLengthTakeIterable.prototype = {
    get$length: function(_) {
      var iterableLength = J.get$length$asx(this.__internal$_iterable),
        t1 = this._takeCount;
      if (typeof iterableLength !== "number")
        return iterableLength.$gt();
      if (iterableLength > t1)
        return t1;
      return iterableLength;
    },
    $isEfficientLengthIterable: 1
  };
  H.TakeIterator.prototype = {
    moveNext$0: function() {
      if (--this._remaining >= 0)
        return this._iterator.moveNext$0();
      this._remaining = -1;
      return false;
    },
    get$current: function(_) {
      var t1;
      if (this._remaining < 0)
        return;
      t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.SkipIterable.prototype = {
    skip$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return new H.SkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    get$iterator: function(_) {
      return new H.SkipIterator(J.get$iterator$ax(this.__internal$_iterable), this._skipCount, this.$ti);
    }
  };
  H.EfficientLengthSkipIterable.prototype = {
    get$length: function(_) {
      var $length,
        t1 = J.get$length$asx(this.__internal$_iterable);
      if (typeof t1 !== "number")
        return t1.$sub();
      $length = t1 - this._skipCount;
      if ($length >= 0)
        return $length;
      return 0;
    },
    skip$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return new H.EfficientLengthSkipIterable(this.__internal$_iterable, this._skipCount + count, this.$ti);
    },
    $isEfficientLengthIterable: 1
  };
  H.SkipIterator.prototype = {
    moveNext$0: function() {
      var t1, i;
      for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
        t1.moveNext$0();
      this._skipCount = 0;
      return t1.moveNext$0();
    },
    get$current: function(_) {
      var t1 = this._iterator;
      return t1.get$current(t1);
    }
  };
  H.EmptyIterable.prototype = {
    get$iterator: function(_) {
      return C.C_EmptyIterator;
    },
    get$isEmpty: function(_) {
      return true;
    },
    get$length: function(_) {
      return 0;
    },
    get$first: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    get$last: function(_) {
      throw H.wrapException(H.IterableElementError_noElement());
    },
    elementAt$1: function(_, index) {
      throw H.wrapException(P.RangeError$range(index, 0, 0, "index", null));
    },
    contains$1: function(_, element) {
      return false;
    },
    join$1: function(_, separator) {
      return "";
    },
    map$1$1: function(_, f, $T) {
      H.functionTypeCheck(f, {func: 1, ret: $T, args: [H.getTypeArgumentByIndex(this, 0)]});
      return new H.EmptyIterable([$T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    skip$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return this;
    },
    take$1: function(_, count) {
      P.RangeError_checkNotNegative(count, "count");
      return this;
    },
    toList$1$growable: function(_, growable) {
      var t2,
        t1 = this.$ti;
      if (growable)
        t1 = H.setRuntimeTypeInfo([], t1);
      else {
        t2 = new Array(0);
        t2.fixed$length = Array;
        t1 = H.setRuntimeTypeInfo(t2, t1);
      }
      return t1;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    }
  };
  H.EmptyIterator.prototype = {
    moveNext$0: function() {
      return false;
    },
    get$current: function(_) {
      return;
    },
    $isIterator: 1
  };
  H.FixedLengthListMixin.prototype = {
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    insert$2: function(receiver, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "FixedLengthListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    remove$1: function(receiver, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    clear$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear a fixed-length list"));
    },
    removeAt$1: function(receiver, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  };
  H.UnmodifiableListMixin.prototype = {
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: function(_, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    insert$2: function(_, index, element) {
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    remove$1: function(_, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    sort$1: function(_, compare) {
      var t1 = H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear an unmodifiable list"));
    },
    removeAt$1: function(_, index) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgument(this, "UnmodifiableListMixin", 0)], "$asIterable");
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    }
  };
  H.UnmodifiableListBase.prototype = {};
  H.ReversedListIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1 = this._source,
        t2 = J.getInterceptor$asx(t1),
        t3 = t2.get$length(t1);
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof index !== "number")
        return H.iae(index);
      return t2.elementAt$1(t1, t3 - 1 - index);
    }
  };
  H.Symbol.prototype = {
    get$hashCode: function(_) {
      var hash = this._hashCode;
      if (hash != null)
        return hash;
      hash = 536870911 & 664597 * J.get$hashCode$(this.__internal$_name);
      this._hashCode = hash;
      return hash;
    },
    toString$0: function(_) {
      return 'Symbol("' + H.S(this.__internal$_name) + '")';
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.Symbol && this.__internal$_name == other.__internal$_name;
    },
    $isSymbol0: 1
  };
  H.__CastListBase__CastIterableBase_ListMixin.prototype = {};
  H.ConstantMapView.prototype = {};
  H.ConstantMap.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    $indexSet: function(_, key, val) {
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtypeOfRuntimeType(val, H.getTypeArgumentByIndex(this, 1));
      return H.ConstantMap__throwUnmodifiable();
    },
    get$entries: function(_) {
      return this.entries$body$ConstantMap(_, [P.MapEntry, H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]);
    },
    entries$body$ConstantMap: function($async$_, $async$type) {
      var $async$self = this;
      return P._makeSyncStarIterable(function() {
        var _ = $async$_;
        var $async$goto = 0, $async$handler = 1, $async$currentError, t1, t2, key;
        return function $async$get$entries($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.get$keys($async$self), t1 = t1.get$iterator(t1), t2 = $async$self.$ti;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                key = t1.get$current(t1);
                $async$goto = 4;
                return new P.MapEntry(key, $async$self.$index(0, key), t2);
              case 4:
                // after yield
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._IterationMarker_endOfIteration();
              case 1:
                // rethrow
                return P._IterationMarker_uncaughtError($async$currentError);
            }
        };
      }, $async$type);
    },
    map$2$1: function(_, transform, K2, V2) {
      var _this = this,
        result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
      _this.forEach$1(0, new H.ConstantMap_map_closure(_this, H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1)]}), result));
      return result;
    },
    map$1: function($receiver, transform) {
      return this.map$2$1($receiver, transform, null, null);
    },
    $isMap: 1
  };
  H.ConstantMap_map_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this,
        entry = this.transform.call$2(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
      this.result.$indexSet(0, entry.key, entry.value);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  H.ConstantStringMap.prototype = {
    get$length: function(_) {
      return this._length;
    },
    containsKey$1: function(_, key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this.__js_helper$_jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(0, key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this.__js_helper$_jsObject[H.stringTypeCheck(key)];
    },
    forEach$1: function(_, f) {
      var keys, t2, i, key, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 1);
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), t1]});
      keys = _this.__js_helper$_keys;
      for (t2 = keys.length, i = 0; i < t2; ++i) {
        key = keys[i];
        f.call$2(key, H.assertSubtypeOfRuntimeType(_this._fetch$1(key), t1));
      }
    },
    get$keys: function(_) {
      return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this.__js_helper$_keys, new H.ConstantStringMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    }
  };
  H.ConstantStringMap_values_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this;
      return H.assertSubtypeOfRuntimeType(t1._fetch$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0))), H.getTypeArgumentByIndex(t1, 1));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H._ConstantMapKeyIterable.prototype = {
    get$iterator: function(_) {
      var t1 = this._map.__js_helper$_keys;
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$length: function(_) {
      return this._map.__js_helper$_keys.length;
    }
  };
  H.GeneralConstantMap.prototype = {
    _getMap$0: function() {
      var _this = this,
        backingMap = _this.$map;
      if (backingMap == null) {
        backingMap = new H.JsLinkedHashMap(_this.$ti);
        H.fillLiteralMap(_this._jsData, backingMap);
        _this.$map = backingMap;
      }
      return backingMap;
    },
    containsKey$1: function(_, key) {
      return this._getMap$0().containsKey$1(0, key);
    },
    $index: function(_, key) {
      return this._getMap$0().$index(0, key);
    },
    forEach$1: function(_, f) {
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]});
      this._getMap$0().forEach$1(0, f);
    },
    get$keys: function(_) {
      var t1 = this._getMap$0();
      return t1.get$keys(t1);
    },
    get$values: function(_) {
      var t1 = this._getMap$0();
      return t1.get$values(t1);
    },
    get$length: function(_) {
      var t1 = this._getMap$0();
      return t1.get$length(t1);
    }
  };
  H.Instantiation.prototype = {
    Instantiation$1: function(_genericClosure) {
      if (false)
        H.instantiatedGenericFunctionType(0, 0);
    },
    toString$0: function(_) {
      var types = "<" + C.JSArray_methods.join$1([new H.TypeImpl(H.getTypeArgumentByIndex(this, 0))], ", ") + ">";
      return H.S(this._genericClosure) + " with " + types;
    }
  };
  H.Instantiation1.prototype = {
    call$1: function(a0) {
      return this._genericClosure.call$1$1(a0, this.$ti[0]);
    },
    call$0: function() {
      return this._genericClosure.call$1$0(this.$ti[0]);
    },
    call$4: function(a0, a1, a2, a3) {
      return this._genericClosure.call$1$4(a0, a1, a2, a3, this.$ti[0]);
    },
    $signature: function() {
      return H.instantiatedGenericFunctionType(H.extractFunctionTypeObjectFromInternal(this._genericClosure), this.$ti);
    }
  };
  H.JSInvocationMirror.prototype = {
    get$memberName: function() {
      var t1 = this._memberName;
      return t1;
    },
    get$positionalArguments: function() {
      var t1, argumentCount, list, index, _this = this;
      if (_this._kind === 1)
        return C.List_empty;
      t1 = _this._arguments;
      argumentCount = t1.length - _this._namedArgumentNames.length - _this._typeArgumentCount;
      if (argumentCount === 0)
        return C.List_empty;
      list = [];
      for (index = 0; index < argumentCount; ++index) {
        if (index >= t1.length)
          return H.ioore(t1, index);
        list.push(t1[index]);
      }
      return J.JSArray_markUnmodifiableList(list);
    },
    get$namedArguments: function() {
      var t1, namedArgumentCount, t2, namedArgumentsStartIndex, t3, map, i, t4, t5, _this = this;
      if (_this._kind !== 0)
        return C.Map_empty;
      t1 = _this._namedArgumentNames;
      namedArgumentCount = t1.length;
      t2 = _this._arguments;
      namedArgumentsStartIndex = t2.length - namedArgumentCount - _this._typeArgumentCount;
      if (namedArgumentCount === 0)
        return C.Map_empty;
      t3 = P.Symbol0;
      map = new H.JsLinkedHashMap([t3, null]);
      for (i = 0; i < namedArgumentCount; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t4 = t1[i];
        t5 = namedArgumentsStartIndex + i;
        if (t5 < 0 || t5 >= t2.length)
          return H.ioore(t2, t5);
        map.$indexSet(0, new H.Symbol(t4), t2[t5]);
      }
      return new H.ConstantMapView(map, [t3, null]);
    },
    $isInvocation: 1
  };
  H.Primitives_initTicker_closure.prototype = {
    call$0: function() {
      return C.JSNumber_methods.floor$0(1000 * this.performance.now());
    },
    $signature: 102
  };
  H.Primitives_functionNoSuchMethod_closure.prototype = {
    call$2: function($name, argument) {
      var t1;
      H.stringTypeCheck($name);
      t1 = this._box_0;
      t1.names = t1.names + "$" + H.S($name);
      C.JSArray_methods.add$1(this.namedArgumentList, $name);
      C.JSArray_methods.add$1(this.$arguments, argument);
      ++t1.argumentCount;
    },
    $signature: 25
  };
  H.TypeErrorDecoder.prototype = {
    matchTypeError$1: function(message) {
      var result, t1, _this = this,
        match = new RegExp(_this._pattern).exec(message);
      if (match == null)
        return;
      result = Object.create(null);
      t1 = _this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = _this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = _this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = _this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = _this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    }
  };
  H.NullError.prototype = {
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      return "NoSuchMethodError: method not found: '" + t1 + "' on null";
    }
  };
  H.JsNoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t2, _this = this,
        _s38_ = "NoSuchMethodError: method not found: '",
        t1 = _this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(_this._message);
      t2 = _this._receiver;
      if (t2 == null)
        return _s38_ + t1 + "' (" + H.S(_this._message) + ")";
      return _s38_ + t1 + "' on '" + t2 + "' (" + H.S(_this._message) + ")";
    }
  };
  H.UnknownJsTypeError.prototype = {
    toString$0: function(_) {
      var t1 = this._message;
      return t1.length === 0 ? "Error" : "Error: " + t1;
    }
  };
  H.ExceptionAndStackTrace.prototype = {};
  H.unwrapException_saveStackTrace.prototype = {
    call$1: function(error) {
      if (!!J.getInterceptor$(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex;
      return error;
    },
    $signature: 4
  };
  H._StackTrace.prototype = {
    toString$0: function(_) {
      var trace,
        t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
      return this._trace = trace == null ? "" : trace;
    },
    $isStackTrace: 1
  };
  H.Closure.prototype = {
    toString$0: function(_) {
      return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
    },
    $isFunction: 1,
    get$$call: function() {
      return this;
    },
    "call*": "call$1",
    $requiredArgCount: 1,
    $defaultValues: null
  };
  H.TearOffClosure.prototype = {};
  H.StaticClosure.prototype = {
    toString$0: function(_) {
      var $name = this.$static_name;
      if ($name == null)
        return "Closure of unknown static method";
      return "Closure '" + H.unminifyOrTag($name) + "'";
    }
  };
  H.BoundClosure.prototype = {
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof H.BoundClosure))
        return false;
      return _this._self === other._self && _this._target === other._target && _this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var receiverHashCode,
        t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
    },
    toString$0: function(_) {
      var receiver = this._receiver;
      if (receiver == null)
        receiver = this._self;
      return "Closure '" + H.S(this._name) + "' of " + ("Instance of '" + H.Primitives_objectTypeName(receiver) + "'");
    }
  };
  H.TypeErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.CastErrorImplementation.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H.RuntimeError.prototype = {
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  H._AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed: " + P.Error_safeToString(this.message);
    }
  };
  H.TypeImpl.prototype = {
    get$_typeName: function() {
      var t1 = this.__typeName;
      return t1 == null ? this.__typeName = H.runtimeTypeToString(this._rti) : t1;
    },
    toString$0: function(_) {
      return this.get$_typeName();
    },
    get$hashCode: function(_) {
      var t1 = this.__js_helper$_hashCode;
      return t1 == null ? this.__js_helper$_hashCode = C.JSString_methods.get$hashCode(this.get$_typeName()) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof H.TypeImpl && this.get$_typeName() === other.get$_typeName();
    },
    $isType: 1
  };
  H.JsLinkedHashMap.prototype = {
    get$length: function(_) {
      return this._length;
    },
    get$isEmpty: function(_) {
      return this._length === 0;
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$keys: function(_) {
      return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      var _this = this;
      return H.MappedIterable_MappedIterable(_this.get$keys(_this), new H.JsLinkedHashMap_values_closure(_this), H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return false;
        return _this._containsTableEntry$2(strings, key);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return false;
        return _this._containsTableEntry$2(nums, key);
      } else
        return _this.internalContainsKey$1(key);
    },
    internalContainsKey$1: function(key) {
      var _this = this,
        rest = _this._rest;
      if (rest == null)
        return false;
      return _this.internalFindBucketIndex$2(_this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key)), key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(H.assertSubtype(other, "$isMap", this.$ti, "$asMap"), new H.JsLinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, t1, nums, _this = this;
      if (typeof key === "string") {
        strings = _this._strings;
        if (strings == null)
          return;
        cell = _this._getTableCell$2(strings, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        if (nums == null)
          return;
        cell = _this._getTableCell$2(nums, key);
        t1 = cell == null ? null : cell.hashMapCellValue;
        return t1;
      } else
        return _this.internalGet$1(key);
    },
    internalGet$1: function(key) {
      var bucket, index, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      bucket = _this._getTableBucket$2(rest, _this.internalComputeHashCode$1(key));
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].hashMapCellValue;
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (typeof key === "string") {
        strings = _this._strings;
        _this._addHashTableEntry$3(strings == null ? _this._strings = _this._newHashTable$0() : strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = _this._nums;
        _this._addHashTableEntry$3(nums == null ? _this._nums = _this._newHashTable$0() : nums, key, value);
      } else
        _this.internalSet$2(key, value);
    },
    internalSet$2: function(key, value) {
      var rest, hash, bucket, index, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      rest = _this._rest;
      if (rest == null)
        rest = _this._rest = _this._newHashTable$0();
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      if (bucket == null)
        _this._setTableEntry$3(rest, hash, [_this._newLinkedCell$2(key, value)]);
      else {
        index = _this.internalFindBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].hashMapCellValue = value;
        else
          bucket.push(_this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(_, key, ifAbsent) {
      var value, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.functionTypeCheck(ifAbsent, {func: 1, ret: H.getTypeArgumentByIndex(_this, 1)});
      if (_this.containsKey$1(0, key))
        return _this.$index(0, key);
      value = ifAbsent.call$0();
      _this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      var _this = this;
      if (typeof key === "string")
        return _this._removeHashTableEntry$2(_this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return _this._removeHashTableEntry$2(_this._nums, key);
      else
        return _this.internalRemove$1(key);
    },
    internalRemove$1: function(key) {
      var hash, bucket, index, cell, _this = this,
        rest = _this._rest;
      if (rest == null)
        return;
      hash = _this.internalComputeHashCode$1(key);
      bucket = _this._getTableBucket$2(rest, hash);
      index = _this.internalFindBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      _this._unlinkCell$1(cell);
      if (bucket.length === 0)
        _this._deleteTableEntry$2(rest, hash);
      return cell.hashMapCellValue;
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._length > 0) {
        _this._strings = _this._nums = _this._rest = _this._first = _this._last = null;
        _this._length = 0;
        _this._modified$0();
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0), H.getTypeArgumentByIndex(_this, 1)]});
      cell = _this._first;
      modifications = _this._modifications;
      for (; cell != null;) {
        action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
        if (modifications !== _this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      cell = _this._getTableCell$2(table, key);
      if (cell == null)
        _this._setTableEntry$3(table, key, _this._newLinkedCell$2(key, value));
      else
        cell.hashMapCellValue = value;
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = this._getTableCell$2(table, key);
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      this._deleteTableEntry$2(table, key);
      return cell.hashMapCellValue;
    },
    _modified$0: function() {
      this._modifications = this._modifications + 1 & 67108863;
    },
    _newLinkedCell$2: function(key, value) {
      var last, _this = this,
        cell = new H.LinkedHashMapCell(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1)));
      if (_this._first == null)
        _this._first = _this._last = cell;
      else {
        last = _this._last;
        cell._previous = last;
        _this._last = last._next = cell;
      }
      ++_this._length;
      _this._modified$0();
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._previous,
        next = cell._next;
      if (previous == null)
        _this._first = next;
      else
        previous._next = next;
      if (next == null)
        _this._last = previous;
      else
        next._previous = previous;
      --_this._length;
      _this._modified$0();
    },
    internalComputeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i].hashMapCellKey, key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.MapBase_mapToString(this);
    },
    _getTableCell$2: function(table, key) {
      return table[key];
    },
    _getTableBucket$2: function(table, key) {
      return table[key];
    },
    _setTableEntry$3: function(table, key, value) {
      table[key] = value;
    },
    _deleteTableEntry$2: function(table, key) {
      delete table[key];
    },
    _containsTableEntry$2: function(table, key) {
      return this._getTableCell$2(table, key) != null;
    },
    _newHashTable$0: function() {
      var _s20_ = "<non-identifier-key>",
        table = Object.create(null);
      this._setTableEntry$3(table, _s20_, table);
      this._deleteTableEntry$2(table, _s20_);
      return table;
    },
    $isLinkedHashMap: 1
  };
  H.JsLinkedHashMap_values_closure.prototype = {
    call$1: function(each) {
      var t1 = this.$this;
      return t1.$index(0, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  H.JsLinkedHashMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this;
      t1.$indexSet(0, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(t1, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(t1, 1)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
    }
  };
  H.LinkedHashMapCell.prototype = {};
  H.LinkedHashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._map._length;
    },
    get$isEmpty: function(_) {
      return this._map._length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map,
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, this.$ti);
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(0, element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell.hashMapCellKey);
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    }
  };
  H.LinkedHashMapKeyIterator.prototype = {
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._map;
      if (_this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._cell;
        if (t1 == null) {
          _this.set$__js_helper$_current(null);
          return false;
        } else {
          _this.set$__js_helper$_current(t1.hashMapCellKey);
          _this._cell = _this._cell._next;
          return true;
        }
      }
    },
    set$__js_helper$_current: function(_current) {
      this.__js_helper$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  H.initHooks_closure.prototype = {
    call$1: function(o) {
      return this.getTag(o);
    },
    $signature: 4
  };
  H.initHooks_closure0.prototype = {
    call$2: function(o, tag) {
      return this.getUnknownTag(o, tag);
    },
    $signature: 223
  };
  H.initHooks_closure1.prototype = {
    call$1: function(tag) {
      return this.prototypeForTag(H.stringTypeCheck(tag));
    },
    $signature: 185
  };
  H.JSSyntaxRegExp.prototype = {
    toString$0: function(_) {
      return "RegExp/" + this.pattern + "/" + this._nativeRegExp.flags;
    },
    get$_nativeGlobalVersion: function() {
      var _this = this,
        t1 = _this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeGlobalRegExp = H.JSSyntaxRegExp_makeNative(_this.pattern, t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    get$_nativeAnchoredVersion: function() {
      var _this = this,
        t1 = _this._nativeAnchoredRegExp;
      if (t1 != null)
        return t1;
      t1 = _this._nativeRegExp;
      return _this._nativeAnchoredRegExp = H.JSSyntaxRegExp_makeNative(_this.pattern + "|()", t1.multiline, !t1.ignoreCase, t1.unicode, t1.dotAll, true);
    },
    firstMatch$1: function(string) {
      var m;
      if (typeof string !== "string")
        H.throwExpression(H.argumentErrorValue(string));
      m = this._nativeRegExp.exec(string);
      if (m == null)
        return;
      return new H._MatchImplementation(m);
    },
    allMatches$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var match,
        regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return new H._MatchImplementation(match);
    },
    _execAnchored$2: function(string, start) {
      var match,
        regexp = this.get$_nativeAnchoredVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      if (0 >= match.length)
        return H.ioore(match, -1);
      if (match.pop() != null)
        return;
      return new H._MatchImplementation(match);
    },
    matchAsPrefix$2: function(_, string, start) {
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
      return this._execAnchored$2(string, start);
    },
    matchAsPrefix$1: function($receiver, string) {
      return this.matchAsPrefix$2($receiver, string, 0);
    },
    $isPattern: 1,
    $isRegExp: 1
  };
  H._MatchImplementation.prototype = {
    get$end: function(_) {
      var t1 = this._match;
      return t1.index + t1[0].length;
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._match;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $isMatch: 1,
    $isRegExpMatch: 1
  };
  H._AllMatchesIterable.prototype = {
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start);
    },
    $asIterable: function() {
      return [P.RegExpMatch];
    }
  };
  H._AllMatchesIterator.prototype = {
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t2, t3, match, nextIndex, _this = this,
        t1 = _this._string;
      if (t1 == null)
        return false;
      t2 = _this._nextIndex;
      if (t2 <= t1.length) {
        t3 = _this._regExp;
        match = t3._execGlobal$2(t1, t2);
        if (match != null) {
          _this.__js_helper$_current = match;
          nextIndex = match.get$end(match);
          if (match._match.index === nextIndex) {
            if (t3._nativeRegExp.unicode) {
              t1 = _this._nextIndex;
              t2 = t1 + 1;
              t3 = _this._string;
              if (t2 < t3.length) {
                t1 = J.getInterceptor$s(t3).codeUnitAt$1(t3, t1);
                if (t1 >= 55296 && t1 <= 56319) {
                  t1 = C.JSString_methods.codeUnitAt$1(t3, t2);
                  t1 = t1 >= 56320 && t1 <= 57343;
                } else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
            nextIndex = (t1 ? nextIndex + 1 : nextIndex) + 1;
          }
          _this._nextIndex = nextIndex;
          return true;
        }
      }
      _this._string = _this.__js_helper$_current = null;
      return false;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.RegExpMatch];
    }
  };
  H.StringMatch.prototype = {
    get$end: function(_) {
      return this.start + this.pattern.length;
    },
    $index: function(_, g) {
      H.intTypeCheck(g);
      if (g !== 0)
        H.throwExpression(P.RangeError$value(g, null));
      return this.pattern;
    },
    $isMatch: 1
  };
  H._StringAllMatchesIterable.prototype = {
    get$iterator: function(_) {
      return new H._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index);
    },
    get$first: function(_) {
      var t1 = this._pattern,
        index = this._input.indexOf(t1, this.__js_helper$_index);
      if (index >= 0)
        return new H.StringMatch(index, t1);
      throw H.wrapException(H.IterableElementError_noElement());
    },
    $asIterable: function() {
      return [P.Match];
    }
  };
  H._StringAllMatchesIterator.prototype = {
    moveNext$0: function() {
      var index, end, _this = this,
        t1 = _this.__js_helper$_index,
        t2 = _this._pattern,
        t3 = t2.length,
        t4 = _this._input,
        t5 = t4.length;
      if (t1 + t3 > t5) {
        _this.__js_helper$_current = null;
        return false;
      }
      index = t4.indexOf(t2, t1);
      if (index < 0) {
        _this.__js_helper$_index = t5 + 1;
        _this.__js_helper$_current = null;
        return false;
      }
      end = index + t3;
      _this.__js_helper$_current = new H.StringMatch(index, t2);
      _this.__js_helper$_index = end === _this.__js_helper$_index ? end + 1 : end;
      return true;
    },
    get$current: function(_) {
      return this.__js_helper$_current;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.Match];
    }
  };
  H.NativeByteBuffer.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteBuffer_RkP;
    },
    $isNativeByteBuffer: 1,
    $isByteBuffer: 1
  };
  H.NativeTypedData.prototype = {
    _invalidPosition$3: function(receiver, position, $length, $name) {
      if (typeof position !== "number" || Math.floor(position) !== position)
        throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
      else
        throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
    },
    _checkPosition$3: function(receiver, position, $length, $name) {
      if (position >>> 0 !== position || position > $length)
        this._invalidPosition$3(receiver, position, $length, $name);
    },
    $isNativeTypedData: 1,
    $isTypedData: 1
  };
  H.NativeByteData.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_ByteData_zNC;
    },
    $isByteData: 1
  };
  H.NativeTypedArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var count, sourceLength,
        targetLength = receiver.length;
      this._checkPosition$3(receiver, start, targetLength, "start");
      this._checkPosition$3(receiver, end, targetLength, "end");
      if (typeof end !== "number")
        return H.iae(end);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
      count = end - start;
      if (skipCount < 0)
        throw H.wrapException(P.ArgumentError$(skipCount));
      sourceLength = source.length;
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
    }
  };
  H.NativeTypedArrayOfDouble.prototype = {
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.doubleTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [P.double], "$asIterable");
      if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $asFixedLengthListMixin: function() {
      return [P.double];
    },
    $asListMixin: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    }
  };
  H.NativeTypedArrayOfInt.prototype = {
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.intTypeCheck(value);
      H._checkValidIndex(index, receiver, receiver.length);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [P.int], "$asIterable");
      if (!!J.getInterceptor$(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $asFixedLengthListMixin: function() {
      return [P.int];
    },
    $asListMixin: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    }
  };
  H.NativeFloat32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Float32List_LB7;
    },
    $isFloat32List: 1
  };
  H.NativeFloat64List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Float64List_LB7;
    }
  };
  H.NativeInt16List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int16List_uXf;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeInt32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int32List_O50;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeInt8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Int8List_ekJ;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint16List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint16List_2bx;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint32List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint32List_2bx;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    },
    $isUint32List: 1
  };
  H.NativeUint8ClampedList.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint8ClampedList_Jik;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    }
  };
  H.NativeUint8List.prototype = {
    get$runtimeType: function(receiver) {
      return C.Type_Uint8List_WLA;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      H._checkValidIndex(index, receiver, receiver.length);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
    },
    $isNativeUint8List: 1,
    $isUint8List: 1
  };
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.prototype = {};
  H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.prototype = {};
  P._AsyncRun__initializeScheduleImmediate_internalCallback.prototype = {
    call$1: function(_) {
      var t1 = this._box_0,
        f = t1.storedCallback;
      t1.storedCallback = null;
      f.call$0();
    },
    $signature: 2
  };
  P._AsyncRun__initializeScheduleImmediate_closure.prototype = {
    call$1: function(callback) {
      var t1, t2;
      this._box_0.storedCallback = H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = this.div;
      t2 = this.span;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $signature: 121
  };
  P._AsyncRun__scheduleImmediateJsOverride_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._TimerImpl.prototype = {
    _TimerImpl$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
    },
    _TimerImpl$periodic$2: function(milliseconds, callback) {
      if (self.setTimeout != null)
        this._handle = self.setInterval(H.convertDartClosureToJS(new P._TimerImpl$periodic_closure(this, milliseconds, Date.now(), callback), 0), milliseconds);
      else
        throw H.wrapException(P.UnsupportedError$("Periodic timer."));
    },
    cancel$0: function(_) {
      var t1;
      if (self.setTimeout != null) {
        t1 = this._handle;
        if (t1 == null)
          return;
        if (this._once)
          self.clearTimeout(t1);
        else
          self.clearInterval(t1);
        this._handle = null;
      } else
        throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
    },
    $isTimer: 1
  };
  P._TimerImpl_internalCallback.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._handle = null;
      t1._tick = 1;
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._TimerImpl$periodic_closure.prototype = {
    call$0: function() {
      var duration, _this = this,
        t1 = _this.$this,
        tick = t1._tick + 1,
        t2 = _this.milliseconds;
      if (t2 > 0) {
        duration = Date.now() - _this.start;
        if (duration > (tick + 1) * t2)
          tick = C.JSInt_methods.$tdiv(duration, t2);
      }
      t1._tick = tick;
      _this.callback.call$1(t1);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._AsyncAwaitCompleter.prototype = {
    complete$1: function(_, value) {
      var t1, _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      if (_this.isSync)
        _this._completer.complete$1(0, value);
      else if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        t1 = _this._completer;
        value.then$1$2$onError(t1.get$complete(t1), t1.get$completeError(), -1);
      } else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(_this, value));
    },
    completeError$2: function(e, st) {
      if (this.isSync)
        this._completer.completeError$2(e, st);
      else
        P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
    },
    completeError$1: function(e) {
      return this.completeError$2(e, null);
    },
    $isCompleter: 1
  };
  P._AsyncAwaitCompleter_complete_closure.prototype = {
    call$0: function() {
      this.$this._completer.complete$1(0, this.value);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._AsyncAwaitCompleter_completeError_closure.prototype = {
    call$0: function() {
      this.$this._completer.completeError$2(this.e, this.st);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._awaitOnObject_closure.prototype = {
    call$1: function(result) {
      return this.bodyFunction.call$2(0, result);
    },
    $signature: 7
  };
  P._awaitOnObject_closure0.prototype = {
    call$2: function(error, stackTrace) {
      this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace")));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 31
  };
  P._wrapJsFunctionForAsync_closure.prototype = {
    call$2: function(errorCode, result) {
      this.$protected(H.intTypeCheck(errorCode), result);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 149
  };
  P._IterationMarker.prototype = {
    toString$0: function(_) {
      return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  P._SyncStarIterator.prototype = {
    get$current: function(_) {
      var t1 = this._nestedIterator;
      if (t1 == null)
        return this._async$_current;
      return H.assertSubtypeOfRuntimeType(t1.get$current(t1), H.getTypeArgumentByIndex(this, 0));
    },
    moveNext$0: function() {
      var t1, value, state, inner, _this = this;
      for (; true;) {
        t1 = _this._nestedIterator;
        if (t1 != null)
          if (t1.moveNext$0())
            return true;
          else
            _this._nestedIterator = null;
        value = function(body, SUCCESS, ERROR) {
          var errorValue,
            errorCode = SUCCESS;
          while (true)
            try {
              return body(errorCode, errorValue);
            } catch (error) {
              errorValue = error;
              errorCode = ERROR;
            }
        }(_this._body, 0, 1);
        if (value instanceof P._IterationMarker) {
          state = value.state;
          if (state === 2) {
            t1 = _this._suspendedBodies;
            if (t1 == null || t1.length === 0) {
              _this.set$_async$_current(null);
              return false;
            }
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            _this._body = t1.pop();
            continue;
          } else {
            t1 = value.value;
            if (state === 3)
              throw t1;
            else {
              inner = J.get$iterator$ax(t1);
              if (!!inner.$is_SyncStarIterator) {
                t1 = _this._suspendedBodies;
                if (t1 == null)
                  t1 = _this._suspendedBodies = [];
                C.JSArray_methods.add$1(t1, _this._body);
                _this._body = inner._body;
                continue;
              } else {
                _this._nestedIterator = inner;
                continue;
              }
            }
          }
        } else {
          _this.set$_async$_current(value);
          return true;
        }
      }
      return false;
    },
    set$_async$_current: function(_current) {
      this._async$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._SyncStarIterable.prototype = {
    get$iterator: function(_) {
      return new P._SyncStarIterator(this._outerHelper(), this.$ti);
    }
  };
  P._BroadcastStream.prototype = {
    get$isBroadcast: function() {
      return true;
    }
  };
  P._BroadcastSubscription.prototype = {
    _onPause$0: function() {
    },
    _onResume$0: function() {
    },
    set$_async$_next: function(_next) {
      this._async$_next = H.assertSubtype(_next, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
    },
    set$_async$_previous: function(_previous) {
      this._async$_previous = H.assertSubtype(_previous, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
    }
  };
  P._BroadcastStreamController.prototype = {
    get$stream: function(_) {
      return new P._BroadcastStream(this, this.$ti);
    },
    get$_mayAddEvent: function() {
      return this._state < 4;
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 != null)
        return t1;
      return this._doneFuture = new P._Future($.Zone__current, [null]);
    },
    _removeListener$1: function(subscription) {
      var previous, next;
      H.assertSubtype(subscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
      previous = subscription._async$_previous;
      next = subscription._async$_next;
      if (previous == null)
        this.set$_firstSubscription(next);
      else
        previous.set$_async$_next(next);
      if (next == null)
        this.set$_lastSubscription(previous);
      else
        next.set$_async$_previous(previous);
      subscription.set$_async$_previous(subscription);
      subscription.set$_async$_next(subscription);
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, oldLast, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if ((_this._state & 4) !== 0) {
        if (onDone == null)
          onDone = P.async___nullDoneHandler$closure();
        t1 = new P._DoneStreamSubscription($.Zone__current, onDone, _this.$ti);
        t1._schedule$0();
        return t1;
      }
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = _this.$ti;
      subscription = new P._BroadcastSubscription(_this, t2, t3, t4);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
      subscription.set$_async$_previous(subscription);
      subscription.set$_async$_next(subscription);
      H.assertSubtype(subscription, "$is_BroadcastSubscription", t4, "$as_BroadcastSubscription");
      subscription._eventState = _this._state & 1;
      oldLast = _this._lastSubscription;
      _this.set$_lastSubscription(subscription);
      subscription.set$_async$_next(null);
      subscription.set$_async$_previous(oldLast);
      if (oldLast == null)
        _this.set$_firstSubscription(subscription);
      else
        oldLast.set$_async$_next(subscription);
      if (_this._firstSubscription == _this._lastSubscription)
        P._runGuarded(_this.onListen);
      return subscription;
    },
    _recordCancel$1: function(sub) {
      var _this = this,
        t1 = _this.$ti;
      sub = H.assertSubtype(H.assertSubtype(sub, "$isStreamSubscription", t1, "$asStreamSubscription"), "$is_BroadcastSubscription", t1, "$as_BroadcastSubscription");
      if (sub._async$_next === sub)
        return;
      t1 = sub._eventState;
      if ((t1 & 2) !== 0)
        sub._eventState = t1 | 4;
      else {
        _this._removeListener$1(sub);
        if ((_this._state & 2) === 0 && _this._firstSubscription == null)
          _this._callOnCancel$0();
      }
      return;
    },
    _recordPause$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", this.$ti, "$asStreamSubscription");
    },
    _recordResume$1: function(subscription) {
      H.assertSubtype(subscription, "$isStreamSubscription", this.$ti, "$asStreamSubscription");
    },
    _addEventError$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add new events after calling close");
      return new P.StateError("Cannot add new events while doing an addStream");
    },
    add$1: function(_, data) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(_this, 0));
      if (!_this.get$_mayAddEvent())
        throw H.wrapException(_this._addEventError$0());
      _this._sendData$1(data);
    },
    addError$2: function(error, stackTrace) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      if (error == null)
        error = new P.NullThrownError();
      if (!this.get$_mayAddEvent())
        throw H.wrapException(this._addEventError$0());
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._sendError$2(error, stackTrace);
    },
    close$0: function(_) {
      var doneFuture, _this = this;
      if ((_this._state & 4) !== 0)
        return _this._doneFuture;
      if (!_this.get$_mayAddEvent())
        throw H.wrapException(_this._addEventError$0());
      _this._state |= 4;
      doneFuture = _this._ensureDoneFuture$0();
      _this._sendDone$0();
      return doneFuture;
    },
    _addError$2: function(error, stackTrace) {
      this._sendError$2(error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    },
    _forEachListener$1: function(action) {
      var t1, subscription, id, next, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(_this, 0)]]});
      t1 = _this._state;
      if ((t1 & 2) !== 0)
        throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
      subscription = _this._firstSubscription;
      if (subscription == null)
        return;
      id = t1 & 1;
      _this._state = t1 ^ 3;
      for (; subscription != null;) {
        t1 = subscription._eventState;
        if ((t1 & 1) === id) {
          subscription._eventState = t1 | 2;
          action.call$1(subscription);
          t1 = subscription._eventState ^= 1;
          next = subscription._async$_next;
          if ((t1 & 4) !== 0)
            _this._removeListener$1(subscription);
          subscription._eventState &= 4294967293;
          subscription = next;
        } else
          subscription = subscription._async$_next;
      }
      _this._state &= 4294967293;
      if (_this._firstSubscription == null)
        _this._callOnCancel$0();
    },
    _callOnCancel$0: function() {
      var _this = this;
      if ((_this._state & 4) !== 0 && _this._doneFuture._state === 0)
        _this._doneFuture._asyncComplete$1(null);
      P._runGuarded(_this.onCancel);
    },
    set$_firstSubscription: function(_firstSubscription) {
      this._firstSubscription = H.assertSubtype(_firstSubscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
    },
    set$_lastSubscription: function(_lastSubscription) {
      this._lastSubscription = H.assertSubtype(_lastSubscription, "$is_BroadcastSubscription", this.$ti, "$as_BroadcastSubscription");
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_StreamControllerBase: 1,
    $is_EventSink: 1,
    $is_EventDispatch: 1
  };
  P._SyncBroadcastStreamController.prototype = {
    get$_mayAddEvent: function() {
      return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && (this._state & 2) === 0;
    },
    _addEventError$0: function() {
      if ((this._state & 2) !== 0)
        return new P.StateError("Cannot fire new event. Controller is already firing an event");
      return this.super$_BroadcastStreamController$_addEventError();
    },
    _sendData$1: function(data) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._firstSubscription;
      if (t1 == null)
        return;
      if (t1 === _this._lastSubscription) {
        _this._state |= 2;
        t1._add$1(0, data);
        _this._state &= 4294967293;
        if (_this._firstSubscription == null)
          _this._callOnCancel$0();
        return;
      }
      _this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(_this, data));
    },
    _sendError$2: function(error, stackTrace) {
      if (this._firstSubscription == null)
        return;
      this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
    },
    _sendDone$0: function() {
      var _this = this;
      if (_this._firstSubscription != null)
        _this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(_this));
      else
        _this._doneFuture._asyncComplete$1(null);
    }
  };
  P._SyncBroadcastStreamController__sendData_closure.prototype = {
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._add$1(0, this.data);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  P._SyncBroadcastStreamController__sendError_closure.prototype = {
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._addError$2(this.error, this.stackTrace);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  P._SyncBroadcastStreamController__sendDone_closure.prototype = {
    call$1: function(subscription) {
      H.assertSubtype(subscription, "$is_BufferingStreamSubscription", [H.getTypeArgumentByIndex(this.$this, 0)], "$as_BufferingStreamSubscription")._close$0();
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  P._AsyncBroadcastStreamController.prototype = {
    _sendData$1: function(data) {
      var subscription, t1;
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
      for (subscription = this._firstSubscription, t1 = this.$ti; subscription != null; subscription = subscription._async$_next)
        subscription._addPending$1(new P._DelayedData(data, t1));
    },
    _sendError$2: function(error, stackTrace) {
      var subscription;
      for (subscription = this._firstSubscription; subscription != null; subscription = subscription._async$_next)
        subscription._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _sendDone$0: function() {
      var subscription = this._firstSubscription;
      if (subscription != null)
        for (; subscription != null; subscription = subscription._async$_next)
          subscription._addPending$1(C.C__DelayedDone);
      else
        this._doneFuture._asyncComplete$1(null);
    }
  };
  P.Future.prototype = {};
  P.Future_Future_closure.prototype = {
    call$0: function() {
      var e, s, exception;
      try {
        this.result._complete$1(this.computation.call$0());
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this.result, e, s);
      }
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.Future_wait_handleError.prototype = {
    call$2: function(theError, theStackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(theStackTrace, "$isStackTrace");
      t1 = _this._box_0;
      t2 = --t1.remaining;
      if (t1.values != null) {
        t1.values = null;
        if (t1.remaining === 0 || _this.eagerError)
          _this.result._completeError$2(theError, theStackTrace);
        else {
          t1.error = theError;
          t1.stackTrace = theStackTrace;
        }
      } else if (t2 === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 31
  };
  P.Future_wait_closure.prototype = {
    call$1: function(value) {
      var t1, t2, _this = this;
      H.assertSubtypeOfRuntimeType(value, _this.T);
      t1 = _this._box_0;
      --t1.remaining;
      t2 = t1.values;
      if (t2 != null) {
        C.JSArray_methods.$indexSet(t2, _this.pos, value);
        if (t1.remaining === 0)
          _this.result._completeWithValue$1(t1.values);
      } else if (t1.remaining === 0 && !_this.eagerError)
        _this.result._completeError$2(t1.error, t1.stackTrace);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [this.T]};
    }
  };
  P.Future_forEach_closure.prototype = {
    call$0: function() {
      var result,
        t1 = this.iterator;
      if (!t1.moveNext$0())
        return false;
      result = this.action.call$1(t1._current);
      if (!!J.getInterceptor$(result).$isFuture)
        return result.then$1$1(P.async_Future__kTrue$closure(), P.bool);
      return true;
    },
    $signature: 249
  };
  P.Future_doWhile_closure.prototype = {
    call$1: function(keepGoing) {
      var result, error, stackTrace, t1, t2, exception, error0, stackTrace0, replacement, t3, _this = this;
      H.boolTypeCheck(keepGoing);
      for (t1 = [P.bool], t2 = _this.action; H.boolConversionCheck(keepGoing);) {
        result = null;
        try {
          result = t2.call$0();
        } catch (exception) {
          error = H.unwrapException(exception);
          stackTrace = H.getTraceFromException(exception);
          error0 = error;
          stackTrace0 = stackTrace;
          replacement = $.Zone__current.errorCallback$2(error0, stackTrace0);
          if (replacement != null) {
            error = replacement.error;
            if (error == null)
              error = new P.NullThrownError();
            stackTrace = replacement.stackTrace;
          } else {
            stackTrace = stackTrace0;
            error = error0;
          }
          _this.doneSignal._asyncCompleteError$2(error, stackTrace);
          return;
        }
        t3 = result;
        if (H.checkSubtype(t3, "$isFuture", t1, "$asFuture")) {
          result.then$1$2$onError(_this._box_0.nextIteration, _this.doneSignal.get$_completeError(), -1);
          return;
        }
        keepGoing = H.boolTypeCheck(result);
      }
      _this.doneSignal._complete$1(null);
    },
    $signature: 9
  };
  P.Completer.prototype = {};
  P._Completer.prototype = {
    completeError$2: function(error, stackTrace) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      if (error == null)
        error = new P.NullThrownError();
      if (this.future._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._completeError$2(error, stackTrace);
    },
    completeError$1: function(error) {
      return this.completeError$2(error, null);
    },
    $isCompleter: 1
  };
  P._AsyncCompleter.prototype = {
    complete$1: function(_, value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncComplete$1(value);
    },
    complete$0: function($receiver) {
      return this.complete$1($receiver, null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._asyncCompleteError$2(error, stackTrace);
    }
  };
  P._SyncCompleter.prototype = {
    complete$1: function(_, value) {
      var t1;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(this, 0)});
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._complete$1(value);
    },
    complete$0: function($receiver) {
      return this.complete$1($receiver, null);
    },
    _completeError$2: function(error, stackTrace) {
      this.future._completeError$2(error, stackTrace);
    }
  };
  P._FutureListener.prototype = {
    matchesErrorTest$1: function(asyncError) {
      if (this.state !== 6)
        return true;
      return this.result._zone.runUnary$2$2(H.functionTypeCheck(this.callback, {func: 1, ret: P.bool, args: [P.Object]}), asyncError.error, P.bool, P.Object);
    },
    handleError$1: function(asyncError) {
      var errorCallback = this.errorCallback,
        t1 = P.Object,
        t2 = {futureOr: 1, type: H.getTypeArgumentByIndex(this, 1)},
        t3 = this.result._zone;
      if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
        return H.futureOrCheck(t3.runBinary$3$3(errorCallback, asyncError.error, asyncError.stackTrace, null, t1, P.StackTrace), t2);
      else
        return H.futureOrCheck(t3.runUnary$2$2(H.functionTypeCheck(errorCallback, {func: 1, args: [P.Object]}), asyncError.error, null, t1), t2);
    }
  };
  P._Future.prototype = {
    then$1$2$onError: function(f, onError, $R) {
      var currentZone,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $R}, args: [t1]});
      currentZone = $.Zone__current;
      if (currentZone !== C.C__RootZone) {
        f = currentZone.registerUnaryCallback$2$1(f, {futureOr: 1, type: $R}, t1);
        if (onError != null)
          onError = P._registerErrorHandler(onError, currentZone);
      }
      return this._thenNoZoneRegistration$1$2(f, onError, $R);
    },
    then$1$1: function(f, $R) {
      return this.then$1$2$onError(f, null, $R);
    },
    _thenNoZoneRegistration$1$2: function(f, onError, $E) {
      var result, t2,
        t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(f, {func: 1, ret: {futureOr: 1, type: $E}, args: [t1]});
      result = new P._Future($.Zone__current, [$E]);
      t2 = onError == null ? 1 : 3;
      this._addListener$1(new P._FutureListener(result, t2, f, onError, [t1, $E]));
      return result;
    },
    catchError$2$test: function(onError, test) {
      var t1, result, t2;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [,]});
      t1 = $.Zone__current;
      result = new P._Future(t1, this.$ti);
      if (t1 !== C.C__RootZone) {
        onError = P._registerErrorHandler(onError, t1);
        if (test != null)
          test = t1.registerUnaryCallback$2$1(test, P.bool, null);
      }
      t1 = H.getTypeArgumentByIndex(this, 0);
      t2 = test == null ? 2 : 6;
      this._addListener$1(new P._FutureListener(result, t2, test, onError, [t1, t1]));
      return result;
    },
    catchError$1: function(onError) {
      return this.catchError$2$test(onError, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      H.functionTypeCheck(action, {func: 1});
      t1 = $.Zone__current;
      result = new P._Future(t1, this.$ti);
      if (t1 !== C.C__RootZone)
        action = t1.registerCallback$1$1(action, null);
      t1 = H.getTypeArgumentByIndex(this, 0);
      this._addListener$1(new P._FutureListener(result, 8, action, null, [t1, t1]));
      return result;
    },
    _addListener$1: function(listener) {
      var source, _this = this,
        t1 = _this._state;
      if (t1 <= 1) {
        listener._nextListener = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        _this._resultOrListeners = listener;
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          t1 = source._state;
          if (t1 < 4) {
            source._addListener$1(listener);
            return;
          }
          _this._state = t1;
          _this._resultOrListeners = source._resultOrListeners;
        }
        _this._zone.scheduleMicrotask$1(new P._Future__addListener_closure(_this, listener));
      }
    },
    _prependListeners$1: function(listeners) {
      var t1, existingListeners, cursor, cursor0, source, _this = this, _box_0 = {};
      _box_0.listeners = listeners;
      if (listeners == null)
        return;
      t1 = _this._state;
      if (t1 <= 1) {
        existingListeners = H.interceptedTypeCheck(_this._resultOrListeners, "$is_FutureListener");
        cursor = _this._resultOrListeners = listeners;
        if (existingListeners != null) {
          for (; cursor0 = cursor._nextListener, cursor0 != null; cursor = cursor0)
            ;
          cursor._nextListener = existingListeners;
        }
      } else {
        if (t1 === 2) {
          source = H.interceptedTypeCheck(_this._resultOrListeners, "$is_Future");
          t1 = source._state;
          if (t1 < 4) {
            source._prependListeners$1(listeners);
            return;
          }
          _this._state = t1;
          _this._resultOrListeners = source._resultOrListeners;
        }
        _box_0.listeners = _this._reverseListeners$1(listeners);
        _this._zone.scheduleMicrotask$1(new P._Future__prependListeners_closure(_box_0, _this));
      }
    },
    _removeListeners$0: function() {
      var current = H.interceptedTypeCheck(this._resultOrListeners, "$is_FutureListener");
      this._resultOrListeners = null;
      return this._reverseListeners$1(current);
    },
    _reverseListeners$1: function(listeners) {
      var current, prev, next;
      for (current = listeners, prev = null; current != null; prev = current, current = next) {
        next = current._nextListener;
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t2, listeners, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.futureOrCheck(value, {futureOr: 1, type: t1});
      t2 = _this.$ti;
      if (H.checkSubtype(value, "$isFuture", t2, "$asFuture"))
        if (H.checkSubtype(value, "$is_Future", t2, null))
          P._Future__chainCoreFuture(value, _this);
        else
          P._Future__chainForeignFuture(value, _this);
      else {
        listeners = _this._removeListeners$0();
        H.assertSubtypeOfRuntimeType(value, t1);
        _this._state = 4;
        _this._resultOrListeners = value;
        P._Future__propagateToListeners(_this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      listeners = _this._removeListeners$0();
      _this._state = 4;
      _this._resultOrListeners = value;
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$2: function(error, stackTrace) {
      var listeners, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      listeners = _this._removeListeners$0();
      _this._state = 8;
      _this._resultOrListeners = new P.AsyncError(error, stackTrace);
      P._Future__propagateToListeners(_this, listeners);
    },
    _completeError$1: function(error) {
      return this._completeError$2(error, null);
    },
    _asyncComplete$1: function(value) {
      var _this = this;
      H.futureOrCheck(value, {futureOr: 1, type: H.getTypeArgumentByIndex(_this, 0)});
      if (H.checkSubtype(value, "$isFuture", _this.$ti, "$asFuture")) {
        _this._chainFuture$1(value);
        return;
      }
      _this._state = 1;
      _this._zone.scheduleMicrotask$1(new P._Future__asyncComplete_closure(_this, value));
    },
    _chainFuture$1: function(value) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(value, "$isFuture", t1, "$asFuture");
      if (H.checkSubtype(value, "$is_Future", t1, null)) {
        if (value._state === 8) {
          _this._state = 1;
          _this._zone.scheduleMicrotask$1(new P._Future__chainFuture_closure(_this, value));
        } else
          P._Future__chainCoreFuture(value, _this);
        return;
      }
      P._Future__chainForeignFuture(value, _this);
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      this._state = 1;
      this._zone.scheduleMicrotask$1(new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    $isFuture: 1
  };
  P._Future__addListener_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this.listener);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__prependListeners_closure.prototype = {
    call$0: function() {
      P._Future__propagateToListeners(this.$this, this._box_0.listeners);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__chainForeignFuture_closure.prototype = {
    call$1: function(value) {
      var t1 = this.target;
      t1._state = 0;
      t1._complete$1(value);
    },
    $signature: 2
  };
  P._Future__chainForeignFuture_closure0.prototype = {
    call$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      this.target._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    "call*": "call$2",
    $defaultValues: function() {
      return [null];
    },
    $signature: 161
  };
  P._Future__chainForeignFuture_closure1.prototype = {
    call$0: function() {
      this.target._completeError$2(this.e, this.s);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__asyncComplete_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._completeWithValue$1(H.assertSubtypeOfRuntimeType(this.value, H.getTypeArgumentByIndex(t1, 0)));
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__chainFuture_closure.prototype = {
    call$0: function() {
      P._Future__chainCoreFuture(this.value, this.$this);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__asyncCompleteError_closure.prototype = {
    call$0: function() {
      this.$this._completeError$2(this.error, this.stackTrace);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback.prototype = {
    call$0: function() {
      var e, s, t1, exception, t2, originalSource, _this = this, completeResult = null;
      try {
        t1 = _this.listener;
        completeResult = t1.result._zone.run$1$1(H.functionTypeCheck(t1.callback, {func: 1}), null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (_this.hasError) {
          t1 = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError").error;
          t2 = e;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        t2 = _this._box_0;
        if (t1)
          t2.listenerValueOrError = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        else
          t2.listenerValueOrError = new P.AsyncError(e, s);
        t2.listenerHasError = true;
        return;
      }
      if (!!J.getInterceptor$(completeResult).$isFuture) {
        if (completeResult instanceof P._Future && completeResult._state >= 4) {
          if (completeResult._state === 8) {
            t1 = _this._box_0;
            t1.listenerValueOrError = H.interceptedTypeCheck(completeResult._resultOrListeners, "$isAsyncError");
            t1.listenerHasError = true;
          }
          return;
        }
        originalSource = _this._box_1.source;
        t1 = _this._box_0;
        t1.listenerValueOrError = completeResult.then$1$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource), null);
        t1.listenerHasError = false;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleWhenCompleteCallback_closure.prototype = {
    call$1: function(_) {
      return this.originalSource;
    },
    $signature: 179
  };
  P._Future__propagateToListeners_handleValueCallback.prototype = {
    call$0: function() {
      var e, s, t1, t2, t3, t4, exception, _this = this;
      try {
        t1 = _this.listener;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t3 = H.assertSubtypeOfRuntimeType(_this.sourceResult, t2);
        t4 = H.getTypeArgumentByIndex(t1, 1);
        _this._box_0.listenerValueOrError = t1.result._zone.runUnary$2$2(H.functionTypeCheck(t1.callback, {func: 1, ret: {futureOr: 1, type: t4}, args: [t2]}), t3, {futureOr: 1, type: t4}, t2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._box_0;
        t1.listenerValueOrError = new P.AsyncError(e, s);
        t1.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._Future__propagateToListeners_handleError.prototype = {
    call$0: function() {
      var asyncError, e, s, t1, t2, exception, t3, t4, _this = this;
      try {
        asyncError = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        t1 = _this.listener;
        if (H.boolConversionCheck(t1.matchesErrorTest$1(asyncError)) && t1.errorCallback != null) {
          t2 = _this._box_0;
          t2.listenerValueOrError = t1.handleError$1(asyncError);
          t2.listenerHasError = false;
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = H.interceptedTypeCheck(_this._box_1.source._resultOrListeners, "$isAsyncError");
        t2 = t1.error;
        t3 = e;
        t4 = _this._box_0;
        if (t2 == null ? t3 == null : t2 === t3)
          t4.listenerValueOrError = t1;
        else
          t4.listenerValueOrError = new P.AsyncError(e, s);
        t4.listenerHasError = true;
      }
    },
    $signature: 1
  };
  P._AsyncCallbackEntry.prototype = {};
  P.Stream.prototype = {
    get$isBroadcast: function() {
      return false;
    },
    map$1$1: function(_, convert, $S) {
      var t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
      return new P._MapStream(H.functionTypeCheck(convert, {func: 1, ret: $S, args: [t1]}), this, [t1, $S]);
    },
    map$1: function($receiver, convert) {
      return this.map$1$1($receiver, convert, null);
    },
    asyncMap$1$1: function(convert, $E) {
      var t2, t1 = {};
      H.functionTypeCheck(convert, {func: 1, ret: {futureOr: 1, type: $E}, args: [H.getRuntimeTypeArgument(this, "Stream", 0)]});
      t1.subscription = t1.controller = null;
      t2 = new P.Stream_asyncMap_onListen(t1, this, $E, convert);
      if (this.get$isBroadcast())
        t1 = t1.controller = H.assertSubtype(new P._SyncBroadcastStreamController(t2, new P.Stream_asyncMap_closure(t1), [$E]), "$is_StreamControllerBase", [$E], "$as_StreamControllerBase");
      else
        t1 = t1.controller = H.assertSubtype(P.StreamController_StreamController(new P.Stream_asyncMap_closure0(t1), t2, new P.Stream_asyncMap_closure1(t1), new P.Stream_asyncMap_closure2(t1), true, $E), "$is_StreamControllerBase", [$E], "$as_StreamControllerBase");
      return t1.get$stream(t1);
    },
    transform$1$1: function(_, streamTransformer, $S) {
      var t1, t2;
      H.assertSubtype(streamTransformer, "$isStreamTransformer", [H.getRuntimeTypeArgument(this, "Stream", 0), $S], "$asStreamTransformer");
      t1 = streamTransformer.transformer;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._BoundSubscriptionStream(t1._onListen, H.assertSubtype(H.assertSubtype(this, "$isStream", [H.getTypeArgumentByIndex(streamTransformer, 0)], "$asStream"), "$isStream", [t2], "$asStream"), [t2, H.getTypeArgumentByIndex(t1, 1)]);
    },
    contains$1: function(_, needle) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.bool]);
      t1.subscription = null;
      t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [P.int]);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1, this), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    cast$1$0: function(_, $R) {
      return new H.CastStream(this, [H.getRuntimeTypeArgument(this, "Stream", 0), $R]);
    },
    toList$0: function(_) {
      var t1 = H.getRuntimeTypeArgument(this, "Stream", 0),
        result = H.setRuntimeTypeInfo([], [t1]),
        future = new P._Future($.Zone__current, [[P.List, t1]]);
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(future, result), future.get$_completeError());
      return future;
    },
    get$first: function(_) {
      var t1 = {},
        future = new P._Future($.Zone__current, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      t1.subscription = null;
      t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return future;
    }
  };
  P.Stream_Stream$fromIterable_closure.prototype = {
    call$0: function() {
      var t1 = this.elements;
      return new P._IterablePendingEvents(new J.ArrayIterator(t1, 1, [H.getTypeArgumentByIndex(t1, 0)]), [this.T]);
    },
    $signature: function() {
      return {func: 1, ret: [P._IterablePendingEvents, this.T]};
    }
  };
  P.Stream_asyncMap_onListen.prototype = {
    call$0: function() {
      var t3, _this = this,
        t1 = _this._box_0,
        t2 = t1.controller,
        add = t2.get$add(t2),
        addError = t1.controller.get$_addError();
      t2 = _this.$this;
      t3 = t1.controller;
      t1.subscription = t2.listen$3$onDone$onError(new P.Stream_asyncMap_onListen_closure(t1, t2, _this.convert, _this.E, add, addError), t3.get$close(t3), addError);
    },
    $signature: 1
  };
  P.Stream_asyncMap_onListen_closure.prototype = {
    call$1: function($event) {
      var newValue, e, s, exception, t1, t2, t3, _this = this;
      H.assertSubtypeOfRuntimeType($event, H.getRuntimeTypeArgument(_this.$this, "Stream", 0));
      newValue = null;
      try {
        newValue = _this.convert.call$1($event);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        _this._box_0.controller.addError$2(e, s);
        return;
      }
      t1 = newValue;
      t2 = _this.E;
      t3 = _this._box_0;
      if (H.checkSubtype(t1, "$isFuture", [t2], "$asFuture")) {
        t3.subscription.pause$0(0);
        t1 = newValue.then$1$2$onError(_this.add, _this.addError, -1);
        t3 = t3.subscription;
        t1.whenComplete$1(t3.get$resume(t3));
      } else
        t3.controller.add$1(0, H.assertSubtypeOfRuntimeType(newValue, t2));
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_asyncMap_closure.prototype = {
    call$0: function() {
      this._box_0.subscription.cancel$0(0);
    },
    $signature: 0
  };
  P.Stream_asyncMap_closure1.prototype = {
    call$0: function() {
      this._box_0.subscription.pause$0(0);
    },
    $signature: 0
  };
  P.Stream_asyncMap_closure2.prototype = {
    call$0: function() {
      this._box_0.subscription.resume$0(0);
    },
    $signature: 0
  };
  P.Stream_asyncMap_closure0.prototype = {
    call$0: function() {
      return this._box_0.subscription.cancel$0(0);
    },
    $signature: 10
  };
  P.Stream_contains_closure.prototype = {
    call$1: function(element) {
      var _this = this,
        t1 = _this._box_0,
        t2 = _this.future;
      P._runUserCode(new P.Stream_contains__closure(H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgument(_this.$this, "Stream", 0)), _this.needle), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2), P.bool);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_contains__closure.prototype = {
    call$0: function() {
      return J.$eq$(this.element, this.needle);
    },
    $signature: 71
  };
  P.Stream_contains__closure0.prototype = {
    call$1: function(isMatch) {
      if (H.boolConversionCheck(H.boolTypeCheck(isMatch)))
        P._cancelAndValue(this._box_0.subscription, this.future, true);
    },
    $signature: 9
  };
  P.Stream_contains_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(false);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.Stream_length_closure.prototype = {
    call$1: function(_) {
      H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgument(this.$this, "Stream", 0));
      ++this._box_0.count;
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_length_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(this._box_0.count);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.Stream_toList_closure.prototype = {
    call$1: function(data) {
      C.JSArray_methods.add$1(this.result, H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this.$this, "Stream", 0)));
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_toList_closure0.prototype = {
    call$0: function() {
      this.future._complete$1(this.result);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.Stream_first_closure.prototype = {
    call$1: function(value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this.$this, "Stream", 0));
      P._cancelAndValue(this._box_0.subscription, this.future, value);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
    }
  };
  P.Stream_first_closure0.prototype = {
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._completeWithErrorCallback(this.future, e, s);
      }
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P.StreamSubscription.prototype = {};
  P.StreamView.prototype = {
    get$isBroadcast: function() {
      this._stream.get$isBroadcast();
      return false;
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._stream.listen$4$cancelOnError$onDone$onError(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "StreamView", 0)]}), cancelOnError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  P.StreamTransformerBase.prototype = {$isStreamTransformer: 1};
  P.StreamController.prototype = {};
  P._StreamController.prototype = {
    get$stream: function(_) {
      return new P._ControllerStream(this, this.$ti);
    },
    get$_pendingEvents: function() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return H.assertSubtype(_this._varData, "$is_PendingEvents", _this.$ti, "$as_PendingEvents");
      t1 = _this.$ti;
      return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").get$varData(), "$is_PendingEvents", t1, "$as_PendingEvents");
    },
    _ensurePendingEvents$0: function() {
      var t1, state, _this = this;
      if ((_this._state & 8) === 0) {
        t1 = _this._varData;
        if (t1 == null)
          t1 = _this._varData = new P._StreamImplEvents(_this.$ti);
        return H.assertSubtype(t1, "$is_StreamImplEvents", _this.$ti, "$as_StreamImplEvents");
      }
      t1 = _this.$ti;
      state = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState");
      state.get$varData();
      return H.assertSubtype(state.get$varData(), "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
    },
    get$_subscription: function() {
      var t1, _this = this;
      if ((_this._state & 8) !== 0) {
        t1 = _this.$ti;
        return H.assertSubtype(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState").get$varData(), "$is_ControllerSubscription", t1, "$as_ControllerSubscription");
      }
      return H.assertSubtype(_this._varData, "$is_ControllerSubscription", _this.$ti, "$as_ControllerSubscription");
    },
    _badEventState$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future($.Zone__current, [null]);
      return t1;
    },
    add$1: function(_, value) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._state;
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      if ((t1 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, _this.$ti));
    },
    addError$2: function(error, stackTrace) {
      var replacement;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      if (this._state >= 4)
        throw H.wrapException(this._badEventState$0());
      if (error == null)
        error = new P.NullThrownError();
      replacement = $.Zone__current.errorCallback$2(error, stackTrace);
      if (replacement != null) {
        error = replacement.error;
        if (error == null)
          error = new P.NullThrownError();
        stackTrace = replacement.stackTrace;
      }
      this._addError$2(error, stackTrace);
    },
    addError$1: function(error) {
      return this.addError$2(error, null);
    },
    close$0: function(_) {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _addError$2: function(error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace));
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, subscription, pendingEvents, addState, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if ((_this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = _this.$ti;
      subscription = new P._ControllerSubscription(_this, t2, t3, t4);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
      pendingEvents = _this.get$_pendingEvents();
      t1 = _this._state |= 1;
      if ((t1 & 8) !== 0) {
        addState = H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t4, "$as_StreamControllerAddStreamState");
        addState.set$varData(subscription);
        addState.resume$0(0);
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, result0, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
      result = null;
      if ((_this._state & 8) !== 0)
        result = C.JSNull_methods.cancel$0(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState"));
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      t1 = _this.onCancel;
      if (t1 != null)
        if (result == null)
          try {
            result = H.interceptedTypeCheck(_this.onCancel.call$0(), "$isFuture");
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            result0 = new P._Future($.Zone__current, [null]);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(t1);
      t1 = new P._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    _recordPause$1: function(subscription) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
      if ((_this._state & 8) !== 0)
        C.JSNull_methods.pause$0(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState"));
      P._runGuarded(_this.onPause);
    },
    _recordResume$1: function(subscription) {
      var _this = this,
        t1 = _this.$ti;
      H.assertSubtype(subscription, "$isStreamSubscription", t1, "$asStreamSubscription");
      if ((_this._state & 8) !== 0)
        C.JSNull_methods.resume$0(H.assertSubtype(_this._varData, "$is_StreamControllerAddStreamState", t1, "$as_StreamControllerAddStreamState"));
      P._runGuarded(_this.onResume);
    },
    set$onListen: function(onListen) {
      this.onListen = H.functionTypeCheck(onListen, {func: 1, ret: -1});
    },
    set$onCancel: function(_, onCancel) {
      this.onCancel = H.functionTypeCheck(onCancel, {func: 1});
    },
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_StreamControllerBase: 1,
    $is_EventSink: 1,
    $is_EventDispatch: 1
  };
  P._StreamController__subscribe_closure.prototype = {
    call$0: function() {
      P._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  P._StreamController__recordCancel_complete.prototype = {
    call$0: function() {
      var t1 = this.$this._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._SyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0));
      this.get$_subscription()._add$1(0, data);
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    }
  };
  P._AsyncStreamControllerDispatch.prototype = {
    _sendData$1: function(data) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      this.get$_subscription()._addPending$1(new P._DelayedData(data, [t1]));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  };
  P._AsyncStreamController.prototype = {};
  P._SyncStreamController.prototype = {};
  P._ControllerStream.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof P._ControllerStream && other._async$_controller === this._async$_controller;
    }
  };
  P._ControllerSubscription.prototype = {
    _onCancel$0: function() {
      return this._async$_controller._recordCancel$1(this);
    },
    _onPause$0: function() {
      this._async$_controller._recordPause$1(this);
    },
    _onResume$0: function() {
      this._async$_controller._recordResume$1(this);
    }
  };
  P._BufferingStreamSubscription.prototype = {
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      this.onData$1(onData);
      this.onError$1(0, onError);
      this.onDone$1(onDone);
    },
    _setPendingEvents$1: function(pendingEvents) {
      var _this = this;
      H.assertSubtype(pendingEvents, "$is_PendingEvents", [H.getRuntimeTypeArgument(_this, "_BufferingStreamSubscription", 0)], "$as_PendingEvents");
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (!pendingEvents.get$isEmpty(pendingEvents)) {
        _this._state = (_this._state | 64) >>> 0;
        _this._pending.schedule$1(_this);
      }
    },
    onData$1: function(handleData) {
      var t1 = H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0);
      H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [t1]});
      if (handleData == null)
        handleData = P.async___nullDataHandler$closure();
      this.set$_onData(this._zone.registerUnaryCallback$2$1(handleData, null, t1));
    },
    onError$1: function(_, handleError) {
      var _this = this;
      if (handleError == null)
        handleError = P.async___nullErrorHandler$closure();
      if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        _this._onError = _this._zone.registerBinaryCallback$3$1(handleError, null, P.Object, P.StackTrace);
      else if (H.functionTypeTest(handleError, {func: 1, ret: -1, args: [P.Object]}))
        _this._onError = _this._zone.registerUnaryCallback$2$1(handleError, null, P.Object);
      else
        throw H.wrapException(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
    },
    onDone$1: function(handleDone) {
      H.functionTypeCheck(handleDone, {func: 1, ret: -1});
      if (handleDone == null)
        handleDone = P.async___nullDoneHandler$closure();
      this.set$_onDone(this._zone.registerCallback$1$1(handleDone, -1));
    },
    pause$1: function(_, resumeSignal) {
      var t2, t3, _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      _this._state = t2;
      if (t1 < 128 && _this._pending != null) {
        t3 = _this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        _this._guardCallback$1(_this.get$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function(_) {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 = _this._state = t1 - 128;
        if (t1 < 128) {
          if ((t1 & 64) !== 0) {
            t1 = _this._pending;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = false;
          if (t1)
            _this._pending.schedule$1(_this);
          else {
            t1 = (_this._state & 4294967291) >>> 0;
            _this._state = t1;
            if ((t1 & 32) === 0)
              _this._guardCallback$1(_this.get$_onResume());
          }
        }
      }
    },
    cancel$0: function(_) {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0: function() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 64) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _add$1: function(_, data) {
      var t2, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "_BufferingStreamSubscription", 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      t2 = _this._state;
      if ((t2 & 8) !== 0)
        return;
      if (t2 < 32)
        _this._sendData$1(data);
      else
        _this._addPending$1(new P._DelayedData(data, [t1]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace));
    },
    _close$0: function() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      _this._state = t1;
      if (t1 < 32)
        _this._sendDone$0();
      else
        _this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: function() {
    },
    _onResume$0: function() {
    },
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var _this = this,
        t1 = [H.getRuntimeTypeArgument(_this, "_BufferingStreamSubscription", 0)],
        pending = H.assertSubtype(_this._pending, "$is_StreamImplEvents", t1, "$as_StreamImplEvents");
      if (pending == null) {
        pending = new P._StreamImplEvents(t1);
        _this.set$_pending(pending);
      }
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        _this._state = t1;
        if (t1 < 128)
          _this._pending.schedule$1(_this);
      }
    },
    _sendData$1: function(data) {
      var t2, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "_BufferingStreamSubscription", 0);
      H.assertSubtypeOfRuntimeType(data, t1);
      t2 = _this._state;
      _this._state = (t2 | 32) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._onData, data, t1);
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = _this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        t1 = _this._cancelFuture;
        if (t1 != null && t1 !== $.$get$Future__nullFuture())
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t2, _this = this,
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      t2 = _this._cancelFuture;
      if (t2 != null && t2 !== $.$get$Future__nullFuture())
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1, _this = this;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = _this._state;
      _this._state = (t1 | 32) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, isInputPaused, _this = this;
      if ((_this._state & 64) !== 0) {
        t1 = _this._pending;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1) {
        t1 = _this._state = (_this._state & 4294967231) >>> 0;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t1 = _this._pending;
            t1 = t1 == null || t1.get$isEmpty(t1);
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          _this._state = (_this._state & 4294967291) >>> 0;
      }
      for (; true; wasInputPaused = isInputPaused) {
        t1 = _this._state;
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        _this._state = (_this._state & 4294967263) >>> 0;
      }
      t1 = _this._state;
      if ((t1 & 64) !== 0 && t1 < 128)
        _this._pending.schedule$1(_this);
    },
    set$_onData: function(_onData) {
      this._onData = H.functionTypeCheck(_onData, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]});
    },
    set$_onDone: function(_onDone) {
      this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
    },
    set$_pending: function(_pending) {
      this._pending = H.assertSubtype(_pending, "$is_PendingEvents", [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)], "$as_PendingEvents");
    },
    $isStreamSubscription: 1,
    $is_EventSink: 1,
    $is_EventDispatch: 1
  };
  P._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0: function() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = P.Object;
      t4 = t1._zone;
      if (H.functionTypeTest(onError, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, P.StackTrace);
      else
        t4.runUnaryGuarded$1$2(H.functionTypeCheck(t1._onError, {func: 1, ret: -1, args: [P.Object]}), t2, t3);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), true === cancelOnError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return P._BufferingStreamSubscription$(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]}), onError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), cancelOnError, t1);
    }
  };
  P._GeneratedStreamImpl.prototype = {
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      if (_this._isUsed)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      _this._isUsed = true;
      t1 = P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, t1);
      t1._setPendingEvents$1(_this._pending.call$0());
      return t1;
    }
  };
  P._IterablePendingEvents.prototype = {
    get$isEmpty: function(_) {
      return this._async$_iterator == null;
    },
    handleNext$1: function(dispatch) {
      var hasMore, e, s, t1, exception, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      t1 = _this._async$_iterator;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No events pending."));
      hasMore = null;
      try {
        hasMore = t1.moveNext$0();
        if (H.boolConversionCheck(hasMore)) {
          t1 = _this._async$_iterator;
          dispatch._sendData$1(t1.get$current(t1));
        } else {
          _this.set$_async$_iterator(null);
          dispatch._sendDone$0();
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        if (hasMore == null) {
          _this.set$_async$_iterator(C.C_EmptyIterator);
          dispatch._sendError$2(e, s);
        } else
          dispatch._sendError$2(e, s);
      }
    },
    set$_async$_iterator: function(_iterator) {
      this._async$_iterator = H.assertSubtype(_iterator, "$isIterator", this.$ti, "$asIterator");
    }
  };
  P._DelayedEvent.prototype = {
    set$next: function(_, next) {
      this.next = H.interceptedTypeCheck(next, "$is_DelayedEvent");
    },
    get$next: function(receiver) {
      return this.next;
    }
  };
  P._DelayedData.prototype = {
    perform$1: function(dispatch) {
      H.assertSubtype(dispatch, "$is_EventDispatch", this.$ti, "$as_EventDispatch")._sendData$1(this.value);
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  P._DelayedError.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    },
    $as_DelayedEvent: function() {
    }
  };
  P._DelayedDone.prototype = {
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function(_) {
      return;
    },
    set$next: function(_, _0) {
      throw H.wrapException(P.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1,
    $as_DelayedEvent: function() {
    }
  };
  P._PendingEvents.prototype = {
    schedule$1: function(dispatch) {
      var t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    }
  };
  P._PendingEvents_schedule_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  P._StreamImplEvents.prototype = {
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var _this = this,
        t1 = _this.lastPendingEvent;
      if (t1 == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        t1.set$next(0, $event);
        _this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1, _this = this;
      H.assertSubtype(dispatch, "$is_EventDispatch", _this.$ti, "$as_EventDispatch");
      $event = _this.firstPendingEvent;
      t1 = $event.get$next($event);
      _this.firstPendingEvent = t1;
      if (t1 == null)
        _this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    }
  };
  P._DoneStreamSubscription.prototype = {
    _schedule$0: function() {
      var _this = this;
      if ((_this._state & 2) !== 0)
        return;
      _this._zone.scheduleMicrotask$1(_this.get$_sendDone());
      _this._state = (_this._state | 2) >>> 0;
    },
    onData$1: function(handleData) {
      H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
    },
    onError$1: function(_, handleError) {
    },
    onDone$1: function(handleDone) {
      this.set$_onDone(H.functionTypeCheck(handleDone, {func: 1, ret: -1}));
    },
    pause$1: function(_, resumeSignal) {
      this._state += 4;
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function(_) {
      var t1 = this._state;
      if (t1 >= 4) {
        t1 = this._state = t1 - 4;
        if (t1 < 4 && (t1 & 1) === 0)
          this._schedule$0();
      }
    },
    cancel$0: function(_) {
      return $.$get$Future__nullFuture();
    },
    _sendDone$0: function() {
      var _this = this,
        t1 = _this._state = (_this._state & 4294967293) >>> 0;
      if (t1 >= 4)
        return;
      _this._state = (t1 | 1) >>> 0;
      t1 = _this._onDone;
      if (t1 != null)
        _this._zone.runGuarded$1(t1);
    },
    set$_onDone: function(_onDone) {
      this._onDone = H.functionTypeCheck(_onDone, {func: 1, ret: -1});
    },
    $isStreamSubscription: 1
  };
  P._StreamIterator.prototype = {};
  P._cancelAndError_closure.prototype = {
    call$0: function() {
      return this.future._completeError$2(this.error, this.stackTrace);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._cancelAndErrorClosure_closure.prototype = {
    call$2: function(error, stackTrace) {
      P._cancelAndError(this.subscription, this.future, error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    },
    $signature: 31
  };
  P._cancelAndValue_closure.prototype = {
    call$0: function() {
      return this.future._complete$1(this.value);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._ForwardingStream.prototype = {
    get$isBroadcast: function() {
      return this._async$_source.get$isBroadcast();
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t2, t3, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "_ForwardingStream", 1);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      cancelOnError = true === cancelOnError;
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t3 = new P._ForwardingStreamSubscription(_this, t2, t3, [H.getRuntimeTypeArgument(_this, "_ForwardingStream", 0), t1]);
      t3._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
      t3.set$_subscription(_this._async$_source.listen$3$onDone$onError(t3.get$_handleData(), t3.get$_handleDone(), t3.get$_handleError()));
      return t3;
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    _handleData$2: function(data, sink) {
      var t1;
      H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0));
      t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
      H.assertSubtype(sink, "$is_EventSink", [t1], "$as_EventSink")._add$1(0, H.assertSubtypeOfRuntimeType(data, t1));
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  };
  P._ForwardingStreamSubscription.prototype = {
    _add$1: function(_, data) {
      H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 1));
      if ((this._state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_add(0, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
    },
    _onPause$0: function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    },
    _onResume$0: function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0(0);
    },
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this.set$_subscription(null);
        return t1.cancel$0(0);
      }
      return;
    },
    _handleData$1: function(data) {
      this._stream._handleData$2(H.assertSubtypeOfRuntimeType(data, H.getTypeArgumentByIndex(this, 0)), this);
    },
    _handleError$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      H.assertSubtype(this, "$is_EventSink", [H.getRuntimeTypeArgument(this._stream, "_ForwardingStream", 1)], "$as_EventSink")._addError$2(error, stackTrace);
    },
    _handleDone$0: function() {
      H.assertSubtype(this, "$is_EventSink", [H.getRuntimeTypeArgument(this._stream, "_ForwardingStream", 1)], "$as_EventSink")._close$0();
    },
    set$_subscription: function(_subscription) {
      this._subscription = H.assertSubtype(_subscription, "$isStreamSubscription", [H.getTypeArgumentByIndex(this, 0)], "$asStreamSubscription");
    },
    $asStreamSubscription: function($S, $T) {
      return [$T];
    },
    $as_EventSink: function($S, $T) {
      return [$T];
    },
    $as_EventDispatch: function($S, $T) {
      return [$T];
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    }
  };
  P._WhereStream.prototype = {
    _handleData$2: function(inputEvent, sink) {
      var satisfies, e, s, exception;
      H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtype(sink, "$is_EventSink", this.$ti, "$as_EventSink");
      satisfies = null;
      try {
        satisfies = this._test.call$1(inputEvent);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }
      if (H.boolConversionCheck(satisfies))
        J._add$1$z(sink, inputEvent);
    },
    $asStream: null,
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    }
  };
  P._MapStream.prototype = {
    _handleData$2: function(inputEvent, sink) {
      var outputEvent, e, s, exception;
      H.assertSubtypeOfRuntimeType(inputEvent, H.getTypeArgumentByIndex(this, 0));
      H.assertSubtype(sink, "$is_EventSink", [H.getTypeArgumentByIndex(this, 1)], "$as_EventSink");
      outputEvent = null;
      try {
        outputEvent = this._transform.call$1(inputEvent);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._addErrorWithReplacement(sink, e, s);
        return;
      }
      J._add$1$z(sink, outputEvent);
    }
  };
  P._StreamSubscriptionTransformer.prototype = {};
  P._BoundSubscriptionStream.prototype = {
    get$isBroadcast: function() {
      return this._stream.get$isBroadcast();
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var result;
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 1)]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      result = this._onListen.call$2(this._stream, true === cancelOnError);
      result.onData$1(onData);
      result.onError$1(0, onError);
      result.onDone$1(onDone);
      return result;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  };
  P.Timer.prototype = {};
  P.AsyncError.prototype = {
    toString$0: function(_) {
      return H.S(this.error);
    },
    $isError: 1
  };
  P._ZoneFunction.prototype = {};
  P.ZoneSpecification.prototype = {};
  P._ZoneSpecification.prototype = {$isZoneSpecification: 1};
  P.ZoneDelegate.prototype = {};
  P.Zone.prototype = {};
  P._ZoneDelegate.prototype = {
    handleUncaughtError$3: function(zone, error, stackTrace) {
      var implementation, implZone;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      implementation = this._delegationTarget.get$_handleUncaughtError();
      implZone = implementation.zone;
      return implementation.$function.call$5(implZone, P._parentDelegate(implZone), zone, error, stackTrace);
    },
    $isZoneDelegate: 1
  };
  P._Zone.prototype = {$isZone: 1};
  P._CustomZone.prototype = {
    get$_delegate: function() {
      var t1 = this._delegateCache;
      if (t1 != null)
        return t1;
      return this._delegateCache = new P._ZoneDelegate(this);
    },
    get$errorZone: function() {
      return this._handleUncaughtError.zone;
    },
    runGuarded$1: function(f) {
      var e, s, exception;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      try {
        this.run$1$1(f, -1);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    runUnaryGuarded$1$2: function(f, arg, $T) {
      var e, s, exception;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      try {
        this.runUnary$2$2(f, arg, -1, $T);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2, T1, T2) {
      var e, s, exception;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      try {
        this.runBinary$3$3(f, arg1, arg2, -1, T1, T2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        this.handleUncaughtError$2(e, s);
      }
    },
    bindCallback$1$1: function(f, $R) {
      return new P._CustomZone_bindCallback_closure(this, this.registerCallback$1$1(H.functionTypeCheck(f, {func: 1, ret: $R}), $R), $R);
    },
    bindUnaryCallback$2$1: function(f, $R, $T) {
      return new P._CustomZone_bindUnaryCallback_closure(this, this.registerUnaryCallback$2$1(H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]}), $R, $T), $T, $R);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._CustomZone_bindCallbackGuarded_closure(this, this.registerCallback$1$1(H.functionTypeCheck(f, {func: 1, ret: -1}), -1));
    },
    bindUnaryCallbackGuarded$1$1: function(f, $T) {
      return new P._CustomZone_bindUnaryCallbackGuarded_closure(this, this.registerUnaryCallback$2$1(H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]}), -1, $T), $T);
    },
    $index: function(_, key) {
      var value,
        t1 = this._async$_map,
        result = t1.$index(0, key);
      if (result != null || t1.containsKey$1(0, key))
        return result;
      value = this.parent.$index(0, key);
      if (value != null)
        t1.$indexSet(0, key, value);
      return value;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var implementation, t1, parentDelegate;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      implementation = this._handleUncaughtError;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, error, stackTrace);
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      var implementation = this._fork,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, specification, zoneValues);
    },
    run$1$1: function(f, $R) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: $R});
      implementation = this._run;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}).call$1$4(t1, parentDelegate, this, f, $R);
    },
    runUnary$2$2: function(f, arg, $R, $T) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      implementation = this._runUnary;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}, 1]}).call$2$5(t1, parentDelegate, this, f, arg, $R, $T);
    },
    runBinary$3$3: function(f, arg1, arg2, $R, T1, T2) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      implementation = this._runBinary;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}, 1, 2]}).call$3$6(t1, parentDelegate, this, f, arg1, arg2, $R, T1, T2);
    },
    registerCallback$1$1: function(callback, $R) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(callback, {func: 1, ret: $R});
      implementation = this._registerCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object], ret: {func: 1, ret: 0}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}).call$1$4(t1, parentDelegate, this, callback, $R);
    },
    registerUnaryCallback$2$1: function(callback, $R, $T) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(callback, {func: 1, ret: $R, args: [$T]});
      implementation = this._registerUnaryCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object, P.Object], ret: {func: 1, ret: 0, args: [1]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}]}).call$2$4(t1, parentDelegate, this, callback, $R, $T);
    },
    registerBinaryCallback$3$1: function(callback, $R, T1, T2) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(callback, {func: 1, ret: $R, args: [T1, T2]});
      implementation = this._registerBinaryCallback;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return H.functionTypeCheck(implementation.$function, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: {func: 1, ret: 0, args: [1, 2]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}]}).call$3$4(t1, parentDelegate, this, callback, $R, T1, T2);
    },
    errorCallback$2: function(error, stackTrace) {
      var implementation, implementationZone, parentDelegate;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      implementation = this._errorCallback;
      implementationZone = implementation.zone;
      if (implementationZone === C.C__RootZone)
        return;
      parentDelegate = P._parentDelegate(implementationZone);
      return implementation.$function.call$5(implementationZone, parentDelegate, this, error, stackTrace);
    },
    scheduleMicrotask$1: function(f) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      implementation = this._scheduleMicrotask;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, f);
    },
    createTimer$2: function(duration, f) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      implementation = this._createTimer;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, duration, f);
    },
    createPeriodicTimer$2: function(duration, f) {
      var implementation, t1, parentDelegate;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.Timer]});
      implementation = this._createPeriodicTimer;
      t1 = implementation.zone;
      parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$5(t1, parentDelegate, this, duration, f);
    },
    print$1: function(_, line) {
      var implementation = this._print,
        t1 = implementation.zone,
        parentDelegate = P._parentDelegate(t1);
      return implementation.$function.call$4(t1, parentDelegate, this, line);
    },
    set$_run: function(_run) {
      this._run = H.assertSubtype(_run, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_runUnary: function(_runUnary) {
      this._runUnary = H.assertSubtype(_runUnary, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_runBinary: function(_runBinary) {
      this._runBinary = H.assertSubtype(_runBinary, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_registerCallback: function(_registerCallback) {
      this._registerCallback = H.assertSubtype(_registerCallback, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_registerUnaryCallback: function(_registerUnaryCallback) {
      this._registerUnaryCallback = H.assertSubtype(_registerUnaryCallback, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_registerBinaryCallback: function(_registerBinaryCallback) {
      this._registerBinaryCallback = H.assertSubtype(_registerBinaryCallback, "$is_ZoneFunction", [P.Function], "$as_ZoneFunction");
    },
    set$_errorCallback: function(_errorCallback) {
      this._errorCallback = H.assertSubtype(_errorCallback, "$is_ZoneFunction", [{func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}], "$as_ZoneFunction");
    },
    set$_scheduleMicrotask: function(_scheduleMicrotask) {
      this._scheduleMicrotask = H.assertSubtype(_scheduleMicrotask, "$is_ZoneFunction", [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}], "$as_ZoneFunction");
    },
    set$_createTimer: function(_createTimer) {
      this._createTimer = H.assertSubtype(_createTimer, "$is_ZoneFunction", [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1}]}], "$as_ZoneFunction");
    },
    set$_createPeriodicTimer: function(_createPeriodicTimer) {
      this._createPeriodicTimer = H.assertSubtype(_createPeriodicTimer, "$is_ZoneFunction", [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1, args: [P.Timer]}]}], "$as_ZoneFunction");
    },
    set$_print: function(_print) {
      this._print = H.assertSubtype(_print, "$is_ZoneFunction", [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}], "$as_ZoneFunction");
    },
    set$_fork: function(_fork) {
      this._fork = H.assertSubtype(_fork, "$is_ZoneFunction", [{func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, [P.Map,,,]]}], "$as_ZoneFunction");
    },
    set$_handleUncaughtError: function(_handleUncaughtError) {
      this._handleUncaughtError = H.assertSubtype(_handleUncaughtError, "$is_ZoneFunction", [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}], "$as_ZoneFunction");
    },
    get$_run: function() {
      return this._run;
    },
    get$_runUnary: function() {
      return this._runUnary;
    },
    get$_runBinary: function() {
      return this._runBinary;
    },
    get$_registerCallback: function() {
      return this._registerCallback;
    },
    get$_registerUnaryCallback: function() {
      return this._registerUnaryCallback;
    },
    get$_registerBinaryCallback: function() {
      return this._registerBinaryCallback;
    },
    get$_errorCallback: function() {
      return this._errorCallback;
    },
    get$_scheduleMicrotask: function() {
      return this._scheduleMicrotask;
    },
    get$_createTimer: function() {
      return this._createTimer;
    },
    get$_createPeriodicTimer: function() {
      return this._createPeriodicTimer;
    },
    get$_print: function() {
      return this._print;
    },
    get$_fork: function() {
      return this._fork;
    },
    get$_handleUncaughtError: function() {
      return this._handleUncaughtError;
    },
    get$parent: function(receiver) {
      return this.parent;
    },
    get$_async$_map: function() {
      return this._async$_map;
    }
  };
  P._CustomZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1$1(this.registered, this.R);
    },
    $signature: function() {
      return {func: 1, ret: this.R};
    }
  };
  P._CustomZone_bindUnaryCallback_closure.prototype = {
    call$1: function(arg) {
      var _this = this,
        t1 = _this.T;
      return _this.$this.runUnary$2$2(_this.registered, H.assertSubtypeOfRuntimeType(arg, t1), _this.R, t1);
    },
    $signature: function() {
      return {func: 1, ret: this.R, args: [this.T]};
    }
  };
  P._CustomZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.registered);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._CustomZone_bindUnaryCallbackGuarded_closure.prototype = {
    call$1: function(arg) {
      var t1 = this.T;
      return this.$this.runUnaryGuarded$1$2(this.registered, H.assertSubtypeOfRuntimeType(arg, t1), t1);
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [this.T]};
    }
  };
  P._rootHandleUncaughtError_closure.prototype = {
    call$0: function() {
      var error,
        t1 = this._box_0,
        t2 = t1.error;
      t1 = t2 == null ? t1.error = new P.NullThrownError() : t2;
      t2 = this.stackTrace;
      if (t2 == null)
        throw H.wrapException(t1);
      error = H.wrapException(t1);
      error.stack = t2.toString$0(0);
      throw error;
    },
    $signature: 0
  };
  P._RootZone.prototype = {
    get$_run: function() {
      return C._ZoneFunction__RootZone__rootRun;
    },
    get$_runUnary: function() {
      return C._ZoneFunction__RootZone__rootRunUnary;
    },
    get$_runBinary: function() {
      return C._ZoneFunction__RootZone__rootRunBinary;
    },
    get$_registerCallback: function() {
      return C._ZoneFunction__RootZone__rootRegisterCallback;
    },
    get$_registerUnaryCallback: function() {
      return C._ZoneFunction_Eeh;
    },
    get$_registerBinaryCallback: function() {
      return C._ZoneFunction_7G2;
    },
    get$_errorCallback: function() {
      return C._ZoneFunction__RootZone__rootErrorCallback;
    },
    get$_scheduleMicrotask: function() {
      return C._ZoneFunction__RootZone__rootScheduleMicrotask;
    },
    get$_createTimer: function() {
      return C._ZoneFunction__RootZone__rootCreateTimer;
    },
    get$_createPeriodicTimer: function() {
      return C._ZoneFunction_3bB;
    },
    get$_print: function() {
      return C._ZoneFunction__RootZone__rootPrint;
    },
    get$_fork: function() {
      return C._ZoneFunction__RootZone__rootFork;
    },
    get$_handleUncaughtError: function() {
      return C._ZoneFunction_NMc;
    },
    get$parent: function(_) {
      return;
    },
    get$_async$_map: function() {
      return $.$get$_RootZone__rootMap();
    },
    get$_delegate: function() {
      var t1 = $._RootZone__rootDelegate;
      if (t1 != null)
        return t1;
      return $._RootZone__rootDelegate = new P._ZoneDelegate(this);
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1});
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$0();
          return;
        }
        P._rootRun(_null, _null, this, f, -1);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runUnaryGuarded$1$2: function(f, arg, $T) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$1(arg);
          return;
        }
        P._rootRunUnary(_null, _null, this, f, arg, -1, $T);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    runBinaryGuarded$2$3: function(f, arg1, arg2, T1, T2) {
      var e, s, exception, _null = null;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      try {
        if (C.C__RootZone === $.Zone__current) {
          f.call$2(arg1, arg2);
          return;
        }
        P._rootRunBinary(_null, _null, this, f, arg1, arg2, -1, T1, T2);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P._rootHandleUncaughtError(_null, _null, this, e, H.interceptedTypeCheck(s, "$isStackTrace"));
      }
    },
    bindCallback$1$1: function(f, $R) {
      return new P._RootZone_bindCallback_closure(this, H.functionTypeCheck(f, {func: 1, ret: $R}), $R);
    },
    bindCallbackGuarded$1: function(f) {
      return new P._RootZone_bindCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1}));
    },
    bindUnaryCallbackGuarded$1$1: function(f, $T) {
      return new P._RootZone_bindUnaryCallbackGuarded_closure(this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [$T]}), $T);
    },
    $index: function(_, key) {
      return;
    },
    handleUncaughtError$2: function(error, stackTrace) {
      P._rootHandleUncaughtError(null, null, this, error, H.interceptedTypeCheck(stackTrace, "$isStackTrace"));
    },
    fork$2$specification$zoneValues: function(specification, zoneValues) {
      return P._rootFork(null, null, this, specification, zoneValues);
    },
    run$1$1: function(f, $R) {
      H.functionTypeCheck(f, {func: 1, ret: $R});
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f, $R);
    },
    runUnary$2$2: function(f, arg, $R, $T) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
      H.assertSubtypeOfRuntimeType(arg, $T);
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg, $R, $T);
    },
    runBinary$3$3: function(f, arg1, arg2, $R, T1, T2) {
      H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
      H.assertSubtypeOfRuntimeType(arg1, T1);
      H.assertSubtypeOfRuntimeType(arg2, T2);
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2, $R, T1, T2);
    },
    registerCallback$1$1: function(f, $R) {
      return H.functionTypeCheck(f, {func: 1, ret: $R});
    },
    registerUnaryCallback$2$1: function(f, $R, $T) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [$T]});
    },
    registerBinaryCallback$3$1: function(f, $R, T1, T2) {
      return H.functionTypeCheck(f, {func: 1, ret: $R, args: [T1, T2]});
    },
    errorCallback$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      return;
    },
    scheduleMicrotask$1: function(f) {
      P._rootScheduleMicrotask(null, null, this, H.functionTypeCheck(f, {func: 1, ret: -1}));
    },
    createTimer$2: function(duration, f) {
      return P.Timer__createTimer(duration, H.functionTypeCheck(f, {func: 1, ret: -1}));
    },
    createPeriodicTimer$2: function(duration, f) {
      return P.Timer__createPeriodicTimer(duration, H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.Timer]}));
    },
    print$1: function(_, line) {
      H.printString(line);
    }
  };
  P._RootZone_bindCallback_closure.prototype = {
    call$0: function() {
      return this.$this.run$1$1(this.f, this.R);
    },
    $signature: function() {
      return {func: 1, ret: this.R};
    }
  };
  P._RootZone_bindCallbackGuarded_closure.prototype = {
    call$0: function() {
      return this.$this.runGuarded$1(this.f);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  P._RootZone_bindUnaryCallbackGuarded_closure.prototype = {
    call$1: function(arg) {
      var t1 = this.T;
      return this.$this.runUnaryGuarded$1$2(this.f, H.assertSubtypeOfRuntimeType(arg, t1), t1);
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [this.T]};
    }
  };
  P.runZoned_closure.prototype = {
    call$5: function($self, $parent, zone, error, stackTrace) {
      var e, s, t1, t2, t3, exception;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      try {
        t1 = this._box_0;
        t2 = -1;
        t3 = P.Object;
        if (t1.binaryOnError != null)
          $self.get$parent($self).runBinary$3$3(t1.binaryOnError, error, stackTrace, t2, t3, P.StackTrace);
        else
          $self.get$parent($self).runUnary$2$2(t1.unaryOnError, error, t2, t3);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = e;
        if (t1 == null ? error == null : t1 === error)
          $parent.handleUncaughtError$3(zone, error, stackTrace);
        else
          $parent.handleUncaughtError$3(zone, e, s);
      }
    },
    $signature: 210
  };
  P._HashMap.prototype = {
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    get$keys: function(_) {
      return new P._HashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      var _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      return H.MappedIterable_MappedIterable(new P._HashMapKeyIterable(_this, [t1]), new P._HashMap_values_closure(_this), t1, H.getTypeArgumentByIndex(_this, 1));
    },
    containsKey$1: function(_, key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, key), key) >= 0;
    },
    $index: function(_, key) {
      var strings, t1, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._collection$_strings;
        t1 = strings == null ? null : P._HashMap__getTableEntry(strings, key);
        return t1;
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = this._collection$_nums;
        t1 = nums == null ? null : P._HashMap__getTableEntry(nums, key);
        return t1;
      } else
        return this._get$1(0, key);
    },
    _get$1: function(_, key) {
      var bucket, index,
        rest = this._collection$_rest;
      if (rest == null)
        return;
      bucket = this._getBucket$2(rest, key);
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (typeof key === "string" && key !== "__proto__") {
        strings = _this._collection$_strings;
        _this._collection$_addHashTableEntry$3(strings == null ? _this._collection$_strings = P._HashMap__newHashTable() : strings, key, value);
      } else if (typeof key === "number" && (key & 1073741823) === key) {
        nums = _this._collection$_nums;
        _this._collection$_addHashTableEntry$3(nums == null ? _this._collection$_nums = P._HashMap__newHashTable() : nums, key, value);
      } else
        _this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._HashMap__newHashTable();
      hash = _this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++_this._collection$_length;
        _this._keys = null;
      } else {
        index = _this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++_this._collection$_length;
          _this._keys = null;
        }
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1, H.getTypeArgumentByIndex(_this, 1)]});
      keys = _this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(H.assertSubtypeOfRuntimeType(key, t1), _this.$index(0, key));
        if (keys !== _this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    _computeKeys$0: function() {
      var result, strings, names, entries, index, i, nums, rest, bucket, $length, i0, _this = this,
        t1 = _this._keys;
      if (t1 != null)
        return t1;
      result = new Array(_this._collection$_length);
      result.fixed$length = Array;
      strings = _this._collection$_strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = _this._collection$_nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = _this._collection$_rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      return _this._keys = result;
    },
    _collection$_addHashTableEntry$3: function(table, key, value) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (table[key] == null) {
        ++_this._collection$_length;
        _this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 1073741823;
    },
    _getBucket$2: function(table, key) {
      return table[this._computeHashCode$1(key)];
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq$(bucket[i], key))
          return i;
      return -1;
    }
  };
  P._HashMap_values_closure.prototype = {
    call$1: function(each) {
      var t1 = this.$this;
      return t1.$index(0, H.assertSubtypeOfRuntimeType(each, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: H.getTypeArgumentByIndex(t1, 1), args: [H.getTypeArgumentByIndex(t1, 0)]};
    }
  };
  P._IdentityHashMap.prototype = {
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2) {
        t1 = bucket[i];
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  P._CustomHashMap.prototype = {
    $index: function(_, key) {
      if (!H.boolConversionCheck(this._validKey.call$1(key)))
        return;
      return this.super$_HashMap$_get(0, key);
    },
    $indexSet: function(_, key, value) {
      this.super$_HashMap$_set(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
    },
    containsKey$1: function(_, key) {
      if (!H.boolConversionCheck(this._validKey.call$1(key)))
        return false;
      return this.super$_HashMap$_containsKey(key);
    },
    _computeHashCode$1: function(key) {
      return this._hashCode.call$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0))) & 1073741823;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, t1, t2, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (t1 = H.getTypeArgumentByIndex(this, 0), t2 = this._equals, i = 0; i < $length; i += 2)
        if (H.boolConversionCheck(t2.call$2(bucket[i], H.assertSubtypeOfRuntimeType(key, t1))))
          return i;
      return -1;
    }
  };
  P._CustomHashMap_closure.prototype = {
    call$1: function(v) {
      return H.checkSubtypeOfRuntimeType(v, this.K);
    },
    $signature: 11
  };
  P._HashMapKeyIterable.prototype = {
    get$length: function(_) {
      return this._collection$_map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map;
      return new P._HashMapKeyIterator(t1, t1._computeKeys$0(), this.$ti);
    },
    contains$1: function(_, element) {
      return this._collection$_map.containsKey$1(0, element);
    }
  };
  P._HashMapKeyIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        keys = _this._keys,
        offset = _this._offset,
        t1 = _this._collection$_map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        _this.set$_collection$_current(null);
        return false;
      } else {
        _this.set$_collection$_current(keys[offset]);
        _this._offset = offset + 1;
        return true;
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P._LinkedIdentityHashMap.prototype = {
    internalComputeHashCode$1: function(key) {
      return H.objectHashCode(key) & 1073741823;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i].hashMapCellKey;
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  };
  P._LinkedCustomHashMap.prototype = {
    $index: function(_, key) {
      if (!H.boolConversionCheck(this._validKey.call$1(key)))
        return;
      return this.super$JsLinkedHashMap$internalGet(key);
    },
    $indexSet: function(_, key, value) {
      this.super$JsLinkedHashMap$internalSet(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
    },
    containsKey$1: function(_, key) {
      if (!H.boolConversionCheck(this._validKey.call$1(key)))
        return false;
      return this.super$JsLinkedHashMap$internalContainsKey(key);
    },
    remove$1: function(_, key) {
      if (!H.boolConversionCheck(this._validKey.call$1(key)))
        return;
      return this.super$JsLinkedHashMap$internalRemove(key);
    },
    internalComputeHashCode$1: function(key) {
      return this._hashCode.call$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0))) & 1073741823;
    },
    internalFindBucketIndex$2: function(bucket, key) {
      var $length, t1, t2, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (t1 = H.getTypeArgumentByIndex(this, 0), t2 = this._equals, i = 0; i < $length; ++i)
        if (H.boolConversionCheck(t2.call$2(H.assertSubtypeOfRuntimeType(bucket[i].hashMapCellKey, t1), H.assertSubtypeOfRuntimeType(key, t1))))
          return i;
      return -1;
    }
  };
  P._LinkedCustomHashMap_closure.prototype = {
    call$1: function(v) {
      return H.checkSubtypeOfRuntimeType(v, this.K);
    },
    $signature: 11
  };
  P._LinkedHashSet.prototype = {
    _newSimilarSet$1$0: function($R) {
      return new P._LinkedHashSet([$R]);
    },
    _newSimilarSet$0: function() {
      return this._newSimilarSet$1$0(null);
    },
    get$iterator: function(_) {
      var _this = this,
        t1 = new P._LinkedHashSetIterator(_this, _this._collection$_modifications, _this.$ti);
      t1._collection$_cell = _this._collection$_first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._collection$_strings;
        if (strings == null)
          return false;
        return H.interceptedTypeCheck(strings[object], "$is_LinkedHashSetCell") != null;
      } else if (typeof object === "number" && (object & 1073741823) === object) {
        nums = this._collection$_nums;
        if (nums == null)
          return false;
        return H.interceptedTypeCheck(nums[object], "$is_LinkedHashSetCell") != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._collection$_rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(this._getBucket$2(rest, object), object) >= 0;
    },
    forEach$1: function(_, action) {
      var cell, modifications, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [t1]});
      cell = _this._collection$_first;
      modifications = _this._collection$_modifications;
      for (; cell != null;) {
        action.call$1(H.assertSubtypeOfRuntimeType(cell._collection$_element, t1));
        if (modifications !== _this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        cell = cell._collection$_next;
      }
    },
    get$first: function(_) {
      var t1 = this._collection$_first;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return H.assertSubtypeOfRuntimeType(t1._collection$_element, H.getTypeArgumentByIndex(this, 0));
    },
    get$last: function(_) {
      var t1 = this._collection$_last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return H.assertSubtypeOfRuntimeType(t1._collection$_element, H.getTypeArgumentByIndex(this, 0));
    },
    add$1: function(_, element) {
      var strings, nums, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof element === "string" && element !== "__proto__") {
        strings = _this._collection$_strings;
        return _this._collection$_addHashTableEntry$2(strings == null ? _this._collection$_strings = P._LinkedHashSet__newHashTable() : strings, element);
      } else if (typeof element === "number" && (element & 1073741823) === element) {
        nums = _this._collection$_nums;
        return _this._collection$_addHashTableEntry$2(nums == null ? _this._collection$_nums = P._LinkedHashSet__newHashTable() : nums, element);
      } else
        return _this._collection$_add$1(0, element);
    },
    _collection$_add$1: function(_, element) {
      var rest, hash, bucket, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rest = _this._collection$_rest;
      if (rest == null)
        rest = _this._collection$_rest = P._LinkedHashSet__newHashTable();
      hash = _this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [_this._collection$_newLinkedCell$1(element)];
      else {
        if (_this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(_this._collection$_newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      var _this = this;
      if (typeof object === "string" && object !== "__proto__")
        return _this._collection$_removeHashTableEntry$2(_this._collection$_strings, object);
      else if (typeof object === "number" && (object & 1073741823) === object)
        return _this._collection$_removeHashTableEntry$2(_this._collection$_nums, object);
      else
        return _this._collection$_remove$1(0, object);
    },
    _collection$_remove$1: function(_, object) {
      var bucket, index, _this = this,
        rest = _this._collection$_rest;
      if (rest == null)
        return false;
      bucket = _this._getBucket$2(rest, object);
      index = _this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      _this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    removeWhere$1: function(_, test) {
      this._filterWhere$2(H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this, 0)]}), true);
    },
    _filterWhere$2: function(test, removeMatching) {
      var cell, element, next, modifications, t2, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      cell = _this._collection$_first;
      for (; cell != null; cell = next) {
        element = H.assertSubtypeOfRuntimeType(cell._collection$_element, t1);
        next = cell._collection$_next;
        modifications = _this._collection$_modifications;
        t2 = test.call$1(element);
        if (modifications !== _this._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
        if (true === t2)
          _this.remove$1(0, element);
      }
    },
    clear$0: function(_) {
      var _this = this;
      if (_this._collection$_length > 0) {
        _this._collection$_strings = _this._collection$_nums = _this._collection$_rest = _this._collection$_first = _this._collection$_last = null;
        _this._collection$_length = 0;
        _this._collection$_modified$0();
      }
    },
    _collection$_addHashTableEntry$2: function(table, element) {
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(this, 0));
      if (H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell") != null)
        return false;
      table[element] = this._collection$_newLinkedCell$1(element);
      return true;
    },
    _collection$_removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = H.interceptedTypeCheck(table[element], "$is_LinkedHashSetCell");
      if (cell == null)
        return false;
      this._collection$_unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _collection$_modified$0: function() {
      this._collection$_modifications = 1073741823 & this._collection$_modifications + 1;
    },
    _collection$_newLinkedCell$1: function(element) {
      var last, _this = this,
        cell = new P._LinkedHashSetCell(H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0)));
      if (_this._collection$_first == null)
        _this._collection$_first = _this._collection$_last = cell;
      else {
        last = _this._collection$_last;
        cell._collection$_previous = last;
        _this._collection$_last = last._collection$_next = cell;
      }
      ++_this._collection$_length;
      _this._collection$_modified$0();
      return cell;
    },
    _collection$_unlinkCell$1: function(cell) {
      var _this = this,
        previous = cell._collection$_previous,
        next = cell._collection$_next;
      if (previous == null)
        _this._collection$_first = next;
      else
        previous._collection$_next = next;
      if (next == null)
        _this._collection$_last = previous;
      else
        next._collection$_previous = previous;
      --_this._collection$_length;
      _this._collection$_modified$0();
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 1073741823;
    },
    _getBucket$2: function(table, element) {
      return table[this._computeHashCode$1(element)];
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq$(bucket[i]._collection$_element, element))
          return i;
      return -1;
    }
  };
  P._LinkedHashSetCell.prototype = {};
  P._LinkedHashSetIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this._set;
      if (_this._collection$_modifications !== t1._collection$_modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = _this._collection$_cell;
        if (t1 == null) {
          _this.set$_collection$_current(null);
          return false;
        } else {
          _this.set$_collection$_current(H.assertSubtypeOfRuntimeType(t1._collection$_element, H.getTypeArgumentByIndex(_this, 0)));
          _this._collection$_cell = _this._collection$_cell._collection$_next;
          return true;
        }
      }
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P.IterableBase.prototype = {};
  P.LinkedHashMap_LinkedHashMap$from_closure.prototype = {
    call$2: function(k, v) {
      this.result.$indexSet(0, H.assertSubtypeOfRuntimeType(k, this.K), H.assertSubtypeOfRuntimeType(v, this.V));
    },
    $signature: 12
  };
  P.ListBase.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isList: 1};
  P.ListMixin.prototype = {
    get$iterator: function(receiver) {
      return new H.ListIterator(receiver, this.get$length(receiver), [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$isNotEmpty: function(receiver) {
      return !this.get$isEmpty(receiver);
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.$index(receiver, 0);
    },
    get$last: function(receiver) {
      var t1;
      if (this.get$length(receiver) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this.get$length(receiver);
      if (typeof t1 !== "number")
        return t1.$sub();
      return this.$index(receiver, t1 - 1);
    },
    contains$1: function(receiver, element) {
      var i,
        $length = this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        if (J.$eq$(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    firstWhere$2$orElse: function(receiver, test, orElse) {
      var $length, i, element, _this = this,
        t1 = H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      $length = _this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = _this.$index(receiver, i);
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return orElse.call$0();
    },
    join$1: function(receiver, separator) {
      var t1;
      if (this.get$length(receiver) === 0)
        return "";
      t1 = P.StringBuffer__writeAll("", receiver, separator);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    where$1: function(receiver, test) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      return new H.WhereIterable(receiver, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), [t1]);
    },
    map$1$1: function(receiver, f, $T) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      return new H.MappedListIterable(receiver, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    fold$1$2: function(receiver, initialValue, combine, $T) {
      var $length, value, i, _this = this;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]});
      $length = _this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      value = initialValue;
      i = 0;
      for (; i < $length; ++i) {
        value = combine.call$2(value, _this.$index(receiver, i));
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    skip$1: function(receiver, count) {
      return H.SubListIterable$(receiver, count, null, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
    },
    take$1: function(receiver, count) {
      return H.SubListIterable$(receiver, 0, count, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
    },
    toList$1$growable: function(receiver, growable) {
      var i, t1, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(receiver));
      i = 0;
      while (true) {
        t1 = _this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        C.JSArray_methods.$indexSet(result, i, _this.$index(receiver, i));
        ++i;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: function(receiver, element) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0));
      t1 = _this.get$length(receiver);
      if (typeof t1 !== "number")
        return t1.$add();
      _this.set$length(receiver, t1 + 1);
      _this.$indexSet(receiver, t1, element);
    },
    remove$1: function(receiver, element) {
      var t1, i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq$(this.$index(receiver, i), element)) {
          this._closeGap$2(receiver, i, i + 1);
          return true;
        }
        ++i;
      }
      return false;
    },
    _closeGap$2: function(receiver, start, end) {
      var size, i, _this = this,
        $length = _this.get$length(receiver);
      if (typeof start !== "number")
        return H.iae(start);
      size = end - start;
      if (typeof $length !== "number")
        return H.iae($length);
      i = end;
      for (; i < $length; ++i)
        _this.$indexSet(receiver, i - size, _this.$index(receiver, i));
      _this.set$length(receiver, $length - size);
    },
    removeWhere$1: function(receiver, test) {
      this._filter$2(receiver, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]}), false);
    },
    _filter$2: function(receiver, test, retainMatching) {
      var retained, $length, i, element, _this = this,
        t1 = H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      retained = H.setRuntimeTypeInfo([], [t1]);
      $length = _this.get$length(receiver);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i) {
        element = _this.$index(receiver, i);
        if (J.$eq$(test.call$1(element), false))
          C.JSArray_methods.add$1(retained, element);
        if ($length !== _this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      if (retained.length !== _this.get$length(receiver)) {
        _this.setRange$3(receiver, 0, retained.length, retained);
        _this.set$length(receiver, retained.length);
      }
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    cast$1$0: function(receiver, $R) {
      return new H.CastList(receiver, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), $R]);
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      H.Sort_sort(receiver, compare == null ? P.collection_ListMixin__compareAny$closure() : compare, t1);
    },
    $add: function(receiver, other) {
      var result, t2, _this = this,
        t1 = [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0)];
      H.assertSubtype(other, "$isList", t1, "$asList");
      result = H.setRuntimeTypeInfo([], t1);
      t1 = _this.get$length(receiver);
      t2 = J.get$length$asx(other);
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      C.JSArray_methods.set$length(result, t1 + t2);
      C.JSArray_methods.setRange$3(result, 0, _this.get$length(receiver), receiver);
      C.JSArray_methods.setRange$3(result, _this.get$length(receiver), result.length, other);
      return result;
    },
    fillRange$3: function(receiver, start, end, fill) {
      var i;
      H.assertSubtypeOfRuntimeType(fill, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      P.RangeError_checkValidRange(start, end, this.get$length(receiver));
      for (i = start; i < end; ++i)
        this.$indexSet(receiver, i, fill);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, otherStart, otherList, t2, i, _this = this,
        t1 = H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0);
      H.assertSubtype(iterable, "$isIterable", [t1], "$asIterable");
      P.RangeError_checkValidRange(start, end, _this.get$length(receiver));
      if (typeof end !== "number")
        return end.$sub();
      $length = end - start;
      if ($length === 0)
        return;
      P.RangeError_checkNotNegative(skipCount, "skipCount");
      if (H.checkSubtype(iterable, "$isList", [t1], "$asList")) {
        otherStart = skipCount;
        otherList = iterable;
      } else {
        otherList = J.skip$1$ax(iterable, skipCount).toList$1$growable(0, false);
        otherStart = 0;
      }
      t1 = J.getInterceptor$asx(otherList);
      t2 = t1.get$length(otherList);
      if (typeof t2 !== "number")
        return H.iae(t2);
      if (otherStart + $length > t2)
        throw H.wrapException(H.IterableElementError_tooFew());
      if (otherStart < start)
        for (i = $length - 1; i >= 0; --i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
      else
        for (i = 0; i < $length; ++i)
          _this.$indexSet(receiver, start + i, t1.$index(otherList, otherStart + i));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    indexOf$1: function(receiver, element) {
      var t1, i = 0;
      while (true) {
        t1 = this.get$length(receiver);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(i < t1))
          break;
        if (J.$eq$(this.$index(receiver, i), element))
          return i;
        ++i;
      }
      return -1;
    },
    insert$2: function(receiver, index, element) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(_this, receiver, "ListMixin", 0));
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull("index"));
      P.RangeError_checkValueInInterval(index, 0, _this.get$length(receiver), "index");
      if (index == _this.get$length(receiver)) {
        _this.add$1(receiver, element);
        return;
      }
      t1 = _this.get$length(receiver);
      if (typeof t1 !== "number")
        return t1.$add();
      _this.set$length(receiver, t1 + 1);
      if (typeof index !== "number")
        return index.$add();
      _this.setRange$4(receiver, index + 1, _this.get$length(receiver), receiver, index);
      _this.$indexSet(receiver, index, element);
    },
    removeAt$1: function(receiver, index) {
      var result = this.$index(receiver, index);
      if (typeof index !== "number")
        return index.$add();
      this._closeGap$2(receiver, index, index + 1);
      return result;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    }
  };
  P.MapBase.prototype = {};
  P.MapBase_mapToString_closure.prototype = {
    call$2: function(k, v) {
      var t2,
        t1 = this._box_0;
      if (!t1.first)
        this.result._contents += ", ";
      t1.first = false;
      t1 = this.result;
      t2 = t1._contents += H.S(k);
      t1._contents = t2 + ": ";
      t1._contents += H.S(v);
    },
    $signature: 12
  };
  P.MapMixin.prototype = {
    forEach$1: function(receiver, action) {
      var t1, key, _this = this;
      H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 1)]});
      for (t1 = J.get$iterator$ax(_this.get$keys(receiver)); t1.moveNext$0();) {
        key = t1.get$current(t1);
        action.call$2(key, _this.$index(receiver, key));
      }
    },
    get$entries: function(receiver) {
      return J.map$1$1$ax(this.get$keys(receiver), new P.MapMixin_entries_closure(receiver), [P.MapEntry, H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 1)]);
    },
    map$2$1: function(receiver, transform, K2, V2) {
      var result, t1, key, entry, _this = this;
      H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(_this, receiver, "MapMixin", 1)]});
      result = P.LinkedHashMap_LinkedHashMap$_empty(K2, V2);
      for (t1 = J.get$iterator$ax(_this.get$keys(receiver)); t1.moveNext$0();) {
        key = t1.get$current(t1);
        entry = transform.call$2(key, _this.$index(receiver, key));
        result.$indexSet(0, entry.key, entry.value);
      }
      return result;
    },
    map$1: function($receiver, transform) {
      return this.map$2$1($receiver, transform, null, null);
    },
    addEntries$1: function(receiver, newEntries) {
      var t1, t2;
      H.assertSubtype(newEntries, "$isIterable", [[P.MapEntry, H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 1)]], "$asIterable");
      for (t1 = newEntries.get$iterator(newEntries); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        this.$indexSet(receiver, t2.key, t2.value);
      }
    },
    containsKey$1: function(receiver, key) {
      return J.contains$1$asx(this.get$keys(receiver), key);
    },
    get$length: function(receiver) {
      return J.get$length$asx(this.get$keys(receiver));
    },
    get$isEmpty: function(receiver) {
      return J.get$isEmpty$asx(this.get$keys(receiver));
    },
    get$isNotEmpty: function(receiver) {
      return J.get$isNotEmpty$asx(this.get$keys(receiver));
    },
    get$values: function(receiver) {
      return new P._MapBaseValueIterable(receiver, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 0), H.getRuntimeTypeArgumentIntercepted(this, receiver, "MapMixin", 1)]);
    },
    toString$0: function(receiver) {
      return P.MapBase_mapToString(receiver);
    },
    $isMap: 1
  };
  P.MapMixin_entries_closure.prototype = {
    call$1: function(key) {
      var t1 = this.$this,
        t2 = J.getInterceptor$(t1),
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 0);
      H.assertSubtypeOfRuntimeType(key, t3);
      return new P.MapEntry(key, t2.$index(t1, key), [t3, H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 1)]);
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = J.getInterceptor$(t1),
        t3 = H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 0);
      return {func: 1, ret: [P.MapEntry, t3, H.getRuntimeTypeArgumentIntercepted(t2, t1, "MapMixin", 1)], args: [t3]};
    }
  };
  P._MapBaseValueIterable.prototype = {
    get$length: function(_) {
      return J.get$length$asx(this._collection$_map);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._collection$_map);
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this._collection$_map);
    },
    get$first: function(_) {
      var t1 = this._collection$_map,
        t2 = J.getInterceptor$x(t1);
      return t2.$index(t1, J.get$first$ax(t2.get$keys(t1)));
    },
    get$last: function(_) {
      var t1 = this._collection$_map,
        t2 = J.getInterceptor$x(t1);
      return t2.$index(t1, J.get$last$ax(t2.get$keys(t1)));
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map;
      return new P._MapBaseValueIterator(J.get$iterator$ax(J.get$keys$x(t1)), t1, this.$ti);
    },
    $asEfficientLengthIterable: function($K, $V) {
      return [$V];
    },
    $asIterable: function($K, $V) {
      return [$V];
    }
  };
  P._MapBaseValueIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        t1 = _this._keys;
      if (t1.moveNext$0()) {
        _this.set$_collection$_current(J.$index$asx(_this._collection$_map, t1.get$current(t1)));
        return true;
      }
      _this.set$_collection$_current(null);
      return false;
    },
    get$current: function(_) {
      return this._collection$_current;
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 1));
    },
    $isIterator: 1,
    $asIterator: function($K, $V) {
      return [$V];
    }
  };
  P._UnmodifiableMapMixin.prototype = {
    $indexSet: function(_, key, value) {
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 0));
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(this, "_UnmodifiableMapMixin", 1));
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
    }
  };
  P.MapView.prototype = {
    $index: function(_, key) {
      return J.$index$asx(this._collection$_map, key);
    },
    $indexSet: function(_, key, value) {
      J.$indexSet$ax(this._collection$_map, H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0)), H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1)));
    },
    containsKey$1: function(_, key) {
      return J.containsKey$1$x(this._collection$_map, key);
    },
    forEach$1: function(_, action) {
      J.forEach$1$ax(this._collection$_map, H.functionTypeCheck(action, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]}));
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._collection$_map);
    },
    get$isNotEmpty: function(_) {
      return J.get$isNotEmpty$asx(this._collection$_map);
    },
    get$length: function(_) {
      return J.get$length$asx(this._collection$_map);
    },
    get$keys: function(_) {
      return J.get$keys$x(this._collection$_map);
    },
    toString$0: function(_) {
      return J.toString$0$(this._collection$_map);
    },
    get$values: function(_) {
      return J.get$values$x(this._collection$_map);
    },
    get$entries: function(_) {
      return J.get$entries$x(this._collection$_map);
    },
    map$2$1: function(_, transform, K2, V2) {
      return J.map$2$1$ax(this._collection$_map, H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1)]}), K2, V2);
    },
    map$1: function($receiver, transform) {
      return this.map$2$1($receiver, transform, null, null);
    },
    $isMap: 1
  };
  P.UnmodifiableMapView.prototype = {};
  P.ListQueue.prototype = {
    cast$1$0: function(_, $R) {
      return new H.CastQueue(this, [H.getTypeArgumentByIndex(this, 0), $R]);
    },
    get$iterator: function(_) {
      var _this = this;
      return new P._ListQueueIterator(_this, _this._tail, _this._modificationCount, _this._head, _this.$ti);
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._collection$_table.length - 1) >>> 0;
    },
    get$first: function(_) {
      var t2,
        t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      t2 = this._collection$_table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return t2[t1];
    },
    get$last: function(_) {
      var t3,
        t1 = this._head,
        t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._collection$_table;
      t3 = t1.length;
      t2 = (t2 - 1 & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    elementAt$1: function(_, index) {
      var t1, t2, t3, _this = this,
        $length = _this.get$length(_this);
      if (typeof index !== "number")
        return H.iae(index);
      if (0 > index || index >= $length)
        H.throwExpression(P.IndexError$(index, _this, "index", null, $length));
      t1 = _this._collection$_table;
      t2 = t1.length;
      t3 = (_this._head + index & t2 - 1) >>> 0;
      if (t3 < 0 || t3 >= t2)
        return H.ioore(t1, t3);
      return t1[t3];
    },
    toList$1$growable: function(_, growable) {
      var _this = this,
        list = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(list, _this.get$length(_this));
      _this._writeToList$1(list);
      return list;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize, _this = this;
      H.assertSubtype(target, "$isList", _this.$ti, "$asList");
      t1 = _this._head;
      t2 = _this._tail;
      t3 = _this._collection$_table;
      if (t1 <= t2) {
        $length = t2 - t1;
        C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
        C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + _this._tail, _this._collection$_table, 0);
        return _this._tail + firstPartSize;
      }
    },
    set$_collection$_table: function(_table) {
      this._collection$_table = H.assertSubtype(_table, "$isList", this.$ti, "$asList");
    },
    $isQueue: 1
  };
  P._ListQueueIterator.prototype = {
    get$current: function(_) {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._queue;
      if (_this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = _this._collection$_position;
      if (t2 === _this._end) {
        _this.set$_collection$_current(null);
        return false;
      }
      t3 = t1._collection$_table;
      if (t2 >= t3.length)
        return H.ioore(t3, t2);
      _this.set$_collection$_current(t3[t2]);
      _this._collection$_position = (_this._collection$_position + 1 & t1._collection$_table.length - 1) >>> 0;
      return true;
    },
    set$_collection$_current: function(_current) {
      this._collection$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  P.SetMixin.prototype = {
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) !== 0;
    },
    cast$1$0: function(_, $R) {
      return P.Set_castFrom(this, null, H.getRuntimeTypeArgument(this, "SetMixin", 0), $R);
    },
    removeWhere$1: function(_, test) {
      var toRemove, t1, element;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getRuntimeTypeArgument(this, "SetMixin", 0)]});
      toRemove = [];
      for (t1 = this.readClasses$0(), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();) {
        element = t1._collection$_current;
        if (H.boolConversionCheck(test.call$1(element)))
          toRemove.push(element);
      }
      this.removeAll$1(toRemove);
    },
    toList$1$growable: function(_, growable) {
      var t1, i, i0, _this = this,
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(_this, "SetMixin", 0)]);
      C.JSArray_methods.set$length(result, _this.get$length(_this));
      for (t1 = _this.readClasses$0(), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        C.JSArray_methods.$indexSet(result, i, t1._collection$_current);
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "SetMixin", 0);
      return new H.EfficientLengthMappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "SetMixin", 0)]});
      for (t1 = this.readClasses$0(), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
        f.call$1(t1._collection$_current);
    },
    join$1: function(_, separator) {
      var t1 = this.readClasses$0(),
        iterator = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0));
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator._collection$_current);
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator._collection$_current);
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator._collection$_current);
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    take$1: function(_, n) {
      return H.TakeIterable_TakeIterable(this, n, H.getRuntimeTypeArgument(this, "SetMixin", 0));
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getRuntimeTypeArgument(this, "SetMixin", 0));
    },
    get$first: function(_) {
      var t1 = this.readClasses$0(),
        it = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0));
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it._collection$_current;
    },
    get$last: function(_) {
      var result,
        t1 = this.readClasses$0(),
        it = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0));
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it._collection$_current;
      while (it.moveNext$0());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = this.readClasses$0(), t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)), elementIndex = 0; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    }
  };
  P.SetBase.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1, $isSet: 1};
  P._SetBase.prototype = {
    cast$1$0: function(_, $R) {
      return P.Set_castFrom(this, this.get$_newSimilarSet(), H.getTypeArgumentByIndex(this, 0), $R);
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_length !== 0;
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(H.assertSubtype(elements, "$isIterable", this.$ti, "$asIterable")); t1.moveNext$0();)
        this.add$1(0, t1.get$current(t1));
    },
    removeAll$1: function(elements) {
      var t1, _i;
      H.assertSubtype(elements, "$isIterable", [P.Object], "$asIterable");
      for (t1 = elements.length, _i = 0; _i < elements.length; elements.length === t1 || (0, H.throwConcurrentModificationError)(elements), ++_i)
        this.remove$1(0, elements[_i]);
    },
    removeWhere$1: function(_, test) {
      var toRemove, t1, element, _this = this;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(_this, 0)]});
      toRemove = [];
      for (t1 = P._LinkedHashSetIterator$(_this, _this._collection$_modifications, H.getTypeArgumentByIndex(_this, 0)); t1.moveNext$0();) {
        element = t1._collection$_current;
        if (H.boolConversionCheck(test.call$1(element)))
          toRemove.push(element);
      }
      _this.removeAll$1(toRemove);
    },
    toList$1$growable: function(_, growable) {
      var t1, i, i0, _this = this,
        result = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(result, _this._collection$_length);
      for (t1 = P._LinkedHashSetIterator$(_this, _this._collection$_modifications, H.getTypeArgumentByIndex(_this, 0)), i = 0; t1.moveNext$0(); i = i0) {
        i0 = i + 1;
        C.JSArray_methods.$indexSet(result, i, t1._collection$_current);
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      return new H.EfficientLengthMappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), [t1, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    forEach$1: function(_, f) {
      var t1, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      for (t1 = P._LinkedHashSetIterator$(_this, _this._collection$_modifications, H.getTypeArgumentByIndex(_this, 0)); t1.moveNext$0();)
        f.call$1(t1._collection$_current);
    },
    join$1: function(_, separator) {
      var t1,
        iterator = P._LinkedHashSetIterator$(this, this._collection$_modifications, H.getTypeArgumentByIndex(this, 0));
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator._collection$_current);
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator._collection$_current);
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator._collection$_current);
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    take$1: function(_, n) {
      return H.TakeIterable_TakeIterable(this, n, H.getTypeArgumentByIndex(this, 0));
    },
    skip$1: function(_, n) {
      return H.SkipIterable_SkipIterable(this, n, H.getTypeArgumentByIndex(this, 0));
    },
    get$first: function(_) {
      var it = P._LinkedHashSetIterator$(this, this._collection$_modifications, H.getTypeArgumentByIndex(this, 0));
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it._collection$_current;
    },
    get$last: function(_) {
      var result,
        it = P._LinkedHashSetIterator$(this, this._collection$_modifications, H.getTypeArgumentByIndex(this, 0));
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it._collection$_current;
      while (it.moveNext$0());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _this = this, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = P._LinkedHashSetIterator$(_this, _this._collection$_modifications, H.getTypeArgumentByIndex(_this, 0)), elementIndex = 0; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, _this, _s5_, null, elementIndex));
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isSet: 1
  };
  P._SplayTreeNode.prototype = {
    set$left: function(_, left) {
      this.left = H.assertSubtype(left, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeNode", 0)], "$as_SplayTreeNode");
    },
    set$right: function(_, right) {
      this.right = H.assertSubtype(right, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeNode", 0)], "$as_SplayTreeNode");
    },
    get$key: function(receiver) {
      return this.key;
    }
  };
  P._SplayTreeMapNode.prototype = {
    set$value: function(_, value) {
      this.value = H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 1));
    },
    $as_SplayTreeNode: function($K, $V) {
      return [$K];
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  P._SplayTree.prototype = {
    _splay$1: function(key) {
      var current, left, t1, t2, right, left0, comp, t3, t4, t5, tmp, current0, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(_this, "_SplayTree", 0));
      current = _this._collection$_root;
      if (current == null)
        return -1;
      left = _this._dummy;
      for (t1 = H.getRuntimeTypeArgument(_this, "_SplayTree", 1), t2 = H.getTypeArgumentByIndex(_this, 0), right = left, left0 = right, comp = null; true;) {
        t3 = H.assertSubtypeOfRuntimeType(current.key, t2);
        H.assertSubtypeOfRuntimeType(key, t2);
        t4 = _this._comparator;
        t3 = t4.call$2(t3, key);
        if (typeof t3 !== "number")
          return t3.$gt();
        if (t3 > 0) {
          t5 = current.left;
          if (t5 == null) {
            comp = t3;
            break;
          }
          t3 = t4.call$2(H.assertSubtypeOfRuntimeType(t5.key, t2), key);
          if (typeof t3 !== "number")
            return t3.$gt();
          if (t3 > 0) {
            tmp = current.left;
            current.set$left(0, tmp.right);
            tmp.set$right(0, current);
            H.assertSubtypeOfRuntimeType(tmp, t1);
            if (tmp.left == null) {
              comp = t3;
              current = tmp;
              break;
            }
            current = tmp;
          }
          right.set$left(0, current);
          current0 = H.assertSubtypeOfRuntimeType(current.left, t1);
          comp = t3;
          right = current;
          current = current0;
        } else {
          if (t3 < 0) {
            t5 = current.right;
            if (t5 == null) {
              comp = t3;
              break;
            }
            t3 = t4.call$2(H.assertSubtypeOfRuntimeType(t5.key, t2), key);
            if (typeof t3 !== "number")
              return t3.$lt();
            if (t3 < 0) {
              tmp = H.assertSubtypeOfRuntimeType(current.right, t1);
              current.set$right(0, tmp.left);
              tmp.set$left(0, current);
              if (tmp.right == null) {
                comp = t3;
                current = tmp;
                break;
              }
              current = tmp;
            }
            left0.set$right(0, current);
            current0 = H.assertSubtypeOfRuntimeType(current.right, t1);
          } else {
            comp = t3;
            break;
          }
          comp = t3;
          left0 = current;
          current = current0;
        }
      }
      left0.set$right(0, current.left);
      right.set$left(0, current.right);
      current.set$left(0, left.right);
      current.set$right(0, left.left);
      _this.set$_collection$_root(current);
      left.set$right(0, null);
      left.set$left(0, null);
      ++_this._splayCount;
      return comp;
    },
    _addNewRoot$2: function(node, comp) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(node, H.getRuntimeTypeArgument(_this, "_SplayTree", 1));
      ++_this._count;
      ++_this._modificationCount;
      t1 = _this._collection$_root;
      if (t1 == null) {
        _this.set$_collection$_root(node);
        return;
      }
      if (typeof comp !== "number")
        return comp.$lt();
      if (comp < 0) {
        node.set$left(0, t1);
        node.set$right(0, _this._collection$_root.right);
        _this._collection$_root.set$right(0, null);
      } else {
        node.set$right(0, t1);
        node.set$left(0, _this._collection$_root.left);
        _this._collection$_root.set$left(0, null);
      }
      _this.set$_collection$_root(node);
    }
  };
  P.SplayTreeMap.prototype = {
    $index: function(_, key) {
      var _this = this;
      if (!H.boolConversionCheck(_this._validKey.call$1(key)))
        return;
      if (_this._collection$_root != null)
        if (_this._splay$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0))) === 0)
          return _this._collection$_root.value;
      return;
    },
    $indexSet: function(_, key, value) {
      var comp, _this = this;
      H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(_this, 1));
      if (key == null)
        throw H.wrapException(P.ArgumentError$(key));
      comp = _this._splay$1(key);
      if (comp === 0) {
        _this._collection$_root.set$value(0, value);
        return;
      }
      _this._addNewRoot$2(new P._SplayTreeMapNode(value, key, _this.$ti), comp);
    },
    get$isEmpty: function(_) {
      return this._collection$_root == null;
    },
    get$isNotEmpty: function(_) {
      return this._collection$_root != null;
    },
    forEach$1: function(_, f) {
      var nodes, node, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [t1, H.getTypeArgumentByIndex(_this, 1)]});
      nodes = new P._SplayTreeNodeIterator(_this, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, t1]]), _this._modificationCount, _this._splayCount, [t1]);
      nodes._findLeftMostDescendent$1(_this._collection$_root);
      for (t1 = _this.$ti; nodes.moveNext$0();) {
        node = H.assertSubtype(nodes.get$current(nodes), "$is_SplayTreeMapNode", t1, "$as_SplayTreeMapNode");
        f.call$2(node.key, node.value);
      }
    },
    get$length: function(_) {
      return this._count;
    },
    containsKey$1: function(_, key) {
      return H.boolConversionCheck(this._validKey.call$1(key)) && this._splay$1(H.assertSubtypeOfRuntimeType(key, H.getTypeArgumentByIndex(this, 0))) === 0;
    },
    get$keys: function(_) {
      return new P._SplayTreeKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return new P._SplayTreeValueIterable(this, this.$ti);
    },
    set$_collection$_root: function(_root) {
      this._collection$_root = H.assertSubtype(_root, "$is_SplayTreeMapNode", this.$ti, "$as_SplayTreeMapNode");
    },
    $as_SplayTree: function($K, $V) {
      return [$K, [P._SplayTreeMapNode, $K, $V]];
    },
    $isMap: 1
  };
  P.SplayTreeMap_closure.prototype = {
    call$1: function(v) {
      return H.checkSubtypeOfRuntimeType(v, this.K);
    },
    $signature: 11
  };
  P._SplayTreeIterator.prototype = {
    get$current: function(_) {
      var t1 = this._currentNode;
      if (t1 == null)
        return;
      return this._getValue$1(t1);
    },
    _findLeftMostDescendent$1: function(node) {
      var t1;
      H.assertSubtype(node, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
      for (t1 = this._workList; node != null;) {
        C.JSArray_methods.add$1(t1, node);
        node = node.left;
      }
    },
    moveNext$0: function() {
      var t2, t3, _this = this,
        t1 = _this._tree;
      if (_this._modificationCount !== t1._modificationCount)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t2 = _this._workList;
      if (t2.length === 0) {
        _this.set$_currentNode(null);
        return false;
      }
      if (t1._splayCount !== _this._splayCount && _this._currentNode != null) {
        t3 = H.assertSubtype(_this._currentNode, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(_this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
        C.JSArray_methods.set$length(t2, 0);
        if (t3 == null)
          _this._findLeftMostDescendent$1(t1._collection$_root);
        else {
          t1._splay$1(t3.key);
          _this._findLeftMostDescendent$1(t1._collection$_root.right);
        }
      }
      if (0 >= t2.length)
        return H.ioore(t2, -1);
      _this.set$_currentNode(t2.pop());
      _this._findLeftMostDescendent$1(_this._currentNode.right);
      return true;
    },
    set$_currentNode: function(_currentNode) {
      this._currentNode = H.assertSubtype(_currentNode, "$is_SplayTreeNode", [H.getRuntimeTypeArgument(this, "_SplayTreeIterator", 0)], "$as_SplayTreeNode");
    },
    $isIterator: 1,
    $asIterator: function($K, $T) {
      return [$T];
    }
  };
  P._SplayTreeKeyIterable.prototype = {
    get$length: function(_) {
      return this._tree._count;
    },
    get$isEmpty: function(_) {
      return this._tree._count === 0;
    },
    get$iterator: function(_) {
      var t1 = this._tree,
        t2 = new P._SplayTreeKeyIterator(t1, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, H.getTypeArgumentByIndex(this, 0)]]), t1._modificationCount, t1._splayCount, this.$ti);
      t2._findLeftMostDescendent$1(t1._collection$_root);
      return t2;
    }
  };
  P._SplayTreeValueIterable.prototype = {
    get$length: function(_) {
      return this._collection$_map._count;
    },
    get$isEmpty: function(_) {
      return this._collection$_map._count === 0;
    },
    get$iterator: function(_) {
      var t1 = this._collection$_map,
        t2 = new P._SplayTreeValueIterator(t1, H.setRuntimeTypeInfo([], [[P._SplayTreeNode, H.getTypeArgumentByIndex(this, 0)]]), t1._modificationCount, t1._splayCount, this.$ti);
      t2._findLeftMostDescendent$1(t1._collection$_root);
      return t2;
    },
    $asEfficientLengthIterable: function($K, $V) {
      return [$V];
    },
    $asIterable: function($K, $V) {
      return [$V];
    }
  };
  P._SplayTreeKeyIterator.prototype = {
    _getValue$1: function(node) {
      return H.assertSubtype(node, "$is_SplayTreeNode", this.$ti, "$as_SplayTreeNode").key;
    },
    $as_SplayTreeIterator: function($K) {
      return [$K, $K];
    },
    $asIterator: null
  };
  P._SplayTreeValueIterator.prototype = {
    _getValue$1: function(node) {
      return H.assertSubtype(H.assertSubtype(node, "$is_SplayTreeNode", [H.getTypeArgumentByIndex(this, 0)], "$as_SplayTreeNode"), "$is_SplayTreeMapNode", this.$ti, "$as_SplayTreeMapNode").value;
    }
  };
  P._SplayTreeNodeIterator.prototype = {
    _getValue$1: function(node) {
      return H.assertSubtype(node, "$is_SplayTreeNode", this.$ti, "$as_SplayTreeNode");
    },
    $as_SplayTreeIterator: function($K) {
      return [$K, [P._SplayTreeNode, $K]];
    },
    $asIterator: function($K) {
      return [[P._SplayTreeNode, $K]];
    }
  };
  P._ListBase_Object_ListMixin.prototype = {};
  P._SetBase_Object_SetMixin.prototype = {};
  P._SplayTreeMap__SplayTree_MapMixin.prototype = {};
  P._UnmodifiableMapView_MapView__UnmodifiableMapMixin.prototype = {};
  P._JsonMap.prototype = {
    $index: function(_, key) {
      var result,
        t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._convert$_computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$length(this) > 0;
    },
    get$keys: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$keys(t1);
      }
      return new P._JsonMapKeyIterable(this);
    },
    get$values: function(_) {
      var t1, _this = this;
      if (_this._processed == null) {
        t1 = _this._data;
        return t1.get$values(t1);
      }
      return H.MappedIterable_MappedIterable(_this._convert$_computeKeys$0(), new P._JsonMap_values_closure(_this), P.String, null);
    },
    $indexSet: function(_, key, value) {
      var processed, original, _this = this;
      H.stringTypeCheck(key);
      if (_this._processed == null)
        _this._data.$indexSet(0, key, value);
      else if (_this.containsKey$1(0, key)) {
        processed = _this._processed;
        processed[key] = value;
        original = _this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        _this._upgrade$0().$indexSet(0, key, value);
    },
    containsKey$1: function(_, key) {
      if (this._processed == null)
        return this._data.containsKey$1(0, key);
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    forEach$1: function(_, f) {
      var keys, i, key, value, _this = this;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      if (_this._processed == null)
        return _this._data.forEach$1(0, f);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = _this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(_this._original[key]);
          _this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== _this._data)
          throw H.wrapException(P.ConcurrentModificationError$(_this));
      }
    },
    _convert$_computeKeys$0: function() {
      var keys = H.listTypeCheck(this._data);
      if (keys == null)
        keys = this._data = H.setRuntimeTypeInfo(Object.keys(this._original), [P.String]);
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key, _this = this;
      if (_this._processed == null)
        return _this._data;
      result = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      keys = _this._convert$_computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, _this.$index(0, key));
      }
      if (t1 === 0)
        C.JSArray_methods.add$1(keys, null);
      else
        C.JSArray_methods.set$length(keys, 0);
      _this._original = _this._processed = null;
      return _this._data = result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $asMap: function() {
      return [P.String, null];
    }
  };
  P._JsonMap_values_closure.prototype = {
    call$1: function(each) {
      return this.$this.$index(0, each);
    },
    $signature: 4
  };
  P._JsonMapKeyIterable.prototype = {
    get$length: function(_) {
      var t1 = this._parent;
      return t1.get$length(t1);
    },
    elementAt$1: function(_, index) {
      var t1 = this._parent;
      return t1._processed == null ? t1.get$keys(t1).elementAt$1(0, index) : C.JSArray_methods.$index(t1._convert$_computeKeys$0(), index);
    },
    get$iterator: function(_) {
      var t1 = this._parent;
      if (t1._processed == null) {
        t1 = t1.get$keys(t1);
        t1 = t1.get$iterator(t1);
      } else {
        t1 = t1._convert$_computeKeys$0();
        t1 = new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
      }
      return t1;
    },
    contains$1: function(_, key) {
      return this._parent.containsKey$1(0, key);
    },
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asListIterable: function() {
      return [P.String];
    },
    $asIterable: function() {
      return [P.String];
    }
  };
  P.AsciiCodec.prototype = {
    get$name: function(_) {
      return "us-ascii";
    },
    encode$1: function(source) {
      return C.AsciiEncoder_127.convert$1(source);
    },
    decode$1: function(_, bytes) {
      var t1;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      t1 = C.AsciiDecoder_false_127.convert$1(bytes);
      return t1;
    },
    get$encoder: function() {
      return C.AsciiEncoder_127;
    }
  };
  P._UnicodeSubsetEncoder.prototype = {
    convert$1: function(string) {
      var $length, result, t1, t2, t3, i, codeUnit,
        end = P.RangeError_checkValidRange(0, null, string.length);
      if (typeof end !== "number")
        return end.$sub();
      $length = end - 0;
      result = new Uint8Array($length);
      for (t1 = result.length, t2 = ~this._subsetMask, t3 = J.getInterceptor$s(string), i = 0; i < $length; ++i) {
        codeUnit = t3._codeUnitAt$1(string, i);
        if ((codeUnit & t2) !== 0)
          throw H.wrapException(P.ArgumentError$value(string, "string", "Contains invalid characters."));
        if (i >= t1)
          return H.ioore(result, i);
        result[i] = codeUnit;
      }
      return result;
    },
    $asStreamTransformer: function() {
      return [P.String, [P.List, P.int]];
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.AsciiEncoder.prototype = {};
  P._UnicodeSubsetDecoder.prototype = {
    convert$1: function(bytes) {
      var byteCount, t1, t2, i, byte;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      byteCount = bytes.length;
      P.RangeError_checkValidRange(0, null, byteCount);
      for (t1 = ~this._subsetMask, t2 = bytes.length, i = 0; i < byteCount; ++i) {
        if (i >= t2)
          return H.ioore(bytes, i);
        byte = bytes[i];
        if (typeof byte !== "number")
          return byte.$and();
        if ((byte & t1) >>> 0 !== 0) {
          if (!this._allowInvalid)
            throw H.wrapException(P.FormatException$("Invalid value in input: " + byte, null, null));
          return this._convertInvalid$3(bytes, 0, byteCount);
        }
      }
      return P.String_String$fromCharCodes(bytes, 0, byteCount);
    },
    _convertInvalid$3: function(bytes, start, end) {
      var t1, i, t2, value;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      for (t1 = ~this._subsetMask, i = start, t2 = ""; i < end; ++i) {
        if (i >= bytes.length)
          return H.ioore(bytes, i);
        value = bytes[i];
        if (typeof value !== "number")
          return value.$and();
        if ((value & t1) >>> 0 !== 0)
          value = 65533;
        t2 += H.Primitives_stringFromCharCode(value);
      }
      return t2.charCodeAt(0) == 0 ? t2 : t2;
    },
    $asStreamTransformer: function() {
      return [[P.List, P.int], P.String];
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.AsciiDecoder.prototype = {};
  P.Base64Codec.prototype = {
    get$encoder: function() {
      return C.C_Base64Encoder;
    },
    normalize$3: function(_, source, start, end) {
      var inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t1, t2, endLength, $length,
        _s31_ = "Invalid base64 encoding length ";
      end = P.RangeError_checkValidRange(start, end, source.length);
      inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      sliceStart = i;
      buffer = null;
      firstPadding = -1;
      firstPaddingSourceIndex = -1;
      paddingCount = 0;
      for (; i < end; i = i0) {
        i0 = i + 1;
        char = C.JSString_methods._codeUnitAt$1(source, i);
        if (char === 37) {
          i1 = i0 + 2;
          if (i1 <= end) {
            digit1 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0));
            digit2 = H.hexDigitValue(C.JSString_methods._codeUnitAt$1(source, i0 + 1));
            char0 = digit1 * 16 + digit2 - (digit2 & 256);
            if (char0 === 37)
              char0 = -1;
            i0 = i1;
          } else
            char0 = -1;
        } else
          char0 = char;
        if (0 <= char0 && char0 <= 127) {
          if (char0 < 0 || char0 >= inverseAlphabet.length)
            return H.ioore(inverseAlphabet, char0);
          value = inverseAlphabet[char0];
          if (value >= 0) {
            char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
            if (char0 === char)
              continue;
            char = char0;
          } else {
            if (value === -1) {
              if (firstPadding < 0) {
                t1 = buffer == null ? null : buffer._contents.length;
                if (t1 == null)
                  t1 = 0;
                firstPadding = t1 + (i - sliceStart);
                firstPaddingSourceIndex = i;
              }
              ++paddingCount;
              if (char === 61)
                continue;
            }
            char = char0;
          }
          if (value !== -2) {
            if (buffer == null)
              buffer = new P.StringBuffer("");
            buffer._contents += C.JSString_methods.substring$2(source, sliceStart, i);
            buffer._contents += H.Primitives_stringFromCharCode(char);
            sliceStart = i0;
            continue;
          }
        }
        throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
      }
      if (buffer != null) {
        t1 = buffer._contents += C.JSString_methods.substring$2(source, sliceStart, end);
        t2 = t1.length;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t2);
        else {
          endLength = C.JSInt_methods.$mod(t2 - 1, 4) + 1;
          if (endLength === 1)
            throw H.wrapException(P.FormatException$(_s31_, source, end));
          for (; endLength < 4;) {
            t1 += "=";
            buffer._contents = t1;
            ++endLength;
          }
        }
        t1 = buffer._contents;
        return C.JSString_methods.replaceRange$3(source, start, end, t1.charCodeAt(0) == 0 ? t1 : t1);
      }
      $length = end - start;
      if (firstPadding >= 0)
        P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
      else {
        endLength = C.JSInt_methods.$mod($length, 4);
        if (endLength === 1)
          throw H.wrapException(P.FormatException$(_s31_, source, end));
        if (endLength > 1)
          source = C.JSString_methods.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
      }
      return source;
    },
    $asCodec: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P.Base64Encoder.prototype = {
    convert$1: function(input) {
      H.assertSubtype(input, "$isList", [P.int], "$asList");
      if (C.JSNull_methods.get$isEmpty(input))
        return "";
      return P.String_String$fromCharCodes(new P._Base64Encoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").encode$4(input, 0, input.get$length(input), true), 0, null);
    },
    $asStreamTransformer: function() {
      return [[P.List, P.int], P.String];
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Base64Encoder.prototype = {
    createBuffer$1: function(_, bufferLength) {
      return new Uint8Array(bufferLength);
    },
    encode$4: function(bytes, start, end, isLast) {
      var byteCount, fullChunks, bufferLength, output, _this = this;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      byteCount = (_this._convert$_state & 3) + (end - start);
      fullChunks = C.JSInt_methods._tdivFast$1(byteCount, 3);
      bufferLength = fullChunks * 4;
      if (isLast && byteCount - fullChunks * 3 > 0)
        bufferLength += 4;
      output = _this.createBuffer$1(0, bufferLength);
      _this._convert$_state = P._Base64Encoder_encodeChunk(_this._alphabet, bytes, start, end, isLast, output, 0, _this._convert$_state);
      if (bufferLength > 0)
        return output;
      return;
    }
  };
  P.Base64Decoder.prototype = {
    convert$1: function(input) {
      var decoder, buffer,
        end = P.RangeError_checkValidRange(0, null, input.length);
      if (0 === end)
        return new Uint8Array(0);
      decoder = new P._Base64Decoder();
      buffer = decoder.decode$3(0, input, 0, end);
      decoder.close$2(0, input, end);
      return buffer;
    },
    $asStreamTransformer: function() {
      return [P.String, [P.List, P.int]];
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P._Base64Decoder.prototype = {
    decode$3: function(_, input, start, end) {
      var buffer, _this = this,
        t1 = _this._convert$_state;
      if (t1 < 0) {
        _this._convert$_state = P._Base64Decoder__checkPadding(input, start, end, t1);
        return;
      }
      if (start === end)
        return new Uint8Array(0);
      buffer = P._Base64Decoder__allocateBuffer(input, start, end, t1);
      _this._convert$_state = P._Base64Decoder_decodeChunk(input, start, end, buffer, 0, _this._convert$_state);
      return buffer;
    },
    close$2: function(_, input, end) {
      var t1 = this._convert$_state;
      if (t1 < -1)
        throw H.wrapException(P.FormatException$("Missing padding character", input, end));
      if (t1 > 0)
        throw H.wrapException(P.FormatException$("Invalid length, must be multiple of four", input, end));
      this._convert$_state = -1;
    }
  };
  P.ByteConversionSink.prototype = {
    $asChunkedConversionSink: function() {
      return [[P.List, P.int]];
    }
  };
  P.ByteConversionSinkBase.prototype = {};
  P._ByteCallbackSink.prototype = {
    add$1: function(_, chunk) {
      var t1, t2, t3, t4, v, grown, _this = this;
      H.assertSubtype(chunk, "$isIterable", [P.int], "$asIterable");
      t1 = _this._convert$_buffer;
      t2 = _this._bufferIndex;
      t3 = J.getInterceptor$asx(chunk);
      t4 = t3.get$length(chunk);
      if (typeof t4 !== "number")
        return t4.$gt();
      if (t4 > t1.length - t2) {
        t1 = _this._convert$_buffer;
        t2 = t3.get$length(chunk);
        if (typeof t2 !== "number")
          return t2.$add();
        v = t2 + t1.length - 1;
        v |= C.JSInt_methods._shrOtherPositive$1(v, 1);
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        grown = new Uint8Array((((v | v >>> 16) >>> 0) + 1) * 2);
        t1 = _this._convert$_buffer;
        C.NativeUint8List_methods.setRange$3(grown, 0, t1.length, t1);
        _this.set$_convert$_buffer(grown);
      }
      t1 = _this._convert$_buffer;
      t2 = _this._bufferIndex;
      t4 = t3.get$length(chunk);
      if (typeof t4 !== "number")
        return H.iae(t4);
      C.NativeUint8List_methods.setRange$3(t1, t2, t2 + t4, chunk);
      t4 = _this._bufferIndex;
      t3 = t3.get$length(chunk);
      if (typeof t3 !== "number")
        return H.iae(t3);
      _this._bufferIndex = t4 + t3;
    },
    close$0: function(_) {
      this._convert$_callback.call$1(C.NativeUint8List_methods.sublist$2(this._convert$_buffer, 0, this._bufferIndex));
    },
    set$_convert$_buffer: function(_buffer) {
      this._convert$_buffer = H.assertSubtype(_buffer, "$isList", [P.int], "$asList");
    }
  };
  P.ChunkedConversionSink.prototype = {};
  P.Codec.prototype = {
    encode$1: function(input) {
      H.assertSubtypeOfRuntimeType(input, H.getRuntimeTypeArgument(this, "Codec", 0));
      return this.get$encoder().convert$1(input);
    }
  };
  P.Converter.prototype = {};
  P.Encoding.prototype = {
    $asCodec: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P.HtmlEscapeMode.prototype = {
    toString$0: function(_) {
      return this._convert$_name;
    }
  };
  P.HtmlEscape.prototype = {
    convert$1: function(text) {
      var val = this._convert$3(text, 0, text.length);
      return val == null ? text : val;
    },
    _convert$3: function(text, start, end) {
      var i, result, replacement, t1;
      for (i = start, result = null; i < end; ++i) {
        if (i >= text.length)
          return H.ioore(text, i);
        switch (text[i]) {
          case "&":
            replacement = "&amp;";
            break;
          case '"':
            replacement = "&quot;";
            break;
          case "'":
            replacement = "&#39;";
            break;
          case "<":
            replacement = "&lt;";
            break;
          case ">":
            replacement = "&gt;";
            break;
          case "/":
            replacement = "&#47;";
            break;
          default:
            replacement = null;
        }
        if (replacement != null) {
          if (result == null)
            result = new P.StringBuffer("");
          if (i > start)
            result._contents += C.JSString_methods.substring$2(text, start, i);
          result._contents += replacement;
          start = i + 1;
        }
      }
      if (result == null)
        return;
      if (end > start)
        result._contents += J.substring$2$s(text, start, end);
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asStreamTransformer: function() {
      return [P.String, P.String];
    },
    $asConverter: function() {
      return [P.String, P.String];
    }
  };
  P.JsonUnsupportedObjectError.prototype = {
    toString$0: function(_) {
      var safeString = P.Error_safeToString(this.unsupportedObject);
      return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + safeString;
    }
  };
  P.JsonCyclicError.prototype = {
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    }
  };
  P.JsonCodec.prototype = {
    decode$2$reviver: function(_, source, reviver) {
      var t1 = P._parseJson(source, this.get$decoder()._reviver);
      return t1;
    },
    encode$2$toEncodable: function(value, toEncodable) {
      var t1 = this.get$encoder();
      t1 = P._JsonStringStringifier_stringify(value, t1._toEncodable, t1.indent);
      return t1;
    },
    get$encoder: function() {
      return C.JsonEncoder_null_null;
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonEncoder.prototype = {
    convert$1: function(object) {
      var t1,
        output = new P.StringBuffer("");
      P._JsonStringStringifier_printOn(object, output, this._toEncodable, this.indent);
      t1 = output._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asStreamTransformer: function() {
      return [P.Object, P.String];
    },
    $asConverter: function() {
      return [P.Object, P.String];
    }
  };
  P.JsonDecoder.prototype = {
    convert$1: function(input) {
      return P._parseJson(input, this._reviver);
    },
    $asStreamTransformer: function() {
      return [P.String, P.Object];
    },
    $asConverter: function() {
      return [P.String, P.Object];
    }
  };
  P._JsonStringifier.prototype = {
    writeStringContent$1: function(s) {
      var t1, offset, i, charCode, t2, _this = this,
        $length = s.length;
      for (t1 = J.getInterceptor$s(s), offset = 0, i = 0; i < $length; ++i) {
        charCode = t1._codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            _this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          _this.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              _this.writeCharCode$1(98);
              break;
            case 9:
              _this.writeCharCode$1(116);
              break;
            case 10:
              _this.writeCharCode$1(110);
              break;
            case 12:
              _this.writeCharCode$1(102);
              break;
            case 13:
              _this.writeCharCode$1(114);
              break;
            default:
              _this.writeCharCode$1(117);
              _this.writeCharCode$1(48);
              _this.writeCharCode$1(48);
              t2 = charCode >>> 4 & 15;
              _this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              t2 = charCode & 15;
              _this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            _this.writeStringSlice$3(s, offset, i);
          offset = i + 1;
          _this.writeCharCode$1(92);
          _this.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        _this.writeString$1(s);
      else if (offset < $length)
        _this.writeStringSlice$3(s, offset, $length);
    },
    _checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(new P.JsonCyclicError(object, null));
      }
      C.JSArray_methods.add$1(t1, object);
    },
    writeObject$1: function(object) {
      var customJson, e, t1, exception, _this = this;
      if (_this.writeJsonValue$1(object))
        return;
      _this._checkCycle$1(object);
      try {
        customJson = _this._toEncodable.call$1(object);
        if (!_this.writeJsonValue$1(customJson)) {
          t1 = P.JsonUnsupportedObjectError$(object, null, _this.get$_partialResult());
          throw H.wrapException(t1);
        }
        t1 = _this._seen;
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      } catch (exception) {
        e = H.unwrapException(exception);
        t1 = P.JsonUnsupportedObjectError$(object, e, _this.get$_partialResult());
        throw H.wrapException(t1);
      }
    },
    writeJsonValue$1: function(object) {
      var t1, success, _this = this;
      if (typeof object === "number") {
        if (!isFinite(object))
          return false;
        _this.writeNumber$1(object);
        return true;
      } else if (object === true) {
        _this.writeString$1("true");
        return true;
      } else if (object === false) {
        _this.writeString$1("false");
        return true;
      } else if (object == null) {
        _this.writeString$1("null");
        return true;
      } else if (typeof object === "string") {
        _this.writeString$1('"');
        _this.writeStringContent$1(object);
        _this.writeString$1('"');
        return true;
      } else {
        t1 = J.getInterceptor$(object);
        if (!!t1.$isList) {
          _this._checkCycle$1(object);
          _this.writeList$1(object);
          t1 = _this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
          return true;
        } else if (!!t1.$isMap) {
          _this._checkCycle$1(object);
          success = _this.writeMap$1(object);
          t1 = _this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
          return success;
        } else
          return false;
      }
    },
    writeList$1: function(list) {
      var t1, i, t2, _this = this;
      _this.writeString$1("[");
      t1 = J.getInterceptor$asx(list);
      if (t1.get$isNotEmpty(list)) {
        _this.writeObject$1(t1.$index(list, 0));
        i = 1;
        while (true) {
          t2 = t1.get$length(list);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          _this.writeString$1(",");
          _this.writeObject$1(t1.$index(list, i));
          ++i;
        }
      }
      _this.writeString$1("]");
    },
    writeMap$1: function(map) {
      var t2, keyValueList, i, separator, _this = this, _box_0 = {},
        t1 = J.getInterceptor$asx(map);
      if (t1.get$isEmpty(map)) {
        _this.writeString$1("{}");
        return true;
      }
      t2 = t1.get$length(map);
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 *= 2;
      keyValueList = new Array(t2);
      keyValueList.fixed$length = Array;
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      t1.forEach$1(map, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      _this.writeString$1("{");
      for (separator = '"'; i < t2; i += 2, separator = ',"') {
        _this.writeString$1(separator);
        _this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
        _this.writeString$1('":');
        t1 = i + 1;
        if (t1 >= t2)
          return H.ioore(keyValueList, t1);
        _this.writeObject$1(keyValueList[t1]);
      }
      _this.writeString$1("}");
      return true;
    }
  };
  P._JsonStringifier_writeMap_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2;
      if (typeof key !== "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      C.JSArray_methods.$indexSet(t1, t2.i++, key);
      C.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 12
  };
  P._JsonPrettyPrintMixin.prototype = {
    writeList$1: function(list) {
      var i, t2, _this = this,
        t1 = J.getInterceptor$asx(list);
      if (t1.get$isEmpty(list))
        _this.writeString$1("[]");
      else {
        _this.writeString$1("[\n");
        _this.writeIndentation$1(++_this._JsonPrettyPrintMixin__indentLevel);
        _this.writeObject$1(t1.$index(list, 0));
        i = 1;
        while (true) {
          t2 = t1.get$length(list);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          _this.writeString$1(",\n");
          _this.writeIndentation$1(_this._JsonPrettyPrintMixin__indentLevel);
          _this.writeObject$1(t1.$index(list, i));
          ++i;
        }
        _this.writeString$1("\n");
        _this.writeIndentation$1(--_this._JsonPrettyPrintMixin__indentLevel);
        _this.writeString$1("]");
      }
    },
    writeMap$1: function(map) {
      var t2, keyValueList, i, separator, _this = this, _box_0 = {},
        t1 = J.getInterceptor$asx(map);
      if (t1.get$isEmpty(map)) {
        _this.writeString$1("{}");
        return true;
      }
      t2 = t1.get$length(map);
      if (typeof t2 !== "number")
        return t2.$mul();
      t2 *= 2;
      keyValueList = new Array(t2);
      keyValueList.fixed$length = Array;
      i = _box_0.i = 0;
      _box_0.allStringKeys = true;
      t1.forEach$1(map, new P._JsonPrettyPrintMixin_writeMap_closure(_box_0, keyValueList));
      if (!_box_0.allStringKeys)
        return false;
      _this.writeString$1("{\n");
      ++_this._JsonPrettyPrintMixin__indentLevel;
      for (separator = ""; i < t2; i += 2, separator = ",\n") {
        _this.writeString$1(separator);
        _this.writeIndentation$1(_this._JsonPrettyPrintMixin__indentLevel);
        _this.writeString$1('"');
        _this.writeStringContent$1(H.stringTypeCheck(keyValueList[i]));
        _this.writeString$1('": ');
        t1 = i + 1;
        if (t1 >= t2)
          return H.ioore(keyValueList, t1);
        _this.writeObject$1(keyValueList[t1]);
      }
      _this.writeString$1("\n");
      _this.writeIndentation$1(--_this._JsonPrettyPrintMixin__indentLevel);
      _this.writeString$1("}");
      return true;
    }
  };
  P._JsonPrettyPrintMixin_writeMap_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2;
      if (typeof key !== "string")
        this._box_0.allStringKeys = false;
      t1 = this.keyValueList;
      t2 = this._box_0;
      C.JSArray_methods.$indexSet(t1, t2.i++, key);
      C.JSArray_methods.$indexSet(t1, t2.i++, value);
    },
    $signature: 12
  };
  P._JsonStringStringifier.prototype = {
    get$_partialResult: function() {
      var t1 = this._sink;
      return !!t1.$isStringBuffer ? t1.toString$0(0) : null;
    },
    writeNumber$1: function(number) {
      this._sink.write$1(0, C.JSNumber_methods.toString$0(number));
    },
    writeString$1: function(string) {
      this._sink.write$1(0, string);
    },
    writeStringSlice$3: function(string, start, end) {
      this._sink.write$1(0, C.JSString_methods.substring$2(string, start, end));
    },
    writeCharCode$1: function(charCode) {
      this._sink.writeCharCode$1(charCode);
    }
  };
  P._JsonStringStringifierPretty.prototype = {
    writeIndentation$1: function(count) {
      var t1, t2, i;
      for (t1 = this._indent, t2 = this._sink, i = 0; i < count; ++i)
        t2.write$1(0, t1);
    }
  };
  P.Latin1Codec.prototype = {
    get$name: function(_) {
      return "iso-8859-1";
    },
    encode$1: function(source) {
      return C.Latin1Encoder_255.convert$1(source);
    },
    decode$1: function(_, bytes) {
      var t1;
      H.assertSubtype(bytes, "$isList", [P.int], "$asList");
      t1 = C.Latin1Decoder_false_255.convert$1(bytes);
      return t1;
    },
    get$encoder: function() {
      return C.Latin1Encoder_255;
    }
  };
  P.Latin1Encoder.prototype = {};
  P.Latin1Decoder.prototype = {};
  P.Utf8Codec.prototype = {
    get$name: function(_) {
      return "utf-8";
    },
    decode$1: function(_, codeUnits) {
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      return new P.Utf8Decoder(false).convert$1(codeUnits);
    },
    get$encoder: function() {
      return C.C_Utf8Encoder;
    }
  };
  P.Utf8Encoder.prototype = {
    convert$1: function(string) {
      var $length, t1, encoder,
        end = P.RangeError_checkValidRange(0, null, string.length);
      if (typeof end !== "number")
        return end.$sub();
      $length = end - 0;
      if ($length === 0)
        return new Uint8Array(0);
      t1 = new Uint8Array($length * 3);
      encoder = new P._Utf8Encoder(t1);
      if (encoder._fillBuffer$3(string, 0, end) !== end)
        encoder._writeSurrogate$2(J.codeUnitAt$1$s(string, end - 1), 0);
      return C.NativeUint8List_methods.sublist$2(t1, 0, encoder._bufferIndex);
    },
    $asStreamTransformer: function() {
      return [P.String, [P.List, P.int]];
    },
    $asConverter: function() {
      return [P.String, [P.List, P.int]];
    }
  };
  P._Utf8Encoder.prototype = {
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var rune, _this = this,
        t1 = _this._convert$_buffer,
        t2 = _this._bufferIndex,
        t3 = t2 + 1,
        t4 = t1.length;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
        _this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 240 | rune >>> 18;
        t2 = _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = _this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | rune >>> 6 & 63;
        _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        _this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = _this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        _this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, stringIndex, codeUnit, t3, stringIndex0, t4, _this = this;
      if (start !== end && (C.JSString_methods.codeUnitAt$1(str, end - 1) & 64512) === 55296)
        --end;
      for (t1 = _this._convert$_buffer, t2 = t1.length, stringIndex = start; stringIndex < end; ++stringIndex) {
        codeUnit = C.JSString_methods._codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t3 = _this._bufferIndex;
          if (t3 >= t2)
            break;
          _this._bufferIndex = t3 + 1;
          t1[t3] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (_this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (_this._writeSurrogate$2(codeUnit, C.JSString_methods._codeUnitAt$1(str, stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t3 = _this._bufferIndex;
          t4 = t3 + 1;
          if (t4 >= t2)
            break;
          _this._bufferIndex = t4;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 192 | codeUnit >>> 6;
          _this._bufferIndex = t4 + 1;
          t1[t4] = 128 | codeUnit & 63;
        } else {
          t3 = _this._bufferIndex;
          if (t3 + 2 >= t2)
            break;
          t4 = _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 224 | codeUnit >>> 12;
          t3 = _this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit >>> 6 & 63;
          _this._bufferIndex = t3 + 1;
          if (t3 >= t2)
            return H.ioore(t1, t3);
          t1[t3] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    }
  };
  P.Utf8Decoder.prototype = {
    convert$1: function(codeUnits) {
      var result, end, oneBytes, firstPart, buffer, start, isFirstCharacter, decoder, t1;
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      result = P.Utf8Decoder__convertIntercepted(false, codeUnits, 0, null);
      if (result != null)
        return result;
      end = P.RangeError_checkValidRange(0, null, J.get$length$asx(codeUnits));
      oneBytes = P._scanOneByteCharacters(codeUnits, 0, end);
      if (oneBytes > 0) {
        firstPart = P.String_String$fromCharCodes(codeUnits, 0, oneBytes);
        if (oneBytes === end)
          return firstPart;
        buffer = new P.StringBuffer(firstPart);
        start = oneBytes;
        isFirstCharacter = false;
      } else {
        start = 0;
        buffer = null;
        isFirstCharacter = true;
      }
      if (buffer == null)
        buffer = new P.StringBuffer("");
      decoder = new P._Utf8Decoder(false, buffer);
      decoder._isFirstCharacter = isFirstCharacter;
      decoder.convert$3(codeUnits, start, end);
      decoder.flush$2(0, codeUnits, end);
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asStreamTransformer: function() {
      return [[P.List, P.int], P.String];
    },
    $asConverter: function() {
      return [[P.List, P.int], P.String];
    }
  };
  P._Utf8Decoder.prototype = {
    flush$2: function(_, source, offset) {
      var t1;
      H.assertSubtype(source, "$isList", [P.int], "$asList");
      if (this._expectedUnits > 0) {
        t1 = P.FormatException$("Unfinished UTF-8 octet sequence", source, offset);
        throw H.wrapException(t1);
      }
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, i, unit, t3, oneBytes, i0, i1, t4, _this = this,
        _s21_ = "Bad UTF-8 encoding 0x";
      H.assertSubtype(codeUnits, "$isList", [P.int], "$asList");
      value = _this._convert$_value;
      expectedUnits = _this._expectedUnits;
      extraUnits = _this._extraUnits;
      _this._extraUnits = _this._expectedUnits = _this._convert$_value = 0;
      $label0$0:
        for (t1 = J.getInterceptor$asx(codeUnits), t2 = _this._stringSink, i = startIndex; true; i = i1) {
          $label1$1:
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $label0$0;
                unit = t1.$index(codeUnits, i);
                if (typeof unit !== "number")
                  return unit.$and();
                if ((unit & 192) !== 128) {
                  t3 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i);
                  throw H.wrapException(t3);
                } else {
                  value = (value << 6 | unit & 63) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t3 = extraUnits - 1;
              if (t3 < 0 || t3 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t3);
              if (value <= C.List_127_2047_65535_1114111[t3]) {
                t3 = P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (value > 1114111) {
                t3 = P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                throw H.wrapException(t3);
              }
              if (!_this._isFirstCharacter || value !== 65279)
                t2._contents += H.Primitives_stringFromCharCode(value);
              _this._isFirstCharacter = false;
            }
          if (typeof endIndex !== "number")
            return H.iae(endIndex);
          t3 = i < endIndex;
          for (; t3;) {
            oneBytes = P._scanOneByteCharacters(codeUnits, i, endIndex);
            if (oneBytes > 0) {
              _this._isFirstCharacter = false;
              i0 = i + oneBytes;
              t2._contents += P.String_String$fromCharCodes(codeUnits, i, i0);
              if (i0 === endIndex)
                break;
            } else
              i0 = i;
            i1 = i0 + 1;
            unit = t1.$index(codeUnits, i0);
            if (typeof unit !== "number")
              return unit.$lt();
            if (unit < 0) {
              t4 = P.FormatException$("Negative UTF-8 code unit: -0x" + C.JSInt_methods.toRadixString$1(-unit, 16), codeUnits, i1 - 1);
              throw H.wrapException(t4);
            } else {
              if ((unit & 224) === 192) {
                value = unit & 31;
                expectedUnits = 1;
                extraUnits = 1;
                continue $label0$0;
              }
              if ((unit & 240) === 224) {
                value = unit & 15;
                expectedUnits = 2;
                extraUnits = 2;
                continue $label0$0;
              }
              if ((unit & 248) === 240 && unit < 245) {
                value = unit & 7;
                expectedUnits = 3;
                extraUnits = 3;
                continue $label0$0;
              }
              t4 = P.FormatException$(_s21_ + C.JSInt_methods.toRadixString$1(unit, 16), codeUnits, i1 - 1);
              throw H.wrapException(t4);
            }
          }
          break $label0$0;
        }
      if (expectedUnits > 0) {
        _this._convert$_value = value;
        _this._expectedUnits = expectedUnits;
        _this._extraUnits = extraUnits;
      }
    }
  };
  P.__JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin.prototype = {};
  P.NoSuchMethodError_toString_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2, t3;
      H.interceptedTypeCheck(key, "$isSymbol0");
      t1 = this.sb;
      t2 = this._box_0;
      t1._contents += t2.comma;
      t3 = t1._contents += H.S(key.__internal$_name);
      t1._contents = t3 + ": ";
      t1._contents += P.Error_safeToString(value);
      t2.comma = ", ";
    },
    $signature: 259
  };
  P.bool.prototype = {};
  P.DateTime.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.DateTime && this._value === other._value && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._value, H.interceptedTypeCheck(other, "$isDateTime")._value);
    },
    DateTime$_withValue$2$isUtc: function(_value, isUtc) {
      var t2,
        t1 = this._value;
      if (Math.abs(t1) <= 864e13)
        t2 = false;
      else
        t2 = true;
      if (t2)
        throw H.wrapException(P.ArgumentError$("DateTime is outside valid range: " + t1));
    },
    get$hashCode: function(_) {
      var t1 = this._value;
      return (t1 ^ C.JSInt_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
    },
    toString$0: function(_) {
      var _this = this,
        y = P.DateTime__fourDigits(H.Primitives_getYear(_this)),
        m = P.DateTime__twoDigits(H.Primitives_getMonth(_this)),
        d = P.DateTime__twoDigits(H.Primitives_getDay(_this)),
        h = P.DateTime__twoDigits(H.Primitives_getHours(_this)),
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(_this)),
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(_this)),
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(_this));
      if (_this.isUtc)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.DateTime];
    }
  };
  P.double.prototype = {};
  P.Duration.prototype = {
    $add: function(_, other) {
      return new P.Duration(this._duration + H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.Duration && this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this._duration);
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, H.interceptedTypeCheck(other, "$isDuration")._duration);
    },
    toString$0: function(_) {
      var twoDigitMinutes, twoDigitSeconds, sixDigitUs,
        t1 = new P.Duration_toString_twoDigits(),
        t2 = this._duration;
      if (t2 < 0)
        return "-" + new P.Duration(0 - t2).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 60000000) % 60);
      twoDigitSeconds = t1.call$1(C.JSInt_methods._tdivFast$1(t2, 1000000) % 60);
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [P.Duration];
    }
  };
  P.Duration_toString_sixDigits.prototype = {
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    },
    $signature: 33
  };
  P.Duration_toString_twoDigits.prototype = {
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    $signature: 33
  };
  P.Error.prototype = {};
  P.AssertionError.prototype = {
    toString$0: function(_) {
      return "Assertion failed";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.NullThrownError.prototype = {
    toString$0: function(_) {
      return "Throw of null.";
    }
  };
  P.ArgumentError.prototype = {
    get$_errorName: function() {
      return "Invalid argument" + (!this._hasValue ? "(s)" : "");
    },
    get$_errorExplanation: function() {
      return "";
    },
    toString$0: function(_) {
      var message, prefix, explanation, errorValue, _this = this,
        t1 = _this.name,
        nameString = t1 != null ? " (" + t1 + ")" : "";
      t1 = _this.message;
      message = t1 == null ? "" : ": " + H.S(t1);
      prefix = _this.get$_errorName() + nameString + message;
      if (!_this._hasValue)
        return prefix;
      explanation = _this.get$_errorExplanation();
      errorValue = P.Error_safeToString(_this.invalidValue);
      return prefix + explanation + ": " + errorValue;
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.RangeError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var explanation, t2,
        t1 = this.start;
      if (t1 == null) {
        t1 = this.end;
        explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
      } else {
        t2 = this.end;
        if (t2 == null)
          explanation = ": Not greater than or equal to " + H.S(t1);
        else if (t2 > t1)
          explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
        else
          explanation = t2 < t1 ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
      }
      return explanation;
    }
  };
  P.IndexError.prototype = {
    get$_errorName: function() {
      return "RangeError";
    },
    get$_errorExplanation: function() {
      var t1,
        invalidValue = H.intTypeCheck(this.invalidValue);
      if (typeof invalidValue !== "number")
        return invalidValue.$lt();
      if (invalidValue < 0)
        return ": index must not be negative";
      t1 = this.length;
      if (t1 === 0)
        return ": no indices are valid";
      return ": index should be less than " + H.S(t1);
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  P.NoSuchMethodError.prototype = {
    toString$0: function(_) {
      var t1, t2, _i, t3, t4, argument, receiverText, actualParameters, _this = this, _box_0 = {},
        sb = new P.StringBuffer("");
      _box_0.comma = "";
      for (t1 = _this._core$_arguments, t2 = t1.length, _i = 0, t3 = "", t4 = ""; _i < t2; ++_i, t4 = ", ") {
        argument = t1[_i];
        sb._contents = t3 + t4;
        t3 = sb._contents += P.Error_safeToString(argument);
        _box_0.comma = ", ";
      }
      _this._namedArguments.forEach$1(0, new P.NoSuchMethodError_toString_closure(_box_0, sb));
      receiverText = P.Error_safeToString(_this._core$_receiver);
      actualParameters = sb.toString$0(0);
      t1 = "NoSuchMethodError: method not found: '" + H.S(_this._core$_memberName.__internal$_name) + "'\nReceiver: " + receiverText + "\nArguments: [" + actualParameters + "]";
      return t1;
    }
  };
  P.UnsupportedError.prototype = {
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.UnimplementedError.prototype = {
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + t1 : "UnimplementedError";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.StateError.prototype = {
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.ConcurrentModificationError.prototype = {
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + P.Error_safeToString(t1) + ".";
    }
  };
  P.OutOfMemoryError.prototype = {
    toString$0: function(_) {
      return "Out of Memory";
    },
    $isError: 1
  };
  P.StackOverflowError.prototype = {
    toString$0: function(_) {
      return "Stack Overflow";
    },
    $isError: 1
  };
  P.CyclicInitializationError.prototype = {
    toString$0: function(_) {
      var t1 = this.variableName;
      return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + t1 + "' during its initialization";
    }
  };
  P._Exception.prototype = {
    toString$0: function(_) {
      return "Exception: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  P.FormatException.prototype = {
    toString$0: function(_) {
      var source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice,
        t1 = this.message,
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException",
        offset = this.offset,
        objectSource = this.source;
      if (typeof objectSource === "string") {
        if (offset != null)
          t1 = offset < 0 || offset > objectSource.length;
        else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          source = objectSource.length > 78 ? C.JSString_methods.substring$2(objectSource, 0, 75) + "..." : objectSource;
          return report + "\n" + source;
        }
        for (lineNum = 1, lineStart = 0, previousCharWasCR = false, i = 0; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(objectSource, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
        lineEnd = objectSource.length;
        for (i = offset; i < lineEnd; ++i) {
          char = C.JSString_methods.codeUnitAt$1(objectSource, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(objectSource, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      } else
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
    },
    get$message: function(receiver) {
      return this.message;
    },
    get$source: function(receiver) {
      return this.source;
    },
    get$offset: function(receiver) {
      return this.offset;
    }
  };
  P.Expando.prototype = {
    $index: function(_, object) {
      var t2, values,
        t1 = this._jsWeakMapOrKey;
      if (typeof t1 !== "string") {
        if (object != null)
          t2 = typeof object === "number" || typeof object === "string";
        else
          t2 = true;
        if (t2)
          H.throwExpression(P.ArgumentError$value(object, "Expandos are not allowed on strings, numbers, booleans or null", null));
        return t1.get(object);
      }
      values = H.Primitives_getProperty(object, "expando$values");
      t1 = values == null ? null : H.Primitives_getProperty(values, t1);
      return H.assertSubtypeOfRuntimeType(t1, H.getTypeArgumentByIndex(this, 0));
    },
    toString$0: function(_) {
      return "Expando:" + this.name;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  P.Function.prototype = {};
  P.int.prototype = {};
  P.Iterable.prototype = {
    cast$1$0: function(_, $R) {
      return H.CastIterable_CastIterable(this, H.getRuntimeTypeArgument(this, "Iterable", 0), $R);
    },
    map$1$1: function(_, f, $T) {
      var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      return H.MappedIterable_MappedIterable(this, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t1]}), t1, $T);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    where$1: function(_, test) {
      var t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      return new H.WhereIterable(this, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]}), [t1]);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq$(t1.get$current(t1), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(this, "Iterable", 0)]});
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current(t1));
    },
    fold$1$2: function(_, initialValue, combine, $T) {
      var t1, value;
      H.assertSubtypeOfRuntimeType(initialValue, $T);
      H.functionTypeCheck(combine, {func: 1, ret: $T, args: [$T, H.getRuntimeTypeArgument(this, "Iterable", 0)]});
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current(t1));
      return value;
    },
    join$1: function(_, separator) {
      var t1,
        iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      if (separator === "") {
        t1 = "";
        do
          t1 += H.S(iterator.get$current(iterator));
        while (iterator.moveNext$0());
      } else {
        t1 = H.S(iterator.get$current(iterator));
        for (; iterator.moveNext$0();)
          t1 = t1 + separator + H.S(iterator.get$current(iterator));
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var count,
        it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    take$1: function(_, count) {
      return H.TakeIterable_TakeIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    skip$1: function(_, count) {
      return H.SkipIterable_SkipIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current(it);
    },
    get$last: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current(it);
      while (it.moveNext$0());
      return result;
    },
    get$single: function(_) {
      var result,
        it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = it.get$current(it);
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return result;
    },
    firstWhere$2$orElse: function(_, test, orElse) {
      var element,
        t1 = H.getRuntimeTypeArgument(this, "Iterable", 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t1]});
      H.functionTypeCheck(orElse, {func: 1, ret: t1});
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (H.boolConversionCheck(test.call$1(element)))
          return element;
      }
      return orElse.call$0();
    },
    elementAt$1: function(_, index) {
      var t1, elementIndex, element, _s5_ = "index";
      if (index == null)
        H.throwExpression(P.ArgumentError$notNull(_s5_));
      P.RangeError_checkNotNegative(index, _s5_);
      for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
        element = t1.get$current(t1);
        if (index === elementIndex)
          return element;
        ++elementIndex;
      }
      throw H.wrapException(P.IndexError$(index, this, _s5_, null, elementIndex));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    }
  };
  P.Iterator.prototype = {};
  P.List.prototype = {$isEfficientLengthIterable: 1, $isIterable: 1};
  P.Map.prototype = {};
  P.MapEntry.prototype = {
    toString$0: function(_) {
      return "MapEntry(" + H.S(this.key) + ": " + H.S(this.value) + ")";
    },
    get$key: function(receiver) {
      return this.key;
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  P.Null.prototype = {
    get$hashCode: function(_) {
      return P.Object.prototype.get$hashCode.call(this, this);
    },
    toString$0: function(_) {
      return "null";
    }
  };
  P.num.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.num];
    }
  };
  P.Object.prototype = {constructor: P.Object, $isObject: 1,
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return "Instance of '" + H.Primitives_objectTypeName(this) + "'";
    },
    noSuchMethod$1: function(_, invocation) {
      H.interceptedTypeCheck(invocation, "$isInvocation");
      throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments()));
    },
    get$runtimeType: function(_) {
      return H.getRuntimeType(this);
    },
    toString: function() {
      return this.toString$0(this);
    }
  };
  P.Match.prototype = {};
  P.RegExp.prototype = {$isPattern: 1};
  P.RegExpMatch.prototype = {$isMatch: 1};
  P.Set.prototype = {};
  P.StackTrace.prototype = {};
  P.Stopwatch.prototype = {
    get$elapsedMicroseconds: function() {
      var t2, ticks,
        t1 = this._stop;
      if (t1 == null)
        t1 = H.intTypeCheck($.Primitives_timerTicks.call$0());
      t2 = this._core$_start;
      if (typeof t1 !== "number")
        return t1.$sub();
      ticks = t1 - t2;
      if ($.Stopwatch__frequency === 1000000)
        return ticks;
      return ticks * 1000;
    },
    start$0: function(_) {
      var t1, t2, t3, _this = this;
      if (_this._stop != null) {
        t1 = _this._core$_start;
        t2 = H.intTypeCheck($.Primitives_timerTicks.call$0());
        t3 = _this._stop;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        _this._core$_start = t1 + (t2 - t3);
        _this._stop = null;
      }
    },
    stop$0: function(_) {
      if (this._stop == null)
        this._stop = H.intTypeCheck($.Primitives_timerTicks.call$0());
    }
  };
  P.String.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [P.String];
    },
    $isPattern: 1
  };
  P.Runes.prototype = {
    get$iterator: function(_) {
      return new P.RuneIterator(this.string);
    },
    get$last: function(_) {
      var code, previousCode,
        t1 = this.string,
        t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(P.StateError$("No elements."));
      code = C.JSString_methods.codeUnitAt$1(t1, t2 - 1);
      if ((code & 64512) === 56320 && t2 > 1) {
        previousCode = C.JSString_methods.codeUnitAt$1(t1, t2 - 2);
        if ((previousCode & 64512) === 55296)
          return P._combineSurrogatePair(previousCode, code);
      }
      return code;
    },
    $asIterable: function() {
      return [P.int];
    }
  };
  P.RuneIterator.prototype = {
    get$current: function(_) {
      return this._currentCodePoint;
    },
    moveNext$0: function() {
      var codeUnit, nextPosition, nextCodeUnit, _this = this,
        t1 = _this._core$_position = _this._nextPosition,
        t2 = _this.string,
        t3 = t2.length;
      if (t1 === t3) {
        _this._currentCodePoint = null;
        return false;
      }
      codeUnit = C.JSString_methods._codeUnitAt$1(t2, t1);
      nextPosition = t1 + 1;
      if ((codeUnit & 64512) === 55296 && nextPosition < t3) {
        nextCodeUnit = C.JSString_methods._codeUnitAt$1(t2, nextPosition);
        if ((nextCodeUnit & 64512) === 56320) {
          _this._nextPosition = nextPosition + 1;
          _this._currentCodePoint = P._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      _this._nextPosition = nextPosition;
      _this._currentCodePoint = codeUnit;
      return true;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.int];
    }
  };
  P.StringBuffer.prototype = {
    get$length: function(_) {
      return this._contents.length;
    },
    write$1: function(_, obj) {
      this._contents += H.S(obj);
    },
    writeCharCode$1: function(charCode) {
      this._contents += H.Primitives_stringFromCharCode(charCode);
    },
    toString$0: function(_) {
      var t1 = this._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isStringSink: 1
  };
  P.Symbol0.prototype = {};
  P.Type.prototype = {};
  P.Uri_splitQueryString_closure.prototype = {
    call$2: function(map, element) {
      var index, key, value,
        t1 = P.String;
      H.assertSubtype(map, "$isMap", [t1, t1], "$asMap");
      H.stringTypeCheck(element);
      index = J.getInterceptor$asx(element).indexOf$1(element, "=");
      if (index === -1) {
        if (element !== "")
          J.$indexSet$ax(map, P._Uri__uriDecode(element, 0, element.length, this.encoding, true), "");
      } else if (index !== 0) {
        key = C.JSString_methods.substring$2(element, 0, index);
        value = C.JSString_methods.substring$1(element, index + 1);
        t1 = this.encoding;
        J.$indexSet$ax(map, P._Uri__uriDecode(key, 0, key.length, t1, true), P._Uri__uriDecode(value, 0, value.length, t1, true));
      }
      return map;
    },
    $signature: 122
  };
  P.Uri__parseIPv4Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
    },
    $signature: 124
  };
  P.Uri_parseIPv6Address_error.prototype = {
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $signature: 125
  };
  P.Uri_parseIPv6Address_parseHex.prototype = {
    call$2: function(start, end) {
      var value;
      if (end - start > 4)
        this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = P.int_parse(C.JSString_methods.substring$2(this.host, start, end), null, 16);
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0 || value > 65535)
        this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $signature: 138
  };
  P._Uri.prototype = {
    get$userInfo: function() {
      return this._userInfo;
    },
    get$host: function(_) {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (C.JSString_methods.startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P._Uri__defaultPort(this.scheme);
      return t1;
    },
    get$query: function(_) {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    get$fragment: function() {
      var t1 = this._fragment;
      return t1 == null ? "" : t1;
    },
    isScheme$1: function(scheme) {
      var thisScheme = this.scheme;
      if (scheme.length !== thisScheme.length)
        return false;
      return P._Uri__compareScheme(scheme, thisScheme);
    },
    replace$3$path$queryParameters$scheme: function(_, path, queryParameters, scheme) {
      var scheme0, schemeChanged, isFile, userInfo, port, host, hasAuthority, t1, query, _this = this;
      H.assertSubtype(queryParameters, "$isMap", [P.String, null], "$asMap");
      scheme0 = _this.scheme;
      if (scheme != null) {
        scheme = P._Uri__makeScheme(scheme, 0, scheme.length);
        schemeChanged = scheme !== scheme0;
      } else {
        scheme = scheme0;
        schemeChanged = false;
      }
      isFile = scheme === "file";
      userInfo = _this._userInfo;
      port = _this._port;
      if (schemeChanged)
        port = P._Uri__makePort(port, scheme);
      host = _this._host;
      if (!(host != null))
        host = userInfo.length !== 0 || port != null || isFile ? "" : null;
      hasAuthority = host != null;
      t1 = path == null;
      if (!t1 || false)
        path = P._Uri__makePath(path, 0, t1 ? 0 : path.length, null, scheme, hasAuthority);
      else {
        path = _this.path;
        if (!isFile)
          t1 = hasAuthority && path.length !== 0;
        else
          t1 = true;
        if (t1 && !C.JSString_methods.startsWith$1(path, "/"))
          path = "/" + path;
      }
      if (queryParameters != null)
        query = P._Uri__makeQuery(null, 0, 0, queryParameters);
      else
        query = _this._query;
      return new P._Uri(scheme, userInfo, host, port, path, query, _this._fragment);
    },
    replace$1$queryParameters: function($receiver, queryParameters) {
      return this.replace$3$path$queryParameters$scheme($receiver, null, queryParameters, null);
    },
    replace$2$path$scheme: function($receiver, path, scheme) {
      return this.replace$3$path$queryParameters$scheme($receiver, path, null, scheme);
    },
    replace$1$path: function($receiver, path) {
      return this.replace$3$path$queryParameters$scheme($receiver, path, null, null);
    },
    removeFragment$0: function() {
      var _this = this;
      if (_this._fragment == null)
        return _this;
      return new P._Uri(_this.scheme, _this._userInfo, _this._host, _this._port, _this.path, _this._query, null);
    },
    get$pathSegments: function() {
      var pathToSplit, t1, t2, t3,
        result = this._pathSegments;
      if (result != null)
        return result;
      pathToSplit = this.path;
      if (pathToSplit.length !== 0 && C.JSString_methods._codeUnitAt$1(pathToSplit, 0) === 47)
        pathToSplit = C.JSString_methods.substring$1(pathToSplit, 1);
      if (pathToSplit === "")
        result = C.List_empty0;
      else {
        t1 = P.String;
        t2 = H.setRuntimeTypeInfo(pathToSplit.split("/"), [t1]);
        t3 = H.getTypeArgumentByIndex(t2, 0);
        result = P.List_List$unmodifiable(new H.MappedListIterable(t2, H.functionTypeCheck(P.core_Uri_decodeComponent$closure(), {func: 1, ret: null, args: [t3]}), [t3, null]), t1);
      }
      this.set$_pathSegments(result);
      return result;
    },
    get$queryParameters: function() {
      var t1, t2, _this = this;
      if (_this._queryParameters == null) {
        t1 = _this._query;
        t2 = P.String;
        _this.set$_queryParameters(new P.UnmodifiableMapView(P.Uri_splitQueryString(t1 == null ? "" : t1), [t2, t2]));
      }
      return _this._queryParameters;
    },
    get$isAbsolute: function() {
      if (this.scheme !== "") {
        var t1 = this._fragment;
        t1 = (t1 == null ? "" : t1) === "";
      } else
        t1 = false;
      return t1;
    },
    _mergePaths$2: function(base, reference) {
      var backCount, refStart, baseEnd, newEnd, delta, t1;
      for (backCount = 0, refStart = 0; C.JSString_methods.startsWith$2(reference, "../", refStart);) {
        refStart += 3;
        ++backCount;
      }
      baseEnd = C.JSString_methods.lastIndexOf$1(base, "/");
      while (true) {
        if (!(baseEnd > 0 && backCount > 0))
          break;
        newEnd = C.JSString_methods.lastIndexOf$2(base, "/", baseEnd - 1);
        if (newEnd < 0)
          break;
        delta = baseEnd - newEnd;
        t1 = delta !== 2;
        if (!t1 || delta === 3)
          if (C.JSString_methods.codeUnitAt$1(base, newEnd + 1) === 46)
            t1 = !t1 || C.JSString_methods.codeUnitAt$1(base, newEnd + 2) === 46;
          else
            t1 = false;
        else
          t1 = false;
        if (t1)
          break;
        --backCount;
        baseEnd = newEnd;
      }
      return C.JSString_methods.replaceRange$3(base, baseEnd + 1, null, C.JSString_methods.substring$1(reference, refStart - 3 * backCount));
    },
    resolve$1: function(reference) {
      return this.resolveUri$1(P.Uri_parse(reference, 0, null));
    },
    resolveUri$1: function(reference) {
      var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, mergedPath, t2, _this = this, _null = null;
      if (reference.get$scheme().length !== 0) {
        targetScheme = reference.get$scheme();
        if (reference.get$hasAuthority()) {
          targetUserInfo = reference.get$userInfo();
          targetHost = reference.get$host(reference);
          targetPort = reference.get$hasPort() ? reference.get$port(reference) : _null;
        } else {
          targetPort = _null;
          targetHost = targetPort;
          targetUserInfo = "";
        }
        targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
        targetQuery = reference.get$hasQuery() ? reference.get$query(reference) : _null;
      } else {
        targetScheme = _this.scheme;
        if (reference.get$hasAuthority()) {
          targetUserInfo = reference.get$userInfo();
          targetHost = reference.get$host(reference);
          targetPort = P._Uri__makePort(reference.get$hasPort() ? reference.get$port(reference) : _null, targetScheme);
          targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
          targetQuery = reference.get$hasQuery() ? reference.get$query(reference) : _null;
        } else {
          targetUserInfo = _this._userInfo;
          targetHost = _this._host;
          targetPort = _this._port;
          if (reference.get$path(reference) === "") {
            targetPath = _this.path;
            targetQuery = reference.get$hasQuery() ? reference.get$query(reference) : _this._query;
          } else {
            if (reference.get$hasAbsolutePath())
              targetPath = P._Uri__removeDotSegments(reference.get$path(reference));
            else {
              t1 = _this.path;
              if (t1.length === 0)
                if (targetHost == null)
                  targetPath = targetScheme.length === 0 ? reference.get$path(reference) : P._Uri__removeDotSegments(reference.get$path(reference));
                else
                  targetPath = P._Uri__removeDotSegments("/" + reference.get$path(reference));
              else {
                mergedPath = _this._mergePaths$2(t1, reference.get$path(reference));
                t2 = targetScheme.length === 0;
                if (!t2 || targetHost != null || C.JSString_methods.startsWith$1(t1, "/"))
                  targetPath = P._Uri__removeDotSegments(mergedPath);
                else
                  targetPath = P._Uri__normalizeRelativePath(mergedPath, !t2 || targetHost != null);
              }
            }
            targetQuery = reference.get$hasQuery() ? reference.get$query(reference) : _null;
          }
        }
      }
      return new P._Uri(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, reference.get$hasFragment() ? reference.get$fragment() : _null);
    },
    get$hasAuthority: function() {
      return this._host != null;
    },
    get$hasPort: function() {
      return this._port != null;
    },
    get$hasQuery: function() {
      return this._query != null;
    },
    get$hasFragment: function() {
      return this._fragment != null;
    },
    get$hasAbsolutePath: function() {
      return C.JSString_methods.startsWith$1(this.path, "/");
    },
    toFilePath$0: function() {
      var windows, pathSegments, _this = this,
        t1 = _this.scheme;
      if (t1 !== "" && t1 !== "file")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(t1) + " URI"));
      t1 = _this._query;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
      t1 = _this._fragment;
      if ((t1 == null ? "" : t1) !== "")
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
      windows = $.$get$_Uri__isWindowsCached();
      if (H.boolConversionCheck(windows))
        t1 = P._Uri__toWindowsFilePath(_this);
      else {
        if (_this._host != null && _this.get$host(_this) !== "")
          H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        pathSegments = _this.get$pathSegments();
        P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
        t1 = P.StringBuffer__writeAll(C.JSString_methods.startsWith$1(_this.path, "/") ? "/" : "", pathSegments, "/");
        t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    toString$0: function(_) {
      var t2, t3, t4, _this = this,
        t1 = _this._text;
      if (t1 == null) {
        t1 = _this.scheme;
        t2 = t1.length !== 0 ? H.S(t1) + ":" : "";
        t3 = _this._host;
        t4 = t3 == null;
        if (!t4 || t1 === "file") {
          t1 = t2 + "//";
          t2 = _this._userInfo;
          if (t2.length !== 0)
            t1 = t1 + H.S(t2) + "@";
          if (!t4)
            t1 += t3;
          t2 = _this._port;
          if (t2 != null)
            t1 = t1 + ":" + H.S(t2);
        } else
          t1 = t2;
        t1 += _this.path;
        t2 = _this._query;
        if (t2 != null)
          t1 = t1 + "?" + t2;
        t2 = _this._fragment;
        if (t2 != null)
          t1 = t1 + "#" + t2;
        t1 = _this._text = t1.charCodeAt(0) == 0 ? t1 : t1;
      }
      return t1;
    },
    $eq: function(_, other) {
      var t1, t2, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!!J.getInterceptor$(other).$isUri)
        if (_this.scheme == other.get$scheme())
          if (_this._host != null === other.get$hasAuthority())
            if (_this._userInfo == other.get$userInfo())
              if (_this.get$host(_this) == other.get$host(other))
                if (_this.get$port(_this) == other.get$port(other))
                  if (_this.path === other.get$path(other)) {
                    t1 = _this._query;
                    t2 = t1 == null;
                    if (!t2 === other.get$hasQuery()) {
                      if (t2)
                        t1 = "";
                      if (t1 === other.get$query(other)) {
                        t1 = _this._fragment;
                        t2 = t1 == null;
                        if (!t2 === other.get$hasFragment()) {
                          if (t2)
                            t1 = "";
                          t1 = t1 === other.get$fragment();
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this.toString$0(0)) : t1;
    },
    set$_pathSegments: function(_pathSegments) {
      this._pathSegments = H.assertSubtype(_pathSegments, "$isList", [P.String], "$asList");
    },
    set$_queryParameters: function(_queryParameters) {
      var t1 = P.String;
      this._queryParameters = H.assertSubtype(_queryParameters, "$isMap", [t1, t1], "$asMap");
    },
    $isUri: 1,
    get$scheme: function() {
      return this.scheme;
    },
    get$path: function(receiver) {
      return this.path;
    }
  };
  P._Uri__Uri$notSimple_closure.prototype = {
    call$1: function(_) {
      throw H.wrapException(P.FormatException$("Invalid port", this.uri, this.portStart + 1));
    },
    $signature: 19
  };
  P._Uri__checkNonWindowsPathReservedCharacters_closure.prototype = {
    call$1: function(segment) {
      var _s23_ = "Illegal path character ";
      H.stringTypeCheck(segment);
      if (J.contains$1$asx(segment, "/"))
        if (this.argumentError)
          throw H.wrapException(P.ArgumentError$(_s23_ + segment));
        else
          throw H.wrapException(P.UnsupportedError$(_s23_ + segment));
    },
    $signature: 19
  };
  P._Uri__makePath_closure.prototype = {
    call$1: function(s) {
      return P._Uri__uriEncode(C.List_qg40, s, C.C_Utf8Codec, false);
    },
    $signature: 5
  };
  P._Uri__makeQuery_writeParameter.prototype = {
    call$2: function(key, value) {
      var t1 = this.result,
        t2 = this._box_0;
      t1._contents += t2.separator;
      t2.separator = "&";
      t2 = t1._contents += H.S(P._Uri__uriEncode(C.List_nxB, key, C.C_Utf8Codec, true));
      if (value != null && value.length !== 0) {
        t1._contents = t2 + "=";
        t1._contents += H.S(P._Uri__uriEncode(C.List_nxB, value, C.C_Utf8Codec, true));
      }
    },
    $signature: 32
  };
  P._Uri__makeQuery_closure.prototype = {
    call$2: function(key, value) {
      var t1, t2;
      H.stringTypeCheck(key);
      if (value == null || typeof value === "string")
        this.writeParameter.call$2(key, H.stringTypeCheck(value));
      else
        for (t1 = J.get$iterator$ax(H.listSuperNativeTypeCheck(value, "$isIterable")), t2 = this.writeParameter; t1.moveNext$0();)
          t2.call$2(key, H.stringTypeCheck(t1.get$current(t1)));
    },
    $signature: 25
  };
  P.UriData.prototype = {
    get$uri: function() {
      var t2, queryIndex, end, query, _this = this, _null = null,
        t1 = _this._uriCache;
      if (t1 != null)
        return t1;
      t1 = _this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = _this._text;
      t1 = t1[0] + 1;
      queryIndex = C.JSString_methods.indexOf$2(t2, "?", t1);
      end = t2.length;
      if (queryIndex >= 0) {
        query = P._Uri__normalizeOrSubstring(t2, queryIndex + 1, end, C.List_CVk, false);
        end = queryIndex;
      } else
        query = _null;
      return _this._uriCache = new P._DataUri("data", _null, _null, _null, P._Uri__normalizeOrSubstring(t2, t1, end, C.List_qg4, false), query, _null);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._separatorIndices;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = this._text;
      return t1[0] === -1 ? "data:" + t2 : t2;
    }
  };
  P._createTables_closure.prototype = {
    call$1: function(_) {
      return new Uint8Array(96);
    },
    $signature: 163
  };
  P._createTables_build.prototype = {
    call$2: function(state, defaultTransition) {
      var t1 = this.tables;
      if (state >= t1.length)
        return H.ioore(t1, state);
      t1 = t1[state];
      J.fillRange$3$x(t1, 0, 96, defaultTransition);
      return t1;
    },
    $signature: 165
  };
  P._createTables_setChars.prototype = {
    call$3: function(target, chars, transition) {
      var t1, t2, i, t3;
      for (t1 = chars.length, t2 = target.length, i = 0; i < t1; ++i) {
        t3 = C.JSString_methods._codeUnitAt$1(chars, i) ^ 96;
        if (t3 >= t2)
          return H.ioore(target, t3);
        target[t3] = transition;
      }
    },
    $signature: 97
  };
  P._createTables_setRange.prototype = {
    call$3: function(target, range, transition) {
      var i, n, t1, t2;
      for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = target.length; i <= n; ++i) {
        t2 = (i ^ 96) >>> 0;
        if (t2 >= t1)
          return H.ioore(target, t2);
        target[t2] = transition;
      }
    },
    $signature: 97
  };
  P._SimpleUri.prototype = {
    get$hasAuthority: function() {
      return this._hostStart > 0;
    },
    get$hasPort: function() {
      var t1, t2;
      if (this._hostStart > 0) {
        t1 = this._portStart;
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = this._pathStart;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 + 1 < t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hasQuery: function() {
      var t1 = this._queryStart;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < this._fragmentStart;
    },
    get$hasFragment: function() {
      return this._fragmentStart < this._uri.length;
    },
    get$_isFile: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "file");
    },
    get$_isHttp: function() {
      return this._schemeEnd === 4 && C.JSString_methods.startsWith$1(this._uri, "http");
    },
    get$_isHttps: function() {
      return this._schemeEnd === 5 && C.JSString_methods.startsWith$1(this._uri, "https");
    },
    get$hasAbsolutePath: function() {
      return C.JSString_methods.startsWith$2(this._uri, "/", this._pathStart);
    },
    get$isAbsolute: function() {
      return this._schemeEnd > 0 && this._fragmentStart >= this._uri.length;
    },
    isScheme$1: function(scheme) {
      var t1 = scheme.length;
      if (t1 === 0)
        return this._schemeEnd < 0;
      if (t1 !== this._schemeEnd)
        return false;
      return P._Uri__compareScheme(scheme, this._uri);
    },
    get$scheme: function() {
      var t2, _this = this,
        _s7_ = "package",
        t1 = _this._schemeEnd;
      if (t1 <= 0)
        return "";
      t2 = _this._schemeCache;
      if (t2 != null)
        return t2;
      if (_this.get$_isHttp())
        t1 = _this._schemeCache = "http";
      else if (_this.get$_isHttps()) {
        _this._schemeCache = "https";
        t1 = "https";
      } else if (_this.get$_isFile()) {
        _this._schemeCache = "file";
        t1 = "file";
      } else if (t1 === 7 && C.JSString_methods.startsWith$1(_this._uri, _s7_)) {
        _this._schemeCache = _s7_;
        t1 = _s7_;
      } else {
        t1 = C.JSString_methods.substring$2(_this._uri, 0, t1);
        _this._schemeCache = t1;
      }
      return t1;
    },
    get$userInfo: function() {
      var t1 = this._hostStart,
        t2 = this._schemeEnd + 3;
      return t1 > t2 ? C.JSString_methods.substring$2(this._uri, t2, t1 - 1) : "";
    },
    get$host: function(_) {
      var t1 = this._hostStart;
      return t1 > 0 ? C.JSString_methods.substring$2(this._uri, t1, this._portStart) : "";
    },
    get$port: function(_) {
      var t1, _this = this;
      if (_this.get$hasPort()) {
        t1 = _this._portStart;
        if (typeof t1 !== "number")
          return t1.$add();
        return P.int_parse(C.JSString_methods.substring$2(_this._uri, t1 + 1, _this._pathStart), null, null);
      }
      if (_this.get$_isHttp())
        return 80;
      if (_this.get$_isHttps())
        return 443;
      return 0;
    },
    get$path: function(_) {
      return C.JSString_methods.substring$2(this._uri, this._pathStart, this._queryStart);
    },
    get$query: function(_) {
      var t1 = this._queryStart,
        t2 = this._fragmentStart;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < t2 ? C.JSString_methods.substring$2(this._uri, t1 + 1, t2) : "";
    },
    get$fragment: function() {
      var t1 = this._fragmentStart,
        t2 = this._uri;
      return t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : "";
    },
    get$pathSegments: function() {
      var t2, parts, i,
        start = this._pathStart,
        end = this._queryStart,
        t1 = this._uri;
      if (C.JSString_methods.startsWith$2(t1, "/", start)) {
        if (typeof start !== "number")
          return start.$add();
        ++start;
      }
      if (start == end)
        return C.List_empty0;
      t2 = P.String;
      parts = H.setRuntimeTypeInfo([], [t2]);
      i = start;
      while (true) {
        if (typeof i !== "number")
          return i.$lt();
        if (typeof end !== "number")
          return H.iae(end);
        if (!(i < end))
          break;
        if (C.JSString_methods.codeUnitAt$1(t1, i) === 47) {
          C.JSArray_methods.add$1(parts, C.JSString_methods.substring$2(t1, start, i));
          start = i + 1;
        }
        ++i;
      }
      C.JSArray_methods.add$1(parts, C.JSString_methods.substring$2(t1, start, end));
      return P.List_List$unmodifiable(parts, t2);
    },
    get$queryParameters: function() {
      var _this = this,
        t1 = _this._queryStart;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 >= _this._fragmentStart)
        return C.Map_empty0;
      t1 = P.String;
      return new P.UnmodifiableMapView(P.Uri_splitQueryString(_this.get$query(_this)), [t1, t1]);
    },
    _isPort$1: function(port) {
      var portDigitStart,
        t1 = this._portStart;
      if (typeof t1 !== "number")
        return t1.$add();
      portDigitStart = t1 + 1;
      return portDigitStart + port.length === this._pathStart && C.JSString_methods.startsWith$2(this._uri, port, portDigitStart);
    },
    removeFragment$0: function() {
      var _this = this,
        t1 = _this._fragmentStart,
        t2 = _this._uri;
      if (t1 >= t2.length)
        return _this;
      return new P._SimpleUri(C.JSString_methods.substring$2(t2, 0, t1), _this._schemeEnd, _this._hostStart, _this._portStart, _this._pathStart, _this._queryStart, t1, _this._schemeCache);
    },
    replace$3$path$queryParameters$scheme: function(_, path, queryParameters, scheme) {
      var schemeChanged, isFile, t1, userInfo, port, host, hasAuthority, query, t2, fragment, _this = this, _null = null;
      H.assertSubtype(queryParameters, "$isMap", [P.String, null], "$asMap");
      if (scheme != null) {
        scheme = P._Uri__makeScheme(scheme, 0, scheme.length);
        schemeChanged = !(_this._schemeEnd === scheme.length && C.JSString_methods.startsWith$1(_this._uri, scheme));
      } else {
        scheme = _this.get$scheme();
        schemeChanged = false;
      }
      isFile = scheme === "file";
      t1 = _this._hostStart;
      userInfo = t1 > 0 ? C.JSString_methods.substring$2(_this._uri, _this._schemeEnd + 3, t1) : "";
      port = _this.get$hasPort() ? _this.get$port(_this) : _null;
      if (schemeChanged)
        port = P._Uri__makePort(port, scheme);
      t1 = _this._hostStart;
      if (t1 > 0)
        host = C.JSString_methods.substring$2(_this._uri, t1, _this._portStart);
      else
        host = userInfo.length !== 0 || port != null || isFile ? "" : _null;
      hasAuthority = host != null;
      t1 = path == null;
      if (!t1 || false)
        path = P._Uri__makePath(path, 0, t1 ? 0 : path.length, _null, scheme, hasAuthority);
      else {
        path = C.JSString_methods.substring$2(_this._uri, _this._pathStart, _this._queryStart);
        if (!isFile)
          t1 = hasAuthority && path.length !== 0;
        else
          t1 = true;
        if (t1 && !C.JSString_methods.startsWith$1(path, "/"))
          path = "/" + path;
      }
      if (queryParameters != null)
        query = P._Uri__makeQuery(_null, 0, 0, queryParameters);
      else {
        t1 = _this._queryStart;
        t2 = _this._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        query = t1 < t2 ? C.JSString_methods.substring$2(_this._uri, t1 + 1, t2) : _null;
      }
      t1 = _this._fragmentStart;
      t2 = _this._uri;
      fragment = t1 < t2.length ? C.JSString_methods.substring$1(t2, t1 + 1) : _null;
      return new P._Uri(scheme, userInfo, host, port, path, query, fragment);
    },
    replace$1$queryParameters: function($receiver, queryParameters) {
      return this.replace$3$path$queryParameters$scheme($receiver, null, queryParameters, null);
    },
    replace$2$path$scheme: function($receiver, path, scheme) {
      return this.replace$3$path$queryParameters$scheme($receiver, path, null, scheme);
    },
    replace$1$path: function($receiver, path) {
      return this.replace$3$path$queryParameters$scheme($receiver, path, null, null);
    },
    resolve$1: function(reference) {
      return this.resolveUri$1(P.Uri_parse(reference, 0, null));
    },
    resolveUri$1: function(reference) {
      if (reference instanceof P._SimpleUri)
        return this._simpleMerge$2(this, reference);
      return this._toNonSimple$0().resolveUri$1(reference);
    },
    _simpleMerge$2: function(base, ref) {
      var t2, t3, isSimple, delta, newUri, t4, t5, refStart, baseStart, baseEnd, baseUri, baseStart0, backCount, refStart0, insert,
        t1 = ref._schemeEnd;
      if (t1 > 0)
        return ref;
      t2 = ref._hostStart;
      if (t2 > 0) {
        t3 = base._schemeEnd;
        if (t3 <= 0)
          return ref;
        if (base.get$_isFile())
          isSimple = ref._pathStart != ref._queryStart;
        else if (base.get$_isHttp())
          isSimple = !ref._isPort$1("80");
        else
          isSimple = !base.get$_isHttps() || !ref._isPort$1("443");
        if (isSimple) {
          delta = t3 + 1;
          newUri = C.JSString_methods.substring$2(base._uri, 0, delta) + C.JSString_methods.substring$1(ref._uri, t1 + 1);
          t1 = ref._portStart;
          if (typeof t1 !== "number")
            return t1.$add();
          t4 = ref._pathStart;
          if (typeof t4 !== "number")
            return t4.$add();
          t5 = ref._queryStart;
          if (typeof t5 !== "number")
            return t5.$add();
          return new P._SimpleUri(newUri, t3, t2 + delta, t1 + delta, t4 + delta, t5 + delta, ref._fragmentStart + delta, base._schemeCache);
        } else
          return this._toNonSimple$0().resolveUri$1(ref);
      }
      refStart = ref._pathStart;
      t1 = ref._queryStart;
      if (refStart == t1) {
        t2 = ref._fragmentStart;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < t2) {
          t3 = base._queryStart;
          if (typeof t3 !== "number")
            return t3.$sub();
          delta = t3 - t1;
          return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(ref._uri, t1), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, t1 + delta, t2 + delta, base._schemeCache);
        }
        t1 = ref._uri;
        if (t2 < t1.length) {
          t3 = base._fragmentStart;
          return new P._SimpleUri(C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(t1, t2), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, base._queryStart, t2 + (t3 - t2), base._schemeCache);
        }
        return base.removeFragment$0();
      }
      t2 = ref._uri;
      if (C.JSString_methods.startsWith$2(t2, "/", refStart)) {
        t3 = base._pathStart;
        if (typeof t3 !== "number")
          return t3.$sub();
        if (typeof refStart !== "number")
          return H.iae(refStart);
        delta = t3 - refStart;
        newUri = C.JSString_methods.substring$2(base._uri, 0, t3) + C.JSString_methods.substring$1(t2, refStart);
        if (typeof t1 !== "number")
          return t1.$add();
        return new P._SimpleUri(newUri, base._schemeEnd, base._hostStart, base._portStart, t3, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseStart = base._pathStart;
      baseEnd = base._queryStart;
      if (baseStart == baseEnd && base._hostStart > 0) {
        for (; C.JSString_methods.startsWith$2(t2, "../", refStart);) {
          if (typeof refStart !== "number")
            return refStart.$add();
          refStart += 3;
        }
        if (typeof baseStart !== "number")
          return baseStart.$sub();
        if (typeof refStart !== "number")
          return H.iae(refStart);
        delta = baseStart - refStart + 1;
        newUri = C.JSString_methods.substring$2(base._uri, 0, baseStart) + "/" + C.JSString_methods.substring$1(t2, refStart);
        if (typeof t1 !== "number")
          return t1.$add();
        return new P._SimpleUri(newUri, base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
      }
      baseUri = base._uri;
      for (baseStart0 = baseStart; C.JSString_methods.startsWith$2(baseUri, "../", baseStart0);) {
        if (typeof baseStart0 !== "number")
          return baseStart0.$add();
        baseStart0 += 3;
      }
      backCount = 0;
      while (true) {
        if (typeof refStart !== "number")
          return refStart.$add();
        refStart0 = refStart + 3;
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (!(refStart0 <= t1 && C.JSString_methods.startsWith$2(t2, "../", refStart)))
          break;
        ++backCount;
        refStart = refStart0;
      }
      insert = "";
      while (true) {
        if (typeof baseEnd !== "number")
          return baseEnd.$gt();
        if (typeof baseStart0 !== "number")
          return H.iae(baseStart0);
        if (!(baseEnd > baseStart0))
          break;
        --baseEnd;
        if (C.JSString_methods.codeUnitAt$1(baseUri, baseEnd) === 47) {
          if (backCount === 0) {
            insert = "/";
            break;
          }
          --backCount;
          insert = "/";
        }
      }
      if (baseEnd === baseStart0 && base._schemeEnd <= 0 && !C.JSString_methods.startsWith$2(baseUri, "/", baseStart)) {
        refStart -= backCount * 3;
        insert = "";
      }
      delta = baseEnd - refStart + insert.length;
      return new P._SimpleUri(C.JSString_methods.substring$2(baseUri, 0, baseEnd) + insert + C.JSString_methods.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, t1 + delta, ref._fragmentStart + delta, base._schemeCache);
    },
    toFilePath$0: function() {
      var t1, t2, windows, t3, _this = this;
      if (_this._schemeEnd >= 0 && !_this.get$_isFile())
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(_this.get$scheme()) + " URI"));
      t1 = _this._queryStart;
      t2 = _this._uri;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < t2.length) {
        if (t1 < _this._fragmentStart)
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
        throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
      }
      windows = $.$get$_Uri__isWindowsCached();
      if (H.boolConversionCheck(windows))
        t1 = P._Uri__toWindowsFilePath(_this);
      else {
        t3 = _this._portStart;
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (_this._hostStart < t3)
          H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
        t1 = C.JSString_methods.substring$2(t2, _this._pathStart, t1);
      }
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this._hashCodeCache;
      return t1 == null ? this._hashCodeCache = C.JSString_methods.get$hashCode(this._uri) : t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return !!J.getInterceptor$(other).$isUri && this._uri === other.toString$0(0);
    },
    _toNonSimple$0: function() {
      var _this = this, _null = null,
        t1 = _this.get$scheme(),
        t2 = _this.get$userInfo(),
        t3 = _this._hostStart > 0 ? _this.get$host(_this) : _null,
        t4 = _this.get$hasPort() ? _this.get$port(_this) : _null,
        t5 = _this._uri,
        t6 = _this._queryStart,
        t7 = C.JSString_methods.substring$2(t5, _this._pathStart, t6),
        t8 = _this._fragmentStart;
      if (typeof t6 !== "number")
        return t6.$lt();
      t6 = t6 < t8 ? _this.get$query(_this) : _null;
      return new P._Uri(t1, t2, t3, t4, t7, t6, t8 < t5.length ? _this.get$fragment() : _null);
    },
    toString$0: function(_) {
      return this._uri;
    },
    $isUri: 1
  };
  P._DataUri.prototype = {};
  W.promiseToFuture_closure.prototype = {
    call$1: function(promiseValue) {
      return this.completer.complete$1(0, H.futureOrCheck(promiseValue, {futureOr: 1, type: this.T}));
    },
    $signature: 7
  };
  W.promiseToFuture_closure0.prototype = {
    call$1: function(promiseError) {
      return this.completer.completeError$1(promiseError);
    },
    $signature: 7
  };
  W.HtmlElement.prototype = {};
  W.AccessibleNodeList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.AnchorElement.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isAnchorElement: 1
  };
  W.Animation.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.ApplicationCacheErrorEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.AreaElement.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  W.BackgroundFetchEvent.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.BackgroundFetchRegistration.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.BaseElement.prototype = {$isBaseElement: 1};
  W.Blob.prototype = {$isBlob: 1};
  W.BluetoothRemoteGattDescriptor.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.Body.prototype = {
    json$0: function(receiver) {
      return W.promiseToFuture(receiver.json(), null);
    }
  };
  W.BodyElement.prototype = {
    get$onBlur: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "blur", false, [W.Event]);
    },
    get$onFocus: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "focus", false, [W.Event]);
    },
    get$onResize: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "resize", false, [W.Event]);
    },
    get$onScroll: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "scroll", false, [W.Event]);
    },
    $isBodyElement: 1
  };
  W.BroadcastChannel.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.ButtonElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.CanvasElement.prototype = {
    get$context2D: function(receiver) {
      return receiver.getContext("2d");
    },
    $isCanvasElement: 1,
    $isCanvasImageSource: 1
  };
  W.CanvasRenderingContext2D.prototype = {
    fillText$4: function(receiver, text, x, y, maxWidth) {
      if (maxWidth != null)
        receiver.fillText(text, x, y, maxWidth);
      else
        receiver.fillText(text, x, y);
    },
    fillText$3: function($receiver, text, x, y) {
      return this.fillText$4($receiver, text, x, y, null);
    },
    $isCanvasRenderingContext2D: 1
  };
  W.CharacterData.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.Client0.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.CloseEvent.prototype = {$isCloseEvent: 1};
  W.Credential.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.CredentialUserData.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.CssKeyframesRule.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.CssKeywordValue.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.CssNumericValue.prototype = {$isCssNumericValue: 1};
  W.CssPerspective.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssRule.prototype = {$isCssRule: 1};
  W.CssStyleDeclaration.prototype = {
    _browserPropertyName$1: function(receiver, propertyName) {
      var t1 = $.$get$CssStyleDeclaration__propertyCache(),
        $name = t1[propertyName];
      if (typeof $name === "string")
        return $name;
      $name = this._supportedBrowserPropertyName$1(receiver, propertyName);
      t1[propertyName] = $name;
      return $name;
    },
    _supportedBrowserPropertyName$1: function(receiver, propertyName) {
      var prefixed;
      if (propertyName.replace(/^-ms-/, "ms-").replace(/-([\da-z])/ig, function(_, letter) {
        return letter.toUpperCase();
      }) in receiver)
        return propertyName;
      prefixed = P.Device_cssPrefix() + propertyName;
      if (prefixed in receiver)
        return prefixed;
      return propertyName;
    },
    _setPropertyHelper$3: function(receiver, propertyName, value, priority) {
      receiver.setProperty(propertyName, value, priority);
    },
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssStyleDeclarationBase.prototype = {};
  W.CssStyleValue.prototype = {};
  W.CssTransformComponent.prototype = {};
  W.CssTransformValue.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.CssUnitValue.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.CssUnparsedValue.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.DataElement.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.DataTransferItem.prototype = {
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.DataTransferItemList.prototype = {
    $index: function(receiver, index) {
      return receiver[H.intTypeCheck(index)];
    },
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.DeprecationReport.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.DivElement.prototype = {};
  W.Document.prototype = {$isDocument: 1};
  W.DomError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.DomException.prototype = {
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (H.boolConversionCheck(P.Device_isWebKit()) && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (H.boolConversionCheck(P.Device_isWebKit()) && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isDomException: 1,
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.DomRectList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.assertSubtype(value, "$isRectangle", [P.num], "$asRectangle");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [[P.Rectangle, P.num]];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [[P.Rectangle, P.num]];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [[P.Rectangle, P.num]];
    },
    $asListMixin: function() {
      return [[P.Rectangle, P.num]];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [[P.Rectangle, P.num]];
    },
    $isList: 1,
    $asList: function() {
      return [[P.Rectangle, P.num]];
    },
    $asImmutableListMixin: function() {
      return [[P.Rectangle, P.num]];
    }
  };
  W.DomRectReadOnly.prototype = {
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(this.get$width(receiver)) + " x " + H.S(this.get$height(receiver));
    },
    $eq: function(receiver, other) {
      var t1;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!t1.$isRectangle)
        return false;
      return receiver.left === other.left && receiver.top === other.top && this.get$width(receiver) === t1.get$width(other) && this.get$height(receiver) === t1.get$height(other);
    },
    get$hashCode: function(receiver) {
      return W._JenkinsSmiHash_hash4(C.JSNumber_methods.get$hashCode(receiver.left), C.JSNumber_methods.get$hashCode(receiver.top), C.JSNumber_methods.get$hashCode(this.get$width(receiver)), C.JSNumber_methods.get$hashCode(this.get$height(receiver)));
    },
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    },
    $isRectangle: 1,
    $asRectangle: function() {
      return [P.num];
    }
  };
  W.DomStringList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.stringTypeCheck(value);
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [P.String];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [P.String];
    },
    $asListMixin: function() {
      return [P.String];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.String];
    },
    $isList: 1,
    $asList: function() {
      return [P.String];
    },
    $asImmutableListMixin: function() {
      return [P.String];
    }
  };
  W.DomTokenList.prototype = {
    contains$1: function(receiver, token) {
      return receiver.contains(token);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W._ChildrenElementList.prototype = {
    contains$1: function(_, element) {
      return J.contains$1$asx(this._childElements, element);
    },
    get$isEmpty: function(_) {
      return this._element.firstElementChild == null;
    },
    get$length: function(_) {
      return this._childElements.length;
    },
    $index: function(_, index) {
      return H.interceptedTypeCheck(J.$index$asx(this._childElements, H.intTypeCheck(index)), "$isElement");
    },
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      this._element.replaceChild(H.interceptedTypeCheck(value, "$isElement"), J.$index$asx(this._childElements, index));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize element lists"));
    },
    add$1: function(_, value) {
      H.interceptedTypeCheck(value, "$isElement");
      this._element.appendChild(value);
      return value;
    },
    get$iterator: function(_) {
      var t1 = this.toList$0(this);
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    addAll$1: function(_, iterable) {
      var t1, t2;
      H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
      for (t1 = iterable.get$iterator(iterable), t2 = this._element; t1.moveNext$0();)
        t2.appendChild(t1.get$current(t1));
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element, W.Element]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort element lists"));
    },
    removeWhere$1: function(_, test) {
      this._html$_filter$2(0, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [W.Element]}), false);
    },
    _html$_filter$2: function(_, test, retainMatching) {
      var t1, t2;
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [W.Element]});
      t1 = J.get$children$x(this._element);
      t2 = H.getRuntimeTypeArgument(t1, "ListMixin", 0);
      H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [t2]});
      for (t1 = t1.get$iterator(t1), t2 = new H.WhereIterator(t1, test, [t2]); t2.moveNext$0();)
        J.remove$0$ax(t1.get$current(t1));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
      throw H.wrapException(P.UnimplementedError$(null));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    remove$1: function(_, object) {
      var t1;
      if (!!J.getInterceptor$(object).$isElement) {
        t1 = this._element;
        if (object.parentNode === t1) {
          t1.removeChild(object);
          return true;
        }
      }
      return false;
    },
    insert$2: function(_, index, element) {
      var t1, t2, t3, _this = this;
      H.interceptedTypeCheck(element, "$isElement");
      if (typeof index !== "number")
        return index.$lt();
      if (index < 0 || index > _this._childElements.length)
        throw H.wrapException(P.RangeError$range(index, 0, _this.get$length(_this), null, null));
      t1 = _this._childElements;
      t2 = t1.length;
      t3 = _this._element;
      if (index === t2)
        t3.appendChild(element);
      else {
        if (index < 0 || index >= t2)
          return H.ioore(t1, index);
        t3.insertBefore(element, H.interceptedTypeCheck(t1[index], "$isElement"));
      }
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._element);
    },
    removeAt$1: function(_, index) {
      var result = H.interceptedTypeCheck(J.$index$asx(this._childElements, index), "$isElement");
      this._element.removeChild(result);
      return result;
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      this._element.removeChild(result);
      return result;
    },
    get$first: function(_) {
      var result = this._element.firstElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$last: function(_) {
      var result = this._element.lastElementChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    $asEfficientLengthIterable: function() {
      return [W.Element];
    },
    $asListMixin: function() {
      return [W.Element];
    },
    $asIterable: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    }
  };
  W._FrozenElementList.prototype = {
    get$length: function(_) {
      return this._nodeList.length;
    },
    $index: function(_, index) {
      return H.assertSubtypeOfRuntimeType(C.NodeList_methods.$index(this._nodeList, H.intTypeCheck(index)), H.getTypeArgumentByIndex(this, 0));
    },
    $indexSet: function(_, index, value) {
      H.intTypeCheck(index);
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify list"));
    },
    sort$1: function(_, compare) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort list"));
    },
    get$first: function(_) {
      return H.assertSubtypeOfRuntimeType(C.NodeList_methods.get$first(this._nodeList), H.getTypeArgumentByIndex(this, 0));
    },
    get$last: function(_) {
      return H.assertSubtypeOfRuntimeType(C.NodeList_methods.get$last(this._nodeList), H.getTypeArgumentByIndex(this, 0));
    }
  };
  W.Element.prototype = {
    get$attributes: function(receiver) {
      return new W._ElementAttributeMap(receiver);
    },
    get$children: function(receiver) {
      return new W._ChildrenElementList(receiver, receiver.children);
    },
    get$classes: function(receiver) {
      return new W._ElementCssClassSet(receiver);
    },
    getComputedStyle$0: function(receiver) {
      return window.getComputedStyle(receiver, "");
    },
    toString$0: function(receiver) {
      return receiver.localName;
    },
    scrollIntoView$1: function(receiver, alignment) {
      var hasScrollIntoViewIfNeeded = !!receiver.scrollIntoViewIfNeeded;
      if (alignment === C.ScrollAlignment_TOP)
        receiver.scrollIntoView(true);
      else if (alignment === C.ScrollAlignment_BOTTOM)
        receiver.scrollIntoView(false);
      else if (hasScrollIntoViewIfNeeded)
        if (alignment === C.ScrollAlignment_CENTER)
          receiver.scrollIntoViewIfNeeded(true);
        else
          receiver.scrollIntoViewIfNeeded();
      else
        receiver.scrollIntoView();
    },
    scrollIntoView$0: function($receiver) {
      return this.scrollIntoView$1($receiver, null);
    },
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, t2, contextElement, fragment;
      if (treeSanitizer == null) {
        t1 = $.Element__defaultValidator;
        if (t1 == null) {
          t1 = H.setRuntimeTypeInfo([], [W.NodeValidator]);
          t2 = new W.NodeValidatorBuilder(t1);
          C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
          C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
          $.Element__defaultValidator = t2;
          validator = t2;
        } else
          validator = t1;
        t1 = $.Element__defaultSanitizer;
        if (t1 == null) {
          t1 = new W._ValidatingTreeSanitizer(validator);
          $.Element__defaultSanitizer = t1;
          treeSanitizer = t1;
        } else {
          t1.validator = validator;
          treeSanitizer = t1;
        }
      }
      if ($.Element__parseDocument == null) {
        t1 = document;
        t2 = t1.implementation.createHTMLDocument("");
        $.Element__parseDocument = t2;
        $.Element__parseRange = t2.createRange();
        t2 = $.Element__parseDocument.createElement("base");
        H.interceptedTypeCheck(t2, "$isBaseElement");
        t2.href = t1.baseURI;
        $.Element__parseDocument.head.appendChild(t2);
      }
      t1 = $.Element__parseDocument;
      if (t1.body == null) {
        t2 = t1.createElement("body");
        t1.body = H.interceptedTypeCheck(t2, "$isBodyElement");
      }
      t1 = $.Element__parseDocument;
      if (!!this.$isBodyElement)
        contextElement = t1.body;
      else {
        contextElement = t1.createElement(receiver.tagName);
        $.Element__parseDocument.body.appendChild(contextElement);
      }
      if ("createContextualFragment" in window.Range.prototype && !C.JSArray_methods.contains$1(C.List_ego, receiver.tagName)) {
        $.Element__parseRange.selectNodeContents(contextElement);
        fragment = $.Element__parseRange.createContextualFragment(html);
      } else {
        contextElement.innerHTML = html;
        fragment = $.Element__parseDocument.createDocumentFragment();
        for (; t1 = contextElement.firstChild, t1 != null;)
          fragment.appendChild(t1);
      }
      t1 = $.Element__parseDocument.body;
      if (contextElement == null ? t1 != null : contextElement !== t1)
        J.remove$0$ax(contextElement);
      treeSanitizer.sanitizeTree$1(fragment);
      document.adoptNode(fragment);
      return fragment;
    },
    createFragment$2$treeSanitizer: function($receiver, html, treeSanitizer) {
      return this.createFragment$3$treeSanitizer$validator($receiver, html, treeSanitizer, null);
    },
    set$innerHtml: function(receiver, html) {
      this.setInnerHtml$1(receiver, html);
    },
    setInnerHtml$2$treeSanitizer: function(receiver, html, treeSanitizer) {
      receiver.textContent = null;
      receiver.appendChild(this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, null));
    },
    setInnerHtml$1: function($receiver, html) {
      return this.setInnerHtml$2$treeSanitizer($receiver, html, null);
    },
    get$innerHtml: function(receiver) {
      return receiver.innerHTML;
    },
    click$0: function(receiver) {
      return receiver.click();
    },
    focus$0: function(receiver) {
      return receiver.focus();
    },
    scrollTo$2: function(receiver, options_OR_x, y) {
      if (options_OR_x == null && y == null) {
        receiver.scrollTo();
        return;
      }
      if (!!J.getInterceptor$(options_OR_x).$isMap && y == null) {
        receiver.scrollTo(P.convertDartToNative_Dictionary(options_OR_x));
        return;
      }
      if (y != null && typeof options_OR_x === "number") {
        receiver.scrollTo(options_OR_x, y);
        return;
      }
      throw H.wrapException(P.ArgumentError$("Incorrect number or type of arguments"));
    },
    scrollTo$1: function($receiver, options_OR_x) {
      return this.scrollTo$2($receiver, options_OR_x, null);
    },
    get$onBlur: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "blur", false, [W.Event]);
    },
    get$onChange: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "change", false, [W.Event]);
    },
    get$onClick: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "click", false, [W.MouseEvent]);
    },
    get$onDoubleClick: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "dblclick", false, [W.Event]);
    },
    get$onFocus: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "focus", false, [W.Event]);
    },
    get$onKeyDown: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "keydown", false, [W.KeyboardEvent]);
    },
    get$onKeyUp: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "keyup", false, [W.KeyboardEvent]);
    },
    get$onMouseDown: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mousedown", false, [W.MouseEvent]);
    },
    get$onMouseLeave: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mouseleave", false, [W.MouseEvent]);
    },
    get$onMouseMove: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mousemove", false, [W.MouseEvent]);
    },
    get$onMouseOver: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mouseover", false, [W.MouseEvent]);
    },
    get$onMouseWheel: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, H.stringTypeCheck(W.Element__determineMouseWheelEventType(receiver)), false, [W.WheelEvent]);
    },
    get$onResize: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "resize", false, [W.Event]);
    },
    get$onScroll: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "scroll", false, [W.Event]);
    },
    $isElement: 1,
    get$id: function(receiver) {
      return receiver.id;
    },
    get$tagName: function(receiver) {
      return receiver.tagName;
    }
  };
  W.Element_Element$html_closure.prototype = {
    call$1: function(e) {
      return !!J.getInterceptor$(H.interceptedTypeCheck(e, "$isNode")).$isElement;
    },
    $signature: 73
  };
  W.ScrollAlignment.prototype = {
    toString$0: function(_) {
      return "ScrollAlignment." + this._html$_value;
    }
  };
  W.EmbedElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Entry.prototype = {
    _remove$2: function(receiver, successCallback, errorCallback) {
      H.functionTypeCheck(successCallback, {func: 1, ret: -1});
      H.functionTypeCheck(errorCallback, {func: 1, ret: -1, args: [W.DomException]});
      return receiver.remove(H.convertDartClosureToJS(successCallback, 0), H.convertDartClosureToJS(errorCallback, 1));
    },
    remove$0: function(receiver) {
      var t1 = new P._Future($.Zone__current, [null]),
        completer = new P._AsyncCompleter(t1, [null]);
      this._remove$2(receiver, new W.Entry_remove_closure(completer), new W.Entry_remove_closure0(completer));
      return t1;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Entry_remove_closure.prototype = {
    call$0: function() {
      this.completer.complete$0(0);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  W.Entry_remove_closure0.prototype = {
    call$1: function(error) {
      this.completer.completeError$1(H.interceptedTypeCheck(error, "$isDomException"));
    },
    $signature: 186
  };
  W.ErrorEvent.prototype = {$isErrorEvent: 1,
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.Event.prototype = {$isEvent: 1};
  W.EventTarget.prototype = {
    addEventListener$3: function(receiver, type, listener, useCapture) {
      H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
      if (listener != null)
        this._addEventListener$3(receiver, type, listener, false);
    },
    _addEventListener$3: function(receiver, type, listener, options) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(H.functionTypeCheck(listener, {func: 1, args: [W.Event]}), 1), false);
    },
    _removeEventListener$3: function(receiver, type, listener, options) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(H.functionTypeCheck(listener, {func: 1, args: [W.Event]}), 1), false);
    },
    $isEventTarget: 1
  };
  W.ExtendableEvent.prototype = {};
  W.FederatedCredential.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.FieldSetElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.File.prototype = {$isFile: 1,
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.FileList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isFile");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.File];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.File];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.File];
    },
    $asListMixin: function() {
      return [W.File];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.File];
    },
    $isList: 1,
    $asList: function() {
      return [W.File];
    },
    $isFileList: 1,
    $asImmutableListMixin: function() {
      return [W.File];
    }
  };
  W.FileReader.prototype = {
    get$result: function(receiver) {
      var res = receiver.result;
      if (!!J.getInterceptor$(res).$isByteBuffer)
        return H.NativeUint8List_NativeUint8List$view(res, 0, null);
      return res;
    },
    readAsText$1: function(receiver, blob) {
      return receiver.readAsText(blob);
    }
  };
  W.FileSystem.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.FileWriter.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.FontFace.prototype = {$isFontFace: 1};
  W.FormElement.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Gamepad.prototype = {$isGamepad: 1,
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.GamepadButton.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.History.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.HtmlCollection.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Node];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $isHtmlCollection: 1,
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W.HttpRequest.prototype = {
    get$responseHeaders: function(receiver) {
      var headersList, _i, header, t2, splitIdx, key, value,
        t1 = P.String,
        headers = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1),
        headersString = receiver.getAllResponseHeaders();
      if (headersString == null)
        return headers;
      headersList = headersString.split("\r\n");
      for (t1 = headersList.length, _i = 0; _i < t1; ++_i) {
        header = headersList[_i];
        t2 = J.getInterceptor$asx(header);
        if (t2.get$length(header) === 0)
          continue;
        splitIdx = t2.indexOf$1(header, ": ");
        if (splitIdx === -1)
          continue;
        key = t2.substring$2(header, 0, splitIdx).toLowerCase();
        value = t2.substring$1(header, splitIdx + 2);
        if (headers.containsKey$1(0, key))
          headers.$indexSet(0, key, H.S(headers.$index(0, key)) + ", " + value);
        else
          headers.$indexSet(0, key, value);
      }
      return headers;
    },
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, true, user, password);
    },
    send$1: function(receiver, body_OR_data) {
      return receiver.send(body_OR_data);
    },
    setRequestHeader$2: function(receiver, $name, value) {
      return receiver.setRequestHeader(H.stringTypeCheck($name), H.stringTypeCheck(value));
    },
    $isHttpRequest: 1
  };
  W.HttpRequestEventTarget.prototype = {};
  W.IFrameElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.ImageData.prototype = {$isImageData: 1};
  W.ImageElement.prototype = {$isImageElement: 1, $isCanvasImageSource: 1};
  W.InputElement.prototype = {$isInputElement: 1,
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.InterventionReport.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.KeyboardEvent.prototype = {$isKeyboardEvent: 1,
    get$key: function(receiver) {
      return receiver.key;
    }
  };
  W.LIElement.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.Location.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    },
    $isLocation: 1
  };
  W.MapElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.MediaDeviceInfo.prototype = {
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.MediaElement.prototype = {};
  W.MediaError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.MediaKeyMessageEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.MediaKeySession.prototype = {
    remove$0: function(receiver) {
      return W.promiseToFuture(receiver.remove(), null);
    }
  };
  W.MediaList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.MediaStream.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.MediaStreamTrack.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    },
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.MessageEvent.prototype = {$isMessageEvent: 1};
  W.MessagePort.prototype = {
    addEventListener$3: function(receiver, type, listener, useCapture) {
      H.functionTypeCheck(listener, {func: 1, args: [W.Event]});
      if (type === "message")
        receiver.start();
      this.super$EventTarget$addEventListener(receiver, type, listener, false);
    },
    $isMessagePort: 1
  };
  W.MetaElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.MeterElement.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.MidiInputMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.MidiInputMap_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = H.setRuntimeTypeInfo([], [[P.Map,,,]]);
      this.forEach$1(receiver, new W.MidiInputMap_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.size !== 0;
    },
    $indexSet: function(receiver, key, value) {
      H.stringTypeCheck(key);
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.MidiInputMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 13
  };
  W.MidiInputMap_values_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.values, v);
    },
    $signature: 13
  };
  W.MidiOutputMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.MidiOutputMap_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = H.setRuntimeTypeInfo([], [[P.Map,,,]]);
      this.forEach$1(receiver, new W.MidiOutputMap_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.size !== 0;
    },
    $indexSet: function(receiver, key, value) {
      H.stringTypeCheck(key);
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.MidiOutputMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 13
  };
  W.MidiOutputMap_values_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.values, v);
    },
    $signature: 13
  };
  W.MidiPort.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.MimeType.prototype = {$isMimeType: 1};
  W.MimeTypeArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isMimeType");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.MimeType];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.MimeType];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.MimeType];
    },
    $asListMixin: function() {
      return [W.MimeType];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.MimeType];
    },
    $isList: 1,
    $asList: function() {
      return [W.MimeType];
    },
    $asImmutableListMixin: function() {
      return [W.MimeType];
    }
  };
  W.MouseEvent.prototype = {$isMouseEvent: 1};
  W.NavigatorUserMediaError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W._ChildNodeListLazy.prototype = {
    get$first: function(_) {
      var result = this._this.firstChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$last: function(_) {
      var result = this._this.lastChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$single: function(_) {
      var t1 = this._this,
        l = t1.childNodes.length;
      if (l === 0)
        throw H.wrapException(P.StateError$("No elements"));
      if (l > 1)
        throw H.wrapException(P.StateError$("More than one element"));
      return t1.firstChild;
    },
    add$1: function(_, value) {
      this._this.appendChild(H.interceptedTypeCheck(value, "$isNode"));
    },
    addAll$1: function(_, iterable) {
      var t1, t2, len, i;
      H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
      if (!!iterable.$is_ChildNodeListLazy) {
        t1 = iterable._this;
        t2 = this._this;
        if (t1 !== t2)
          for (len = t1.childNodes.length, i = 0; i < len; ++i)
            t2.appendChild(t1.firstChild);
        return;
      }
      for (t1 = iterable.get$iterator(iterable), t2 = this._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current(t1));
    },
    insert$2: function(_, index, node) {
      var t1, t2, t3, _this = this;
      H.interceptedTypeCheck(node, "$isNode");
      if (typeof index !== "number")
        return index.$lt();
      if (index < 0 || index > _this._this.childNodes.length)
        throw H.wrapException(P.RangeError$range(index, 0, _this.get$length(_this), null, null));
      t1 = _this._this;
      t2 = t1.childNodes;
      t3 = t2.length;
      if (index === t3)
        t1.appendChild(node);
      else {
        if (index < 0 || index >= t3)
          return H.ioore(t2, index);
        t1.insertBefore(node, t2[index]);
      }
    },
    removeAt$1: function(_, index) {
      var t1 = this._this,
        result = C.NodeList_methods.$index(t1.childNodes, index);
      t1.removeChild(result);
      return result;
    },
    remove$1: function(_, object) {
      return false;
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._this);
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.intTypeCheck(index);
      t1 = this._this;
      t1.replaceChild(H.interceptedTypeCheck(value, "$isNode"), C.NodeList_methods.$index(t1.childNodes, index));
    },
    get$iterator: function(_) {
      var t1 = this._this.childNodes;
      return new W.FixedSizeListIterator(t1, t1.length, [H.getRuntimeTypeArgumentIntercepted(C.NodeList_methods, t1, "ImmutableListMixin", 0)]);
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Node, W.Node]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort Node list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [W.Node], "$asIterable");
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      H.intTypeCheck(index);
      return C.NodeList_methods.$index(this._this.childNodes, index);
    },
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $asIterable: function() {
      return [W.Node];
    },
    $asList: function() {
      return [W.Node];
    }
  };
  W.Node.prototype = {
    remove$0: function(receiver) {
      var t1 = receiver.parentNode;
      if (t1 != null)
        t1.removeChild(receiver);
    },
    replaceWith$1: function(receiver, otherNode) {
      var $parent, exception;
      try {
        $parent = receiver.parentNode;
        J._replaceChild$2$x($parent, otherNode, receiver);
      } catch (exception) {
        H.unwrapException(exception);
      }
      return receiver;
    },
    _clearChildren$0: function(receiver) {
      var t1;
      for (; t1 = receiver.firstChild, t1 != null;)
        receiver.removeChild(t1);
    },
    toString$0: function(receiver) {
      var value = receiver.nodeValue;
      return value == null ? this.super$Interceptor$toString(receiver) : value;
    },
    append$1: function(receiver, node) {
      return receiver.appendChild(node);
    },
    contains$1: function(receiver, other) {
      return receiver.contains(H.interceptedTypeCheck(other, "$isNode"));
    },
    _replaceChild$2: function(receiver, node, child) {
      return receiver.replaceChild(node, child);
    },
    $isNode: 1
  };
  W.NodeList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Node];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W.ObjectElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.OptionElement.prototype = {$isOptionElement: 1,
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.OutputElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.OverconstrainedError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.ParamElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.PasswordCredential.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.PaymentRequest.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.PerformanceEntry.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.PerformanceServerTiming.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Plugin.prototype = {$isPlugin: 1,
    get$length: function(receiver) {
      return receiver.length;
    },
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.PluginArray.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isPlugin");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Plugin];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Plugin];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Plugin];
    },
    $asListMixin: function() {
      return [W.Plugin];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Plugin];
    },
    $isList: 1,
    $asList: function() {
      return [W.Plugin];
    },
    $asImmutableListMixin: function() {
      return [W.Plugin];
    }
  };
  W.PopStateEvent.prototype = {$isPopStateEvent: 1};
  W.PositionError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.PresentationAvailability.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.PresentationConnection.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.PresentationConnectionCloseEvent.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.ProgressElement0.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.ProgressEvent.prototype = {$isProgressEvent: 1};
  W.PushMessageData.prototype = {
    json$0: function(receiver) {
      return receiver.json();
    }
  };
  W.RelatedApplication.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.ReportBody.prototype = {};
  W.ResizeObserver.prototype = {$isResizeObserver: 1};
  W.ResizeObserverEntry.prototype = {$isResizeObserverEntry: 1};
  W.RtcDataChannel.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.RtcLegacyStatsReport.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.RtcStatsReport.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.RtcStatsReport_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = H.setRuntimeTypeInfo([], [[P.Map,,,]]);
      this.forEach$1(receiver, new W.RtcStatsReport_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.size !== 0;
    },
    $indexSet: function(receiver, key, value) {
      H.stringTypeCheck(key);
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  W.RtcStatsReport_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 13
  };
  W.RtcStatsReport_values_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.values, v);
    },
    $signature: 13
  };
  W.SelectElement.prototype = {$isSelectElement: 1,
    get$length: function(receiver) {
      return receiver.length;
    },
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.SharedWorkerGlobalScope.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.SlotElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.SourceBuffer.prototype = {$isSourceBuffer: 1};
  W.SourceBufferList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSourceBuffer");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.SourceBuffer];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SourceBuffer];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SourceBuffer];
    },
    $asListMixin: function() {
      return [W.SourceBuffer];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SourceBuffer];
    },
    $isList: 1,
    $asList: function() {
      return [W.SourceBuffer];
    },
    $asImmutableListMixin: function() {
      return [W.SourceBuffer];
    }
  };
  W.SpeechGrammar.prototype = {$isSpeechGrammar: 1};
  W.SpeechGrammarList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSpeechGrammar");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.SpeechGrammar];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SpeechGrammar];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SpeechGrammar];
    },
    $asListMixin: function() {
      return [W.SpeechGrammar];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SpeechGrammar];
    },
    $isList: 1,
    $asList: function() {
      return [W.SpeechGrammar];
    },
    $asImmutableListMixin: function() {
      return [W.SpeechGrammar];
    }
  };
  W.SpeechRecognitionError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  W.SpeechRecognitionResult.prototype = {$isSpeechRecognitionResult: 1,
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.SpeechSynthesisEvent.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.SpeechSynthesisVoice.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Storage.prototype = {
    containsKey$1: function(receiver, key) {
      return receiver.getItem(key) != null;
    },
    $index: function(receiver, key) {
      return receiver.getItem(H.stringTypeCheck(key));
    },
    $indexSet: function(receiver, key, value) {
      receiver.setItem(H.stringTypeCheck(key), H.stringTypeCheck(value));
    },
    forEach$1: function(receiver, f) {
      var i, key;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String, P.String]});
      for (i = 0; true; ++i) {
        key = receiver.key(i);
        if (key == null)
          return;
        f.call$2(key, receiver.getItem(key));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.Storage_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new W.Storage_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    get$isEmpty: function(receiver) {
      return receiver.key(0) == null;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.key(0) != null;
    },
    $asMapMixin: function() {
      return [P.String, P.String];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, P.String];
    }
  };
  W.Storage_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 32
  };
  W.Storage_values_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.values, v);
    },
    $signature: 32
  };
  W.StorageEvent.prototype = {
    get$key: function(receiver) {
      return receiver.key;
    }
  };
  W.StyleSheet.prototype = {$isStyleSheet: 1};
  W.TableElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var table, fragment;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      table = W.Element_Element$html("<table>" + H.S(html) + "</table>", treeSanitizer, validator);
      fragment = document.createDocumentFragment();
      fragment.toString;
      table.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(table));
      return fragment;
    }
  };
  W.TableRowElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, fragment, section, row;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      t1 = document;
      fragment = t1.createDocumentFragment();
      t1 = C.TableElement_methods.createFragment$3$treeSanitizer$validator(t1.createElement("table"), html, treeSanitizer, validator);
      t1.toString;
      t1 = new W._ChildNodeListLazy(t1);
      section = t1.get$single(t1);
      section.toString;
      t1 = new W._ChildNodeListLazy(section);
      row = t1.get$single(t1);
      fragment.toString;
      row.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(row));
      return fragment;
    }
  };
  W.TableSectionElement.prototype = {
    createFragment$3$treeSanitizer$validator: function(receiver, html, treeSanitizer, validator) {
      var t1, fragment, section;
      if ("createContextualFragment" in window.Range.prototype)
        return this.super$Element$createFragment(receiver, html, treeSanitizer, validator);
      t1 = document;
      fragment = t1.createDocumentFragment();
      t1 = C.TableElement_methods.createFragment$3$treeSanitizer$validator(t1.createElement("table"), html, treeSanitizer, validator);
      t1.toString;
      t1 = new W._ChildNodeListLazy(t1);
      section = t1.get$single(t1);
      fragment.toString;
      section.toString;
      new W._ChildNodeListLazy(fragment).addAll$1(0, new W._ChildNodeListLazy(section));
      return fragment;
    }
  };
  W.TemplateElement.prototype = {
    setInnerHtml$2$treeSanitizer: function(receiver, html, treeSanitizer) {
      var fragment;
      receiver.textContent = null;
      fragment = this.createFragment$3$treeSanitizer$validator(receiver, html, treeSanitizer, null);
      receiver.content.appendChild(fragment);
    },
    setInnerHtml$1: function($receiver, html) {
      return this.setInnerHtml$2$treeSanitizer($receiver, html, null);
    },
    $isTemplateElement: 1
  };
  W.TextAreaElement.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W.TextTrack.prototype = {$isTextTrack: 1,
    get$id: function(receiver) {
      return receiver.id;
    },
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.TextTrackCue.prototype = {$isTextTrackCue: 1,
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.TextTrackCueList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTextTrackCue");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.TextTrackCue];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.TextTrackCue];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.TextTrackCue];
    },
    $asListMixin: function() {
      return [W.TextTrackCue];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.TextTrackCue];
    },
    $isList: 1,
    $asList: function() {
      return [W.TextTrackCue];
    },
    $asImmutableListMixin: function() {
      return [W.TextTrackCue];
    }
  };
  W.TextTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTextTrack");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.TextTrack];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.TextTrack];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.TextTrack];
    },
    $asListMixin: function() {
      return [W.TextTrack];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.TextTrack];
    },
    $isList: 1,
    $asList: function() {
      return [W.TextTrack];
    },
    $asImmutableListMixin: function() {
      return [W.TextTrack];
    }
  };
  W.TimeRanges.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.Touch.prototype = {$isTouch: 1};
  W.TouchList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTouch");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Touch];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Touch];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Touch];
    },
    $asListMixin: function() {
      return [W.Touch];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Touch];
    },
    $isList: 1,
    $asList: function() {
      return [W.Touch];
    },
    $asImmutableListMixin: function() {
      return [W.Touch];
    }
  };
  W.TrackDefaultList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.TrackElement.prototype = {
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.UIEvent.prototype = {};
  W.Url.prototype = {
    toString$0: function(receiver) {
      return String(receiver);
    }
  };
  W.VideoElement.prototype = {$isCanvasImageSource: 1};
  W.VideoTrack.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    },
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  W.VideoTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  W.VttRegion.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    }
  };
  W.WheelEvent.prototype = {
    get$deltaY: function(receiver) {
      if (receiver.deltaY !== undefined)
        return receiver.deltaY;
      throw H.wrapException(P.UnsupportedError$("deltaY is not supported"));
    },
    get$deltaX: function(receiver) {
      if (receiver.deltaX !== undefined)
        return receiver.deltaX;
      throw H.wrapException(P.UnsupportedError$("deltaX is not supported"));
    },
    $isWheelEvent: 1
  };
  W.Window.prototype = {
    get$animationFrame: function(receiver) {
      var t1 = P.num,
        t2 = new P._Future($.Zone__current, [t1]);
      this.requestAnimationFrame$1(receiver, new W.Window_animationFrame_closure(new P._SyncCompleter(t2, [t1])));
      return t2;
    },
    open$2: function(receiver, url, $name) {
      var t1 = W._DOMWindowCrossFrame__createSafe(receiver.open(url, $name));
      return t1;
    },
    requestAnimationFrame$1: function(receiver, callback) {
      H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]});
      this._ensureRequestAnimationFrame$0(receiver);
      return this._requestAnimationFrame$1(receiver, W._wrapZone(callback, P.num));
    },
    _requestAnimationFrame$1: function(receiver, callback) {
      return receiver.requestAnimationFrame(H.convertDartClosureToJS(H.functionTypeCheck(callback, {func: 1, ret: -1, args: [P.num]}), 1));
    },
    _ensureRequestAnimationFrame$0: function(receiver) {
      if (!!(receiver.requestAnimationFrame && receiver.cancelAnimationFrame))
        return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame)
          return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(receiver);
    },
    $isWindow: 1,
    $isWindowBase: 1,
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  W.Window_animationFrame_closure.prototype = {
    call$1: function(time) {
      this.completer.complete$1(0, H.numTypeCheck(time));
    },
    $signature: 64
  };
  W.WorkerGlobalScope.prototype = {$isWorkerGlobalScope: 1};
  W._Attr.prototype = {$is_Attr: 1,
    get$name: function(receiver) {
      return receiver.name;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  W._CssRuleList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isCssRule");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.CssRule];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.CssRule];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.CssRule];
    },
    $asListMixin: function() {
      return [W.CssRule];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.CssRule];
    },
    $isList: 1,
    $asList: function() {
      return [W.CssRule];
    },
    $asImmutableListMixin: function() {
      return [W.CssRule];
    }
  };
  W._DomRect.prototype = {
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1;
      if (other == null)
        return false;
      t1 = J.getInterceptor$(other);
      if (!t1.$isRectangle)
        return false;
      return receiver.left === other.left && receiver.top === other.top && receiver.width === t1.get$width(other) && receiver.height === t1.get$height(other);
    },
    get$hashCode: function(receiver) {
      return W._JenkinsSmiHash_hash4(C.JSNumber_methods.get$hashCode(receiver.left), C.JSNumber_methods.get$hashCode(receiver.top), C.JSNumber_methods.get$hashCode(receiver.width), C.JSNumber_methods.get$hashCode(receiver.height));
    },
    get$height: function(receiver) {
      return receiver.height;
    },
    get$width: function(receiver) {
      return receiver.width;
    }
  };
  W._GamepadList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isGamepad");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Gamepad];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Gamepad];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Gamepad];
    },
    $asListMixin: function() {
      return [W.Gamepad];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Gamepad];
    },
    $isList: 1,
    $asList: function() {
      return [W.Gamepad];
    },
    $asImmutableListMixin: function() {
      return [W.Gamepad];
    }
  };
  W._NamedNodeMap.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNode");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.Node];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.Node];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.Node];
    },
    $asListMixin: function() {
      return [W.Node];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.Node];
    },
    $isList: 1,
    $asList: function() {
      return [W.Node];
    },
    $asImmutableListMixin: function() {
      return [W.Node];
    }
  };
  W._SpeechRecognitionResultList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isSpeechRecognitionResult");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.SpeechRecognitionResult];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.SpeechRecognitionResult];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.SpeechRecognitionResult];
    },
    $asListMixin: function() {
      return [W.SpeechRecognitionResult];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.SpeechRecognitionResult];
    },
    $isList: 1,
    $asList: function() {
      return [W.SpeechRecognitionResult];
    },
    $asImmutableListMixin: function() {
      return [W.SpeechRecognitionResult];
    }
  };
  W._StyleSheetList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isStyleSheet");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isJSIndexable: 1,
    $asJSIndexable: function() {
      return [W.StyleSheet];
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [W.StyleSheet];
    },
    $isJavaScriptIndexingBehavior: 1,
    $asJavaScriptIndexingBehavior: function() {
      return [W.StyleSheet];
    },
    $asListMixin: function() {
      return [W.StyleSheet];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [W.StyleSheet];
    },
    $isList: 1,
    $asList: function() {
      return [W.StyleSheet];
    },
    $asImmutableListMixin: function() {
      return [W.StyleSheet];
    }
  };
  W._AttributeMap.prototype = {
    forEach$1: function(_, f) {
      var t1, t2, t3, _i, key;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String, P.String]});
      for (t1 = this.get$keys(this), t2 = t1.length, t3 = this._element, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        key = H.stringTypeCheck(t1[_i]);
        f.call$2(key, t3.getAttribute(key));
      }
    },
    get$keys: function(_) {
      var len, i, attr,
        attributes = this._element.attributes,
        keys = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        attr = H.interceptedTypeCheck(attributes[i], "$is_Attr");
        if (attr.namespaceURI == null)
          C.JSArray_methods.add$1(keys, attr.name);
      }
      return keys;
    },
    get$values: function(_) {
      var len, i, attr,
        attributes = this._element.attributes,
        values = H.setRuntimeTypeInfo([], [P.String]);
      for (len = attributes.length, i = 0; i < len; ++i) {
        if (i >= attributes.length)
          return H.ioore(attributes, i);
        attr = H.interceptedTypeCheck(attributes[i], "$is_Attr");
        if (attr.namespaceURI == null)
          C.JSArray_methods.add$1(values, attr.value);
      }
      return values;
    },
    get$isEmpty: function(_) {
      return this.get$keys(this).length === 0;
    },
    get$isNotEmpty: function(_) {
      return this.get$keys(this).length !== 0;
    },
    $asMapMixin: function() {
      return [P.String, P.String];
    },
    $asMap: function() {
      return [P.String, P.String];
    }
  };
  W._ElementAttributeMap.prototype = {
    containsKey$1: function(_, key) {
      return this._element.hasAttribute(key);
    },
    $index: function(_, key) {
      return this._element.getAttribute(H.stringTypeCheck(key));
    },
    $indexSet: function(_, key, value) {
      this._element.setAttribute(H.stringTypeCheck(key), H.stringTypeCheck(value));
    },
    get$length: function(_) {
      return this.get$keys(this).length;
    }
  };
  W.CanvasImageSource.prototype = {};
  W._ElementCssClassSet.prototype = {
    readClasses$0: function() {
      var t1, t2, _i, trimmed,
        s = P.LinkedHashSet_LinkedHashSet(P.String);
      for (t1 = this._element.className.split(" "), t2 = t1.length, _i = 0; _i < t2; ++_i) {
        trimmed = J.trim$0$s(t1[_i]);
        if (trimmed.length !== 0)
          s.add$1(0, trimmed);
      }
      return s;
    },
    writeClasses$1: function(s) {
      this._element.className = H.assertSubtype(s, "$isSet", [P.String], "$asSet").join$1(0, " ");
    },
    get$length: function(_) {
      return this._element.classList.length;
    },
    get$isEmpty: function(_) {
      return this._element.classList.length === 0;
    },
    get$isNotEmpty: function(_) {
      return this._element.classList.length !== 0;
    },
    clear$0: function(_) {
      this._element.className = "";
    },
    contains$1: function(_, value) {
      return typeof value === "string" && this._element.classList.contains(value);
    },
    add$1: function(_, value) {
      var list, t1;
      H.stringTypeCheck(value);
      list = this._element.classList;
      t1 = list.contains(value);
      list.add(value);
      return !t1;
    },
    remove$1: function(_, value) {
      var list, removed, t1;
      if (typeof value === "string") {
        list = this._element.classList;
        removed = list.contains(value);
        list.remove(value);
        t1 = removed;
      } else
        t1 = false;
      return t1;
    },
    toggle$2: function(_, value, shouldAdd) {
      var t1 = this._element;
      return shouldAdd == null ? t1.classList.toggle(value) : W._ElementCssClassSet__toggleOnOff(t1, value, shouldAdd);
    },
    addAll$1: function(_, iterable) {
      W._ElementCssClassSet__addAll(this._element, H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable"));
    },
    removeAll$1: function(iterable) {
      W._ElementCssClassSet__removeAll(this._element, H.assertSubtype(iterable, "$isIterable", [P.Object], "$asIterable"));
    },
    removeWhere$1: function(_, test) {
      W._ElementCssClassSet__removeWhere(this._element, H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [P.String]}), true);
    }
  };
  W._EventStream.prototype = {
    get$isBroadcast: function() {
      return true;
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [t1]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      return W._EventStreamSubscription$(this._html$_target, this._eventType, onData, false, t1);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  W._ElementEventStreamImpl.prototype = {};
  W._EventStreamSubscription.prototype = {
    cancel$0: function(_) {
      var _this = this;
      if (_this._html$_target == null)
        return;
      _this._unlisten$0();
      _this._html$_target = null;
      _this.set$_html$_onData(null);
      return;
    },
    onData$1: function(handleData) {
      var _this = this;
      H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(_this, 0)]});
      if (_this._html$_target == null)
        throw H.wrapException(P.StateError$("Subscription has been canceled."));
      _this._unlisten$0();
      _this.set$_html$_onData(W._wrapZone(H.functionTypeCheck(handleData, {func: 1, ret: -1, args: [W.Event]}), W.Event));
      _this._tryResume$0();
    },
    onError$1: function(_, handleError) {
    },
    onDone$1: function(handleDone) {
      H.functionTypeCheck(handleDone, {func: 1, ret: -1});
    },
    pause$1: function(_, resumeSignal) {
      if (this._html$_target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function(_) {
      var _this = this;
      if (_this._html$_target == null || _this._pauseCount <= 0)
        return;
      --_this._pauseCount;
      _this._tryResume$0();
    },
    _tryResume$0: function() {
      var _this = this,
        t1 = _this._html$_onData;
      if (t1 != null && _this._pauseCount <= 0)
        J.addEventListener$3$x(_this._html$_target, _this._eventType, t1, false);
    },
    _unlisten$0: function() {
      var t3,
        t1 = this._html$_onData,
        t2 = t1 != null;
      if (t2) {
        t3 = this._html$_target;
        t3.toString;
        H.functionTypeCheck(t1, {func: 1, args: [W.Event]});
        if (t2)
          J._removeEventListener$3$x(t3, this._eventType, t1, false);
      }
    },
    set$_html$_onData: function(_onData) {
      this._html$_onData = H.functionTypeCheck(_onData, {func: 1, args: [W.Event]});
    }
  };
  W._EventStreamSubscription_closure.prototype = {
    call$1: function(e) {
      return this.onData.call$1(H.interceptedTypeCheck(e, "$isEvent"));
    },
    $signature: 220
  };
  W._Html5NodeValidator.prototype = {
    _Html5NodeValidator$1$uriPolicy: function(uriPolicy) {
      var _i;
      if ($._Html5NodeValidator__attributeValidators.get$isEmpty($._Html5NodeValidator__attributeValidators)) {
        for (_i = 0; _i < 262; ++_i)
          $._Html5NodeValidator__attributeValidators.$indexSet(0, C.List_2Zi[_i], W.html__Html5NodeValidator__standardAttributeValidator$closure());
        for (_i = 0; _i < 12; ++_i)
          $._Html5NodeValidator__attributeValidators.$indexSet(0, C.List_yrN[_i], W.html__Html5NodeValidator__uriAttributeValidator$closure());
      }
    },
    allowsElement$1: function(element) {
      return $.$get$_Html5NodeValidator__allowedElements().contains$1(0, W.Element__safeTagName(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      var validator = $._Html5NodeValidator__attributeValidators.$index(0, H.S(W.Element__safeTagName(element)) + "::" + attributeName);
      if (validator == null)
        validator = $._Html5NodeValidator__attributeValidators.$index(0, "*::" + attributeName);
      if (validator == null)
        return false;
      return H.boolTypeCheck(validator.call$4(element, attributeName, value, this));
    },
    $isNodeValidator: 1
  };
  W.ImmutableListMixin.prototype = {
    get$iterator: function(receiver) {
      return new W.FixedSizeListIterator(receiver, this.get$length(receiver), [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)]);
    },
    add$1: function(receiver, value) {
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    sort$1: function(receiver, compare) {
      var t1 = H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort immutable List."));
    },
    insert$2: function(receiver, index, element) {
      H.assertSubtypeOfRuntimeType(element, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0));
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    removeAt$1: function(receiver, pos) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    remove$1: function(receiver, object) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ImmutableListMixin", 0)], "$asIterable");
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    }
  };
  W.NodeValidatorBuilder.prototype = {
    allowsElement$1: function(element) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsElement_closure(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      return C.JSArray_methods.any$1(this._validators, new W.NodeValidatorBuilder_allowsAttribute_closure(element, attributeName, value));
    },
    $isNodeValidator: 1
  };
  W.NodeValidatorBuilder_allowsElement_closure.prototype = {
    call$1: function(v) {
      return H.interceptedTypeCheck(v, "$isNodeValidator").allowsElement$1(this.element);
    },
    $signature: 65
  };
  W.NodeValidatorBuilder_allowsAttribute_closure.prototype = {
    call$1: function(v) {
      return H.interceptedTypeCheck(v, "$isNodeValidator").allowsAttribute$3(this.element, this.attributeName, this.value);
    },
    $signature: 65
  };
  W._SimpleNodeValidator.prototype = {
    _SimpleNodeValidator$4$allowedAttributes$allowedElements$allowedUriAttributes: function(uriPolicy, allowedAttributes, allowedElements, allowedUriAttributes) {
      var legalAttributes, extraUriAttributes, t1;
      this.allowedElements.addAll$1(0, allowedElements);
      legalAttributes = allowedAttributes.where$1(0, new W._SimpleNodeValidator_closure());
      extraUriAttributes = allowedAttributes.where$1(0, new W._SimpleNodeValidator_closure0());
      this.allowedAttributes.addAll$1(0, legalAttributes);
      t1 = this.allowedUriAttributes;
      t1.addAll$1(0, C.List_empty0);
      t1.addAll$1(0, extraUriAttributes);
    },
    allowsElement$1: function(element) {
      return this.allowedElements.contains$1(0, W.Element__safeTagName(element));
    },
    allowsAttribute$3: function(element, attributeName, value) {
      var _this = this,
        tagName = W.Element__safeTagName(element),
        t1 = _this.allowedUriAttributes;
      if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
        return _this.uriPolicy.allowsUri$1(value);
      else if (t1.contains$1(0, "*::" + attributeName))
        return _this.uriPolicy.allowsUri$1(value);
      else {
        t1 = _this.allowedAttributes;
        if (t1.contains$1(0, H.S(tagName) + "::" + attributeName))
          return true;
        else if (t1.contains$1(0, "*::" + attributeName))
          return true;
        else if (t1.contains$1(0, H.S(tagName) + "::*"))
          return true;
        else if (t1.contains$1(0, "*::*"))
          return true;
      }
      return false;
    },
    $isNodeValidator: 1
  };
  W._SimpleNodeValidator_closure.prototype = {
    call$1: function(x) {
      return !C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
    },
    $signature: 20
  };
  W._SimpleNodeValidator_closure0.prototype = {
    call$1: function(x) {
      return C.JSArray_methods.contains$1(C.List_yrN, H.stringTypeCheck(x));
    },
    $signature: 20
  };
  W._TemplatingNodeValidator.prototype = {
    allowsAttribute$3: function(element, attributeName, value) {
      if (this.super$_SimpleNodeValidator$allowsAttribute(element, attributeName, value))
        return true;
      if (attributeName === "template" && value === "")
        return true;
      if (element.getAttribute("template") === "")
        return this._templateAttrs.contains$1(0, attributeName);
      return false;
    }
  };
  W._TemplatingNodeValidator_closure.prototype = {
    call$1: function(attr) {
      return "TEMPLATE::" + H.S(H.stringTypeCheck(attr));
    },
    $signature: 5
  };
  W._SvgNodeValidator.prototype = {
    allowsElement$1: function(element) {
      var t1 = J.getInterceptor$(element);
      if (!!t1.$isScriptElement)
        return false;
      t1 = !!t1.$isSvgElement;
      if (t1 && W.Element__safeTagName(element) === "foreignObject")
        return false;
      if (t1)
        return true;
      return false;
    },
    allowsAttribute$3: function(element, attributeName, value) {
      if (attributeName === "is" || C.JSString_methods.startsWith$1(attributeName, "on"))
        return false;
      return this.allowsElement$1(element);
    },
    $isNodeValidator: 1
  };
  W.FixedSizeListIterator.prototype = {
    moveNext$0: function() {
      var _this = this,
        nextPosition = _this._position + 1,
        t1 = _this._html$_length;
      if (nextPosition < t1) {
        _this.set$_html$_current(J.$index$asx(_this._array, nextPosition));
        _this._position = nextPosition;
        return true;
      }
      _this.set$_html$_current(null);
      _this._position = t1;
      return false;
    },
    get$current: function(_) {
      return this._html$_current;
    },
    set$_html$_current: function(_current) {
      this._html$_current = H.assertSubtypeOfRuntimeType(_current, H.getTypeArgumentByIndex(this, 0));
    },
    $isIterator: 1
  };
  W._DOMWindowCrossFrame.prototype = {$isEventTarget: 1, $isWindowBase: 1};
  W.NodeValidator.prototype = {};
  W._SameOriginUriPolicy.prototype = {$isUriPolicy: 1};
  W._ValidatingTreeSanitizer.prototype = {
    sanitizeTree$1: function(node) {
      new W._ValidatingTreeSanitizer_sanitizeTree_walk(this).call$2(node, null);
    },
    _removeNode$2: function(node, $parent) {
      if ($parent == null)
        J.remove$0$ax(node);
      else
        $parent.removeChild(node);
    },
    _sanitizeUntrustedElement$2: function(element, $parent) {
      var corruptedTest1, elementText, elementTagName, exception, t1,
        corrupted = true,
        attrs = null, isAttr = null;
      try {
        attrs = J.get$attributes$x(element);
        isAttr = attrs._element.getAttribute("is");
        H.interceptedTypeCheck(element, "$isElement");
        corruptedTest1 = function(element) {
          if (!(element.attributes instanceof NamedNodeMap))
            return true;
          var childNodes = element.childNodes;
          if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1])
            return true;
          if (element.children)
            if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList))
              return true;
          var length = 0;
          if (element.children)
            length = element.children.length;
          for (var i = 0; i < length; i++) {
            var child = element.children[i];
            if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children')
              return true;
          }
          return false;
        }(element);
        corrupted = H.boolConversionCheck(corruptedTest1) ? true : !(element.attributes instanceof NamedNodeMap);
      } catch (exception) {
        H.unwrapException(exception);
      }
      elementText = "element unprintable";
      try {
        elementText = J.toString$0$(element);
      } catch (exception) {
        H.unwrapException(exception);
      }
      try {
        elementTagName = W.Element__safeTagName(element);
        this._sanitizeElement$7(H.interceptedTypeCheck(element, "$isElement"), $parent, corrupted, elementText, elementTagName, H.interceptedTypeCheck(attrs, "$isMap"), H.stringTypeCheck(isAttr));
      } catch (exception) {
        if (H.unwrapException(exception) instanceof P.ArgumentError)
          throw exception;
        else {
          this._removeNode$2(element, $parent);
          window;
          t1 = "Removing corrupted element " + H.S(elementText);
          if (typeof console != "undefined")
            window.console.warn(t1);
        }
      }
    },
    _sanitizeElement$7: function(element, $parent, corrupted, text, tag, attrs, isAttr) {
      var t1, keys, i, $name, t2, t3, _this = this;
      if (corrupted) {
        _this._removeNode$2(element, $parent);
        window;
        t1 = "Removing element due to corrupted attributes on <" + text + ">";
        if (typeof console != "undefined")
          window.console.warn(t1);
        return;
      }
      if (!_this.validator.allowsElement$1(element)) {
        _this._removeNode$2(element, $parent);
        window;
        t1 = "Removing disallowed element <" + H.S(tag) + "> from " + H.S($parent);
        if (typeof console != "undefined")
          window.console.warn(t1);
        return;
      }
      if (isAttr != null)
        if (!_this.validator.allowsAttribute$3(element, "is", isAttr)) {
          _this._removeNode$2(element, $parent);
          window;
          t1 = "Removing disallowed type extension <" + H.S(tag) + ' is="' + isAttr + '">';
          if (typeof console != "undefined")
            window.console.warn(t1);
          return;
        }
      t1 = attrs.get$keys(attrs);
      keys = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      for (i = attrs.get$keys(attrs).length - 1, t1 = attrs._element; i >= 0; --i) {
        if (i >= keys.length)
          return H.ioore(keys, i);
        $name = keys[i];
        t2 = _this.validator;
        t3 = J.toLowerCase$0$s($name);
        H.stringTypeCheck($name);
        if (!t2.allowsAttribute$3(element, t3, t1.getAttribute($name))) {
          window;
          t2 = "Removing disallowed attribute <" + H.S(tag) + " " + $name + '="' + H.S(t1.getAttribute($name)) + '">';
          if (typeof console != "undefined")
            window.console.warn(t2);
          t1.removeAttribute($name);
        }
      }
      if (!!J.getInterceptor$(element).$isTemplateElement)
        _this.sanitizeTree$1(element.content);
    },
    $isNodeTreeSanitizer: 1
  };
  W._ValidatingTreeSanitizer_sanitizeTree_walk.prototype = {
    call$2: function(node, $parent) {
      var child, nextChild, exception, t2, t3,
        t1 = this.$this;
      switch (node.nodeType) {
        case 1:
          t1._sanitizeUntrustedElement$2(node, $parent);
          break;
        case 8:
        case 11:
        case 3:
        case 4:
          break;
        default:
          t1._removeNode$2(node, $parent);
      }
      child = node.lastChild;
      for (t1 = node == null; null != child;) {
        nextChild = null;
        try {
          nextChild = child.previousSibling;
        } catch (exception) {
          H.unwrapException(exception);
          t2 = H.interceptedTypeCheck(child, "$isNode");
          if (t1) {
            t3 = t2.parentNode;
            if (t3 != null)
              t3.removeChild(t2);
          } else
            node.removeChild(t2);
          child = null;
          nextChild = node.lastChild;
        }
        if (child != null)
          this.call$2(child, node);
        child = H.interceptedTypeCheck(nextChild, "$isNode");
      }
    },
    $signature: 227
  };
  W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase.prototype = {};
  W._DomRectList_Interceptor_ListMixin.prototype = {};
  W._DomRectList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._DomStringList_Interceptor_ListMixin.prototype = {};
  W._DomStringList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._FileList_Interceptor_ListMixin.prototype = {};
  W._FileList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._HtmlCollection_Interceptor_ListMixin.prototype = {};
  W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._MidiInputMap_Interceptor_MapMixin.prototype = {};
  W._MidiOutputMap_Interceptor_MapMixin.prototype = {};
  W._MimeTypeArray_Interceptor_ListMixin.prototype = {};
  W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._NodeList_Interceptor_ListMixin.prototype = {};
  W._NodeList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._PluginArray_Interceptor_ListMixin.prototype = {};
  W._PluginArray_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._RtcStatsReport_Interceptor_MapMixin.prototype = {};
  W._SourceBufferList_EventTarget_ListMixin.prototype = {};
  W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin.prototype = {};
  W._SpeechGrammarList_Interceptor_ListMixin.prototype = {};
  W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._Storage_Interceptor_MapMixin.prototype = {};
  W._TextTrackCueList_Interceptor_ListMixin.prototype = {};
  W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W._TextTrackList_EventTarget_ListMixin.prototype = {};
  W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin.prototype = {};
  W._TouchList_Interceptor_ListMixin.prototype = {};
  W._TouchList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__CssRuleList_Interceptor_ListMixin.prototype = {};
  W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__GamepadList_Interceptor_ListMixin.prototype = {};
  W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__NamedNodeMap_Interceptor_ListMixin.prototype = {};
  W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__SpeechRecognitionResultList_Interceptor_ListMixin.prototype = {};
  W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  W.__StyleSheetList_Interceptor_ListMixin.prototype = {};
  W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._StructuredClone.prototype = {
    findSlot$1: function(value) {
      var i,
        t1 = this.values,
        $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      C.JSArray_methods.add$1(t1, value);
      C.JSArray_methods.add$1(this.copies, null);
      return $length;
    },
    walk$1: function(e) {
      var t2, slot, t3, copy, _this = this, t1 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      t2 = J.getInterceptor$(e);
      if (!!t2.$isDateTime)
        return new Date(e._value);
      if (!!t2.$isRegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (!!t2.$isFile)
        return e;
      if (!!t2.$isBlob)
        return e;
      if (!!t2.$isFileList)
        return e;
      if (!!t2.$isImageData)
        return e;
      if (!!t2.$isNativeByteBuffer || !!t2.$isNativeTypedData || !!t2.$isMessagePort)
        return e;
      if (!!t2.$isMap) {
        slot = _this.findSlot$1(e);
        t3 = _this.copies;
        if (slot >= t3.length)
          return H.ioore(t3, slot);
        copy = t1.copy = t3[slot];
        if (copy != null)
          return copy;
        copy = {};
        t1.copy = copy;
        C.JSArray_methods.$indexSet(t3, slot, copy);
        t2.forEach$1(e, new P._StructuredClone_walk_closure(t1, _this));
        return t1.copy;
      }
      if (!!t2.$isList) {
        slot = _this.findSlot$1(e);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = t1[slot];
        if (copy != null)
          return copy;
        return _this.copyList$2(e, slot);
      }
      throw H.wrapException(P.UnimplementedError$("structured clone of other type"));
    },
    copyList$2: function(e, slot) {
      var i,
        t1 = J.getInterceptor$asx(e),
        $length = t1.get$length(e),
        copy = new Array($length);
      C.JSArray_methods.$indexSet(this.copies, slot, copy);
      if (typeof $length !== "number")
        return H.iae($length);
      i = 0;
      for (; i < $length; ++i)
        C.JSArray_methods.$indexSet(copy, i, this.walk$1(t1.$index(e, i)));
      return copy;
    }
  };
  P._StructuredClone_walk_closure.prototype = {
    call$2: function(key, value) {
      this._box_0.copy[key] = this.$this.walk$1(value);
    },
    $signature: 12
  };
  P._AcceptStructuredClone.prototype = {
    findSlot$1: function(value) {
      var i,
        t1 = this.values,
        $length = t1.length;
      for (i = 0; i < $length; ++i)
        if (t1[i] === value)
          return i;
      C.JSArray_methods.add$1(t1, value);
      C.JSArray_methods.add$1(this.copies, null);
      return $length;
    },
    walk$1: function(e) {
      var millisSinceEpoch, t1, proto, slot, copy, l, t2, $length, i, _this = this, _box_0 = {};
      if (e == null)
        return e;
      if (typeof e === "boolean")
        return e;
      if (typeof e === "number")
        return e;
      if (typeof e === "string")
        return e;
      if (e instanceof Date) {
        millisSinceEpoch = e.getTime();
        t1 = new P.DateTime(millisSinceEpoch, true);
        t1.DateTime$_withValue$2$isUtc(millisSinceEpoch, true);
        return t1;
      }
      if (e instanceof RegExp)
        throw H.wrapException(P.UnimplementedError$("structured clone of RegExp"));
      if (typeof Promise != "undefined" && e instanceof Promise)
        return P.convertNativePromiseToDartFuture(e);
      proto = Object.getPrototypeOf(e);
      if (proto === Object.prototype || proto === null) {
        slot = _this.findSlot$1(e);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = _box_0.copy = t1[slot];
        if (copy != null)
          return copy;
        copy = P.LinkedHashMap__makeEmpty();
        _box_0.copy = copy;
        C.JSArray_methods.$indexSet(t1, slot, copy);
        _this.forEachJsField$2(e, new P._AcceptStructuredClone_walk_closure(_box_0, _this));
        return _box_0.copy;
      }
      if (e instanceof Array) {
        l = e;
        slot = _this.findSlot$1(l);
        t1 = _this.copies;
        if (slot >= t1.length)
          return H.ioore(t1, slot);
        copy = t1[slot];
        if (copy != null)
          return copy;
        t2 = J.getInterceptor$asx(l);
        $length = t2.get$length(l);
        copy = _this.mustCopy ? new Array($length) : l;
        C.JSArray_methods.$indexSet(t1, slot, copy);
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = J.getInterceptor$ax(copy);
        i = 0;
        for (; i < $length; ++i)
          t1.$indexSet(copy, i, _this.walk$1(t2.$index(l, i)));
        return copy;
      }
      return e;
    },
    convertNativeToDart_AcceptStructuredClone$2$mustCopy: function(object, mustCopy) {
      this.mustCopy = mustCopy;
      return this.walk$1(object);
    }
  };
  P._AcceptStructuredClone_walk_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this._box_0.copy,
        t2 = this.$this.walk$1(value);
      J.$indexSet$ax(t1, key, t2);
      return t2;
    },
    $signature: 101
  };
  P.convertDartToNative_Dictionary_closure.prototype = {
    call$2: function(key, value) {
      this.object[key] = value;
    },
    $signature: 12
  };
  P._StructuredCloneDart2Js.prototype = {};
  P._AcceptStructuredCloneDart2Js.prototype = {
    forEachJsField$2: function(object, action) {
      var t1, t2, _i, key;
      H.functionTypeCheck(action, {func: 1, args: [,,]});
      for (t1 = Object.keys(object), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        key = t1[_i];
        action.call$2(key, object[key]);
      }
    }
  };
  P.convertNativePromiseToDartFuture_closure.prototype = {
    call$1: function(result) {
      return this.completer.complete$1(0, result);
    },
    $signature: 7
  };
  P.convertNativePromiseToDartFuture_closure0.prototype = {
    call$1: function(result) {
      return this.completer.completeError$1(result);
    },
    $signature: 7
  };
  P.CssClassSetImpl.prototype = {
    _validateToken$1: function(value) {
      var t1;
      H.stringTypeCheck(value);
      t1 = $.$get$CssClassSetImpl__validTokenRE()._nativeRegExp;
      if (typeof value !== "string")
        H.throwExpression(H.argumentErrorValue(value));
      if (t1.test(value))
        return value;
      throw H.wrapException(P.ArgumentError$value(value, "value", "Not a valid class token"));
    },
    toString$0: function(_) {
      return this.readClasses$0().join$1(0, " ");
    },
    toggle$2: function(_, value, shouldAdd) {
      var s, result;
      this._validateToken$1(value);
      s = this.readClasses$0();
      if (shouldAdd == null ? !s.contains$1(0, value) : shouldAdd) {
        s.add$1(0, value);
        result = true;
      } else {
        s.remove$1(0, value);
        result = false;
      }
      this.writeClasses$1(s);
      return result;
    },
    get$iterator: function(_) {
      var t1 = this.readClasses$0();
      return P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0));
    },
    forEach$1: function(_, f) {
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String]});
      this.readClasses$0().forEach$1(0, f);
    },
    join$1: function(_, separator) {
      return this.readClasses$0().join$1(0, separator);
    },
    map$1$1: function(_, f, $T) {
      var t1, t2;
      H.functionTypeCheck(f, {func: 1, ret: $T, args: [P.String]});
      t1 = this.readClasses$0();
      t2 = H.getTypeArgumentByIndex(t1, 0);
      return new H.EfficientLengthMappedIterable(t1, H.functionTypeCheck(f, {func: 1, ret: $T, args: [t2]}), [t2, $T]);
    },
    map$1: function($receiver, f) {
      return this.map$1$1($receiver, f, null);
    },
    get$isEmpty: function(_) {
      return this.readClasses$0()._collection$_length === 0;
    },
    get$isNotEmpty: function(_) {
      return this.readClasses$0()._collection$_length !== 0;
    },
    get$length: function(_) {
      return this.readClasses$0()._collection$_length;
    },
    contains$1: function(_, value) {
      if (typeof value !== "string")
        return false;
      this._validateToken$1(value);
      return this.readClasses$0().contains$1(0, value);
    },
    add$1: function(_, value) {
      H.stringTypeCheck(value);
      this._validateToken$1(value);
      return H.boolTypeCheck(this.modify$1(0, new P.CssClassSetImpl_add_closure(value)));
    },
    remove$1: function(_, value) {
      var s, result;
      H.stringTypeCheck(value);
      this._validateToken$1(value);
      s = this.readClasses$0();
      result = s.remove$1(0, value);
      this.writeClasses$1(s);
      return result;
    },
    addAll$1: function(_, iterable) {
      this.modify$1(0, new P.CssClassSetImpl_addAll_closure(this, H.assertSubtype(iterable, "$isIterable", [P.String], "$asIterable")));
    },
    removeAll$1: function(iterable) {
      this.modify$1(0, new P.CssClassSetImpl_removeAll_closure(H.assertSubtype(iterable, "$isIterable", [P.Object], "$asIterable")));
    },
    removeWhere$1: function(_, test) {
      this.modify$1(0, new P.CssClassSetImpl_removeWhere_closure(H.functionTypeCheck(test, {func: 1, ret: P.bool, args: [P.String]})));
    },
    get$first: function(_) {
      var t1 = this.readClasses$0();
      return t1.get$first(t1);
    },
    get$last: function(_) {
      var t1 = this.readClasses$0();
      return t1.get$last(t1);
    },
    toList$1$growable: function(_, growable) {
      return this.readClasses$0().toList$1$growable(0, true);
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    take$1: function(_, n) {
      var t1 = this.readClasses$0();
      return H.TakeIterable_TakeIterable(t1, n, H.getTypeArgumentByIndex(t1, 0));
    },
    skip$1: function(_, n) {
      var t1 = this.readClasses$0();
      return H.SkipIterable_SkipIterable(t1, n, H.getTypeArgumentByIndex(t1, 0));
    },
    elementAt$1: function(_, index) {
      return this.readClasses$0().elementAt$1(0, index);
    },
    clear$0: function(_) {
      this.modify$1(0, new P.CssClassSetImpl_clear_closure());
    },
    modify$1: function(_, f) {
      var s, ret;
      H.functionTypeCheck(f, {func: 1, args: [[P.Set, P.String]]});
      s = this.readClasses$0();
      ret = f.call$1(s);
      this.writeClasses$1(s);
      return ret;
    },
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asSetMixin: function() {
      return [P.String];
    },
    $asIterable: function() {
      return [P.String];
    },
    $asSet: function() {
      return [P.String];
    }
  };
  P.CssClassSetImpl_add_closure.prototype = {
    call$1: function(s) {
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet").add$1(0, this.value);
    },
    $signature: 257
  };
  P.CssClassSetImpl_addAll_closure.prototype = {
    call$1: function(s) {
      var t1 = P.String;
      return H.assertSubtype(s, "$isSet", [t1], "$asSet").addAll$1(0, J.map$1$1$ax(this.iterable, this.$this.get$_validateToken(), t1));
    },
    $signature: 29
  };
  P.CssClassSetImpl_removeAll_closure.prototype = {
    call$1: function(s) {
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet").removeAll$1(this.iterable);
    },
    $signature: 29
  };
  P.CssClassSetImpl_removeWhere_closure.prototype = {
    call$1: function(s) {
      H.assertSubtype(s, "$isSet", [P.String], "$asSet");
      s._filterWhere$2(H.functionTypeCheck(this.test, {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(s, 0)]}), true);
      return;
    },
    $signature: 29
  };
  P.CssClassSetImpl_clear_closure.prototype = {
    call$1: function(s) {
      return H.assertSubtype(s, "$isSet", [P.String], "$asSet").clear$0(0);
    },
    $signature: 29
  };
  P.FilteredElementList.prototype = {
    get$_html_common$_iterable: function() {
      var t1 = this._childNodes,
        t2 = H.getRuntimeTypeArgument(t1, "ListMixin", 0),
        t3 = W.Element;
      return new H.MappedIterable(new H.WhereIterable(t1, H.functionTypeCheck(new P.FilteredElementList__iterable_closure(), {func: 1, ret: P.bool, args: [t2]}), [t2]), H.functionTypeCheck(new P.FilteredElementList__iterable_closure0(), {func: 1, ret: t3, args: [t2]}), [t2, t3]);
    },
    $indexSet: function(_, index, value) {
      var t1;
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isElement");
      t1 = this.get$_html_common$_iterable();
      J.replaceWith$1$x(t1._f.call$1(J.elementAt$1$ax(t1.__internal$_iterable, index)), value);
    },
    set$length: function(_, newLength) {
      var len = J.get$length$asx(this.get$_html_common$_iterable().__internal$_iterable);
      if (typeof len !== "number")
        return H.iae(len);
      if (newLength >= len)
        return;
      else if (newLength < 0)
        throw H.wrapException(P.ArgumentError$("Invalid list length"));
      this.removeRange$2(0, newLength, len);
    },
    add$1: function(_, value) {
      this._childNodes._this.appendChild(H.interceptedTypeCheck(value, "$isElement"));
    },
    contains$1: function(_, needle) {
      if (!J.getInterceptor$(needle).$isElement)
        return false;
      return needle.parentNode === this._node;
    },
    sort$1: function(_, compare) {
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [W.Element, W.Element]});
      throw H.wrapException(P.UnsupportedError$("Cannot sort filtered list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      H.assertSubtype(iterable, "$isIterable", [W.Element], "$asIterable");
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on filtered list"));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    removeRange$2: function(_, start, end) {
      var t1 = this.get$_html_common$_iterable();
      t1 = H.SkipIterable_SkipIterable(t1, start, H.getRuntimeTypeArgument(t1, "Iterable", 0));
      if (typeof end !== "number")
        return end.$sub();
      C.JSArray_methods.forEach$1(P.List_List$from(H.TakeIterable_TakeIterable(t1, end - start, H.getRuntimeTypeArgument(t1, "Iterable", 0)), true, null), new P.FilteredElementList_removeRange_closure());
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._childNodes._this);
    },
    removeLast$0: function(_) {
      var t1 = this.get$_html_common$_iterable(),
        result = t1._f.call$1(J.get$last$ax(t1.__internal$_iterable));
      if (result != null)
        J.remove$0$ax(result);
      return result;
    },
    insert$2: function(_, index, value) {
      var t1, element;
      H.interceptedTypeCheck(value, "$isElement");
      if (index == J.get$length$asx(this.get$_html_common$_iterable().__internal$_iterable))
        this._childNodes._this.appendChild(value);
      else {
        t1 = this.get$_html_common$_iterable();
        element = t1._f.call$1(J.elementAt$1$ax(t1.__internal$_iterable, index));
        element.parentNode.insertBefore(value, element);
      }
    },
    removeAt$1: function(_, index) {
      var t1 = this.get$_html_common$_iterable();
      t1 = t1._f.call$1(J.elementAt$1$ax(t1.__internal$_iterable, index));
      J.remove$0$ax(t1);
      return t1;
    },
    remove$1: function(_, element) {
      var t1 = J.getInterceptor$(element);
      if (!t1.$isElement)
        return false;
      if (this.contains$1(0, element)) {
        t1.remove$0(element);
        return true;
      } else
        return false;
    },
    get$length: function(_) {
      return J.get$length$asx(this.get$_html_common$_iterable().__internal$_iterable);
    },
    $index: function(_, index) {
      var t1;
      H.intTypeCheck(index);
      t1 = this.get$_html_common$_iterable();
      return t1._f.call$1(J.elementAt$1$ax(t1.__internal$_iterable, index));
    },
    get$iterator: function(_) {
      var t1 = P.List_List$from(this.get$_html_common$_iterable(), false, W.Element);
      return new J.ArrayIterator(t1, t1.length, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    $asEfficientLengthIterable: function() {
      return [W.Element];
    },
    $asListMixin: function() {
      return [W.Element];
    },
    $asIterable: function() {
      return [W.Element];
    },
    $asList: function() {
      return [W.Element];
    }
  };
  P.FilteredElementList__iterable_closure.prototype = {
    call$1: function(n) {
      return !!J.getInterceptor$(H.interceptedTypeCheck(n, "$isNode")).$isElement;
    },
    $signature: 73
  };
  P.FilteredElementList__iterable_closure0.prototype = {
    call$1: function(n) {
      return H.interceptedTypeCast(H.interceptedTypeCheck(n, "$isNode"), "$isElement");
    },
    $signature: 263
  };
  P.FilteredElementList_removeRange_closure.prototype = {
    call$1: function(el) {
      return J.remove$0$ax(el);
    },
    $signature: 4
  };
  P.Cursor.prototype = {
    get$key: function(receiver) {
      return receiver.key;
    }
  };
  P.CursorWithValue.prototype = {
    get$value: function(receiver) {
      return new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(receiver.value, false);
    }
  };
  P.Database.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  P.Index.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  P.KeyRange.prototype = {$isKeyRange: 1};
  P.ObjectStore.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  P.Observation.prototype = {
    get$key: function(receiver) {
      return receiver.key;
    },
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  P.JsObject.prototype = {
    $index: function(_, property) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      return P._convertToDart(this._jsObject[property]);
    },
    $indexSet: function(_, property, value) {
      if (typeof property !== "string" && typeof property !== "number")
        throw H.wrapException(P.ArgumentError$("property is not a String or num"));
      this._jsObject[property] = P._convertToJS(value);
    },
    get$hashCode: function(_) {
      return 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof P.JsObject && this._jsObject === other._jsObject;
    },
    toString$0: function(_) {
      var t1, exception;
      try {
        t1 = String(this._jsObject);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        t1 = this.super$Object$toString(this);
        return t1;
      }
    },
    callMethod$2: function(method, args) {
      var t1, t2;
      if (typeof method !== "string" && true)
        throw H.wrapException(P.ArgumentError$("method is not a String or num"));
      t1 = this._jsObject;
      if (args == null)
        t2 = null;
      else {
        t2 = H.getTypeArgumentByIndex(args, 0);
        t2 = P.List_List$from(new H.MappedListIterable(args, H.functionTypeCheck(P.js___convertToJS$closure(), {func: 1, ret: null, args: [t2]}), [t2, null]), true, null);
      }
      return P._convertToDart(t1[method].apply(t1, t2));
    },
    callMethod$1: function(method) {
      return this.callMethod$2(method, null);
    }
  };
  P.JsObject__convertDataTree__convert.prototype = {
    call$1: function(o) {
      var t2, convertedMap, key, convertedList,
        t1 = this._convertedObjects;
      if (t1.containsKey$1(0, o))
        return t1.$index(0, o);
      t2 = J.getInterceptor$(o);
      if (!!t2.$isMap) {
        convertedMap = {};
        t1.$indexSet(0, o, convertedMap);
        for (t1 = J.get$iterator$ax(t2.get$keys(o)); t1.moveNext$0();) {
          key = t1.get$current(t1);
          convertedMap[key] = this.call$1(t2.$index(o, key));
        }
        return convertedMap;
      } else if (!!t2.$isIterable) {
        convertedList = [];
        t1.$indexSet(0, o, convertedList);
        C.JSArray_methods.addAll$1(convertedList, t2.map$1$1(o, this, null));
        return convertedList;
      } else
        return P._convertToJS(o);
    },
    $signature: 4
  };
  P.JsFunction.prototype = {};
  P.JsArray.prototype = {
    _checkIndex$1: function(index) {
      var t1, _this = this;
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= _this.get$length(_this);
      else
        t1 = false;
      if (t1)
        throw H.wrapException(P.RangeError$range(index, 0, _this.get$length(_this), null, null));
    },
    $index: function(_, index) {
      if (typeof index === "number" && index === C.JSInt_methods.toInt$0(index))
        this._checkIndex$1(H.intTypeCheck(index));
      return H.assertSubtypeOfRuntimeType(this.super$JsObject$$index(0, index), H.getTypeArgumentByIndex(this, 0));
    },
    $indexSet: function(_, index, value) {
      H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0));
      if (typeof index === "number" && index === C.JSNumber_methods.toInt$0(index))
        this._checkIndex$1(H.intTypeCheck(index));
      this.super$JsObject$$indexSet(0, index, value);
    },
    get$length: function(_) {
      var len = this._jsObject.length;
      if (typeof len === "number" && len >>> 0 === len)
        return len;
      throw H.wrapException(P.StateError$("Bad JsArray length"));
    },
    set$length: function(_, $length) {
      this.super$JsObject$$indexSet(0, "length", $length);
    },
    add$1: function(_, value) {
      this.callMethod$2("push", [H.assertSubtypeOfRuntimeType(value, H.getTypeArgumentByIndex(this, 0))]);
    },
    insert$2: function(_, index, element) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      if (typeof index === "number" && Math.floor(index) === index)
        t1 = index < 0 || index >= _this.get$length(_this) + 1;
      else
        t1 = false;
      if (t1)
        H.throwExpression(P.RangeError$range(index, 0, _this.get$length(_this), null, null));
      _this.callMethod$2("splice", [index, 0, element]);
    },
    removeAt$1: function(_, index) {
      this._checkIndex$1(index);
      return H.assertSubtypeOfRuntimeType(J.$index$asx(this.callMethod$2("splice", [index, 1]), 0), H.getTypeArgumentByIndex(this, 0));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      var $length, args, _this = this;
      H.assertSubtype(iterable, "$isIterable", _this.$ti, "$asIterable");
      P.JsArray__checkRange(start, end, _this.get$length(_this));
      if (typeof end !== "number")
        return end.$sub();
      $length = end - start;
      if ($length === 0)
        return;
      if (skipCount < 0)
        throw H.wrapException(P.ArgumentError$(skipCount));
      args = [start, $length];
      C.JSArray_methods.addAll$1(args, J.skip$1$ax(iterable, skipCount).take$1(0, $length));
      _this.callMethod$2("splice", args);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    sort$1: function(_, compare) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.functionTypeCheck(compare, {func: 1, ret: P.int, args: [t1, t1]});
      this.callMethod$2("sort", compare == null ? [] : [compare]);
    },
    $isEfficientLengthIterable: 1,
    $isIterable: 1,
    $isList: 1
  };
  P._convertToJS_closure.prototype = {
    call$1: function(o) {
      var jsFunction;
      H.interceptedTypeCheck(o, "$isFunction");
      jsFunction = function(_call, f, captureThis) {
        return function() {
          return _call(f, captureThis, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunction, o, false);
      P._defineProperty(jsFunction, $.$get$DART_CLOSURE_PROPERTY_NAME(), o);
      return jsFunction;
    },
    $signature: 4
  };
  P._convertToJS_closure0.prototype = {
    call$1: function(o) {
      return new this.ctor(o);
    },
    $signature: 4
  };
  P._wrapToDart_closure.prototype = {
    call$1: function(o) {
      return new P.JsFunction(o);
    },
    $signature: 280
  };
  P._wrapToDart_closure0.prototype = {
    call$1: function(o) {
      return new P.JsArray(o, [null]);
    },
    $signature: 281
  };
  P._wrapToDart_closure1.prototype = {
    call$1: function(o) {
      return new P.JsObject(o);
    },
    $signature: 111
  };
  P._JsArray_JsObject_ListMixin.prototype = {};
  P._convertDataTree__convert.prototype = {
    call$1: function(o) {
      var t2, convertedMap, key, convertedList,
        t1 = this._convertedObjects;
      if (t1.containsKey$1(0, o))
        return t1.$index(0, o);
      t2 = J.getInterceptor$(o);
      if (!!t2.$isMap) {
        convertedMap = {};
        t1.$indexSet(0, o, convertedMap);
        for (t1 = J.get$iterator$ax(t2.get$keys(o)); t1.moveNext$0();) {
          key = t1.get$current(t1);
          convertedMap[key] = this.call$1(t2.$index(o, key));
        }
        return convertedMap;
      } else if (!!t2.$isIterable) {
        convertedList = [];
        t1.$indexSet(0, o, convertedList);
        C.JSArray_methods.addAll$1(convertedList, t2.map$1$1(o, this, null));
        return convertedList;
      } else
        return o;
    },
    $signature: 4
  };
  P.Point.prototype = {
    toString$0: function(_) {
      return "Point(" + H.S(this.x) + ", " + H.S(this.y) + ")";
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isPoint && this.x == other.x && this.y == other.y;
    },
    get$hashCode: function(_) {
      var hash,
        t1 = J.get$hashCode$(this.x),
        t2 = J.get$hashCode$(this.y);
      t2 = P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, t1), t2);
      hash = 536870911 & t2 + ((67108863 & t2) << 3);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15);
    },
    $add: function(_, other) {
      var t2, t3, t4, t5, _this = this,
        t1 = _this.$ti;
      H.assertSubtype(other, "$isPoint", t1, "$asPoint");
      t2 = _this.x;
      t3 = other.x;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = H.getTypeArgumentByIndex(_this, 0);
      t3 = H.assertSubtypeOfRuntimeType(t2 + t3, t4);
      t2 = _this.y;
      t5 = other.y;
      if (typeof t2 !== "number")
        return t2.$add();
      if (typeof t5 !== "number")
        return H.iae(t5);
      return new P.Point(t3, H.assertSubtypeOfRuntimeType(t2 + t5, t4), t1);
    }
  };
  P._RectangleBase.prototype = {};
  P.Rectangle.prototype = {};
  P.Angle.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    },
    get$valueAsString: function(receiver) {
      return receiver.valueAsString;
    }
  };
  P.Length.prototype = {$isLength: 1,
    get$value: function(receiver) {
      return receiver.value;
    },
    get$valueAsString: function(receiver) {
      return receiver.valueAsString;
    }
  };
  P.LengthList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isLength");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Length];
    },
    $asListMixin: function() {
      return [P.Length];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Length];
    },
    $isList: 1,
    $asList: function() {
      return [P.Length];
    },
    $asImmutableListMixin: function() {
      return [P.Length];
    }
  };
  P.Number.prototype = {$isNumber: 1,
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  P.NumberList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isNumber");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Number];
    },
    $asListMixin: function() {
      return [P.Number];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Number];
    },
    $isList: 1,
    $asList: function() {
      return [P.Number];
    },
    $asImmutableListMixin: function() {
      return [P.Number];
    }
  };
  P.PointList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.ScriptElement.prototype = {$isScriptElement: 1};
  P.StringList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.stringTypeCheck(value);
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.String];
    },
    $asListMixin: function() {
      return [P.String];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.String];
    },
    $isList: 1,
    $asList: function() {
      return [P.String];
    },
    $asImmutableListMixin: function() {
      return [P.String];
    }
  };
  P.AttributeClassSet.prototype = {
    readClasses$0: function() {
      var t1, t2, _i, trimmed,
        classname = this._svg$_element.getAttribute("class"),
        s = P.LinkedHashSet_LinkedHashSet(P.String);
      if (classname == null)
        return s;
      for (t1 = classname.split(" "), t2 = t1.length, _i = 0; _i < t2; ++_i) {
        trimmed = J.trim$0$s(t1[_i]);
        if (trimmed.length !== 0)
          s.add$1(0, trimmed);
      }
      return s;
    },
    writeClasses$1: function(s) {
      this._svg$_element.setAttribute("class", s.join$1(0, " "));
    }
  };
  P.SvgElement.prototype = {
    get$classes: function(receiver) {
      return new P.AttributeClassSet(receiver);
    },
    get$children: function(receiver) {
      return new P.FilteredElementList(receiver, new W._ChildNodeListLazy(receiver));
    },
    get$innerHtml: function(receiver) {
      var container = document.createElement("div"),
        cloned = H.interceptedTypeCheck(receiver.cloneNode(true), "$isSvgElement"),
        t1 = container.children;
      cloned.toString;
      new W._ChildrenElementList(container, t1).addAll$1(0, new P.FilteredElementList(cloned, new W._ChildNodeListLazy(cloned)));
      return container.innerHTML;
    },
    set$innerHtml: function(receiver, value) {
      this.setInnerHtml$1(receiver, value);
    },
    createFragment$3$treeSanitizer$validator: function(receiver, svg, treeSanitizer, validator) {
      var t1, html, t2, fragment, svgFragment, root;
      if (treeSanitizer == null) {
        t1 = H.setRuntimeTypeInfo([], [W.NodeValidator]);
        C.JSArray_methods.add$1(t1, W._Html5NodeValidator$(null));
        C.JSArray_methods.add$1(t1, W._TemplatingNodeValidator$());
        C.JSArray_methods.add$1(t1, new W._SvgNodeValidator());
        treeSanitizer = new W._ValidatingTreeSanitizer(new W.NodeValidatorBuilder(t1));
      }
      html = '<svg version="1.1">' + H.S(svg) + "</svg>";
      t1 = document;
      t2 = t1.body;
      fragment = (t2 && C.BodyElement_methods).createFragment$2$treeSanitizer(t2, html, treeSanitizer);
      svgFragment = t1.createDocumentFragment();
      fragment.toString;
      t1 = new W._ChildNodeListLazy(fragment);
      root = t1.get$single(t1);
      for (; t1 = root.firstChild, t1 != null;)
        svgFragment.appendChild(t1);
      return svgFragment;
    },
    click$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot invoke click SVG."));
    },
    focus$0: function(receiver) {
      return receiver.focus();
    },
    get$onBlur: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "blur", false, [W.Event]);
    },
    get$onChange: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "change", false, [W.Event]);
    },
    get$onClick: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "click", false, [W.MouseEvent]);
    },
    get$onDoubleClick: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "dblclick", false, [W.Event]);
    },
    get$onFocus: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "focus", false, [W.Event]);
    },
    get$onKeyDown: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "keydown", false, [W.KeyboardEvent]);
    },
    get$onKeyUp: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "keyup", false, [W.KeyboardEvent]);
    },
    get$onMouseDown: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mousedown", false, [W.MouseEvent]);
    },
    get$onMouseLeave: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mouseleave", false, [W.MouseEvent]);
    },
    get$onMouseMove: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mousemove", false, [W.MouseEvent]);
    },
    get$onMouseOver: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mouseover", false, [W.MouseEvent]);
    },
    get$onMouseWheel: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "mousewheel", false, [W.WheelEvent]);
    },
    get$onResize: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "resize", false, [W.Event]);
    },
    get$onScroll: function(receiver) {
      return new W._ElementEventStreamImpl(receiver, "scroll", false, [W.Event]);
    },
    $isSvgElement: 1
  };
  P.Transform.prototype = {$isTransform: 1};
  P.TransformList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return receiver.getItem(index);
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isTransform");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    clear$0: function(receiver) {
      return receiver.clear();
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.Transform];
    },
    $asListMixin: function() {
      return [P.Transform];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.Transform];
    },
    $isList: 1,
    $asList: function() {
      return [P.Transform];
    },
    $asImmutableListMixin: function() {
      return [P.Transform];
    }
  };
  P._LengthList_Interceptor_ListMixin.prototype = {};
  P._LengthList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._NumberList_Interceptor_ListMixin.prototype = {};
  P._NumberList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._StringList_Interceptor_ListMixin.prototype = {};
  P._StringList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P._TransformList_Interceptor_ListMixin.prototype = {};
  P._TransformList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  P.ByteBuffer.prototype = {};
  P.ByteData.prototype = {$isTypedData: 1};
  P.Int8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Uint8List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Uint8ClampedList.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Int16List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Uint16List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Int32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Uint32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.int];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.int];
    },
    $isList: 1,
    $asList: function() {
      return [P.int];
    },
    $isTypedData: 1
  };
  P.Float32List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    },
    $isTypedData: 1
  };
  P.Float64List.prototype = {$isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [P.double];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [P.double];
    },
    $isList: 1,
    $asList: function() {
      return [P.double];
    },
    $isTypedData: 1
  };
  P.AudioBuffer.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.AudioParam.prototype = {
    get$value: function(receiver) {
      return receiver.value;
    }
  };
  P.AudioParamMap.prototype = {
    containsKey$1: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(key)) != null;
    },
    $index: function(receiver, key) {
      return P.convertNativeToDart_Dictionary(receiver.get(H.stringTypeCheck(key)));
    },
    forEach$1: function(receiver, f) {
      var entries, entry;
      H.functionTypeCheck(f, {func: 1, ret: -1, args: [P.String,,]});
      entries = receiver.entries();
      for (; true;) {
        entry = entries.next();
        if (entry.done)
          return;
        f.call$2(entry.value[0], P.convertNativeToDart_Dictionary(entry.value[1]));
      }
    },
    get$keys: function(receiver) {
      var keys = H.setRuntimeTypeInfo([], [P.String]);
      this.forEach$1(receiver, new P.AudioParamMap_keys_closure(keys));
      return keys;
    },
    get$values: function(receiver) {
      var values = H.setRuntimeTypeInfo([], [[P.Map,,,]]);
      this.forEach$1(receiver, new P.AudioParamMap_values_closure(values));
      return values;
    },
    get$length: function(receiver) {
      return receiver.size;
    },
    get$isEmpty: function(receiver) {
      return receiver.size === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.size !== 0;
    },
    $indexSet: function(receiver, key, value) {
      H.stringTypeCheck(key);
      throw H.wrapException(P.UnsupportedError$("Not supported"));
    },
    $asMapMixin: function() {
      return [P.String, null];
    },
    $isMap: 1,
    $asMap: function() {
      return [P.String, null];
    }
  };
  P.AudioParamMap_keys_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.keys, k);
    },
    $signature: 13
  };
  P.AudioParamMap_values_closure.prototype = {
    call$2: function(k, v) {
      return C.JSArray_methods.add$1(this.values, v);
    },
    $signature: 13
  };
  P.AudioTrack.prototype = {
    get$id: function(receiver) {
      return receiver.id;
    },
    get$kind: function(receiver) {
      return receiver.kind;
    }
  };
  P.AudioTrackList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P.BaseAudioContext.prototype = {};
  P.OfflineAudioContext.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    }
  };
  P._AudioParamMap_Interceptor_MapMixin.prototype = {};
  P.ActiveInfo.prototype = {
    get$name: function(receiver) {
      return receiver.name;
    }
  };
  P.SqlError.prototype = {
    get$message: function(receiver) {
      return receiver.message;
    }
  };
  P.SqlResultSetRowList.prototype = {
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      H.intTypeCheck(index);
      if (index >>> 0 !== index || index >= receiver.length)
        throw H.wrapException(P.IndexError$(index, receiver, null, null, null));
      return P.convertNativeToDart_Dictionary(receiver.item(index));
    },
    $indexSet: function(receiver, index, value) {
      H.intTypeCheck(index);
      H.interceptedTypeCheck(value, "$isMap");
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    $isEfficientLengthIterable: 1,
    $asEfficientLengthIterable: function() {
      return [[P.Map,,,]];
    },
    $asListMixin: function() {
      return [[P.Map,,,]];
    },
    $isIterable: 1,
    $asIterable: function() {
      return [[P.Map,,,]];
    },
    $isList: 1,
    $asList: function() {
      return [[P.Map,,,]];
    },
    $asImmutableListMixin: function() {
      return [[P.Map,,,]];
    }
  };
  P._SqlResultSetRowList_Interceptor_ListMixin.prototype = {};
  P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin.prototype = {};
  X.CodeMirror.prototype = {
    getDoc$0: function() {
      var t1 = this._doc;
      return t1 == null ? this._doc = new X.Doc(H.interceptedTypeCheck(this.jsProxy.callMethod$1("getDoc"), "$isJsObject"), P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,])) : t1;
    },
    setReadOnly$1: function(value) {
      this.jsProxy.callMethod$2("setOption", ["readOnly", true]);
    },
    removeLineClass$3: function(line, where, cssClass) {
      var t1 = H.interceptedTypeCheck(this.jsProxy.callMethod$2("removeLineClass", [line, where, cssClass]), "$isJsObject");
      return new X.LineHandle(t1, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [R.JsEventListener,,]));
    },
    scrollIntoView$3$margin: function(_, line, ch, margin) {
      var _s14_ = "scrollIntoView",
        t1 = P.String,
        t2 = P.int,
        t3 = this.jsProxy;
      if (margin != null)
        t3.callMethod$2(_s14_, [P.JsObject_JsObject$jsify(P.LinkedHashMap_LinkedHashMap$_literal(["line", line, "ch", ch], t1, t2)), margin]);
      else
        t3.callMethod$2(_s14_, [P.JsObject_JsObject$jsify(P.LinkedHashMap_LinkedHashMap$_literal(["line", line, "ch", ch], t1, t2))]);
    },
    scrollIntoView$2: function($receiver, line, ch) {
      return this.scrollIntoView$3$margin($receiver, line, ch, null);
    }
  };
  X.Doc.prototype = {};
  X.Position.prototype = {
    toProxy$0: function() {
      return P.JsObject_JsObject$jsify(P.LinkedHashMap_LinkedHashMap$_literal(["line", this.line, "ch", this.ch], P.String, P.int));
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof X.Position && this.line === other.line && this.ch === other.ch;
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode((this.line << 8 | this.ch) >>> 0);
    },
    compareTo$1: function(_, other) {
      var t1, t2;
      H.interceptedTypeCheck(other, "$isPosition");
      t1 = this.line;
      t2 = other.line;
      if (t1 === t2)
        return this.ch - other.ch;
      return t1 - t2;
    },
    toString$0: function(_) {
      return "[" + this.line + ":" + this.ch + "]";
    },
    $isComparable: 1,
    $asComparable: function() {
      return [X.Position];
    }
  };
  X.LineHandle.prototype = {};
  X.ProxyHolder.prototype = {
    call$1: function(methodName) {
      return this.jsProxy.callMethod$1(H.stringTypeCheck(methodName));
    },
    onEvent$1$2$argCount: function(eventName, argCount, $T) {
      var t2, t3, _this = this,
        t1 = _this._events;
      if (!t1.containsKey$1(0, eventName))
        if (argCount === 4)
          t1.$indexSet(0, eventName, new R.JsEventListener(_this.jsProxy, eventName, new X.ProxyHolder_onEvent_closure(), argCount, [$T]));
        else if (argCount === 3)
          t1.$indexSet(0, eventName, new R.JsEventListener(_this.jsProxy, eventName, new X.ProxyHolder_onEvent_closure0(), argCount, [$T]));
        else {
          t2 = [$T];
          t3 = _this.jsProxy;
          if (argCount === 2)
            t1.$indexSet(0, eventName, new R.JsEventListener(t3, eventName, null, argCount, t2));
          else
            t1.$indexSet(0, eventName, new R.JsEventListener(t3, eventName, null, 1, t2));
        }
      t1 = t1.$index(0, eventName);
      return H.assertSubtype(t1.get$stream(t1), "$isStream", [$T], "$asStream");
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.jsProxy);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof X.ProxyHolder && J.$eq$(this.jsProxy, other.jsProxy);
    }
  };
  X.ProxyHolder_onEvent_closure.prototype = {
    call$3: function(a, b, c) {
      return a;
    },
    "call*": "call$3",
    $requiredArgCount: 3,
    $signature: 116
  };
  X.ProxyHolder_onEvent_closure0.prototype = {
    call$2: function(a, b) {
      return a;
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 101
  };
  R.JsEventListener.prototype = {
    get$stream: function(_) {
      var t1, _this = this;
      if (_this._js_utils$_controller == null)
        _this.set$_js_utils$_controller(new P._SyncBroadcastStreamController(new R.JsEventListener_stream_closure(_this), new R.JsEventListener_stream_closure0(_this), _this.$ti));
      t1 = _this._js_utils$_controller;
      t1.toString;
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    set$_js_utils$_controller: function(_controller) {
      this._js_utils$_controller = H.assertSubtype(_controller, "$isStreamController", this.$ti, "$asStreamController");
    }
  };
  R.JsEventListener_stream_closure.prototype = {
    call$0: function() {
      var t3, t4, _s2_ = "on",
        t1 = this.$this,
        t2 = t1.argCount;
      if (t2 === 4)
        t1._callback = H.interceptedTypeCheck(t1._proxy.callMethod$2(_s2_, [t1._js_utils$_name, new R.JsEventListener_stream__closure(t1)]), "$isJsFunction");
      else if (t2 === 3)
        t1._callback = H.interceptedTypeCheck(t1._proxy.callMethod$2(_s2_, [t1._js_utils$_name, new R.JsEventListener_stream__closure0(t1)]), "$isJsFunction");
      else {
        t3 = t1._proxy;
        t4 = t1._js_utils$_name;
        if (t2 === 2)
          t1._callback = H.interceptedTypeCheck(t3.callMethod$2(_s2_, [t4, new R.JsEventListener_stream__closure1(t1)]), "$isJsFunction");
        else
          t1._callback = H.interceptedTypeCheck(t3.callMethod$2(_s2_, [t4, new R.JsEventListener_stream__closure2(t1)]), "$isJsFunction");
      }
    },
    $signature: 0
  };
  R.JsEventListener_stream__closure.prototype = {
    call$4: function(obj, a, b, c) {
      var t1 = this.$this,
        t2 = t1._js_utils$_controller,
        t3 = t1.cvtEvent;
      t3 = t3 == null ? a : t3.call$3(a, b, c);
      t2.add$1(0, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
    },
    "call*": "call$4",
    $requiredArgCount: 4,
    $signature: 118
  };
  R.JsEventListener_stream__closure0.prototype = {
    call$3: function(obj, a, b) {
      var t1 = this.$this,
        t2 = t1._js_utils$_controller,
        t3 = t1.cvtEvent;
      t3 = t3 == null ? a : t3.call$2(a, b);
      t2.add$1(0, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
    },
    "call*": "call$3",
    $requiredArgCount: 3,
    $signature: 120
  };
  R.JsEventListener_stream__closure1.prototype = {
    call$2: function(obj, a) {
      var t1 = this.$this,
        t2 = t1._js_utils$_controller,
        t3 = t1.cvtEvent;
      t3 = t3 == null ? a : t3.call$1(a);
      t2.add$1(0, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 12
  };
  R.JsEventListener_stream__closure2.prototype = {
    call$1: function(obj) {
      var t1 = this.$this,
        t2 = t1._js_utils$_controller,
        t3 = t1.cvtEvent;
      t3 = t3 == null ? null : t3.call$1(obj);
      t2.add$1(0, H.assertSubtypeOfRuntimeType(t3, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: 2
  };
  R.JsEventListener_stream_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._proxy.callMethod$2("off", [t1._js_utils$_name, t1._callback]);
      t1._callback = null;
    },
    $signature: 0
  };
  M.CanonicalizedMap.prototype = {
    $index: function(_, key) {
      var pair, _this = this;
      if (!_this._isValidKey$1(key))
        return;
      pair = _this._base.$index(0, _this._canonicalize.call$1(H.subtypeOfRuntimeTypeCast(key, H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1))));
      return pair == null ? null : pair.last;
    },
    $indexSet: function(_, key, value) {
      var t2, _this = this,
        t1 = H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1);
      H.assertSubtypeOfRuntimeType(key, t1);
      t2 = H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 2);
      H.assertSubtypeOfRuntimeType(value, t2);
      if (!_this._isValidKey$1(key))
        return;
      _this._base.$indexSet(0, _this._canonicalize.call$1(key), new B.Pair(key, value, [t1, t2]));
    },
    addAll$1: function(_, other) {
      H.assertSubtype(other, "$isMap", [H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2)], "$asMap").forEach$1(0, new M.CanonicalizedMap_addAll_closure(this));
    },
    containsKey$1: function(_, key) {
      var _this = this;
      if (!_this._isValidKey$1(key))
        return false;
      return _this._base.containsKey$1(0, _this._canonicalize.call$1(H.subtypeOfRuntimeTypeCast(key, H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1))));
    },
    get$entries: function(_) {
      var _this = this,
        t1 = _this._base;
      return t1.get$entries(t1).map$1$1(0, new M.CanonicalizedMap_entries_closure(_this), [P.MapEntry, H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 2)]);
    },
    forEach$1: function(_, f) {
      var _this = this;
      _this._base.forEach$1(0, new M.CanonicalizedMap_forEach_closure(_this, H.functionTypeCheck(f, {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 2)]})));
    },
    get$isEmpty: function(_) {
      var t1 = this._base;
      return t1.get$isEmpty(t1);
    },
    get$isNotEmpty: function(_) {
      var t1 = this._base;
      return t1.get$isNotEmpty(t1);
    },
    get$keys: function(_) {
      var t2, t3,
        t1 = this._base;
      t1 = t1.get$values(t1);
      t2 = H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1);
      t3 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
      return H.MappedIterable_MappedIterable(t1, H.functionTypeCheck(new M.CanonicalizedMap_keys_closure(this), {func: 1, ret: t2, args: [t3]}), t3, t2);
    },
    get$length: function(_) {
      var t1 = this._base;
      return t1.get$length(t1);
    },
    map$2$1: function(_, transform, K2, V2) {
      var _this = this,
        t1 = _this._base;
      return t1.map$2$1(t1, new M.CanonicalizedMap_map_closure(_this, H.functionTypeCheck(transform, {func: 1, ret: [P.MapEntry, K2, V2], args: [H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(_this, "CanonicalizedMap", 2)]}), K2, V2), K2, V2);
    },
    map$1: function($receiver, transform) {
      return this.map$2$1($receiver, transform, null, null);
    },
    get$values: function(_) {
      var t2, t3,
        t1 = this._base;
      t1 = t1.get$values(t1);
      t2 = H.getRuntimeTypeArgument(this, "CanonicalizedMap", 2);
      t3 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
      return H.MappedIterable_MappedIterable(t1, H.functionTypeCheck(new M.CanonicalizedMap_values_closure(this), {func: 1, ret: t2, args: [t3]}), t3, t2);
    },
    toString$0: function(_) {
      var result, _this = this, t1 = {};
      if (M._isToStringVisiting0(_this))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        C.JSArray_methods.add$1($._toStringVisiting0, _this);
        result._contents += "{";
        t1.first = true;
        _this.forEach$1(0, new M.CanonicalizedMap_toString_closure(t1, _this, result));
        result._contents += "}";
      } finally {
        if (0 >= $._toStringVisiting0.length)
          return H.ioore($._toStringVisiting0, -1);
        $._toStringVisiting0.pop();
      }
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isValidKey$1: function(key) {
      var t1;
      if (key == null || H.checkSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(this, "CanonicalizedMap", 1)))
        t1 = H.boolConversionCheck(this._isValidKeyFn.call$1(key));
      else
        t1 = false;
      return t1;
    },
    $isMap: 1,
    $asMap: function($C, $K, $V) {
      return [$K, $V];
    }
  };
  M.CanonicalizedMap_addAll_closure.prototype = {
    call$2: function(key, value) {
      var t1 = this.$this;
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1));
      H.assertSubtypeOfRuntimeType(value, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2));
      t1.$indexSet(0, key, value);
      return value;
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2);
      return {func: 1, ret: t2, args: [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), t2]};
    }
  };
  M.CanonicalizedMap_entries_closure.prototype = {
    call$1: function(e) {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1),
        t3 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2);
      t1 = H.assertSubtype(e, "$isMapEntry", [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0), [B.Pair, t2, t3]], "$asMapEntry").value;
      return new P.MapEntry(t1.first, t1.last, [t2, t3]);
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1),
        t3 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2);
      return {func: 1, ret: [P.MapEntry, t2, t3], args: [[P.MapEntry, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0), [B.Pair, t2, t3]]]};
    }
  };
  M.CanonicalizedMap_forEach_closure.prototype = {
    call$2: function(key, pair) {
      var t1 = this.$this;
      H.assertSubtypeOfRuntimeType(key, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0));
      H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)], "$asPair");
      return this.f.call$2(pair.first, pair.last);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: -1, args: [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0), [B.Pair, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)]]};
    }
  };
  M.CanonicalizedMap_keys_closure.prototype = {
    call$1: function(pair) {
      var t1 = this.$this;
      return H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)], "$asPair").first;
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1);
      return {func: 1, ret: t2, args: [[B.Pair, t2, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)]]};
    }
  };
  M.CanonicalizedMap_map_closure.prototype = {
    call$2: function(_, pair) {
      var t1 = this.$this;
      H.assertSubtypeOfRuntimeType(_, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0));
      H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)], "$asPair");
      return this.transform.call$2(pair.first, pair.last);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: [P.MapEntry, this.K2, this.V2], args: [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 0), [B.Pair, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)]]};
    }
  };
  M.CanonicalizedMap_values_closure.prototype = {
    call$1: function(pair) {
      var t1 = this.$this;
      return H.assertSubtype(pair, "$isPair", [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)], "$asPair").last;
    },
    $signature: function() {
      var t1 = this.$this,
        t2 = H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2);
      return {func: 1, ret: t2, args: [[B.Pair, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), t2]]};
    }
  };
  M.CanonicalizedMap_toString_closure.prototype = {
    call$2: function(k, v) {
      var _this = this,
        t1 = _this.$this;
      H.assertSubtypeOfRuntimeType(k, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1));
      H.assertSubtypeOfRuntimeType(v, H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2));
      t1 = _this._box_0;
      if (!t1.first)
        _this.result._contents += ", ";
      t1.first = false;
      _this.result._contents += H.S(k) + ": " + H.S(v);
    },
    $signature: function() {
      var t1 = this.$this;
      return {func: 1, ret: P.Null, args: [H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 1), H.getRuntimeTypeArgument(t1, "CanonicalizedMap", 2)]};
    }
  };
  M._isToStringVisiting_closure.prototype = {
    call$1: function(e) {
      return this.o === e;
    },
    $signature: 11
  };
  U.DefaultEquality.prototype = {
    equals$2: function(e1, e2) {
      return J.$eq$(e1, e2);
    },
    hash$1: function(_, e) {
      return J.get$hashCode$(e);
    },
    $isEquality: 1
  };
  U.IterableEquality.prototype = {
    equals$2: function(elements1, elements2) {
      var it1, it2, hasNext,
        t1 = this.$ti;
      H.assertSubtype(elements1, "$isIterable", t1, "$asIterable");
      H.assertSubtype(elements2, "$isIterable", t1, "$asIterable");
      if (elements1 === elements2)
        return true;
      it1 = J.get$iterator$ax(elements1);
      it2 = J.get$iterator$ax(elements2);
      for (t1 = this._elementEquality; true;) {
        hasNext = it1.moveNext$0();
        if (hasNext !== it2.moveNext$0())
          return false;
        if (!hasNext)
          return true;
        if (!t1.equals$2(it1.get$current(it1), it2.get$current(it2)))
          return false;
      }
    },
    hash$1: function(_, elements) {
      var t1, t2, hash;
      H.assertSubtype(elements, "$isIterable", this.$ti, "$asIterable");
      for (t1 = J.get$iterator$ax(elements), t2 = this._elementEquality, hash = 0; t1.moveNext$0();) {
        hash = hash + t2.hash$1(0, t1.get$current(t1)) & 2147483647;
        hash = hash + (hash << 10 >>> 0) & 2147483647;
        hash ^= hash >>> 6;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1,
    $asEquality: function($E) {
      return [[P.Iterable, $E]];
    }
  };
  U.ListEquality.prototype = {
    equals$2: function(list1, list2) {
      var $length, t2, t3, i,
        t1 = this.$ti;
      H.assertSubtype(list1, "$isList", t1, "$asList");
      H.assertSubtype(list2, "$isList", t1, "$asList");
      if (list1 === list2)
        return true;
      t1 = J.getInterceptor$asx(list1);
      $length = t1.get$length(list1);
      t2 = J.getInterceptor$asx(list2);
      if ($length != t2.get$length(list2))
        return false;
      if (typeof $length !== "number")
        return H.iae($length);
      t3 = this._elementEquality;
      i = 0;
      for (; i < $length; ++i)
        if (!t3.equals$2(t1.$index(list1, i), t2.$index(list2, i)))
          return false;
      return true;
    },
    hash$1: function(_, list) {
      var t1, t2, hash, i, t3;
      H.assertSubtype(list, "$isList", this.$ti, "$asList");
      t1 = J.getInterceptor$asx(list);
      t2 = this._elementEquality;
      hash = 0;
      i = 0;
      while (true) {
        t3 = t1.get$length(list);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        hash = hash + t2.hash$1(0, t1.$index(list, i)) & 2147483647;
        hash = hash + (hash << 10 >>> 0) & 2147483647;
        hash ^= hash >>> 6;
        ++i;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1,
    $asEquality: function($E) {
      return [[P.List, $E]];
    }
  };
  U._UnorderedEquality.prototype = {
    equals$2: function(elements1, elements2) {
      var counts, $length, e, count,
        t1 = H.getRuntimeTypeArgument(this, "_UnorderedEquality", 1);
      H.assertSubtypeOfRuntimeType(elements1, t1);
      H.assertSubtypeOfRuntimeType(elements2, t1);
      if (elements1 === elements2)
        return true;
      t1 = this._elementEquality;
      counts = P.HashMap_HashMap(t1.get$equals(), t1.get$hash(t1), t1.get$isValidKey(), H.getRuntimeTypeArgument(this, "_UnorderedEquality", 0), P.int);
      for (t1 = J.get$iterator$ax(elements1), $length = 0; t1.moveNext$0();) {
        e = t1.get$current(t1);
        count = counts.$index(0, e);
        counts.$indexSet(0, e, (count == null ? 0 : count) + 1);
        ++$length;
      }
      for (t1 = J.get$iterator$ax(elements2); t1.moveNext$0();) {
        e = t1.get$current(t1);
        count = counts.$index(0, e);
        if (count == null || count === 0)
          return false;
        if (typeof count !== "number")
          return count.$sub();
        counts.$indexSet(0, e, count - 1);
        --$length;
      }
      return $length === 0;
    },
    hash$1: function(_, elements) {
      var t1, t2, hash;
      H.assertSubtypeOfRuntimeType(elements, H.getRuntimeTypeArgument(this, "_UnorderedEquality", 1));
      for (t1 = J.get$iterator$ax(elements), t2 = this._elementEquality, hash = 0; t1.moveNext$0();)
        hash = hash + t2.hash$1(0, t1.get$current(t1)) & 2147483647;
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1,
    $asEquality: function($E, $T) {
      return [$T];
    }
  };
  U.SetEquality.prototype = {
    $asEquality: function($E) {
      return [[P.Set, $E]];
    },
    $as_UnorderedEquality: function($E) {
      return [$E, [P.Set, $E]];
    }
  };
  U._MapEntry.prototype = {
    get$hashCode: function(_) {
      var t1 = this.equality;
      return 3 * t1._keyEquality.hash$1(0, this.key) + 7 * t1._valueEquality.hash$1(0, this.value) & 2147483647;
    },
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      if (other instanceof U._MapEntry) {
        t1 = this.equality;
        t1 = t1._keyEquality.equals$2(this.key, other.key) && t1._valueEquality.equals$2(this.value, other.value);
      } else
        t1 = false;
      return t1;
    },
    get$key: function(receiver) {
      return this.key;
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  U.MapEquality.prototype = {
    equals$2: function(map1, map2) {
      var t2, equalElementCounts, t3, key, entry, count,
        t1 = this.$ti;
      H.assertSubtype(map1, "$isMap", t1, "$asMap");
      H.assertSubtype(map2, "$isMap", t1, "$asMap");
      if (map1 === map2)
        return true;
      t1 = J.getInterceptor$asx(map1);
      t2 = J.getInterceptor$asx(map2);
      if (t1.get$length(map1) != t2.get$length(map2))
        return false;
      equalElementCounts = P.HashMap_HashMap(null, null, null, U._MapEntry, P.int);
      for (t3 = J.get$iterator$ax(t1.get$keys(map1)); t3.moveNext$0();) {
        key = t3.get$current(t3);
        entry = new U._MapEntry(this, key, t1.$index(map1, key));
        count = equalElementCounts.$index(0, entry);
        equalElementCounts.$indexSet(0, entry, (count == null ? 0 : count) + 1);
      }
      for (t1 = J.get$iterator$ax(t2.get$keys(map2)); t1.moveNext$0();) {
        key = t1.get$current(t1);
        entry = new U._MapEntry(this, key, t2.$index(map2, key));
        count = equalElementCounts.$index(0, entry);
        if (count == null || count === 0)
          return false;
        if (typeof count !== "number")
          return count.$sub();
        equalElementCounts.$indexSet(0, entry, count - 1);
      }
      return true;
    },
    hash$1: function(_, map) {
      var t1, t2, t3, t4, hash, key;
      H.assertSubtype(map, "$isMap", this.$ti, "$asMap");
      for (t1 = J.getInterceptor$x(map), t2 = J.get$iterator$ax(t1.get$keys(map)), t3 = this._keyEquality, t4 = this._valueEquality, hash = 0; t2.moveNext$0();) {
        key = t2.get$current(t2);
        hash = hash + 3 * t3.hash$1(0, key) + 7 * t4.hash$1(0, t1.$index(map, key)) & 2147483647;
      }
      hash = hash + (hash << 3 >>> 0) & 2147483647;
      hash ^= hash >>> 11;
      return hash + (hash << 15 >>> 0) & 2147483647;
    },
    $isEquality: 1,
    $asEquality: function($K, $V) {
      return [[P.Map, $K, $V]];
    }
  };
  U.DeepCollectionEquality.prototype = {
    equals$2: function(e1, e2) {
      var _this = this,
        t1 = J.getInterceptor$(e1);
      if (!!t1.$isSet)
        return !!J.getInterceptor$(e2).$isSet && new U.SetEquality(_this, [null]).equals$2(e1, e2);
      if (!!t1.$isMap)
        return !!J.getInterceptor$(e2).$isMap && new U.MapEquality(_this, _this, [null, null]).equals$2(e1, e2);
      if (!!t1.$isList)
        return !!J.getInterceptor$(e2).$isList && new U.ListEquality(_this, [null]).equals$2(e1, e2);
      if (!!t1.$isIterable)
        return !!J.getInterceptor$(e2).$isIterable && H.boolConversionCheck(new U.IterableEquality(_this, [null]).equals$2(e1, e2));
      return t1.$eq(e1, e2);
    },
    hash$1: function(_, o) {
      var _this = this,
        t1 = J.getInterceptor$(o);
      if (!!t1.$isSet)
        return new U.SetEquality(_this, [null]).hash$1(0, o);
      if (!!t1.$isMap)
        return new U.MapEquality(_this, _this, [null, null]).hash$1(0, o);
      if (!!t1.$isList)
        return new U.ListEquality(_this, [null]).hash$1(0, o);
      if (!!t1.$isIterable)
        return new U.IterableEquality(_this, [null]).hash$1(0, o);
      return t1.get$hashCode(o);
    },
    isValidKey$1: function(o) {
      !J.getInterceptor$(o).$isIterable;
      return true;
    },
    $isEquality: 1,
    $asEquality: function() {
    }
  };
  Y.HeapPriorityQueue.prototype = {
    contains$1: function(_, object) {
      return this._locate$1(H.assertSubtypeOfRuntimeType(object, H.getTypeArgumentByIndex(this, 0))) >= 0;
    },
    get$length: function(_) {
      return this._priority_queue$_length;
    },
    toList$0: function(_) {
      var _this = this,
        list = H.setRuntimeTypeInfo([], _this.$ti);
      C.JSArray_methods.set$length(list, _this._priority_queue$_length);
      C.JSArray_methods.setRange$3(list, 0, _this._priority_queue$_length, _this._priority_queue$_queue);
      C.JSArray_methods.sort$1(list, _this.comparison);
      return list;
    },
    toString$0: function(_) {
      var t1 = this._priority_queue$_queue;
      return P.IterableBase_iterableToShortString(H.SubListIterable$(t1, 0, this._priority_queue$_length, H.getTypeArgumentByIndex(t1, 0)), "(", ")");
    },
    _locate$1: function(object) {
      var t1, position, index, t2, comp, leftChildPosition, _this = this;
      H.assertSubtypeOfRuntimeType(object, H.getTypeArgumentByIndex(_this, 0));
      if (_this._priority_queue$_length === 0)
        return -1;
      t1 = _this.comparison;
      position = 1;
      do
        c$0: {
          index = position - 1;
          t2 = _this._priority_queue$_queue;
          if (index < 0 || index >= t2.length)
            return H.ioore(t2, index);
          comp = t1.call$2(t2[index], object);
          if (comp === 0)
            return index;
          if (typeof comp !== "number")
            return comp.$lt();
          if (comp < 0) {
            leftChildPosition = position * 2;
            if (leftChildPosition <= _this._priority_queue$_length) {
              position = leftChildPosition;
              break c$0;
            }
          }
          t2 = _this._priority_queue$_length;
          do {
            for (; (position & 1) === 1;)
              position = position >>> 1;
            ++position;
          } while (position > t2);
        }
      while (position !== 1);
      return -1;
    },
    _bubbleUp$2: function(element, index) {
      var t1, parentIndex, t2, $parent, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      for (t1 = _this.comparison; index > 0; index = parentIndex) {
        parentIndex = C.JSInt_methods._tdivFast$1(index - 1, 2);
        t2 = _this._priority_queue$_queue;
        if (parentIndex < 0 || parentIndex >= t2.length)
          return H.ioore(t2, parentIndex);
        $parent = t2[parentIndex];
        t2 = t1.call$2(element, $parent);
        if (typeof t2 !== "number")
          return t2.$gt();
        if (t2 > 0)
          break;
        C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, $parent);
      }
      C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
    },
    _bubbleDown$2: function(element, index) {
      var rightChildIndex, t1, t2, leftChildIndex, t3, leftChild, rightChild, comp, minChild, minChildIndex, child, _this = this;
      H.assertSubtypeOfRuntimeType(element, H.getTypeArgumentByIndex(_this, 0));
      rightChildIndex = index * 2 + 2;
      for (t1 = _this.comparison; t2 = _this._priority_queue$_length, rightChildIndex < t2; index = minChildIndex) {
        leftChildIndex = rightChildIndex - 1;
        t2 = _this._priority_queue$_queue;
        t3 = t2.length;
        if (leftChildIndex < 0 || leftChildIndex >= t3)
          return H.ioore(t2, leftChildIndex);
        leftChild = t2[leftChildIndex];
        if (rightChildIndex < 0 || rightChildIndex >= t3)
          return H.ioore(t2, rightChildIndex);
        rightChild = t2[rightChildIndex];
        comp = t1.call$2(leftChild, rightChild);
        if (typeof comp !== "number")
          return comp.$lt();
        if (comp < 0) {
          minChild = leftChild;
          minChildIndex = leftChildIndex;
        } else {
          minChild = rightChild;
          minChildIndex = rightChildIndex;
        }
        comp = t1.call$2(element, minChild);
        if (typeof comp !== "number")
          return comp.$le();
        if (comp <= 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
          return;
        }
        C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, minChild);
        rightChildIndex = minChildIndex * 2 + 2;
      }
      leftChildIndex = rightChildIndex - 1;
      if (leftChildIndex < t2) {
        t2 = _this._priority_queue$_queue;
        if (leftChildIndex < 0 || leftChildIndex >= t2.length)
          return H.ioore(t2, leftChildIndex);
        child = t2[leftChildIndex];
        comp = t1.call$2(element, child);
        if (typeof comp !== "number")
          return comp.$gt();
        if (comp > 0) {
          C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, child);
          index = leftChildIndex;
        }
      }
      C.JSArray_methods.$indexSet(_this._priority_queue$_queue, index, element);
    },
    set$_priority_queue$_queue: function(_queue) {
      this._priority_queue$_queue = H.assertSubtype(_queue, "$isList", this.$ti, "$asList");
    }
  };
  B.Pair.prototype = {};
  B.defaultCompare_closure.prototype = {
    call$2: function(value1, value2) {
      var t1 = this.T;
      H.assertSubtypeOfRuntimeType(value1, t1);
      H.assertSubtypeOfRuntimeType(value2, t1);
      return J.compareTo$1$ns(H.numberOrStringSuperNativeTypeCast(value1, "$isComparable"), value2);
    },
    $signature: function() {
      var t1 = this.T;
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  O.LineChart.prototype = {
    LineChart$2$classes: function($parent, classes, $T) {
      var t3, _this = this,
        t1 = _this.parent,
        t2 = t1.element.style;
      t2.position = "relative";
      t2 = W.Event;
      _this.set$_windowResizeSubscription(W._EventStreamSubscription$(window, "resize", H.functionTypeCheck(new O.LineChart_closure(_this), {func: 1, ret: -1, args: [t2]}), false, t2));
      P.Timer_Timer(C.Duration_0, _this.get$_updateSize());
      t2 = A.CoreElement$("div", null, classes, null, null);
      t3 = t2.element;
      t3.setAttribute("layout", "");
      t3.setAttribute("vertical", "");
      t2.flex$0(0);
      t2 = H.interceptedTypeCheck(t1.add$1(0, t2), "$isCoreElement");
      _this.chartElement = t2;
      J.setInnerHtml$2$treeSanitizer$x(t2.element, '<svg viewBox="0 0 500 98">\n<polyline fill="none" stroke="#0074d9" stroke-width="2" points=""/>\n</svg>\n', C.C_TrustedHtmlTreeSanitizer);
    },
    _updateSize$0: function() {
      var rect, _this = this,
        t1 = _this.chartElement.element;
      if (t1.parentElement == null)
        return;
      rect = t1.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0)
        return;
      t1 = J.get$children$x(_this.chartElement.element);
      t1.get$first(t1).setAttribute("viewBox", "0 0 " + H.S(rect.width) + " 98");
      _this.set$dim(new P.Point(C.JSNumber_methods.toInt$0(rect.width), C.JSNumber_methods.toInt$0(rect.height), [P.int]));
      if (_this.data != null)
        _this._charts$_state.setState$1(new O.LineChart__updateSize_closure(_this));
    },
    set$_windowResizeSubscription: function(_windowResizeSubscription) {
      H.assertSubtype(_windowResizeSubscription, "$isStreamSubscription", [W.Event], "$asStreamSubscription");
    },
    set$dim: function(dim) {
      this.dim = H.assertSubtype(dim, "$isPoint", [P.int], "$asPoint");
    },
    set$data: function(_, data) {
      this.data = H.assertSubtypeOfRuntimeType(data, H.getRuntimeTypeArgument(this, "LineChart", 0));
    }
  };
  O.LineChart_closure.prototype = {
    call$1: function(e) {
      return this.$this._updateSize$0();
    },
    $signature: 23
  };
  O.LineChart__updateSize_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.update$1(0, t1.data);
    },
    $signature: 0
  };
  L.ConnectedApp.prototype = {
    get$isFlutterApp: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1;
      var $async$get$isFlutterApp = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._libraryUriAvailable$1("package:flutter/src/widgets/binding.dart"), $async$get$isFlutterApp);
            case 3:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$get$isFlutterApp, $async$completer);
    },
    get$isFlutterWebApp: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1;
      var $async$get$isFlutterWebApp = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._libraryUriAvailable$1("package:flutter_web/src/widgets/binding.dart"), $async$get$isFlutterWebApp);
            case 3:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$get$isFlutterWebApp, $async$completer);
    },
    get$isProfileBuild: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1;
      var $async$get$isProfileBuild = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self._connectedToProfileBuild$0(), $async$get$isProfileBuild);
            case 3:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$get$isProfileBuild, $async$completer);
    },
    get$isAnyFlutterApp: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$get$isAnyFlutterApp = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.get$isFlutterApp(), $async$get$isAnyFlutterApp);
            case 5:
              // returning from await.
              $async$temp1 = $async$temp1.boolConversionCheck($async$result);
              if ($async$temp1)
                $async$result = $async$temp1;
              else {
                // goto then
                $async$goto = 3;
                break;
              }
              // goto join
              $async$goto = 4;
              break;
            case 3:
              // then
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self.get$isFlutterWebApp(), $async$get$isAnyFlutterApp);
            case 6:
              // returning from await.
              $async$result = $async$temp1.boolConversionCheck($async$result);
            case 4:
              // join
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$get$isAnyFlutterApp, $async$completer);
    },
    _connectedToProfileBuild$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, isolate, t1, t2, t3, exception, $async$exception, $async$temp1;
      var $async$_connectedToProfileBuild$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait($async$self.get$isFlutterWebApp(), $async$_connectedToProfileBuild$0);
            case 3:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 5;
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              t2 = C.JSArray_methods.get$first(P.List_List$unmodifiable(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolates, S.IsolateRef)).id;
              t3 = t1._vmService;
              t3.toString;
              $async$temp1 = H;
              $async$goto = 8;
              return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t3._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null), $async$_connectedToProfileBuild$0);
            case 8:
              // returning from await.
              isolate = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate");
              $async$goto = 9;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.evaluate$3(0, isolate.id, isolate.rootLib.id, "1+1"), $async$_connectedToProfileBuild$0);
            case 9:
              // returning from await.
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$currentError;
              if (H.unwrapException($async$exception) instanceof S.RPCError) {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_connectedToProfileBuild$0, $async$completer);
    },
    _libraryUriAvailable$1: function(uri) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, t1, t2, t3;
      var $async$_libraryUriAvailable$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager.selectedIsolateAvailable.future, $async$_libraryUriAvailable$1);
            case 3:
              // returning from await.
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager.selectedIsolateLibraries;
              t2 = P.String;
              t1.toString;
              t3 = H.getTypeArgumentByIndex(t1, 0);
              $async$returnValue = C.JSArray_methods.contains$1(new H.MappedListIterable(t1, H.functionTypeCheck(new L.ConnectedApp__libraryUriAvailable_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0), uri);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_libraryUriAvailable$1, $async$completer);
    }
  };
  L.ConnectedApp__libraryUriAvailable_closure.prototype = {
    call$1: function(ref) {
      return H.interceptedTypeCheck(ref, "$isLibraryRef").uri;
    },
    $signature: 127
  };
  A.BusEvent.prototype = {
    toString$0: function(_) {
      return this.type;
    }
  };
  A.MessageBus.prototype = {
    onEvent$1$type: function(type) {
      var t1 = this._controller,
        t2 = H.getTypeArgumentByIndex(t1, 0),
        t3 = H.functionTypeCheck(new A.MessageBus_onEvent_closure(type), {func: 1, ret: P.bool, args: [t2]});
      return new P._WhereStream(t3, new P._BroadcastStream(t1, [t2]), [t2]);
    },
    set$_controller: function(_controller) {
      this._controller = H.assertSubtype(_controller, "$isStreamController", [A.BusEvent], "$asStreamController");
    }
  };
  A.MessageBus_onEvent_closure.prototype = {
    call$1: function($event) {
      return H.interceptedTypeCheck($event, "$isBusEvent").type === this.type;
    },
    $signature: 130
  };
  F._breakpointComparator_getRef.prototype = {
    call$1: function($location) {
      var t1 = J.getInterceptor$($location);
      if (!!t1.$isSourceLocation)
        return $location.script;
      else if (!!t1.$isUnresolvedSourceLocation)
        return $location.script;
      else
        return;
    },
    $signature: 137
  };
  F._breakpointComparator_getPos.prototype = {
    call$1: function($location) {
      var t1 = J.getInterceptor$($location);
      if (!!t1.$isSourceLocation) {
        t1 = $location.tokenPos;
        return t1 == null ? 0 : t1;
      } else if (!!t1.$isUnresolvedSourceLocation) {
        t1 = $location.line;
        return t1 == null ? 0 : t1;
      } else
        return 0;
    },
    $signature: 80
  };
  F.BreakpointsView.prototype = {
    BreakpointsView$3: function(_breakpointsCountDiv, debuggerState, uriDescriber) {
      var _null = null,
        t1 = S.Breakpoint,
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = [t1];
      t1 = new N.SelectableList(t2, new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, [-1]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"), [t1]);
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.flex$0(0);
      t1.clazz$1("menu-item-bottom-border");
      t1.clazz$1("debugger-items-list");
      this.set$_breakpoints_view$_items(t1);
      t1 = this._breakpoints_view$_items;
      t1.set$renderer(H.functionTypeCheck(new F.BreakpointsView_closure(uriDescriber, debuggerState), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    get$element: function() {
      return this._breakpoints_view$_items;
    },
    set$_breakpoints_view$_items: function(_items) {
      this._breakpoints_view$_items = H.assertSubtype(_items, "$isSelectableList", [S.Breakpoint], "$asSelectableList");
    },
    $isCoreElementView: 1
  };
  F.BreakpointsView_closure.prototype = {
    call$1: function(breakpoint) {
      var $location, element, t1, _null = null;
      H.interceptedTypeCheck(breakpoint, "$isBreakpoint");
      $location = breakpoint.location;
      element = A.CoreElement$("li", _null, "list-item", _null, _null);
      t1 = J.getInterceptor$($location);
      if (!!t1.$isUnresolvedSourceLocation) {
        element.element.textContent = H.stringTypeCheck(this.uriDescriber.call$1($location.script.uri));
        element.add$1(0, A.CoreElement$("span", _null, "subtle", _null, " line " + H.S($location.line)));
      } else if (!!t1.$isSourceLocation) {
        element.element.textContent = H.stringTypeCheck(this.uriDescriber.call$1($location.script.uri));
        t1 = this.debuggerState;
        t1.getScript$1($location.script).then$1$1(new F.BreakpointsView__closure(t1, $location, element), _null);
      }
      if (!H.boolConversionCheck(breakpoint.resolved))
        element.add$1(0, A.CoreElement$("span", _null, "subtle", _null, " (unresolved)"));
      return element;
    },
    $signature: 140
  };
  F.BreakpointsView__closure.prototype = {
    call$1: function(script) {
      this.element.add$1(0, A.CoreElement$("span", null, "subtle", null, " line " + H.S(this.debuggerState.calculatePosition$2(H.interceptedTypeCheck(script, "$isScript"), this.location.tokenPos).line)));
    },
    $signature: 144
  };
  F.BreakOnExceptionControl.prototype = {
    BreakOnExceptionControl$0: function() {
      var allExceptionsElement, t2, t3, t4, t5, t6, t7, t8, _this = this, _null = null,
        _s8_ = "checkbox",
        _s4_ = "span",
        unhandledExceptionsElement = A.CoreElement$("input", _null, _null, _null, _null),
        t1 = unhandledExceptionsElement.element;
      t1.setAttribute("type", _s8_);
      H.interceptedTypeCheck(t1, "$isInputElement");
      _this._unhandledElement = t1;
      allExceptionsElement = A.CoreElement$("input", _null, _null, _null, _null);
      t2 = allExceptionsElement.element;
      t2.setAttribute("type", _s8_);
      H.interceptedTypeCheck(t2, "$isInputElement");
      _this._allElement = t2;
      t3 = A.CoreElement$(_s4_, _null, "strong", _null, "Break on");
      t4 = A.CoreElement$(_s4_, _null, "strong optional-1000", _null, " exceptions");
      t5 = A.CoreElement$(_s4_, _null, "strong", _null, ": ");
      t6 = A.CoreElement$("label", _null, _null, _null, _null);
      t7 = [A.CoreElement];
      t6.add$1(0, H.setRuntimeTypeInfo([unhandledExceptionsElement, A.CoreElement$(_s4_, _null, _null, _null, " unhandled")], t7));
      t8 = A.CoreElement$("label", _null, _null, _null, _null);
      t8.add$1(0, H.setRuntimeTypeInfo([allExceptionsElement, A.CoreElement$(_s4_, _null, _null, _null, " all")], t7));
      _this.add$1(0, H.setRuntimeTypeInfo([t3, t4, t5, t6, t8], t7));
      t1 = C.InputElement_methods.get$onChange(t1);
      t7 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new F.BreakOnExceptionControl_closure(_this), {func: 1, ret: -1, args: [t7]}), false, t7);
      t2 = C.InputElement_methods.get$onChange(t2);
      t7 = H.getTypeArgumentByIndex(t2, 0);
      W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new F.BreakOnExceptionControl_closure0(_this, unhandledExceptionsElement), {func: 1, ret: -1, args: [t7]}), false, t7);
    },
    get$exceptionPauseMode: function() {
      if (H.boolConversionCheck(this._allElement.checked))
        return "All";
      else if (H.boolConversionCheck(this._unhandledElement.checked))
        return "Unhandled";
      else
        return "None";
    }
  };
  F.BreakOnExceptionControl_closure.prototype = {
    call$1: function(_) {
      var t1;
      F.select("debugger", "unhandledExceptions", 0);
      t1 = this.$this;
      t1._pauseModeController.add$1(0, t1.get$exceptionPauseMode());
    },
    $signature: 6
  };
  F.BreakOnExceptionControl_closure0.prototype = {
    call$1: function(_) {
      var t1, t2,
        _s8_ = "disabled";
      F.select("debugger", "allExceptions", 0);
      t1 = this.$this;
      t2 = this.unhandledExceptionsElement;
      if (H.boolConversionCheck(t1._allElement.checked)) {
        t2.attribute$2(_s8_, true);
        t1._unhandledElement.checked = true;
      } else
        t2.attribute$2(_s8_, false);
      t1._pauseModeController.add$1(0, t1.get$exceptionPauseMode());
    },
    $signature: 6
  };
  S.CallStackView.prototype = {
    CallStackView$0: function() {
      var _null = null,
        t1 = S.Frame,
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = [t1];
      t1 = new N.SelectableList(t2, new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, [-1]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"), [t1]);
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.flex$0(0);
      t1.clazz$1("menu-item-bottom-border");
      t1.clazz$1("debugger-items-list");
      this.set$_callstack_view$_items(t1);
      t1 = this._callstack_view$_items;
      t1.set$renderer(H.functionTypeCheck(new S.CallStackView_closure(), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    get$element: function() {
      return this._callstack_view$_items;
    },
    set$_callstack_view$_items: function(_items) {
      this._callstack_view$_items = H.assertSubtype(_items, "$isSelectableList", [S.Frame], "$asSelectableList");
    },
    $isCoreElementView: 1
  };
  S.CallStackView_closure.prototype = {
    call$1: function(frame) {
      var t1, $name, locationDescription, element, _null = null,
        _s21_ = "AsyncSuspensionMarker",
        _s16_ = "EmptyStackMarker";
      H.interceptedTypeCheck(frame, "$isFrame");
      t1 = frame.code;
      $name = t1 == null ? _null : t1.name;
      if ($name == null)
        $name = "<none>";
      if (C.JSString_methods.startsWith$1($name, "[Unoptimized] "))
        $name = C.JSString_methods.substring$1($name, 14);
      $name = H.stringReplaceAllUnchecked($name, "<anonymous closure>", "<closure>");
      t1 = frame.kind;
      if (t1 === _s21_) {
        locationDescription = _null;
        $name = "<async break>";
      } else if (t1 !== _s16_) {
        locationDescription = frame.location.script.uri;
        if (J.getInterceptor$asx(locationDescription).contains$1(locationDescription, "/"))
          locationDescription = C.JSString_methods.substring$1(locationDescription, C.JSString_methods.lastIndexOf$1(locationDescription, "/") + 1);
      } else
        locationDescription = _null;
      element = A.CoreElement$("li", _null, "list-item", _null, $name);
      t1 = frame.kind;
      if (t1 === _s21_ || t1 === _s16_)
        J.get$classes$x(element.element).toggle$2(0, "subtle", _null);
      if (locationDescription != null)
        element.add$1(0, A.CoreElement$("span", _null, "subtle", _null, " " + locationDescription));
      return element;
    },
    $signature: 153
  };
  O.ConsoleArea.prototype = {
    get$element: function() {
      return this._console_area$_container;
    },
    appendText$1: function(_, text) {
      var t1, t2, t3, t4;
      this._bufferedText._contents += text;
      t1 = this._timer;
      t1.set$_closure(H.functionTypeCheck(new O.ConsoleArea_appendText_closure(this), {func: 1, ret: -1}));
      t2 = t1._minTimer;
      t3 = t1.get$_fire();
      t4 = t1.minDelay;
      if (t2 == null) {
        t1._minTimer = P.Timer_Timer(t4, t3);
        t1._maxTimer = P.Timer_Timer(t1.maxDelay, t3);
      } else {
        t2.cancel$0(0);
        t1._minTimer = P.Timer_Timer(t4, t3);
      }
    },
    $isCoreElementView: 1
  };
  O.ConsoleArea_appendText_closure.prototype = {
    call$0: function() {
      var t4, lastLineIndex, lastLine,
        _s8_ = "lastLine",
        t1 = this.$this,
        t2 = t1._bufferedText,
        t3 = t2._contents;
      t2._contents = "";
      t2 = t1._editor.getDoc$0();
      t4 = H.intTypeCheck(t1._editor.getDoc$0().jsProxy.callMethod$1(_s8_));
      if (typeof t4 !== "number")
        return t4.$add();
      t2.toString;
      t4 = new X.Position(t4 + 1, 0).toProxy$0();
      t3 = [t3.charCodeAt(0) == 0 ? t3 : t3, t4, null];
      t2.jsProxy.callMethod$2("replaceRange", t3);
      lastLineIndex = H.intTypeCheck(t1._editor.getDoc$0().jsProxy.callMethod$1(_s8_));
      lastLine = H.stringTypeCheck(t1._editor.getDoc$0().jsProxy.callMethod$2("getLine", [lastLineIndex]));
      t1._editor.scrollIntoView$2(0, lastLineIndex, lastLine.length);
    },
    $signature: 0
  };
  X.DebuggerScreen.prototype = {
    debuggerShortcuts$4: function(ctrlKey, shiftKey, altKey, key) {
      var t1, t2, t3, t4, sourceAreaWidth, t5, t6, r, nameHeight, elems, firstGutter, leftPosition, bgColor, _this = this, _s6_ = "inline";
      if (H.boolConversionCheck(ctrlKey))
        switch (key) {
          case "o":
            t1 = _this._matcher;
            if (t1 != null && t1._keyEventSubscription != null) {
              t1.revert$0();
              t1 = t1._finishCallback;
              if (t1 != null)
                t1.call$0();
              _this._matcher = null;
            }
            t1 = _this._popupView;
            t2 = t1.element;
            t3 = t2.style;
            t3.display = _s6_;
            if (!t1._poppedUp) {
              t1._poppedUp = true;
              t3 = t1._scriptsView;
              t1.add$1(0, t3);
              t4 = t1._sourceArea.element;
              sourceAreaWidth = t4.clientWidth;
              t5 = t3._scripts_view$_items.element.style;
              t6 = H.S(t2.getBoundingClientRect().height - 2) + "px";
              t5.height = t6;
              if (typeof sourceAreaWidth !== "number")
                return sourceAreaWidth.$div();
              t6 = H.S(sourceAreaWidth / 2) + "px";
              t5.width = t6;
              r = t4.getBoundingClientRect();
              t4 = t1._scripts_view$_sourcePathDiv.element;
              nameHeight = t4.clientHeight;
              elems = document.getElementsByClassName("CodeMirror-gutters");
              t5 = elems.length;
              if (t5 === 2) {
                if (0 >= t5)
                  return H.ioore(elems, 0);
                firstGutter = H.interceptedTypeCast(elems[0].firstChild, "$isElement");
                leftPosition = firstGutter.style.display !== "none" ? H.intTypeCheck(firstGutter.parentElement.getBoundingClientRect().width + 5) : 20;
              } else
                leftPosition = 20;
              t5 = J.getInterceptor$x(t4);
              bgColor = t5.getComputedStyle$0(t4).backgroundColor;
              t1._oldSourceNameTextColor = t5.getComputedStyle$0(t4).color;
              t4 = t4.style;
              t4.color = bgColor;
              t1 = t1._scripts_view$_popupTextfield.element.style;
              t4 = H.S(nameHeight) + "px";
              t1.height = t4;
              t4 = H.S(nameHeight) + "px";
              t1.minHeight = t4;
              t4 = H.S(nameHeight) + "px";
              t1.maxHeight = t4;
              t3 = t3._scripts_view$_items.element.style.width;
              t1.width = t3;
              t3 = H.S(r.top) + "px";
              t1.top = t3;
              t3 = H.S(r.left + leftPosition) + "px";
              t1.left = t3;
              t1.display = _s6_;
              t1 = t2.style;
              t2 = r.top;
              if (typeof nameHeight !== "number")
                return H.iae(nameHeight);
              t2 = H.S(t2 + nameHeight) + "px";
              t1.top = t2;
              t2 = H.S(r.left + leftPosition) + "px";
              t1.left = t2;
              t1.display = _s6_;
              _this._hookupListeners$1(_this._popupView._scriptsView);
            } else {
              t1 = t1._scriptsView._scripts_view$_items;
              t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
              t1 = _this._popupView._scriptsView._scripts_view$_items.element.style;
              t1.display = _s6_;
            }
            J.focus$0$x(_this._popupView._scripts_view$_popupTextfield.element);
            F.select("debugger", "openShortcut", 0);
            return true;
        }
      return false;
    },
    createContent$1: function(framework) {
      var screenDiv, t2, resumeButton, pauseButton, t3, t4, t5, breakOnExceptionControl, options, t6, t7, t8, t9, t10, t11, stepIn, stepOver, stepOut, t12, sourceArea, consoleDiv, navEditorPanels, codeMirror, _this = this, _null = null, _s3_ = "div", _s6_ = "layout",
        _s8_ = "vertical",
        _s9_ = "setOption",
        _s10_ = "horizontal",
        _s20_ = "section table-border",
        t1 = {};
      E.setupDimensions();
      screenDiv = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t2 = screenDiv.element;
      t2.setAttribute(_s6_, "");
      t2.setAttribute(_s8_, "");
      resumeButton = N.PButton$icon("Resume", C.UrlIcon_JmU, _null);
      resumeButton.clazz$1("btn-primary");
      resumeButton.clazz$1("btn-sm");
      resumeButton.clazz$1("margin-left");
      resumeButton.attribute$2("disabled", true);
      pauseButton = N.PButton$icon("Pause", C.UrlIcon_lyL, _null);
      pauseButton.clazz$1("btn-sm");
      t2 = new X.DebuggerScreen_createContent__updateResumeButton(resumeButton);
      t3 = new X.DebuggerScreen_createContent__updatePauseButton(pauseButton);
      resumeButton.click$1(0, new X.DebuggerScreen_createContent_closure(_this, t2));
      pauseButton.click$1(0, new X.DebuggerScreen_createContent_closure0(_this, t3));
      t4 = _this.debuggerState;
      t5 = t4._paused;
      t5.listen$1(new X.DebuggerScreen_createContent_closure1(t3, t2));
      t1.stepOut = t1.stepIn = t1.stepOver = null;
      breakOnExceptionControl = F.BreakOnExceptionControl$();
      t2 = breakOnExceptionControl._pauseModeController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new X.DebuggerScreen_createContent_closure2(_this));
      t4._exceptionPauseMode.listen$1(new X.DebuggerScreen_createContent_closure3(breakOnExceptionControl));
      t2 = new O.ConsoleArea(new B.DelayedTimer(C.Duration_100000, C.Duration_1000000), new P.StringBuffer(""));
      t3 = P.String;
      options = P.LinkedHashMap_LinkedHashMap$_literal(["mode", "text/plain"], t3, _null);
      t6 = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t7 = t6.element;
      t7.setAttribute(_s6_, "");
      t7.setAttribute(_s8_, "");
      t6.flex$0(0);
      t2._console_area$_container = t6;
      t6 = t2._editor = X.CodeMirror$fromElement(t7, options);
      t6.setReadOnly$1(true);
      if ($._isDarkTheme)
        t6.jsProxy.callMethod$2(_s9_, ["theme", "zenburn"]);
      J.get$children$x(t7).$index(0, 0).setAttribute("flex", "");
      _this.consoleArea = t2;
      t2 = A.CoreElement$("input", _null, "form-control input-sm popup-textfield", _null, _null);
      t6 = t2.element;
      t6.setAttribute("type", "text");
      t6.setAttribute("placeholder", "search");
      t6.setAttribute("id", "popup_script_name");
      t2.focus$1(0, new X.DebuggerScreen_createContent_closure4(_this));
      t2.blur$1(0, new X.DebuggerScreen_createContent_closure5(_this));
      t6 = J.get$onKeyUp$x(t6);
      t7 = H.getTypeArgumentByIndex(t6, 0);
      W._EventStreamSubscription$(t6._html$_target, t6._eventType, H.functionTypeCheck(new X.DebuggerScreen_createContent_closure6(_this), {func: 1, ret: -1, args: [t7]}), false, t7);
      _this._popupTextfield = t2;
      t2 = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t2.flex$0(0);
      t7 = t2.element;
      t7.setAttribute(_s6_, "");
      t7.setAttribute(_s10_, "");
      t7 = A.CoreElement$(_s3_, _null, "debugger-menu", _null, _null);
      t6 = t7.element;
      t6.setAttribute(_s6_, "");
      t6.setAttribute(_s8_, "");
      t6 = [A.CoreElement];
      t7.add$1(0, H.setRuntimeTypeInfo([_this._buildMenuNav$0()], t6));
      t8 = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t9 = t8.element;
      t10 = t9.style;
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t10, (t10 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t10, "overflow-x"), "hidden", "");
      t9.setAttribute(_s6_, "");
      t9.setAttribute(_s8_, "");
      t9 = A.CoreElement$(_s3_, _null, "section flex-wrap", _null, _null);
      t10 = t9.element;
      t10.setAttribute(_s6_, "");
      t10.setAttribute(_s10_, "");
      t10 = A.CoreElement$(_s3_, _null, "btn-group collapsible-700 flex-no-wrap", _null, _null);
      t10.add$1(0, H.setRuntimeTypeInfo([pauseButton, resumeButton], t6));
      t11 = A.CoreElement$(_s3_, _null, "btn-group flex-no-wrap margin-left collapsible-1000", _null, _null);
      stepIn = N.PButton$octicon("Step in", "chevron-down");
      t1.stepIn = stepIn;
      stepOver = N.PButton$octicon("Step over", "chevron-right");
      t1.stepOver = stepOver;
      stepOut = N.PButton$octicon("Step out", "chevron-up");
      t1.stepOut = stepOut;
      t11.add$1(0, H.setRuntimeTypeInfo([stepIn, stepOver, stepOut], t6));
      t12 = A.CoreElement$(_s3_, _null, "margin-right", _null, _null);
      t12.flex$0(0);
      t9.add$1(0, H.setRuntimeTypeInfo([t10, t11, t12, breakOnExceptionControl], t6));
      sourceArea = A.CoreElement$(_s3_, _null, _s20_, _null, _null);
      t12 = sourceArea.element;
      t12.setAttribute(_s6_, "");
      t12.setAttribute(_s8_, "");
      t11 = A.CoreElement$(_s3_, _null, "source-head", _null, _null);
      _this._sourcePathDiv = t11;
      sourceArea.add$1(0, H.setRuntimeTypeInfo([t11], t6));
      consoleDiv = A.CoreElement$(_s3_, _null, _s20_, _null, _null);
      t11 = consoleDiv.element;
      t11.setAttribute(_s6_, "");
      t11.setAttribute(_s8_, "");
      consoleDiv.add$1(0, _this.consoleArea._console_area$_container);
      t8.add$1(0, H.setRuntimeTypeInfo([t9, sourceArea, consoleDiv], t6));
      navEditorPanels = H.setRuntimeTypeInfo([t7, t8], t6);
      t2.add$1(0, navEditorPanels);
      screenDiv.add$1(0, H.setRuntimeTypeInfo([t2], t6));
      t2 = _this._popupTextfield;
      t8 = _this.popupScriptsView;
      t8 = new X.PopupView(sourceArea, _this._sourcePathDiv, t2, t8, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      t8.CoreElement$5$attributes$classes$html$text(_s3_, _null, "open-popup", _null, _null);
      _this._popupView = t8;
      screenDiv.add$1(0, H.setRuntimeTypeInfo([t2, t8], t6));
      J.setInnerHtml$2$treeSanitizer$x(_this._sourcePathDiv.element, "&nbsp;", C.C_TrustedHtmlTreeSanitizer);
      t6 = W.Element;
      t8 = H.getTypeArgumentByIndex(navEditorPanels, 0);
      t6 = new H.MappedListIterable(navEditorPanels, H.functionTypeCheck(new X.DebuggerScreen_createContent_closure7(), {func: 1, ret: t6, args: [t8]}), [t8, t6]).toList$0(0);
      t8 = [P.num];
      t2 = H.setRuntimeTypeInfo([22, 78], t8);
      A.flexSplit(t6, 10, true, H.setRuntimeTypeInfo([200, 600], t8), t2);
      t2 = H.setRuntimeTypeInfo([80, 20], t8);
      A.flexSplit([t12, t11], 10, false, H.setRuntimeTypeInfo([200, 60], t8), t2);
      t2 = P.bool;
      new X.Observable(new R.ConcatStream(R.ConcatStream__buildController(H.setRuntimeTypeInfo([t5, t4._supportsStepping], [[P.Stream, P.bool]]), t2), [t2]), [t2]).listen$1(new X.DebuggerScreen_createContent_closure8(t1, _this));
      t1.stepOver.click$1(0, new X.DebuggerScreen_createContent_closure9(_this));
      t1.stepIn.click$1(0, new X.DebuggerScreen_createContent_closure10(_this));
      t1.stepOut.click$1(0, new X.DebuggerScreen_createContent_closure11(_this));
      codeMirror = X.CodeMirror$fromElement(t12, P.LinkedHashMap_LinkedHashMap$_literal(["mode", "dart", "lineNumbers", true, "gutters", H.setRuntimeTypeInfo(["breakpoints"], [t3])], t3, _null));
      codeMirror.setReadOnly$1(true);
      if ($._isDarkTheme)
        codeMirror.jsProxy.callMethod$2(_s9_, ["theme", "zenburn"]);
      J.get$children$x(_this._sourcePathDiv.element.parentElement).$index(0, 1).setAttribute("flex", "");
      _this.sourceEditor = X.SourceEditor$(codeMirror, t4);
      t4._breakpoints.listen$1(new X.DebuggerScreen_createContent_closure12(_this));
      t5.listen$1(new X.DebuggerScreen_createContent_closure13(_this));
      t5.listen$1(new X.DebuggerScreen_createContent_closure14(_this));
      t1 = _this.callStackView._callstack_view$_items._selectionController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new X.DebuggerScreen_createContent_closure15(_this));
      _this.consoleArea._editor.jsProxy.callMethod$1("refresh");
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("reload.start").listen$1(new X.DebuggerScreen_createContent_closure16(_this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("reload.end").listen$1(new X.DebuggerScreen_createContent_closure17(_this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("restart.start").listen$1(new X.DebuggerScreen_createContent_closure18(_this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("restart.end").listen$1(new X.DebuggerScreen_createContent_closure19(_this));
      return screenDiv;
    },
    entering$0: function() {
      var t1, _this = this;
      if (!_this._initialized) {
        _this._initialized = true;
        t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
        new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(_this.get$_debugger$_handleConnectionStart());
        if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
          _this._debugger$_handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
        t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolateController;
        new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(_this.get$_handleIsolateChanged());
        t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
        new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(_this.get$_debugger$_handleConnectionStop());
      }
    },
    _hookupListeners$1: function(scriptsView) {
      var t1 = scriptsView._scripts_view$_items._selectionController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new X.DebuggerScreen__hookupListeners_closure(this, scriptsView));
    },
    _buildMenuNav$0: function() {
      var t1, t2, t3, textfield, t4, scriptCountDiv, t5, t6, t7, t8, t9, t10, menu, _this = this, _null = null, _s1_ = "a",
        _s9_ = "menu-item";
      _this.callStackView = S.CallStackView$();
      t1 = _this.debuggerState;
      _this.variablesView = V.VariablesView$(t1, new X.DebuggerScreen__buildMenuNav_closure(_this));
      t2 = A.CoreElement$("span", _null, "counter", _null, "0");
      _this._breakpointsCountDiv = t2;
      t3 = t1.get$getShortScriptName();
      t2 = F.BreakpointsView$(t2, t1, t3);
      _this.breakpointsView = t2;
      t2 = t2._breakpoints_view$_items._doubleClickController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new X.DebuggerScreen__buildMenuNav_closure0(_this));
      textfield = A.CoreElement$("input", _null, "form-control input-sm margin-left", _null, _null);
      t2 = textfield.element;
      t2.setAttribute("type", "text");
      t2.setAttribute("placeholder", "search");
      t4 = t2.style;
      t4.width = "calc(100% - 105px)";
      t2.setAttribute("id", "script_name");
      scriptCountDiv = A.CoreElement$("span", _null, "counter", _null, "-");
      t4 = scriptCountDiv.element.style;
      t4.marginTop = "4px";
      t4 = X.ScriptsView$(t3);
      _this.scriptsView = t4;
      _this._hookupListeners$1(t4);
      t3 = X.ScriptsView$(t3);
      _this.popupScriptsView = t3;
      _this._hookupListeners$1(t3);
      t3 = _this.scriptsView._scripts_view$_items._itemsChangedController;
      new P._BroadcastStream(t3, [H.getTypeArgumentByIndex(t3, 0)]).listen$1(new X.DebuggerScreen__buildMenuNav_closure1(_this, scriptCountDiv));
      t3 = new N.PNavMenuItem(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s1_, _null), "$isElement"));
      t3.CoreElement$5$attributes$classes$html$text(_s1_, _null, _s9_, _null, "Call stack");
      t3.click$1(0, new X.DebuggerScreen__buildMenuNav_closure2(_this));
      t4 = _this.callStackView._callstack_view$_items;
      t5 = new N.PNavMenuItem(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s1_, _null), "$isElement"));
      t5.CoreElement$5$attributes$classes$html$text(_s1_, _null, _s9_, _null, "Variables");
      t5.click$1(0, new X.DebuggerScreen__buildMenuNav_closure3(_this));
      t6 = _this.variablesView._items;
      t7 = new N.PNavMenuItem(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s1_, _null), "$isElement"));
      t7.CoreElement$5$attributes$classes$html$text(_s1_, _null, _s9_, _null, "Breakpoints");
      t7.add$1(0, _this._breakpointsCountDiv);
      t7.click$1(0, new X.DebuggerScreen__buildMenuNav_closure4(_this));
      t8 = _this.breakpointsView._breakpoints_view$_items;
      t9 = new N.PNavMenuItem(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s1_, _null), "$isElement"));
      t9.CoreElement$5$attributes$classes$html$text(_s1_, _null, _s9_, _null, "Libraries");
      textfield.click$1(0, new X.DebuggerScreen__buildMenuNav_closure5(_this));
      textfield.focus$1(0, new X.DebuggerScreen__buildMenuNav_closure6(_this));
      t2 = J.get$onKeyUp$x(t2);
      t10 = H.getTypeArgumentByIndex(t2, 0);
      W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new X.DebuggerScreen__buildMenuNav_closure7(_this, textfield), {func: 1, ret: -1, args: [t10]}), false, t10);
      t10 = [A.CoreElement];
      t9.add$1(0, H.setRuntimeTypeInfo([textfield, scriptCountDiv], t10));
      t9.click$1(0, new X.DebuggerScreen__buildMenuNav_closure8(_this));
      menu = N.PNavMenu$(H.setRuntimeTypeInfo([t3, t4, t5, t6, t7, t8, t9, _this.scriptsView._scripts_view$_items], t10), false);
      menu.flex$0(0);
      t10 = menu.element;
      t10.setAttribute("layout", "");
      t10.setAttribute("vertical", "");
      t1._breakpoints.listen$1(new X.DebuggerScreen__buildMenuNav_closure9(_this));
      return menu;
    },
    _debugger$_handleConnectionStart$1: function(service) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck(service, "$isVmService");
      t1 = _this.debuggerState;
      t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      t1._service = t2;
      t2 = t2._vmService._getEventController$1("Debug");
      t1.set$_debugSubscription(new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1.get$_debugger_state$_handleIsolateEvent()));
      service.get$onStdoutEvent().listen$1(new X.DebuggerScreen__handleConnectionStart_closure(_this));
      service.get$onStderrEvent().listen$1(new X.DebuggerScreen__handleConnectionStart_closure0(_this));
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate != null)
        _this._handleIsolateChanged$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate);
    },
    _handleIsolateChanged$1: function(isolateRef) {
      var t1, t2, t3, _this = this,
        _s10_ = "getIsolate";
      H.interceptedTypeCheck(isolateRef, "$isIsolateRef");
      if (isolateRef == null) {
        t1 = _this.scriptsView._scripts_view$_items;
        t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
        _this.debuggerState.switchToIsolate$1(isolateRef);
        return;
      }
      t1 = _this.debuggerState;
      if (isolateRef.$eq(0, t1.isolateRef))
        return;
      t1.switchToIsolate$1(isolateRef);
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      t2 = isolateRef.id;
      t3 = t1._vmService;
      t3.toString;
      t1._trackFuture$1$2(_s10_, t3._call$1$2(0, _s10_, P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null).then$1$1(new X.DebuggerScreen__handleIsolateChanged_closure(_this), null).catchError$1(new X.DebuggerScreen__handleIsolateChanged_closure0(_this));
    },
    _debugger$_handleConnectionStop$1: function($event) {
      var t1;
      this.deviceStatus.element.element.textContent = "";
      t1 = this.scriptsView._scripts_view$_items;
      t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
      t1 = this.debuggerState;
      t1.switchToIsolate$1(null);
      t1 = t1._debugSubscription;
      if (t1 != null)
        t1.cancel$0(0);
    },
    _populateFromIsolate$2: function(isolate, scriptsViewers) {
      return this._populateFromIsolate$body$DebuggerScreen(isolate, H.assertSubtype(scriptsViewers, "$isList", [X.ScriptsView], "$asList"));
    },
    _populateFromIsolate$body$DebuggerScreen: function(isolate, scriptsViewers) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, scriptPrefix, isRunning, t3, t4, t5, scripts, _i, t1, t2;
      var $async$_populateFromIsolate$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.debuggerState;
              t2 = isolate.rootLib;
              t1.rootLib = t2;
              scriptPrefix = t2.uri;
              if (J.getInterceptor$s(scriptPrefix).startsWith$1(scriptPrefix, "package:"))
                scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.indexOf$1(scriptPrefix, "/") + 1);
              else if (C.JSString_methods.contains$1(scriptPrefix, "/lib/")) {
                scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/lib/"));
                if (C.JSString_methods.contains$1(scriptPrefix, "/"))
                  scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/") + 1);
              } else if (C.JSString_methods.contains$1(scriptPrefix, "/bin/")) {
                scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/bin/"));
                if (C.JSString_methods.contains$1(scriptPrefix, "/"))
                  scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/") + 1);
              } else if (C.JSString_methods.contains$1(scriptPrefix, "/test/")) {
                scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/test/"));
                if (C.JSString_methods.contains$1(scriptPrefix, "/"))
                  scriptPrefix = C.JSString_methods.substring$2(scriptPrefix, 0, C.JSString_methods.lastIndexOf$1(scriptPrefix, "/") + 1);
              } else
                scriptPrefix = null;
              t1.commonScriptPrefix = scriptPrefix;
              t1._breakpoints.add$1(0, isolate.breakpoints);
              t2 = isolate.pauseEvent;
              isRunning = t2 == null || t2.kind === "Resume";
              $async$goto = 4;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").get$serviceCapabilities(), $async$_populateFromIsolate$2);
            case 4:
              // returning from await.
              $async$goto = $async$result.get$supportsGetScripts() ? 2 : 3;
              break;
            case 2:
              // then
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              t3 = isolate.id;
              t4 = t2._vmService;
              t4.toString;
              t5 = S.ScriptList;
              $async$goto = 5;
              return P._asyncAwait(t2._trackFuture$1$2("getScripts", t4._call$1$2(0, "getScripts", P.LinkedHashMap__makeLiteral(["isolateId", t3]), t5), t5), $async$_populateFromIsolate$2);
            case 5:
              // returning from await.
              t5 = $async$result.scripts;
              scripts = H.setRuntimeTypeInfo(t5.slice(0), [H.getTypeArgumentByIndex(t5, 0)]);
              t1.set$scripts(scripts);
              for (_i = 0; _i < 2; ++_i)
                scriptsViewers[_i].showScripts$4$selectRootScript(scripts, t1.rootLib.uri, t1.commonScriptPrefix, isRunning);
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_populateFromIsolate$2, $async$completer);
    },
    _displaySource$2: function(script, scriptRef) {
      var t1, t2, _this = this;
      if (script == null)
        _this.sourceEditor.displayScript$1(script);
      else {
        t1 = _this._sourcePathDiv;
        t2 = script.uri;
        t1.element.textContent = t2;
        _this.sourceEditor.displayScript$1(script);
        _this.sourceEditor.scriptRef = scriptRef;
      }
    },
    _displaySource$1: function(script) {
      return this._displaySource$2(script, null);
    },
    _retrieveFullStringValue$1: function(stringRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, t2, t3, result;
      var $async$_retrieveFullStringValue$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!stringRef.valueAsStringIsTruncated) {
                $async$returnValue = stringRef.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              t2 = $async$self.debuggerState.isolateRef.id;
              t3 = stringRef.id;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getObject", t1._vmService.getObject$2(0, t2, t3), P.Object), $async$_retrieveFullStringValue$1);
            case 3:
              // returning from await.
              result = $async$result;
              if (result instanceof S.Instance) {
                $async$returnValue = result.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = H.S(stringRef.valueAsString) + "...";
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_retrieveFullStringValue$1, $async$completer);
    }
  };
  X.DebuggerScreen_createContent__updateResumeButton.prototype = {
    call$1$disabled: function(disabled) {
      this.resumeButton.attribute$2("disabled", disabled);
    },
    call$0: function() {
      return this.call$1$disabled(null);
    },
    $signature: 61
  };
  X.DebuggerScreen_createContent__updatePauseButton.prototype = {
    call$1$disabled: function(disabled) {
      this.pauseButton.attribute$2("disabled", disabled);
    },
    call$0: function() {
      return this.call$1$disabled(null);
    },
    $signature: 61
  };
  X.DebuggerScreen_createContent_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("debugger", "resume", 0);
              t1 = $async$self._updateResumeButton;
              t1.call$1$disabled(true);
              t2 = $async$self.$this.debuggerState;
              $async$goto = 2;
              return P._asyncAwait(t2._service.resume$1(0, t2.isolateRef.id), $async$call$0);
            case 2:
              // returning from await.
              t1.call$1$disabled(false);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 17
  };
  X.DebuggerScreen_createContent_closure0.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2, t3, t4, t5;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("debugger", "pause", 0);
              t1 = $async$self._updatePauseButton;
              t1.call$1$disabled(true);
              t2 = $async$self.$this.debuggerState;
              t3 = t2._service;
              t2 = t2.isolateRef.id;
              t4 = t3._vmService;
              t4.toString;
              t5 = S.Success;
              $async$goto = 2;
              return P._asyncAwait(t3._trackFuture$1$2("pause", t4._call$1$2(0, "pause", P.LinkedHashMap__makeLiteral(["isolateId", t2]), t5), t5), $async$call$0);
            case 2:
              // returning from await.
              t1.call$1$disabled(false);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 17
  };
  X.DebuggerScreen_createContent_closure1.prototype = {
    call$1: function(isPaused) {
      H.boolTypeCheck(isPaused);
      this._updatePauseButton.call$1$disabled(isPaused);
      this._updateResumeButton.call$1$disabled(!H.boolConversionCheck(isPaused));
    },
    $signature: 9
  };
  X.DebuggerScreen_createContent_closure2.prototype = {
    call$1: function(mode) {
      var t1, t2;
      H.stringTypeCheck(mode);
      t1 = this.$this.debuggerState;
      t2 = t1._service;
      t1 = t1.isolateRef.id;
      t2._trackFuture$1$2("setExceptionPauseMode", t2._vmService.setExceptionPauseMode$2(t1, mode), S.Success);
    },
    $signature: 19
  };
  X.DebuggerScreen_createContent_closure3.prototype = {
    call$1: function(mode) {
      var t1, t2;
      H.stringTypeCheck(mode);
      t1 = this.breakOnExceptionControl;
      if (mode === "All") {
        t1._allElement.checked = true;
        t1 = t1._unhandledElement;
        t1.checked = true;
        t1.setAttribute("disabled", "");
      } else {
        t2 = t1._allElement;
        if (mode === "Unhandled") {
          t2.checked = false;
          t1 = t1._unhandledElement;
          t1.checked = true;
          t1.removeAttribute("disabled");
        } else {
          t2.checked = false;
          t1 = t1._unhandledElement;
          t1.checked = false;
          t1.removeAttribute("disabled");
        }
      }
    },
    $signature: 19
  };
  X.DebuggerScreen_createContent_closure4.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._matcher;
      if (t2 == null)
        t2 = t1._matcher = new X.ScriptsMatcher(t1.debuggerState, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List, S.ScriptRef]));
      t1.popupScriptsView._matcherRendering = t2;
    },
    $signature: 0
  };
  X.DebuggerScreen_createContent_closure5.prototype = {
    call$0: function() {
      P.Timer_Timer(C.Duration_200000, new X.DebuggerScreen_createContent__closure(this.$this));
    },
    $signature: 0
  };
  X.DebuggerScreen_createContent__closure.prototype = {
    call$0: function() {
      var t1 = this.$this._matcher;
      if (t1 != null) {
        t1 = t1._finishCallback;
        if (t1 != null)
          t1.call$0();
      }
      return;
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  X.DebuggerScreen_createContent_closure6.prototype = {
    call$1: function(e) {
      var t1, t2, value, t3;
      switch (H.interceptedTypeCheck(e, "$isKeyboardEvent").keyCode) {
        case 13:
        case 27:
        case 33:
        case 34:
        case 35:
        case 36:
        case 38:
        case 40:
          return;
        default:
          t1 = this.$this;
          t2 = t1._popupTextfield;
          value = J.trim$0$s(H.interceptedTypeCheck(t2.element, "$isInputElement").value);
          t3 = t1._matcher;
          if (t3._keyEventSubscription == null)
            t3.start$4(0, t1.sourceEditor.scriptRef, t1.popupScriptsView, t2, t1._popupView.get$hidePopup());
          t1._matcher.displayMatchingScripts$1(value);
      }
    },
    $signature: 14
  };
  X.DebuggerScreen_createContent_closure7.prototype = {
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isCoreElement").element;
    },
    $signature: 74
  };
  X.DebuggerScreen_createContent_closure8.prototype = {
    call$1: function(value) {
      var t1, t2,
        _s8_ = "disabled";
      H.boolTypeCheck(value);
      t1 = this._box_0;
      t2 = t1.stepIn;
      t2.toString;
      H.boolConversionCheck(value);
      t2.attribute$2(_s8_, !value);
      t2 = t1.stepOver;
      t2.attribute$2(_s8_, !(value && this.$this.debuggerState.lastEvent.topFrame != null));
      t1 = t1.stepOut;
      t1.attribute$2(_s8_, !(value && this.$this.debuggerState.lastEvent.topFrame != null));
    },
    $signature: 9
  };
  X.DebuggerScreen_createContent_closure9.prototype = {
    call$0: function() {
      return this.$this.debuggerState.stepOver$0();
    },
    $signature: 55
  };
  X.DebuggerScreen_createContent_closure10.prototype = {
    call$0: function() {
      var t1 = this.$this.debuggerState;
      F.select("debugger", "stepIn", 0);
      return t1._service.resume$2$step(0, t1.isolateRef.id, "Into");
    },
    $signature: 55
  };
  X.DebuggerScreen_createContent_closure11.prototype = {
    call$0: function() {
      var t1 = this.$this.debuggerState;
      F.select("debugger", "stepOut", 0);
      return t1._service.resume$2$step(0, t1.isolateRef.id, "Out");
    },
    $signature: 55
  };
  X.DebuggerScreen_createContent_closure12.prototype = {
    call$1: function(breakpoints) {
      return this.$call$body$DebuggerScreen_createContent_closure2(H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList"));
    },
    $call$body$DebuggerScreen_createContent_closure2: function(breakpoints) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.sourceEditor;
              t1.toString;
              t1.set$breakpoints(H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList"));
              t1._refreshMarkers$0();
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 192
  };
  X.DebuggerScreen_createContent_closure13.prototype = {
    call$1: function(paused) {
      return this.$call$body$DebuggerScreen_createContent_closure1(H.boolTypeCheck(paused));
    },
    $call$body$DebuggerScreen_createContent_closure1: function(paused) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t2, t3, t4, t5, t6, stack, $frames, reportedException, frame, newFrame, newVars, frames0, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = H.boolConversionCheck(paused) ? 2 : 4;
              break;
            case 2:
              // then
              t2 = t1.debuggerState;
              t3 = t2._service;
              t4 = t2.isolateRef.id;
              t5 = t3._vmService;
              t5.toString;
              t6 = S.Stack;
              $async$goto = 5;
              return P._asyncAwait(t3._trackFuture$1$2("getStack", t5._call$1$2(0, "getStack", P.LinkedHashMap__makeLiteral(["isolateId", t4]), t6), t6), $async$call$1);
            case 5:
              // returning from await.
              stack = $async$result;
              $frames = stack.asyncCausalFrames;
              if ($frames == null)
                $frames = stack.frames;
              reportedException = t2._reportedException;
              if (reportedException != null && $frames.length !== 0) {
                frame = C.JSArray_methods.get$first($frames);
                newFrame = new S.Frame(null);
                newFrame.type = frame.type;
                newFrame.index = frame.index;
                newFrame.$function = frame.$function;
                newFrame.code = frame.code;
                newFrame.location = frame.location;
                newFrame.kind = frame.kind;
                t2 = [S.BoundVariable];
                newVars = H.setRuntimeTypeInfo([], t2);
                t3 = new S.BoundVariable(null);
                t3.name = "<exception>";
                t3.value = reportedException;
                C.JSArray_methods.add$1(newVars, t3);
                t3 = frame.vars;
                C.JSArray_methods.addAll$1(newVars, t3 == null ? H.setRuntimeTypeInfo([], t2) : t3);
                newFrame.set$vars(newVars);
                frames0 = H.setRuntimeTypeInfo([newFrame], [S.Frame]);
                C.JSArray_methods.addAll$1(frames0, C.JSArray_methods.sublist$1($frames, 1));
                $frames = frames0;
              }
              t1 = t1.callStackView;
              t1.toString;
              t2 = [S.Frame];
              H.assertSubtype($frames, "$isList", t2, "$asList");
              if ($frames.length === 0) {
                frame = new S.Frame(null);
                frame.kind = "EmptyStackMarker";
                t3 = new S.CodeRef(null);
                t3.name = "<no call frames>";
                frame.code = t3;
                t1._callstack_view$_items.setItems$1(H.setRuntimeTypeInfo([frame], t2));
              } else {
                t1 = t1._callstack_view$_items;
                t2 = C.JSArray_methods.get$first($frames);
                t1.setItems$2$selection($frames, t2);
              }
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              t1.callStackView._callstack_view$_items.setItems$1(H.setRuntimeTypeInfo([], [S.Frame]));
              t1.sourceEditor.clearExecutionPoint$0();
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 87
  };
  X.DebuggerScreen_createContent_closure14.prototype = {
    call$1: function(paused) {
      return this.$call$body$DebuggerScreen_createContent_closure0(H.boolTypeCheck(paused));
    },
    $call$body$DebuggerScreen_createContent_closure0: function(paused) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, topFrame, scriptRef, position, file, t1, t2, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.boolConversionCheck(paused) && $async$self.$this.debuggerState.lastEvent.topFrame != null;
              t2 = $async$self.$this;
              $async$goto = t1 ? 2 : 4;
              break;
            case 2:
              // then
              t1 = t2.debuggerState;
              topFrame = t1.lastEvent.topFrame;
              scriptRef = topFrame.location.script;
              $async$temp1 = t1;
              $async$goto = 5;
              return P._asyncAwait(t1.getScript$1(scriptRef), $async$call$1);
            case 5:
              // returning from await.
              position = $async$temp1.calculatePosition$2($async$result, topFrame.location.tokenPos);
              t1 = scriptRef.uri;
              file = C.JSString_methods.substring$1(t1, J.lastIndexOf$1$s(t1, "/") + 1);
              t2.deviceStatus.element.element.textContent = "paused at " + file + " " + H.S(position.line) + ":" + H.S(position.column);
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              t2.deviceStatus.element.element.textContent = "";
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 87
  };
  X.DebuggerScreen_createContent_closure15.prototype = {
    call$1: function(frame) {
      return this.$call$body$DebuggerScreen_createContent_closure(H.interceptedTypeCheck(frame, "$isFrame"));
    },
    $call$body$DebuggerScreen_createContent_closure: function(frame) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1, $location, t2, script, position, t3, t4;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = frame == null ? 3 : 5;
              break;
            case 3:
              // then
              t1 = $async$self.$this;
              t1.callStackView._callstack_view$_items.setItems$1(H.setRuntimeTypeInfo([], [S.Frame]));
              t1.variablesView._items.setItems$1(H.setRuntimeTypeInfo([], [S.BoundVariable]));
              t1.sourceEditor.clearExecutionPoint$0();
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $location = frame.location;
              $async$goto = $location != null ? 6 : 7;
              break;
            case 6:
              // then
              t1 = $async$self.$this;
              t2 = t1.debuggerState;
              $async$goto = 8;
              return P._asyncAwait(t2.getScript$1($location.script), $async$call$1);
            case 8:
              // returning from await.
              script = $async$result;
              position = t2.calculatePosition$2(script, $location.tokenPos);
              t2 = t1._sourcePathDiv;
              t3 = script.uri;
              t2.element.textContent = t3;
              t1 = t1.sourceEditor;
              t1.executionPoint = new X.ScriptAndPosition(script, position);
              t1.displayScript$2$scrollTo(script, position);
              t3 = t1._executionPointElement;
              if (t3 != null)
                t3.dispose$0();
              t1._executionPointElement = null;
              if (script.source != null && position != null) {
                t2 = A.CoreElement$("span", null, "octicon octicon-arrow-up execution-marker", null, null);
                t1._executionPointElement = t2;
                t1 = t1.codeMirror;
                t3 = position.line;
                if (typeof t3 !== "number") {
                  $async$returnValue = t3.$sub();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t4 = position.column;
                if (typeof t4 !== "number") {
                  $async$returnValue = t4.$sub();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1.jsProxy.callMethod$2("addWidget", [new X.Position(t3 - 1, t4 - 1).toProxy$0(), t2.element, false]);
              }
            case 7:
              // join
              t1 = $async$self.$this.variablesView._items;
              t2 = frame.vars;
              t1.setItems$1(t2 == null ? H.setRuntimeTypeInfo([], [S.BoundVariable]) : t2);
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 196
  };
  X.DebuggerScreen_createContent_closure16.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isBusEvent");
      this.$this.consoleArea._editor.getDoc$0().jsProxy.callMethod$2("setValue", [""]);
    },
    $signature: 21
  };
  X.DebuggerScreen_createContent_closure17.prototype = {
    call$1: function($event) {
      H.interceptedTypeCheck($event, "$isBusEvent");
      this.$this.consoleArea.appendText$1(0, H.S($event.data) + "\n\n");
    },
    $signature: 21
  };
  X.DebuggerScreen_createContent_closure18.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isBusEvent");
      this.$this.consoleArea._editor.getDoc$0().jsProxy.callMethod$2("setValue", [""]);
    },
    $signature: 21
  };
  X.DebuggerScreen_createContent_closure19.prototype = {
    call$1: function($event) {
      H.interceptedTypeCheck($event, "$isBusEvent");
      this.$this.consoleArea.appendText$1(0, H.S($event.data) + "\n\n");
    },
    $signature: 21
  };
  X.DebuggerScreen__hookupListeners_closure.prototype = {
    call$1: function(scriptRef) {
      return this.$call$body$DebuggerScreen__hookupListeners_closure(H.interceptedTypeCheck(scriptRef, "$isScriptRef"));
    },
    $call$body$DebuggerScreen__hookupListeners_closure: function(scriptRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t1, t2, isolateRef, t3, t4, result;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.scriptsView._scripts_view$_items._hadClicked) {
                t1 = $async$self.$this._matcher;
                t1 = t1 != null && t1._keyEventSubscription != null;
              } else
                t1 = false;
              if (t1)
                $async$self.$this._matcher.reset$0(0);
              t1 = $async$self.$this;
              t2 = t1._matcher;
              if (t2 != null && t2._keyEventSubscription != null) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (scriptRef == null) {
                t1._displaySource$1(null);
                // goto return
                $async$goto = 1;
                break;
              }
              isolateRef = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate;
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              t3 = isolateRef.id;
              t4 = scriptRef.id;
              $async$goto = 3;
              return P._asyncAwait(t2._trackFuture$1$2("getObject", t2._vmService.getObject$2(0, t3, t4), P.Object), $async$call$1);
            case 3:
              // returning from await.
              result = $async$result;
              if (result instanceof S.Script)
                t1._displaySource$2(result, scriptRef);
              else
                t1._displaySource$1(null);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 204
  };
  X.DebuggerScreen__buildMenuNav_closure.prototype = {
    call$1: function(variable) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, result, t2, value, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              value = variable.value;
              t1 = J.getInterceptor$(value);
              if (!!t1.$isSentinel) {
                $async$returnValue = value.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              }
              if (!!t1.$isTypeArgumentsRef) {
                $async$returnValue = value.name;
                // goto return
                $async$goto = 1;
                break;
              }
              H.interceptedTypeCheck(value, "$isInstanceRef");
              t1 = value.valueAsString;
              $async$goto = t1 != null && !value.valueAsStringIsTruncated ? 3 : 5;
              break;
            case 3:
              // then
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = $async$self.$this;
              $async$goto = 6;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.invoke$5$disableBreakpoints(t1.debuggerState.isolateRef.id, value.id, "toString", H.setRuntimeTypeInfo([], [P.String]), true), $async$call$1);
            case 6:
              // returning from await.
              result = $async$result;
              t2 = J.getInterceptor$(result);
              $async$goto = !!t2.$isErrorRef ? 7 : 9;
              break;
            case 7:
              // then
              $async$returnValue = H.S(result.kind) + " " + H.S(result.message);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = !!t2.$isInstanceRef ? 10 : 12;
              break;
            case 10:
              // then
              $async$goto = 13;
              return P._asyncAwait(t1._retrieveFullStringValue$1(result), $async$call$1);
            case 13:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 11;
              break;
            case 12:
              // else
              // goto return
              $async$goto = 1;
              break;
            case 11:
              // join
            case 8:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 208
  };
  X.DebuggerScreen__buildMenuNav_closure0.prototype = {
    call$1: function(breakpoint) {
      return this.$call$body$DebuggerScreen__buildMenuNav_closure(H.interceptedTypeCheck(breakpoint, "$isBreakpoint"));
    },
    $call$body$DebuggerScreen__buildMenuNav_closure: function(breakpoint) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t2, script, pos, $location, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $location = breakpoint.location;
              t1 = J.getInterceptor$($location);
              $async$goto = !!t1.$isSourceLocation ? 3 : 5;
              break;
            case 3:
              // then
              t1 = $async$self.$this;
              t2 = t1.debuggerState;
              $async$goto = 6;
              return P._asyncAwait(t2.getScript$1($location.script), $async$call$1);
            case 6:
              // returning from await.
              script = $async$result;
              pos = t2.calculatePosition$2(script, $location.tokenPos);
              t1 = t1.sourceEditor;
              t2 = pos.line;
              if (typeof t2 !== "number") {
                $async$returnValue = t2.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              t1.displayScript$2$scrollTo(script, new X.SourcePosition(t2 - 1, null));
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = !!t1.$isUnresolvedSourceLocation ? 7 : 8;
              break;
            case 7:
              // then
              t1 = $async$self.$this;
              $async$goto = 9;
              return P._asyncAwait(t1.debuggerState.getScript$1($location.script), $async$call$1);
            case 9:
              // returning from await.
              script = $async$result;
              t1 = t1.sourceEditor;
              t2 = $location.line;
              if (typeof t2 !== "number") {
                $async$returnValue = t2.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              t1.displayScript$2$scrollTo(script, new X.SourcePosition(t2 - 1, null));
            case 8:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 209
  };
  X.DebuggerScreen__buildMenuNav_closure1.prototype = {
    call$1: function(_) {
      this.scriptCountDiv.element.textContent = J.toString$0$(J.get$length$asx(this.$this.scriptsView._scripts_view$_items.items));
    },
    $signature: 49
  };
  X.DebuggerScreen__buildMenuNav_closure2.prototype = {
    call$0: function() {
      return this.$this.callStackView._callstack_view$_items.attribute$2("hidden", null);
    },
    $signature: 1
  };
  X.DebuggerScreen__buildMenuNav_closure3.prototype = {
    call$0: function() {
      return this.$this.variablesView._items.attribute$2("hidden", null);
    },
    $signature: 1
  };
  X.DebuggerScreen__buildMenuNav_closure4.prototype = {
    call$0: function() {
      return this.$this.breakpointsView._breakpoints_view$_items.attribute$2("hidden", null);
    },
    $signature: 1
  };
  X.DebuggerScreen__buildMenuNav_closure5.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._matcher;
      if (t2 == null)
        t2 = t1._matcher = new X.ScriptsMatcher(t1.debuggerState, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List, S.ScriptRef]));
      t1.scriptsView._matcherRendering = t2;
    },
    $signature: 0
  };
  X.DebuggerScreen__buildMenuNav_closure6.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._matcher;
      if (t2 == null)
        t2 = t1._matcher = new X.ScriptsMatcher(t1.debuggerState, P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List, S.ScriptRef]));
      t1.scriptsView._matcherRendering = t2;
    },
    $signature: 0
  };
  X.DebuggerScreen__buildMenuNav_closure7.prototype = {
    call$1: function(e) {
      var t1, value, t2, t3;
      switch (H.interceptedTypeCheck(e, "$isKeyboardEvent").keyCode) {
        case 13:
        case 27:
        case 33:
        case 34:
        case 35:
        case 36:
        case 38:
        case 40:
          return;
        default:
          t1 = this.textfield;
          value = J.trim$0$s(H.interceptedTypeCheck(t1.element, "$isInputElement").value);
          t2 = this.$this;
          t3 = t2._matcher;
          if (t3._keyEventSubscription == null)
            t3.start$3(0, t2.sourceEditor.scriptRef, t2.scriptsView, t1);
          t2._matcher.displayMatchingScripts$1(value);
      }
    },
    $signature: 14
  };
  X.DebuggerScreen__buildMenuNav_closure8.prototype = {
    call$0: function() {
      return this.$this.scriptsView._scripts_view$_items.attribute$2("hidden", null);
    },
    $signature: 1
  };
  X.DebuggerScreen__buildMenuNav_closure9.prototype = {
    call$1: function(breakpoints) {
      var t1, t2;
      H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
      t1 = this.$this.breakpointsView;
      t1.toString;
      breakpoints = J.toList$0$ax(breakpoints);
      C.JSArray_methods.sort$1(breakpoints, F.breakpoints_view___breakpointComparator$closure());
      t1._breakpoints_view$_items.setItems$1(breakpoints);
      t1 = t1._breakpoints_view$_breakpointsCountDiv;
      t2 = C.JSInt_methods.toString$0(breakpoints.length);
      t1.element.textContent = t2;
    },
    $signature: 213
  };
  X.DebuggerScreen__handleConnectionStart_closure.prototype = {
    call$1: function(e) {
      var message = C.C_Utf8Codec.decode$1(0, C.C_Base64Decoder.convert$1(H.interceptedTypeCheck(e, "$isEvent0").bytes));
      this.$this.consoleArea.appendText$1(0, message);
    },
    $signature: 34
  };
  X.DebuggerScreen__handleConnectionStart_closure0.prototype = {
    call$1: function(e) {
      var message = C.C_Utf8Codec.decode$1(0, C.C_Base64Decoder.convert$1(H.interceptedTypeCheck(e, "$isEvent0").bytes));
      this.$this.consoleArea.appendText$1(0, message);
    },
    $signature: 34
  };
  X.DebuggerScreen__handleIsolateChanged_closure.prototype = {
    call$1: function(result) {
      var t1 = this.$this,
        t2 = t1.scriptsView;
      if (result instanceof S.Isolate)
        t1._populateFromIsolate$2(result, H.setRuntimeTypeInfo([t2, t1.popupScriptsView], [X.ScriptsView]));
      else {
        t1 = t2._scripts_view$_items;
        t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
      }
    },
    $signature: 2
  };
  X.DebuggerScreen__handleIsolateChanged_closure0.prototype = {
    call$1: function(e) {
      this.$this.framework.showError$2("Error retrieving isolate information", e);
    },
    $signature: 2
  };
  X.SourcePosition.prototype = {
    toString$0: function(_) {
      return H.S(this.line) + " " + H.S(this.column);
    }
  };
  X.SourceEditor.prototype = {
    SourceEditor$2: function(codeMirror, debuggerState) {
      this.codeMirror.onEvent$1$2$argCount("gutterClick", 4, P.int).listen$1(new X.SourceEditor_closure(this));
    },
    _refreshMarkers$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, line, _this = this, _null = null,
        _s29_ = "octicon octicon-primitive-dot",
        _s15_ = "setGutterMarker",
        t1 = _this.codeMirror.jsProxy;
      t1.callMethod$2("clearGutter", ["breakpoints"]);
      t2 = _this.linesToBreakpoints;
      t2.clear$0(0);
      if (_this.currentScript == null)
        return;
      for (t3 = J.get$iterator$ax(_this.breakpoints), t4 = _this.debuggerState; t3.moveNext$0();) {
        t5 = t3.get$current(t3);
        t6 = t5.location;
        t7 = J.getInterceptor$(t6);
        if (!!t7.$isSourceLocation) {
          t7 = t6.script.id;
          t8 = _this.currentScript;
          if (t7 != t8.id)
            continue;
          t6 = t4.calculatePosition$2(t8, t6.tokenPos).line;
          if (typeof t6 !== "number")
            return t6.$sub();
          line = t6 - 1;
          J.add$1$ax(t2.putIfAbsent$2(0, line, new X.SourceEditor__refreshMarkers_closure()), t5);
          t1.callMethod$2(_s15_, [line, "breakpoints", A.CoreElement$("span", _null, _s29_, _null, _null).element]);
        } else if (!!t7.$isUnresolvedSourceLocation) {
          if (t6.script.id != _this.currentScript.id)
            continue;
          t6 = t6.line;
          if (typeof t6 !== "number")
            return t6.$sub();
          line = t6 - 1;
          J.add$1$ax(t2.putIfAbsent$2(0, line, new X.SourceEditor__refreshMarkers_closure0()), t5);
          t1.callMethod$2(_s15_, [line, "breakpoints", A.CoreElement$("span", _null, _s29_, _null, _null).element]);
        }
      }
      t1 = _this.executionPoint;
      if (t1 != null) {
        t2 = _this.currentScript;
        t2 = t1.script.uri == t2.uri;
      } else
        t2 = false;
      if (t2) {
        t1 = t1.position;
        if (t1 != null) {
          t1 = t1.line;
          if (typeof t1 !== "number")
            return t1.$sub();
          _this._showLineClass$1(t1 - 1);
        }
      }
    },
    _clearLineClass$0: function() {
      var _this = this,
        t1 = _this._currentLineClass;
      if (t1 != null) {
        _this.codeMirror.removeLineClass$3(t1, "background", "executionLine");
        _this._currentLineClass = null;
      }
      t1 = _this._executionPointElement;
      if (t1 != null)
        t1.dispose$0();
      _this._executionPointElement = null;
    },
    _showLineClass$1: function(line) {
      var _this = this;
      if (_this._currentLineClass === line)
        return;
      _this._clearLineClass$0();
      _this._currentLineClass = line;
      H.interceptedTypeCheck(_this.codeMirror.jsProxy.callMethod$2("addLineClass", [line, "background", "executionLine"]), "$isJsObject");
    },
    clearExecutionPoint$0: function() {
      this.executionPoint = null;
      this._clearLineClass$0();
      this._refreshMarkers$0();
    },
    displayScript$2$scrollTo: function(newScript, $scrollTo) {
      var t1, t2, t3, source, $top, _this = this,
        _s8_ = "setValue";
      if (_this.currentScript != null) {
        t1 = H.interceptedTypeCheck(_this.codeMirror.jsProxy.callMethod$1("getScrollInfo"), "$isJsObject");
        _this._lastScrollPositions.$indexSet(0, _this.currentScript.uri, H.numTypeCheck(t1.$index(0, "top")));
      }
      t1 = _this.currentScript;
      t1 = t1 == null ? null : t1.uri;
      t2 = newScript == null;
      t3 = t2 ? null : newScript.uri;
      _this.currentScript = newScript;
      if (t2)
        _this.codeMirror.getDoc$0().jsProxy.callMethod$2(_s8_, [""]);
      else {
        if (t1 != t3) {
          source = newScript.source;
          if (source == null)
            source = "<source not available>";
          _this.codeMirror.getDoc$0().jsProxy.callMethod$2(_s8_, [source]);
        }
        if ($scrollTo != null) {
          t1 = $scrollTo.line;
          if (typeof t1 !== "number")
            return t1.$sub();
          _this.codeMirror.scrollIntoView$3$margin(0, t1 - 1, 0, 150);
        } else {
          $top = _this._lastScrollPositions.$index(0, newScript.uri);
          if ($top == null)
            $top = 0;
          _this.codeMirror.jsProxy.callMethod$2("scrollTo", [0, $top]);
        }
      }
      t1 = _this._executionPointElement;
      if (t1 != null)
        t1.dispose$0();
      _this._executionPointElement = null;
      _this._refreshMarkers$0();
    },
    displayScript$1: function(newScript) {
      return this.displayScript$2$scrollTo(newScript, null);
    },
    set$breakpoints: function(breakpoints) {
      this.breakpoints = H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
    }
  };
  X.SourceEditor_closure.prototype = {
    call$1: function(line) {
      var t1, lineBps, t2, t3;
      H.intTypeCheck(line);
      t1 = this.$this;
      lineBps = t1.linesToBreakpoints.$index(0, line);
      t2 = lineBps == null || J.get$isEmpty$asx(lineBps);
      t3 = t1.debuggerState;
      if (t2) {
        t1 = t1.currentScript.id;
        if (typeof line !== "number")
          return line.$add();
        t3._service.addBreakpoint$3(t3.isolateRef.id, t1, line + 1).catchError$1(new X.SourceEditor__closure());
      } else
        t3.removeBreakpoint$1(J.removeAt$1$ax(lineBps, 0)).catchError$1(new X.SourceEditor__closure0());
    },
    $signature: 63
  };
  X.SourceEditor__closure.prototype = {
    call$1: function(_) {
    },
    $signature: 2
  };
  X.SourceEditor__closure0.prototype = {
    call$1: function(_) {
    },
    $signature: 2
  };
  X.SourceEditor__refreshMarkers_closure.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [S.Breakpoint]);
    },
    $signature: 70
  };
  X.SourceEditor__refreshMarkers_closure0.prototype = {
    call$0: function() {
      return H.setRuntimeTypeInfo([], [S.Breakpoint]);
    },
    $signature: 70
  };
  X.ScriptAndPosition.prototype = {};
  S.DebuggerState.prototype = {
    switchToIsolate$1: function(ref) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t1, t2, t3, result;
      var $async$switchToIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.isolateRef = ref;
              $async$self._updatePaused$1(false);
              $async$self._scriptCache.clear$0(0);
              $async$self._reportedException = $async$self.lastEvent = null;
              if (ref == null) {
                $async$self._breakpoints.add$1(0, H.setRuntimeTypeInfo([], [S.Breakpoint]));
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self._service;
              t2 = $async$self.isolateRef.id;
              t3 = t1._vmService;
              t3.toString;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t3._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null), $async$switchToIsolate$1);
            case 3:
              // returning from await.
              result = $async$result;
              if (result instanceof S.Isolate) {
                t1 = result.pauseEvent;
                if (t1 != null && t1.kind !== "Resume") {
                  $async$self.lastEvent = t1;
                  $async$self._reportedException = t1.exception;
                  $async$self._updatePaused$1(true);
                }
                $async$self._breakpoints.add$1(0, result.breakpoints);
                $async$self._exceptionPauseMode.add$1(0, result.exceptionPauseMode);
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$switchToIsolate$1, $async$completer);
    },
    stepOver$0: function() {
      var t1, t2, t3;
      F.select("debugger", "stepOver", 0);
      t1 = this.lastEvent;
      t1 = t1 == null ? null : t1.atAsyncSuspension;
      t2 = this._service;
      t3 = this.isolateRef.id;
      return t2.resume$2$step(0, t3, t1 === true ? "OverAsyncSuspension" : "Over");
    },
    clearBreakpoints$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$clearBreakpoints$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(P.Future_forEach(J.toList$0$ax($async$self._breakpoints._wrapper.latestValue), new S.DebuggerState_clearBreakpoints_closure($async$self), S.Breakpoint), $async$clearBreakpoints$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$clearBreakpoints$0, $async$completer);
    },
    addBreakpointByPathFragment$2: function(path, line) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, ref;
      var $async$addBreakpointByPathFragment$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.scripts;
              ref = (t1 && C.JSArray_methods).firstWhere$2$orElse(t1, new S.DebuggerState_addBreakpointByPathFragment_closure(path), new S.DebuggerState_addBreakpointByPathFragment_closure0());
              if (ref != null) {
                $async$returnValue = $async$self._service.addBreakpoint$3($async$self.isolateRef.id, ref.id, line);
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$addBreakpointByPathFragment$2, $async$completer);
    },
    removeBreakpoint$1: function(breakpoint) {
      var t5,
        _s16_ = "removeBreakpoint",
        t1 = this._service,
        t2 = this.isolateRef.id,
        t3 = breakpoint.id,
        t4 = t1._vmService;
      t4.toString;
      t5 = S.Success;
      return t1._trackFuture$1$2(_s16_, t4._call$1$2(0, _s16_, P.LinkedHashMap__makeLiteral(["isolateId", t2, "breakpointId", t3]), t5), t5);
    },
    _debugger_state$_handleIsolateEvent$1: function($event) {
      var t1, t2, _this = this;
      H.interceptedTypeCheck($event, "$isEvent0");
      if ($event.isolate.id != _this.isolateRef.id)
        return;
      _this._supportsStepping.add$1(0, $event.topFrame != null);
      _this.lastEvent = $event;
      switch ($event.kind) {
        case "Resume":
          _this._updatePaused$1(false);
          _this._reportedException = null;
          break;
        case "PauseStart":
        case "PauseExit":
        case "PauseBreakpoint":
        case "PauseInterrupted":
        case "PauseException":
        case "PausePostRequest":
          _this._reportedException = $event.exception;
          _this._updatePaused$1(true);
          break;
        case "BreakpointAdded":
          t1 = _this._breakpoints;
          t2 = t1._wrapper;
          J.add$1$ax(t2.latestValue, $event.breakpoint);
          t1.add$1(0, t2.latestValue);
          break;
        case "BreakpointResolved":
          t1 = _this._breakpoints;
          t2 = t1._wrapper;
          J.remove$1$ax(t2.latestValue, $event.breakpoint);
          J.add$1$ax(t2.latestValue, $event.breakpoint);
          t1.add$1(0, t2.latestValue);
          break;
        case "BreakpointRemoved":
          t1 = _this._breakpoints;
          t2 = t1._wrapper;
          J.remove$1$ax(t2.latestValue, $event.breakpoint);
          t1.add$1(0, t2.latestValue);
          break;
      }
    },
    _updatePaused$1: function(value) {
      var t1 = this._paused;
      if (!J.$eq$(t1._wrapper.latestValue, value))
        t1.add$1(0, value);
    },
    getScript$1: function(scriptRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Script),
        $async$returnValue, $async$self = this, t2, t3, t4, t1, $async$temp1, $async$temp2, $async$temp3;
      var $async$getScript$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._scriptCache;
              $async$goto = !t1.containsKey$1(0, scriptRef.id) ? 3 : 4;
              break;
            case 3:
              // then
              t2 = scriptRef.id;
              t3 = $async$self._service;
              t4 = $async$self.isolateRef.id;
              $async$temp1 = t1;
              $async$temp2 = t2;
              $async$temp3 = H;
              $async$goto = 5;
              return P._asyncAwait(t3._trackFuture$1$2("getObject", t3._vmService.getObject$2(0, t4, t2), P.Object), $async$getScript$1);
            case 5:
              // returning from await.
              $async$temp1.$indexSet(0, $async$temp2, $async$temp3.interceptedTypeCheck($async$result, "$isScript"));
            case 4:
              // join
              $async$returnValue = t1.$index(0, scriptRef.id);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getScript$1, $async$completer);
    },
    calculatePosition$2: function(script, tokenPos) {
      var t1, _i, row, t2, line, index, t3,
        table = script.tokenPosTable;
      if (table == null)
        return;
      for (t1 = table.length, _i = 0; _i < table.length; table.length === t1 || (0, H.throwConcurrentModificationError)(table), ++_i) {
        row = table[_i];
        if (row == null || J.get$isEmpty$asx(row))
          continue;
        t2 = J.getInterceptor$ax(row);
        line = t2.elementAt$1(row, 0);
        index = 1;
        while (true) {
          t3 = t2.get$length(row);
          if (typeof t3 !== "number")
            return t3.$sub();
          if (!(index < t3 - 1))
            break;
          if (J.$eq$(t2.elementAt$1(row, index), tokenPos))
            return new X.SourcePosition(line, t2.elementAt$1(row, index + 1));
          index += 2;
        }
      }
      return;
    },
    getShortScriptName$1: function(uri) {
      var t1 = this.commonScriptPrefix;
      if (t1 == null)
        return uri;
      if (!J.getInterceptor$s(uri).startsWith$1(uri, t1))
        return uri;
      if (C.JSString_methods.startsWith$1(t1, "package:"))
        return C.JSString_methods.substring$1(uri, 8);
      else
        return C.JSString_methods.substring$1(uri, t1.length);
    },
    set$_debugSubscription: function(_debugSubscription) {
      this._debugSubscription = H.assertSubtype(_debugSubscription, "$isStreamSubscription", [S.Event0], "$asStreamSubscription");
    },
    set$scripts: function(scripts) {
      this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
    }
  };
  S.DebuggerState_clearBreakpoints_closure.prototype = {
    call$1: function(breakpoint) {
      return this.$this.removeBreakpoint$1(H.interceptedTypeCheck(breakpoint, "$isBreakpoint"));
    },
    $signature: 241
  };
  S.DebuggerState_addBreakpointByPathFragment_closure.prototype = {
    call$1: function(ref) {
      return J.endsWith$1$s(H.interceptedTypeCheck(ref, "$isScriptRef").uri, this.path);
    },
    $signature: 44
  };
  S.DebuggerState_addBreakpointByPathFragment_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  X.ListDirection.prototype = {
    toString$0: function(_) {
      return this._scripts_view$_name;
    }
  };
  X.PopupView.prototype = {
    hidePopup$0: function() {
      var inputElement, _this = this,
        t1 = _this._scripts_view$_sourcePathDiv.element.style,
        t2 = _this._oldSourceNameTextColor;
      t1.toString;
      t1.color = t2 == null ? "" : t2;
      t1 = _this.element.style;
      t1.display = "none";
      inputElement = H.interceptedTypeCheck(_this._scripts_view$_popupTextfield.element, "$isInputElement");
      inputElement.value = "";
      t1 = inputElement.style;
      t1.display = "none";
      _this._poppedUp = false;
    }
  };
  X.ScriptsView.prototype = {
    ScriptsView$1: function(uriDescriber) {
      var _null = null,
        t1 = S.ScriptRef,
        t2 = H.setRuntimeTypeInfo([], [t1]),
        t3 = [t1];
      t1 = new N.SelectableList(t2, new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, t3), new P._AsyncBroadcastStreamController(_null, _null, [-1]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"), [t1]);
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.flex$0(0);
      t1.clazz$1("debugger-items-list");
      this.set$_scripts_view$_items(t1);
      t1 = this._scripts_view$_items;
      t1.set$renderer(H.functionTypeCheck(new X.ScriptsView_closure(this, uriDescriber), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    scrollAndHighlight$3$top: function(row, topPosition, $top) {
      var newElement, _this = this,
        t1 = H.interceptedTypeCheck(J.$index$asx(_this._scripts_view$_items.items, row), "$isScriptRef");
      _this._highlightRef = t1;
      newElement = H.functionTypeCheck(_this._scripts_view$_items.renderer, {func: 1, ret: A.CoreElement, args: [S.ScriptRef]}).call$1(t1);
      _this._scripts_view$_items.setReplace$2(row, _this._highlightRef);
      if (topPosition !== -1) {
        t1 = _this._scripts_view$_items.element;
        t1.toString;
        t1.scrollTop = C.JSInt_methods.round$0(topPosition);
      }
      if (newElement != null)
        newElement.scrollIntoView$2$bottom$top(0, false, $top);
    },
    scrollAndHighlight$2: function(row, topPosition) {
      return this.scrollAndHighlight$3$top(row, topPosition, false);
    },
    page$2: function(_, direction, startRow) {
      var itemsVis, itemIndex, childToScrollTo, _this = this,
        t1 = _this._scripts_view$_items.element,
        listHeight = t1.clientHeight,
        itemHeight = J.get$children$x(t1).$index(0, 0).clientHeight;
      if (typeof listHeight !== "number")
        return listHeight.$div();
      if (typeof itemHeight !== "number")
        return H.iae(itemHeight);
      itemsVis = C.JSDouble_methods.toInt$0(listHeight / itemHeight) - 1;
      switch (direction) {
        case C.ListDirection_1:
          if (typeof startRow !== "number")
            return startRow.$add();
          itemIndex = startRow + itemsVis;
          t1 = J.get$length$asx(_this._scripts_view$_items.items);
          if (typeof t1 !== "number")
            return t1.$sub();
          if (itemIndex > t1 - 1) {
            t1 = J.get$length$asx(_this._scripts_view$_items.items);
            if (typeof t1 !== "number")
              return t1.$sub();
            itemIndex = t1 - 1;
          }
          _this.scrollAndHighlight$3$top(itemIndex, startRow > 0 ? startRow * itemHeight : 0, true);
          childToScrollTo = itemIndex;
          break;
        case C.ListDirection_0:
          if (typeof startRow !== "number")
            return startRow.$sub();
          itemIndex = startRow - itemsVis;
          if (itemIndex < 0)
            itemIndex = 0;
          _this.scrollAndHighlight$3$top(itemIndex, itemIndex > 0 ? itemIndex * itemHeight : 0, true);
          childToScrollTo = itemIndex;
          break;
        case C.ListDirection_2:
          _this.scrollAndHighlight$2(0, 0);
          childToScrollTo = 0;
          break;
        case C.ListDirection_3:
          t1 = J.get$length$asx(_this._scripts_view$_items.items);
          if (typeof t1 !== "number")
            return t1.$sub();
          childToScrollTo = t1 - 1;
          _this.scrollAndHighlight$2(childToScrollTo, childToScrollTo > 0 ? (childToScrollTo - itemsVis) * itemHeight : 0);
          break;
        default:
          childToScrollTo = null;
      }
      return childToScrollTo;
    },
    page$1: function($receiver, direction) {
      return this.page$2($receiver, direction, 0);
    },
    get$element: function() {
      return this._scripts_view$_items;
    },
    showScripts$5$selectRootScript$selectScriptRef: function(scripts, rootLib, commonPrefix, selectRootScript, selectScriptRef) {
      var t1, selection;
      H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
      t1 = J.getInterceptor$ax(scripts);
      t1.sort$1(scripts, new X.ScriptsView_showScripts_closure(this, commonPrefix));
      if (selectRootScript)
        selection = t1.firstWhere$2$orElse(scripts, new X.ScriptsView_showScripts_closure0(rootLib), new X.ScriptsView_showScripts_closure1());
      else
        selection = selectScriptRef != null ? selectScriptRef : null;
      this._scripts_view$_items.setItems$3$scrollSelectionIntoView$selection(scripts, true, selection);
    },
    showScripts$4$selectRootScript: function(scripts, rootLib, commonPrefix, selectRootScript) {
      return this.showScripts$5$selectRootScript$selectScriptRef(scripts, rootLib, commonPrefix, selectRootScript, null);
    },
    showScripts$3: function(scripts, rootLib, commonPrefix) {
      return this.showScripts$5$selectRootScript$selectScriptRef(scripts, rootLib, commonPrefix, false, null);
    },
    showScripts$4$selectScriptRef: function(scripts, rootLib, commonPrefix, selectScriptRef) {
      return this.showScripts$5$selectRootScript$selectScriptRef(scripts, rootLib, commonPrefix, false, selectScriptRef);
    },
    _convertDartInternalUris$1: function(uri) {
      if (J.startsWith$1$s(uri, "dart:_"))
        return H.stringReplaceAllUnchecked(uri, "dart:_", "dart:");
      else
        return uri;
    },
    set$_scripts_view$_items: function(_items) {
      this._scripts_view$_items = H.assertSubtype(_items, "$isSelectableList", [S.ScriptRef], "$asSelectableList");
    },
    $isCoreElementView: 1
  };
  X.ScriptsView_closure.prototype = {
    call$1: function(scriptRef) {
      var matchPart, startIndex, firstPart, endBoldIndex, boldPart, endPart, element, _null = null,
        _s9_ = "list-item",
        uri = H.interceptedTypeCheck(scriptRef, "$isScriptRef").uri,
        $name = this.uriDescriber.call$1(uri),
        t1 = this.$this._matcherRendering;
      if (t1 != null && t1._keyEventSubscription != null) {
        matchPart = H.interceptedTypeCast(t1._textfield.element, "$isInputElement").value;
        startIndex = J.getInterceptor$s($name).lastIndexOf$1($name, matchPart);
        firstPart = C.JSString_methods.substring$2($name, 0, startIndex);
        endBoldIndex = startIndex + matchPart.length;
        boldPart = C.JSString_methods.substring$2($name, startIndex, endBoldIndex);
        endPart = C.JSString_methods.substring$1($name, endBoldIndex);
        element = A.CoreElement$("li", _null, _s9_, J.get$innerHtml$x(W.Element_Element$html("<div>" + firstPart + '<strong class="strong-match">' + boldPart + "</strong>" + endPart + "</div>", _null, _null)), _null);
      } else
        element = A.CoreElement$("li", _null, _s9_, _null, $name);
      element.element.title = uri;
      return element;
    },
    $signature: 253
  };
  X.ScriptsView_showScripts_closure.prototype = {
    call$2: function(ref1, ref2) {
      var uri1, uri2, t1, t2, _s5_ = "dart:";
      H.interceptedTypeCheck(ref1, "$isScriptRef");
      H.interceptedTypeCheck(ref2, "$isScriptRef");
      uri1 = ref1.uri;
      uri2 = ref2.uri;
      t1 = this.$this;
      uri1 = t1._convertDartInternalUris$1(uri1);
      uri2 = t1._convertDartInternalUris$1(uri2);
      t1 = this.commonPrefix;
      if (t1 != null) {
        t2 = C.JSString_methods.startsWith$1(uri1, t1);
        if (t2 && !C.JSString_methods.startsWith$1(uri2, t1))
          return -1;
        else if (!t2 && C.JSString_methods.startsWith$1(uri2, t1))
          return 1;
      }
      t1 = C.JSString_methods.startsWith$1(uri1, _s5_);
      if (t1 && !C.JSString_methods.startsWith$1(uri2, _s5_))
        return 1;
      else if (!t1 && C.JSString_methods.startsWith$1(uri2, _s5_))
        return -1;
      return C.JSString_methods.compareTo$1(uri1, uri2);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 256
  };
  X.ScriptsView_showScripts_closure0.prototype = {
    call$1: function(script) {
      return H.interceptedTypeCheck(script, "$isScriptRef").uri == this.rootLib;
    },
    $signature: 44
  };
  X.ScriptsView_showScripts_closure1.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  X.ScriptsMatcher.prototype = {
    start$4: function(_, revertScriptRef, scriptView, textfield, finishCallback) {
      var t1, t2, _this = this;
      _this._scriptsView = scriptView;
      _this._textfield = textfield;
      if (finishCallback != null)
        _this._finishCallback = finishCallback;
      _this._startMatching$2(revertScriptRef, true);
      if (_this._keyEventSubscription == null) {
        t1 = J.get$onKeyDown$x(_this._textfield.element);
        t2 = H.getTypeArgumentByIndex(t1, 0);
        _this._keyEventSubscription = W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new X.ScriptsMatcher_start_closure(_this), {func: 1, ret: -1, args: [t2]}), false, t2);
      }
    },
    start$3: function($receiver, revertScriptRef, scriptView, textfield) {
      return this.start$4($receiver, revertScriptRef, scriptView, textfield, null);
    },
    reset$0: function(_) {
      var originalRefs, _this = this,
        t1 = _this._scriptsView,
        t2 = t1._scripts_view$_items,
        selectedScriptRef = t2._hadClicked ? t2.selectedItem$0() : t1._highlightRef;
      t1 = _this._keyEventSubscription;
      if (t1 != null) {
        t1.cancel$0(0);
        _this._keyEventSubscription = null;
      }
      t1 = _this.matchingState;
      originalRefs = t1.$index(0, "");
      t2 = _this._debuggerState;
      _this._scriptsView.showScripts$4$selectScriptRef(originalRefs, t2.rootLib.uri, t2.commonScriptPrefix, selectedScriptRef);
      t1.clear$0(0);
      t1.putIfAbsent$2(0, "", new X.ScriptsMatcher_reset_closure(originalRefs));
      H.interceptedTypeCast(_this._textfield.element, "$isInputElement").value = "";
      _this._scriptsView._highlightRef = null;
    },
    revert$0: function() {
      var t1, t2, _this = this;
      _this.reset$0(0);
      t1 = _this._debuggerState;
      _this._scriptsView.showScripts$4$selectScriptRef(_this.matchingState.$index(0, ""), t1.rootLib.uri, t1.commonScriptPrefix, _this._originalScriptRef);
      if (_this._originalScriptRef != null)
        if (_this._scriptsView._scripts_view$_items.selectedItem$0() != null) {
          t1 = _this._scriptsView._scripts_view$_items;
          t2 = _this._originalScrollTop;
          t1 = t1.element;
          t1.toString;
          t1.scrollTop = J.round$0$n(t2);
        }
    },
    _startMatching$2: function(originalScriptRef, initialize) {
      var _this = this;
      _this._originalScriptRef = originalScriptRef;
      _this._originalScrollTop = C.JSNumber_methods.round$0(_this._scriptsView._scripts_view$_items.element.scrollTop);
      H.interceptedTypeCheck(_this._textfield.element, "$isInputElement");
      _this.matchingState.putIfAbsent$2(0, "", new X.ScriptsMatcher__startMatching_closure(_this));
    },
    displayMatchingScripts$1: function(charsToMatch) {
      var t2, matchingRefs, _this = this,
        charsMatchLen = charsToMatch.length,
        previousMatch = charsMatchLen > 0 ? C.JSString_methods.substring$2(charsToMatch, 0, charsMatchLen - 1) : "",
        t1 = _this.matchingState,
        lastMatchingRefs = t1.$index(0, previousMatch);
      if (lastMatchingRefs == null)
        lastMatchingRefs = t1.$index(0, "");
      t2 = J.where$1$ax(lastMatchingRefs, new X.ScriptsMatcher_displayMatchingScripts_closure(charsToMatch));
      matchingRefs = P.List_List$from(t2, true, H.getTypeArgumentByIndex(t2, 0));
      t1.putIfAbsent$2(0, charsToMatch, new X.ScriptsMatcher_displayMatchingScripts_closure0(matchingRefs));
      t1 = _this._scriptsView._scripts_view$_items;
      t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
      t1 = _this._debuggerState;
      _this._scriptsView.showScripts$3(matchingRefs, t1.rootLib.uri, t1.commonScriptPrefix);
      _this._selectRow = 0;
      _this._scriptsView.scrollAndHighlight$2(0, -1);
      t1 = _this._scriptsView._scripts_view$_items.element;
      t1.toString;
      t1.scrollTop = 0;
    }
  };
  X.ScriptsMatcher_start_closure.prototype = {
    call$1: function(e) {
      var t1, t2, t3, _this = this;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      switch (e.keyCode) {
        case 13:
          t1 = _this.$this;
          t1.reset$0(0);
          t1._scriptsView._highlightRef = null;
          t1 = t1._finishCallback;
          if (t1 != null)
            t1.call$0();
          e.preventDefault();
          break;
        case 27:
          t1 = _this.$this;
          t1.revert$0();
          t1 = t1._finishCallback;
          if (t1 != null)
            t1.call$0();
          break;
        case 33:
          t1 = _this.$this;
          t1._selectRow = t1._scriptsView.page$2(0, C.ListDirection_0, t1._selectRow);
          e.preventDefault();
          break;
        case 34:
          t1 = _this.$this;
          t1._selectRow = t1._scriptsView.page$2(0, C.ListDirection_1, t1._selectRow);
          e.preventDefault();
          break;
        case 35:
          t1 = _this.$this;
          t1._selectRow = t1._scriptsView.page$1(0, C.ListDirection_3);
          e.preventDefault();
          break;
        case 36:
          t1 = _this.$this;
          t1._selectRow = t1._scriptsView.page$1(0, C.ListDirection_2);
          e.preventDefault();
          break;
        case 38:
          t1 = _this.$this;
          t2 = t1._selectRow;
          if (typeof t2 !== "number")
            return t2.$gt();
          if (t2 > 0) {
            --t2;
            t1._selectRow = t2;
            t1._scriptsView.scrollAndHighlight$2(t2, -1);
          }
          e.preventDefault();
          break;
        case 40:
          t1 = _this.$this;
          t2 = t1._selectRow;
          t3 = J.get$length$asx(t1._scriptsView._scripts_view$_items.items);
          if (typeof t3 !== "number")
            return t3.$sub();
          if (typeof t2 !== "number")
            return t2.$lt();
          if (t2 < t3 - 1) {
            t2 = t1._selectRow;
            if (typeof t2 !== "number")
              return t2.$add();
            ++t2;
            t1._selectRow = t2;
            t1._scriptsView.scrollAndHighlight$2(t2, -1);
          }
          e.preventDefault();
          break;
      }
    },
    $signature: 14
  };
  X.ScriptsMatcher_reset_closure.prototype = {
    call$0: function() {
      return this.originalRefs;
    },
    $signature: 45
  };
  X.ScriptsMatcher__startMatching_closure.prototype = {
    call$0: function() {
      return this.$this._scriptsView._scripts_view$_items.items;
    },
    $signature: 45
  };
  X.ScriptsMatcher_displayMatchingScripts_closure.prototype = {
    call$1: function(ref) {
      return J.lastIndexOf$1$s(H.interceptedTypeCheck(ref, "$isScriptRef").uri, this.charsToMatch) >= 0;
    },
    $signature: 44
  };
  X.ScriptsMatcher_displayMatchingScripts_closure0.prototype = {
    call$0: function() {
      return this.matchingRefs;
    },
    $signature: 45
  };
  V.VariablesView.prototype = {
    VariablesView$2: function(debuggerState, variableDescriber) {
      var t1 = N.SelectableTree$(S.BoundVariable);
      t1.flex$0(0);
      t1.clazz$1("menu-item-bottom-border");
      t1.clazz$1("debugger-items-list");
      this.set$_items(t1);
      t1 = this._items;
      t1.set$childProvider(H.assertSubtype(new V.VariablesChildProvider(debuggerState), "$isChildProvider", [H.getTypeArgumentByIndex(t1, 0)], "$asChildProvider"));
      t1 = this._items;
      t1.set$renderer(H.functionTypeCheck(new V.VariablesView_closure(variableDescriber), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    get$element: function() {
      return this._items;
    },
    set$_items: function(_items) {
      this._items = H.assertSubtype(_items, "$isSelectableTree", [S.BoundVariable], "$asSelectableTree");
    },
    $isCoreElementView: 1
  };
  V.VariablesView_closure.prototype = {
    call$1: function(variable) {
      var $name, value, t2, valueStr, element, t3, _null = null, t1 = {};
      H.interceptedTypeCheck(variable, "$isBoundVariable");
      $name = variable.name;
      value = variable.value;
      t2 = J.getInterceptor$(value);
      if (!!t2.$isInstanceRef) {
        valueStr = value.valueAsString;
        if (valueStr == null)
          valueStr = value.classRef.name;
        else {
          if (value.valueAsStringIsTruncated)
            valueStr += "...";
          if (value.kind === "String")
            valueStr = "'" + valueStr + "'";
        }
        t2 = value.kind;
        if (t2 === "List")
          valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
        else if (t2 === "Map")
          valueStr = "{ " + H.S(value.length) + " } " + H.S(valueStr);
        else if (t2 != null && C.JSString_methods.endsWith$1(t2, "List"))
          valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
      } else if (!!t2.$isSentinel)
        valueStr = value.valueAsString;
      else
        valueStr = !!t2.$isTypeArgumentsRef ? value.name : t2.toString$0(value);
      element = A.CoreElement$("li", _null, "list-item", _null, _null);
      element.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", _null, _null, _null, $name), A.CoreElement$("span", _null, "subtle", _null, " " + H.S(valueStr))], [A.CoreElement]));
      t1.sub = null;
      t2 = J.get$onMouseOver$x(element.element);
      t3 = H.getTypeArgumentByIndex(t2, 0);
      t1.sub = W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new V.VariablesView__closure(t1, this.variableDescriber, variable, element), {func: 1, ret: -1, args: [t3]}), false, t3);
      return element;
    },
    $signature: 258
  };
  V.VariablesView__closure.prototype = {
    call$1: function(e) {
      var _this = this;
      H.interceptedTypeCheck(e, "$isMouseEvent");
      _this._box_0.sub.cancel$0(0);
      _this.variableDescriber.call$1(_this.variable).then$1$1(new V.VariablesView___closure(_this.element), null);
    },
    $signature: 3
  };
  V.VariablesView___closure.prototype = {
    call$1: function(desc) {
      this.element.element.title = H.stringTypeCheck(desc);
    },
    $signature: 19
  };
  V.VariablesChildProvider.prototype = {
    hasChildren$1: function(item) {
      var value = H.interceptedTypeCheck(item, "$isBoundVariable").value;
      return value instanceof S.InstanceRef && value.valueAsString == null;
    },
    getChildren$1: function(item) {
      return this.getChildren$body$VariablesChildProvider(H.interceptedTypeCheck(item, "$isBoundVariable"));
    },
    getChildren$body$VariablesChildProvider: function(item) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, S.BoundVariable]),
        $async$returnValue, $async$self = this, t1, t2, t3, result, result0, index, _i, value;
      var $async$getChildren$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              value = item.value;
              if (!(value instanceof S.InstanceRef)) {
                $async$returnValue = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self.debuggerState;
              t2 = t1._service;
              t1 = t1.isolateRef.id;
              t3 = value.id;
              $async$goto = 3;
              return P._asyncAwait(t2._trackFuture$1$2("getObject", t2._vmService.getObject$2(0, t1, t3), P.Object), $async$getChildren$1);
            case 3:
              // returning from await.
              result = $async$result;
              if (!(result instanceof S.Instance)) {
                $async$returnValue = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = result.associations;
              if (t1 != null) {
                t2 = S.BoundVariable;
                t3 = H.getTypeArgumentByIndex(t1, 0);
                $async$returnValue = new H.MappedListIterable(t1, H.functionTypeCheck(new V.VariablesChildProvider_getChildren_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
                // goto return
                $async$goto = 1;
                break;
              } else if (result.elements != null) {
                result0 = H.setRuntimeTypeInfo([], [S.BoundVariable]);
                for (t1 = result.elements, t2 = t1.length, index = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                  value = t1[_i];
                  t3 = new S.BoundVariable(null);
                  t3.name = "[" + index + "]";
                  t3.value = value;
                  C.JSArray_methods.add$1(result0, t3);
                  ++index;
                }
                $async$returnValue = result0;
                // goto return
                $async$goto = 1;
                break;
              } else {
                t1 = result.fields;
                t2 = S.BoundVariable;
                if (t1 != null) {
                  t3 = H.getTypeArgumentByIndex(t1, 0);
                  $async$returnValue = new H.MappedListIterable(t1, H.functionTypeCheck(new V.VariablesChildProvider_getChildren_closure0(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = H.setRuntimeTypeInfo([], [t2]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getChildren$1, $async$completer);
    },
    $asChildProvider: function() {
      return [S.BoundVariable];
    }
  };
  V.VariablesChildProvider_getChildren_closure.prototype = {
    call$1: function(assoc) {
      var keyString, t1;
      H.interceptedTypeCheck(assoc, "$isMapAssociation");
      keyString = J.get$valueAsString$x(assoc.key);
      t1 = assoc.key;
      if (t1 instanceof S.InstanceRef && t1.kind === "String")
        keyString = "'" + H.S(keyString) + "'";
      t1 = new S.BoundVariable(null);
      t1.name = "[" + H.S(keyString) + "]";
      t1.value = assoc.value;
      return t1;
    },
    $signature: 260
  };
  V.VariablesChildProvider_getChildren_closure0.prototype = {
    call$1: function(field) {
      var t1;
      H.interceptedTypeCheck(field, "$isBoundField");
      t1 = new S.BoundVariable(null);
      t1.name = field.decl.name;
      t1.value = field.value;
      return t1;
    },
    $signature: 262
  };
  B.EvalOnDartLibrary.prototype = {
    EvalOnDartLibrary$3$isolateId: function(candidateLibraryNames, service, isolateId) {
      var t1 = S.LibraryRef;
      this.set$_libraryRef(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager.getSelectedIsolate$1(new B.EvalOnDartLibrary_closure(this));
    },
    _init$2: function(isolateId, isIsolateNull) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$_init$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self._initializeComplete, $async$_init$2);
            case 2:
              // returning from await.
              if ($async$self._libraryRef.future._state !== 0) {
                t1 = S.LibraryRef;
                $async$self.set$_libraryRef(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
              }
              if (!isIsolateNull)
                $async$self.set$_initializeComplete($async$self._initialize$1(isolateId));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_init$2, $async$completer);
    },
    _initialize$1: function(isolateId) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, isolate, library, e, stack, t1, t2, t3, _i, exception, $async$exception, $async$temp1;
      var $async$_initialize$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                $async$self._isolateId = isolateId;
                $async$handler = 4;
                t1 = $async$self.service;
                t2 = t1._vmService;
                t2.toString;
                $async$temp1 = H;
                $async$goto = 7;
                return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t2._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", isolateId]), null), null), $async$_initialize$1);
              case 7:
                // returning from await.
                isolate = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate");
                if (isolate == null || $async$self._libraryRef.future._state !== 0) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                for (t1 = isolate.libraries, t2 = t1.length, t3 = $async$self._candidateLibraryNames, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                  library = t1[_i];
                  if (t3.contains$1(0, library.uri)) {
                    t1 = $async$self._libraryRef;
                    t2 = H.futureOrCheck(library, {futureOr: 1, type: H.getTypeArgumentByIndex(t1, 0)});
                    t1 = t1.future;
                    if (t1._state !== 0)
                      H.throwExpression(P.StateError$("Future already completed"));
                    t1._asyncComplete$1(t2);
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  }
                }
                $async$self._libraryRef.completeError$1(new B.LibraryNotFound(t3));
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                e = H.unwrapException($async$exception);
                stack = H.getTraceFromException($async$exception);
                $async$self._eval_on_dart_library$_handleError$2(e, stack);
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
      });
      return P._asyncStartSync($async$_initialize$1, $async$completer);
    },
    eval$3$isAlive$scope: function(expression, isAlive, scope) {
      var t1 = P.String;
      return this.addRequest$1$2(isAlive, new B.EvalOnDartLibrary_eval_closure(this, expression, H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap")), S.InstanceRef);
    },
    eval$2$isAlive: function(expression, isAlive) {
      return this.eval$3$isAlive$scope(expression, isAlive, null);
    },
    _eval$2$scope: function(expression, scope) {
      var t1 = P.String;
      H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap");
      return this._eval$body$EvalOnDartLibrary(expression, scope);
    },
    _eval$body$EvalOnDartLibrary: function(expression, scope) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.InstanceRef),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, libraryRef, result, e, stack, t1, exception, $async$exception;
      var $async$_eval$2$scope = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              libraryRef = null;
            case 7:
              // for condition
              // trivial condition
              $async$goto = 9;
              return P._asyncAwait($async$self._libraryRef.future, $async$_eval$2$scope);
            case 9:
              // returning from await.
              libraryRef = $async$result;
              if ($async$self._libraryRef.future._state !== 0) {
                // goto after for
                $async$goto = 8;
                break;
              }
              // goto for condition
              $async$goto = 7;
              break;
            case 8:
              // after for
              if (libraryRef == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 10;
              return P._asyncAwait($async$self.service.evaluate$4$scope(0, $async$self._isolateId, libraryRef.id, expression, scope), $async$_eval$2$scope);
            case 10:
              // returning from await.
              result = $async$result;
              if (result instanceof S.Sentinel) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (result instanceof S.ErrorRef)
                throw H.wrapException(result);
              t1 = H.futureOrCheck(result, {futureOr: 1, type: S.InstanceRef});
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              stack = H.getTraceFromException($async$exception);
              $async$self._eval_on_dart_library$_handleError$2(e, stack);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_eval$2$scope, $async$completer);
    },
    _eval_on_dart_library$_handleError$2: function(e, stack) {
      var t1;
      H.interceptedTypeCheck(stack, "$isStackTrace");
      t1 = J.getInterceptor$(e);
      switch (t1.get$runtimeType(e)) {
        case C.Type_RPCError_SOa:
          P.print("RPCError: " + H.S(e));
          break;
        case C.Type_Error_A6W:
          P.print(H.S(t1.get$kind(e)) + ": " + H.S(t1.get$message(e)));
          break;
        default:
          P.print("Unrecognized error: " + H.S(e));
      }
      if (stack != null)
        P.print(stack);
    },
    getInstance$2: function(instanceRefFuture, isAlive) {
      return this.getInstance$body$EvalOnDartLibrary(H.futureOrCheck(instanceRefFuture, {futureOr: 1, type: S.InstanceRef}), isAlive);
    },
    getInstance$body$EvalOnDartLibrary: function(instanceRefFuture, isAlive) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Instance),
        $async$returnValue, $async$self = this;
      var $async$getInstance$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 4;
              return P._asyncAwait(instanceRefFuture, $async$getInstance$2);
            case 4:
              // returning from await.
              $async$goto = 3;
              return P._asyncAwait($async$self.getObjHelper$1$2($async$result, isAlive, S.Instance), $async$getInstance$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getInstance$2, $async$completer);
    },
    addRequest$1$2: function(isAlive, request, $T) {
      return this.addRequest$body$EvalOnDartLibrary(isAlive, H.functionTypeCheck(request, {func: 1, ret: [P.Future, $T]}), $T, $T);
    },
    addRequest$body$EvalOnDartLibrary: function(isAlive, request, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, previousDone, e, t2, response, t3, t4, exception, t1, $async$exception;
      var $async$addRequest$1$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = isAlive != null;
              if (t1 && isAlive.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = new P._Future($.Zone__current, [$T]);
              response = new P._AsyncCompleter(t2, [$T]);
              t3 = new B.EvalOnDartLibrary_addRequest_wrappedRequest($async$self, isAlive, response, request, $T);
              t4 = $async$self.allPendingRequestsDone;
              $async$goto = t4 == null || t4.future._state !== 0 ? 3 : 5;
              break;
            case 3:
              // then
              $async$self.allPendingRequestsDone = response;
              t3.call$0();
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              if (t1 && isAlive.disposed || false) {
                response.complete$1(0, null);
                $async$returnValue = t2;
                // goto return
                $async$goto = 1;
                break;
              }
              previousDone = t4.future;
              $async$self.allPendingRequestsDone = response;
              $async$handler = 7;
              $async$goto = 10;
              return P._asyncAwait(previousDone, $async$addRequest$1$2);
            case 10:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 9;
              break;
            case 7:
              // catch
              $async$handler = 6;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              P.print(e);
              // goto after finally
              $async$goto = 9;
              break;
            case 6:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 9:
              // after finally
              t3.call$0();
            case 4:
              // join
              $async$returnValue = t2;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$addRequest$1$2, $async$completer);
    },
    getObjHelper$1$2: function(instance, isAlive, $T) {
      H.assertIsSubtype($T, S.Obj, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'getObjHelper'.");
      return this.addRequest$1$2(isAlive, new B.EvalOnDartLibrary_getObjHelper_closure(this, H.interceptedTypeCheck(instance, "$isObjRef"), null, null, $T), $T);
    },
    set$_libraryRef: function(_libraryRef) {
      this._libraryRef = H.assertSubtype(_libraryRef, "$isCompleter", [S.LibraryRef], "$asCompleter");
    },
    set$_initializeComplete: function(_initializeComplete) {
      this._initializeComplete = H.assertSubtype(_initializeComplete, "$isFuture", [-1], "$asFuture");
    }
  };
  B.EvalOnDartLibrary_closure.prototype = {
    call$1: function(isolate) {
      var t1, id, t2;
      H.interceptedTypeCheck(isolate, "$isIsolateRef");
      t1 = isolate == null;
      id = t1 ? null : isolate.id;
      t2 = this.$this;
      t2.set$_initializeComplete(null);
      t2._init$2(id, t1);
    },
    $signature: 35
  };
  B.EvalOnDartLibrary_eval_closure.prototype = {
    call$0: function() {
      return this.$this._eval$2$scope(this.expression, this.scope);
    },
    $signature: 271
  };
  B.EvalOnDartLibrary_addRequest_wrappedRequest.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, value, e, t3, exception, t1, t2, $async$exception;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.isAlive;
              t2 = t1 == null;
              if (!t2 && t1.disposed || false) {
                $async$self.response.complete$1(0, null);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self.request.call$0(), $async$call$0);
            case 7:
              // returning from await.
              value = $async$result;
              t3 = $async$self.response;
              if (!(value instanceof S.Sentinel))
                t3.complete$1(0, H.futureOrCheck(value, {futureOr: 1, type: $async$self.T}));
              else
                t3.complete$1(0, null);
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              t1 = (t2 ? null : t1.disposed) === true;
              t2 = $async$self.response;
              if (t1)
                t2.complete$1(0, null);
              else
                t2.completeError$1(e);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 1
  };
  B.EvalOnDartLibrary_getObjHelper_closure.prototype = {
    call$0: function() {
      return this.$call$body$EvalOnDartLibrary_getObjHelper_closure(this.T);
    },
    $call$body$EvalOnDartLibrary_getObjHelper_closure: function($async$type) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$self = this, t3, t1, t2, $async$temp1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.service;
              t1 = t1._isolateId;
              t3 = $async$self.instance.id;
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(t2._trackFuture$1$2("getObject", t2._vmService.getObject$2(0, t1, t3), P.Object), $async$call$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.assertSubtypeOfRuntimeType($async$result, $async$self.T);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: function() {
      return {func: 1, ret: [P.Future, this.T]};
    }
  };
  B.LibraryNotFound.prototype = {
    get$message: function(_) {
      return "Library matchining one of " + H.S(this.candidateNames) + " not found";
    }
  };
  N.Framework.prototype = {
    Framework$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, t9, _this = this, _null = null,
        t1 = W.PopStateEvent;
      W._EventStreamSubscription$(window, "popstate", H.functionTypeCheck(_this.get$handlePopState(), {func: 1, ret: -1, args: [t1]}), false, t1);
      _this._initDragDrop$0();
      t1 = document;
      t2 = [N.StatusItem];
      _this.globalStatus = new N.StatusLine(new A.CoreElement(t1.querySelector("#global-status")), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2));
      _this.pageStatus = new N.StatusLine(new A.CoreElement(t1.querySelector("#page-status")), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2));
      _this.auxiliaryStatus = new N.StatusLine(new A.CoreElement(t1.querySelector("#auxiliary-status")), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([], t2));
      _this.globalActions = new N.ActionsContainer(new A.CoreElement(t1.querySelector("#global-actions")), H.setRuntimeTypeInfo([], [N.ActionButton]));
      _this.connectDialog = N.ConnectDialog$(_this);
      t2 = new N.SnapshotMessage();
      t1 = t1.querySelector("#snapshot-message");
      t3 = new A.CoreElement(t1);
      t2.parent = t3;
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      t4 = A.h2("Load DevTools Snapshot");
      t5 = A.CoreElement$("dl", _null, "form-group", _null, _null);
      t6 = A.CoreElement$("dt", _null, _null, _null, _null);
      t7 = [A.CoreElement];
      t6.add$1(0, H.setRuntimeTypeInfo([A.label("Load a DevTools snapshot from a local file.")], t7));
      t8 = A.CoreElement$("dd", _null, _null, _null, _null);
      t8.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("p", _null, "note", _null, "Drag and drop a file anywhere on the page.")], t7));
      t9 = A.CoreElement$("dd", _null, _null, _null, _null);
      t9.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("p", _null, "note", _null, "Supported file formats include any files exported from DevTools, such as the timeline export.")], t7));
      t5.add$1(0, H.setRuntimeTypeInfo([t6, t8, t9], t7));
      t3.add$1(0, H.setRuntimeTypeInfo([t4, t5], t7));
      t1 = t1.style;
      t1.display = "none";
      _this.snapshotMessage = t2;
      _this.analyticsDialog = N.AnalyticsOptInDialog$(_this);
    },
    _initDragDrop$0: function() {
      C.Window_methods.addEventListener$3(window, "dragover", new N.Framework__initDragDrop_closure(this), false);
      C.Window_methods.addEventListener$3(window, "drop", new N.Framework__initDragDrop_closure0(this), false);
    },
    _onDrop$1: function($event) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$next = [], $async$self = this, droppedFile, reader, e, files, t1, exception;
      var $async$_onDrop$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $event.preventDefault();
              files = $event.dataTransfer.files;
              if (files.length > 1) {
                $async$self.toast$1("You cannot import more than one file.");
                // goto return
                $async$goto = 1;
                break;
              }
              droppedFile = (files && C.FileList_methods).get$first(files);
              if (droppedFile.type !== "application/json") {
                $async$self.toast$1(H.S(droppedFile.type) + " is not a supported file type. Please import a .json file that was exported from Dart DevTools.");
                // goto return
                $async$goto = 1;
                break;
              }
              reader = new FileReader();
              t1 = W.ProgressEvent;
              W._EventStreamSubscription$(H.interceptedTypeCheck(reader, "$isEventTarget"), "load", H.functionTypeCheck(new N.Framework__onDrop_closure($async$self, reader), {func: 1, ret: -1, args: [t1]}), false, t1);
              try {
                J.readAsText$1$x(reader, droppedFile);
              } catch (exception) {
                e = H.unwrapException(exception);
                $async$self.toast$1("Could not import file: " + H.S(e));
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_onDrop$1, $async$completer);
    },
    _importTimeline$1: function($import) {
      var t3, t4, t5, traceEvents, cpuProfileJson, cpuProfileData, selectedEventJson, t6, t7, selectedEvent, offlineData, timelineScreen, _this = this, _null = null, _s4_ = "none",
        _s8_ = "timeline",
        _s8_0 = "Timeline",
        _s4_0 = "span",
        t1 = P.String,
        t2 = [t1, null];
      H.assertSubtype($import, "$isMap", t2, "$asMap");
      t3 = J.getInterceptor$asx($import);
      t4 = t3.$index($import, "traceEvents");
      if (t4 == null)
        t4 = [];
      t5 = [P.Map, P.String,,];
      traceEvents = H.listTypeCheck(J.cast$1$0$ax(t4, t5));
      t4 = t3.$index($import, "cpuProfile");
      cpuProfileJson = H.assertSubtype(t4 == null ? P.LinkedHashMap_LinkedHashMap$_empty(t1, _null) : t4, "$isMap", t2, "$asMap");
      cpuProfileData = J.get$isNotEmpty$asx(cpuProfileJson) ? E.CpuProfileData_parse(cpuProfileJson) : _null;
      t3 = t3.$index($import, "selectedEvent");
      selectedEventJson = H.assertSubtype(t3 == null ? P.LinkedHashMap_LinkedHashMap$_empty(t1, _null) : t3, "$isMap", t2, "$asMap");
      t2 = J.getInterceptor$asx(selectedEventJson);
      if (t2.get$isNotEmpty(selectedEventJson)) {
        t3 = H.stringTypeCheck(t2.$index(selectedEventJson, "name"));
        t4 = H.stringTypeCheck(t2.$index(selectedEventJson, "type"));
        t6 = H.intTypeCheck(t2.$index(selectedEventJson, "startMicros"));
        t2 = H.intTypeCheck(t2.$index(selectedEventJson, "durationMicros"));
        t1 = Q.TraceEventWrapper$(Q.TraceEvent$(P.LinkedHashMap_LinkedHashMap$_literal(["name", t3, "ts", t6, "dur", t2, "args", P.LinkedHashMap_LinkedHashMap$_literal(["type", "ui"], t1, t1)], t1, _null)), 0);
        t3 = new B.TimeRange(true);
        t7 = t1.event;
        selectedEvent = new Q.OfflineTimelineEvent(H.setRuntimeTypeInfo([t1], [Q.TraceEventWrapper]), t7.get$type(t7), t3, H.setRuntimeTypeInfo([], [Q.TimelineEvent0]));
        t7 = P.Duration$(t7.timestampMicros, 0, 0, 0);
        t3._utils$_start = t7;
        if (typeof t6 !== "number")
          return t6.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1 = P.Duration$(t6 + t2, 0, 0, 0);
        t3._utils$_end = t1;
        selectedEvent.type = t4 === "TimelineEventType.ui" ? C.TimelineEventType_0 : C.TimelineEventType_1;
      } else
        selectedEvent = _null;
      offlineData = Q.OfflineTimelineData$_(cpuProfileData, _null, selectedEvent, _null, H.assertSubtype(traceEvents, "$isList", [t5], "$asList"));
      if (J.get$isEmpty$asx(offlineData.traceEvents)) {
        _this.toast$1("Imported file does not contain timeline data.");
        return;
      }
      t1 = _this.connectDialog.parent.element.style;
      t1.display = _s4_;
      t1 = _this.snapshotMessage.parent.element.style;
      t1.display = _s4_;
      $.offlineMode = true;
      t1 = _this.screens;
      timelineScreen = H.interceptedTypeCheck(C.JSArray_methods.firstWhere$2$orElse(t1, new N.Framework__importTimeline_closure(), new N.Framework__importTimeline_closure0()), "$isTimelineScreen");
      if (timelineScreen == null) {
        t2 = [Q.TimelineFrame];
        t2 = new Y.TimelineController(new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, [Q.TimelineEvent0]), new P._AsyncBroadcastStreamController(_null, _null, [Q.OfflineTimelineData]), new N.CpuProfileProtocol());
        t3 = new N.TimelineService(t2);
        t3._initListeners$0();
        t2.timelineService = t3;
        t3 = P.bool;
        t4 = H.setRuntimeTypeInfo([], [N.StatusItem]);
        t5 = A.CoreElement$(_s4_0, _null, _null, _null, _null);
        t5.add$1(0, A.CoreElement$(_s4_0, _null, "optional-700", _null, _s8_0));
        t5.add$1(0, A.CoreElement$(_s4_0, _null, _null, _null, " Docs"));
        t5 = Y.createLinkStatusItem(t5, "https://flutter.github.io/devtools/timeline", "Documentation on using the Timeline page");
        Y.hiddenPages().contains$1(0, _s4_);
        timelineScreen = new X.TimelineScreen(t2, _s8_0, _s8_, "octicon-pulse", t5, _null, false, _null, new B.Property(new P._AsyncBroadcastStreamController(_null, _null, [t3]), false, [t3]), t4);
        C.JSArray_methods.add$1(t1, timelineScreen);
      }
      _this.navigateTo$1(_s8_);
      timelineScreen.clearTimeline$0();
      timelineScreen.timelineController.loadOfflineData$1(offlineData);
    },
    exitOfflineMode$0: function() {
      var t1, t2, _this = this;
      $.offlineMode = false;
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp == null) {
        t1 = _this.connectDialog.parent.element.style;
        t1.display = "initial";
        t1 = _this.snapshotMessage.parent.element.style;
        t1.display = "initial";
        J.get$children$x(document.querySelector("#content")).clear$0(0);
        t1 = _this.screens;
        t2 = H.functionTypeCheck(new N.Framework_exitOfflineMode_closure(), {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(t1, 0)]});
        C.JSArray_methods._removeWhere$2(t1, t2, true);
      } else {
        t1 = _this._framework$_previous;
        _this.navigateTo$1((t1 == null ? _this.current : t1).id);
      }
    },
    navigateTo$1: function(id) {
      var $screen, search, t1, ref, t2;
      F.screen(id);
      $screen = this.getScreen$1(id);
      search = window.location.search;
      if (search == null) {
        t1 = $screen.id;
        ref = t1.length === 0 ? t1 : "#" + t1;
      } else {
        t1 = $screen.id;
        ref = search + (t1.length === 0 ? t1 : "#" + t1);
      }
      t1 = window.history;
      t2 = $screen.name;
      t1.toString;
      t1.pushState(new P._StructuredCloneDart2Js([], []).walk$1(null), t2, ref);
      this.load$1(0, $screen);
    },
    _hookupShortcuts$0: function() {
      var t1 = W.KeyboardEvent;
      W._EventStreamSubscription$(window, "keydown", H.functionTypeCheck(new N.Framework__hookupShortcuts_closure(this), {func: 1, ret: -1, args: [t1]}), false, t1);
    },
    loadScreenFromLocation$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this;
      var $async$loadScreenFromLocation$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._hookupShortcuts$0();
              $async$goto = 2;
              return P._asyncAwait($async$self.screensReady.future.whenComplete$1(new N.Framework_loadScreenFromLocation_closure($async$self)), $async$loadScreenFromLocation$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadScreenFromLocation$0, $async$completer);
    },
    getScreen$2$onlyEnabled: function(id, onlyEnabled) {
      return C.JSArray_methods.firstWhere$2$orElse(this.screens, new N.Framework_getScreen_closure(id, onlyEnabled), new N.Framework_getScreen_closure0());
    },
    getScreen$1: function(id) {
      return this.getScreen$2$onlyEnabled(id, false);
    },
    handlePopState$1: function($event) {
      H.interceptedTypeCheck($event, "$isPopStateEvent");
      this.loadScreenFromLocation$0();
    },
    load$1: function(_, $screen) {
      var t1, t2, t3, screenContent, _this = this,
        _s8_ = "#content";
      if (_this.current == null)
        J.get$children$x(document.querySelector(_s8_)).clear$0(0);
      t1 = _this.current;
      if (t1 != null) {
        _this._framework$_previous = t1;
        _this.current = null;
        t1.exiting$0();
        _this._framework$_previous._visible.set$value(0, false);
        t1 = _this.pageStatus;
        C.JSArray_methods.set$length(t1._framework$_items, 0);
        t1._rebuild$0();
        _this.messageManager.removeAll$0();
        _this._screenContents.$index(0, _this._framework$_previous).attribute$2("hidden", true);
      }
      _this.current = $screen;
      t1 = _this._screenContents;
      t2 = t1.containsKey$1(0, $screen);
      t3 = _this.current;
      if (t2) {
        t1.$index(0, t3).attribute$2("hidden", false);
        if ($screen.needsResizing) {
          t1.$index(0, _this.current).element.dispatchEvent(W.Event_Event$eventType("Event", "resize", true, true));
          $screen.needsResizing = false;
        }
      } else {
        t3.framework = _this;
        screenContent = t3.createContent$1(_this);
        screenContent.attribute$1("full");
        new A.CoreElement(document.querySelector(_s8_)).add$1(0, screenContent);
        t1.$indexSet(0, _this.current, screenContent);
        t1 = J.get$onResize$x(screenContent.element);
        t2 = H.getTypeArgumentByIndex(t1, 0);
        W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new N.Framework_load_closure(_this), {func: 1, ret: -1, args: [t2]}), false, t2);
      }
      _this.current._visible.set$value(0, true);
      _this.current.entering$0();
      t1 = _this.pageStatus;
      t2 = _this.current.statusItems;
      t1.toString;
      H.assertSubtype(t2, "$isList", [N.StatusItem], "$asList");
      C.JSArray_methods.addAll$1(t1._framework$_items, t2);
      t1._rebuild$0();
      t1 = _this.messageManager;
      t2 = t1._messages.$index(0, _this.current.id);
      if (t2 != null)
        J.forEach$1$ax(t2, t1.get$_showMessage());
      t1 = _this.auxiliaryStatus;
      t2 = t1._defaultStatusItems;
      C.JSArray_methods.set$length(t2, 0);
      C.JSArray_methods.add$1(t2, $screen.helpStatus);
      t1._rebuild$0();
      _this.updatePage$0();
    },
    updatePage$0: function() {
      var t1, t2, t3, t4;
      for (t1 = W.Element, t2 = document, H.assertIsSubtype(t1, t1, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'."), t2 = new W._FrozenElementList(t2.querySelectorAll("#main-nav a"), [t1]), t1 = new H.ListIterator(t2, t2.get$length(t2), [t1]); t1.moveNext$0();) {
        t2 = t1.__internal$_current;
        t3 = this.current.id;
        t3 = t3.length === 0 ? t3 : "#" + t3;
        t4 = t2.getAttribute("href");
        J.get$classes$x(t2).toggle$2(0, "active", t3 === t4);
      }
    },
    showError$2: function(title, error) {
      var message, _null = null;
      if (error != null) {
        message = H.S(error);
        if (C.JSString_methods.startsWith$1(message, "[object ") || C.JSString_methods.startsWith$1(message, "Instance of "))
          message = _null;
      } else
        message = _null;
      this.messageManager.addMessage$2(X.Message$(C.MessageType_2, _null, _null, message, title), "general");
    },
    toast$3$hideDelay$title: function(message, hideDelay, title) {
      var _null = null,
        toast = new N.Toast(title, message, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"));
      toast.CoreElement$5$attributes$classes$html$text("div", _null, "toast", _null, _null);
      if (title != null)
        toast.add$1(0, A.label(title));
      toast.add$1(0, A.CoreElement$("div", _null, _null, _null, message));
      new A.CoreElement(document.querySelector("#toast-container")).add$1(0, toast);
      toast.show$1$hideDelay(0, hideDelay);
    },
    toast$1: function(message) {
      return this.toast$3$hideDelay$title(message, C.Duration_4000000, null);
    },
    toast$2$title: function(message, title) {
      return this.toast$3$hideDelay$title(message, C.Duration_4000000, title);
    },
    toast$2$hideDelay: function(message, hideDelay) {
      return this.toast$3$hideDelay$title(message, hideDelay, null);
    }
  };
  N.Framework__initDragDrop_closure.prototype = {
    call$1: function(e) {
      e = H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isEvent"), "$isMouseEvent");
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      return;
    },
    $signature: 23
  };
  N.Framework__initDragDrop_closure0.prototype = {
    call$1: function(e) {
      return this.$this._onDrop$1(H.interceptedTypeCheck(H.interceptedTypeCheck(e, "$isEvent"), "$isMouseEvent"));
    },
    $signature: 23
  };
  N.Framework__onDrop_closure.prototype = {
    call$1: function(_) {
      var $import, devToolsScreen, e, t1, exception, _this = this;
      H.interceptedTypeCheck(_, "$isProgressEvent");
      try {
        $import = H.assertSubtype(C.C_JsonCodec.decode$2$reviver(0, H.stringTypeCheck(C.FileReader_methods.get$result(_this.reader)), null), "$isMap", [P.String, null], "$asMap");
        devToolsScreen = J.$index$asx($import, "dartDevToolsScreen");
        if (devToolsScreen == null) {
          _this.$this.toast$2$hideDelay("The imported file is not a Dart DevTools file. At this time, DevTools only supports importing files that were originally exported from DevTools.", C.Duration_10000000);
          return;
        }
        t1 = _this.$this;
        switch (devToolsScreen) {
          case "timeline":
            t1._importTimeline$1($import);
            break;
          default:
            t1.toast$2$hideDelay('Could not import file. The imported file is from "' + H.S(devToolsScreen) + '", which is not supported by this version of Dart DevTools. You may need to upgrade your version of Dart DevTools to view this file.', C.Duration_10000000);
        }
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (!!J.getInterceptor$(t1).$isFormatException) {
          e = t1;
          _this.$this.toast$2$hideDelay('JSON syntax error in imported file: "' + H.S(e) + '". Please make sure the imported file is a Dart DevTools file, and check that it has not been modified.', C.Duration_10000000);
          return;
        } else
          throw exception;
      }
    },
    $signature: 22
  };
  N.Framework__importTimeline_closure.prototype = {
    call$1: function($screen) {
      return H.interceptedTypeCheck($screen, "$isScreen").id === "timeline";
    },
    $signature: 37
  };
  N.Framework__importTimeline_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  N.Framework_exitOfflineMode_closure.prototype = {
    call$1: function($screen) {
      return H.interceptedTypeCheck($screen, "$isScreen").id === "timeline";
    },
    $signature: 37
  };
  N.Framework__hookupShortcuts_closure.prototype = {
    call$1: function(e) {
      var t1, t2, t3, t4, t5;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      t1 = this.$this.current;
      if (t1 != null) {
        t2 = e.key;
        if (t2.length !== 0) {
          t3 = e.ctrlKey;
          t4 = e.shiftKey;
          t5 = e.altKey;
          t2 = H.boolConversionCheck(t1.shortcutCallback.call$4(t3, t4, t5, t2));
          t1 = t2;
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        e.preventDefault();
    },
    $signature: 14
  };
  N.Framework_loadScreenFromLocation_closure.prototype = {
    call$0: function() {
      var t1, $screen, t2, t3, t4, element, t5, element0, _null = null,
        _s9_ = "Not Found",
        _s4_ = "span",
        id = window.location.hash;
      if (id.length !== 0)
        id = J.substring$1$s(id, 1);
      t1 = this.$this;
      $screen = t1.getScreen$2$onlyEnabled(id, true);
      if ($screen == null)
        $screen = C.JSArray_methods.firstWhere$2$orElse(t1.screens, new N.Framework_loadScreenFromLocation__closure(), new N.Framework_loadScreenFromLocation__closure0(t1));
      if ($screen != null) {
        E.setupAndGaScreen(id);
        t1.load$1(0, $screen);
      } else {
        t2 = P.bool;
        t3 = H.setRuntimeTypeInfo([], [N.StatusItem]);
        t4 = A.CoreElement$(_s4_, _null, _null, _null, _null);
        t4.add$1(0, A.CoreElement$(_s4_, _null, "optional-700", _null, _s9_));
        t4.add$1(0, A.CoreElement$(_s4_, _null, _null, _null, " Docs"));
        element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0);
        t5 = element.style;
        t5.verticalAlign = "text-bottom";
        t5.marginBottom = "0";
        element0 = A.CoreElement$("a", _null, _null, _null, _null);
        element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), t4], [A.CoreElement]));
        t4 = element0.element;
        t4.setAttribute("href", "https://flutter.github.io/devtools/notfound");
        t4.setAttribute("target", "_blank");
        t4.title = "Documentation on using the Not Found page";
        t4 = A.CoreElement$(_s4_, _null, _null, _null, _null);
        t4.add$1(0, element0);
        Y.hiddenPages().contains$1(0, "none");
        t1.load$1(0, new F.NotFoundScreen(_s9_, "notfound", _null, new N.StatusItem(t4), "This screen is not available", false, _null, new B.Property(new P._AsyncBroadcastStreamController(_null, _null, [t2]), false, [t2]), t3));
      }
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  N.Framework_loadScreenFromLocation__closure.prototype = {
    call$1: function($screen) {
      return !H.boolConversionCheck(H.interceptedTypeCheck($screen, "$isScreen").disabled);
    },
    $signature: 37
  };
  N.Framework_loadScreenFromLocation__closure0.prototype = {
    call$0: function() {
      return C.JSArray_methods.get$first(this.$this.screens);
    },
    $signature: 296
  };
  N.Framework_getScreen_closure.prototype = {
    call$1: function($screen) {
      var t1;
      H.interceptedTypeCheck($screen, "$isScreen");
      if ($screen.id === this.id)
        t1 = !this.onlyEnabled || !H.boolConversionCheck($screen.disabled);
      else
        t1 = false;
      return t1;
    },
    $signature: 37
  };
  N.Framework_getScreen_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  N.Framework_load_closure.prototype = {
    call$1: function(e) {
      var t1;
      e.stopImmediatePropagation();
      t1 = this.$this;
      t1._screenContents.forEach$1(0, new N.Framework_load__closure(t1));
    },
    $signature: 6
  };
  N.Framework_load__closure.prototype = {
    call$2: function(theScreen, $content) {
      H.interceptedTypeCheck(theScreen, "$isScreen");
      H.interceptedTypeCheck($content, "$isCoreElement");
      if (this.$this.current != theScreen)
        theScreen.needsResizing = true;
    },
    $signature: 300
  };
  N.StatusLine.prototype = {
    _rebuild$0: function() {
      var items, t2, first, _i, item, t3,
        t1 = this.element;
      J.get$children$x(t1.element).clear$0(0);
      items = this._framework$_items;
      if (items.length === 0)
        items = this._defaultStatusItems;
      for (t2 = items.length, first = true, _i = 0; _i < items.length; items.length === t2 || (0, H.throwConcurrentModificationError)(items), ++_i, first = false) {
        item = items[_i];
        if (!first) {
          t3 = document.createElement("span");
          t3.textContent = "\u2022";
          t3.classList.add("separator");
          t1.add$1(0, t3);
        }
        t1.add$1(0, item.element);
      }
    }
  };
  N.ActionsContainer.prototype = {
    addAction$1: function(action) {
      var t1, t2, t3, _i;
      for (t1 = this._actions, t2 = t1.length, t3 = action.id, _i = 0; _i < t2; ++_i)
        if (t1[_i].id === t3)
          return;
      if (t2 === 0)
        this.element.add$1(0, A.CoreElement$("span", "horiz-padding", "masthead-item action-separator", null, "\u2022"));
      C.JSArray_methods.add$1(t1, action);
      this.element.add$1(0, action._custom$_element);
    },
    removeAction$1: function(id) {
      var t1 = this._actions,
        t2 = H.functionTypeCheck(new N.ActionsContainer_removeAction_closure(id), {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(t1, 0)]});
      C.JSArray_methods._removeWhere$2(t1, t2, true);
    }
  };
  N.ActionsContainer_removeAction_closure.prototype = {
    call$1: function(button) {
      return H.interceptedTypeCheck(button, "$isActionButton").id === this.id;
    },
    $signature: 107
  };
  N.Screen.prototype = {
    entering$0: function() {
    },
    get$isCurrentScreen: function() {
      var t1 = this.framework;
      return t1 != null && t1.current === this;
    },
    exiting$0: function() {
    },
    toString$0: function(_) {
      return "Screen(" + this.id + ")";
    },
    set$shortcutCallback: function(shortcutCallback) {
      this.shortcutCallback = H.functionTypeCheck(shortcutCallback, {func: 1, ret: P.bool, args: [P.bool, P.bool, P.bool, P.String]});
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$id: function(receiver) {
      return this.id;
    }
  };
  N.SetStateMixin.prototype = {
    setState$1: function(rebuild) {
      C.Window_methods.requestAnimationFrame$1(window, new N.SetStateMixin_setState_closure(rebuild));
    }
  };
  N.SetStateMixin_setState_closure.prototype = {
    call$1: function(_) {
      H.numTypeCheck(_);
      return this.rebuild.call$0();
    },
    $signature: 108
  };
  N.StatusItem.prototype = {};
  N.Toast.prototype = {
    show$1$hideDelay: function(_, hideDelay) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t1;
      var $async$show$1$hideDelay = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(C.Window_methods.get$animationFrame(window), $async$show$1$hideDelay);
            case 2:
              // returning from await.
              t1 = $async$self.element.style;
              t1.left = "0px";
              P.Timer_Timer(C.Duration_500000, new N.Toast_show_closure($async$self, hideDelay));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$show$1$hideDelay, $async$completer);
    },
    _hide$0: function() {
      var t1 = this.element.style;
      t1.left = "400px";
      P.Timer_Timer(C.Duration_500000, this.get$dispose());
    },
    toString$0: function(_) {
      return H.S(this.title) + " " + H.S(this.message);
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  N.Toast_show_closure.prototype = {
    call$0: function() {
      P.Timer_Timer(this.hideDelay, this.$this.get$_hide());
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  N.ConnectDialog.prototype = {
    ConnectDialog$1: function(framework) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, _this = this, _null = null,
        _s9_ = "uri-field",
        _s6_ = "button",
        t1 = document.querySelector("#connect-dialog");
      _this.parent = new A.CoreElement(t1);
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      t1 = _this.parent;
      t2 = A.h2("Connect");
      t3 = A.CoreElement$("dl", _null, "form-group", _null, _null);
      t4 = A.CoreElement$("dt", _null, _null, _null, _null);
      t5 = A.label("Connect to a running app");
      t5.element.setAttribute("for", _s9_);
      t6 = [A.CoreElement];
      t4.add$1(0, H.setRuntimeTypeInfo([t5], t6));
      t5 = A.CoreElement$("dd", _null, _null, _null, _null);
      t5.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("p", _null, "note", _null, "Enter a port or URL to a running Dart or Flutter application.")], t6));
      t7 = A.CoreElement$("dd", _null, _null, _null, _null);
      t8 = A.CoreElement$("input", _null, "form-control input-sm", _null, _null);
      t9 = t8.element;
      t9.setAttribute("type", "text");
      t9.setAttribute("placeholder", "Port or URL");
      t9.setAttribute("id", _s9_);
      _this.textfield = t8;
      t9 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_, _null), "$isElement");
      t10 = new N.PButton(t9);
      t10.CoreElement$5$attributes$classes$html$text(_s6_, _null, "btn", _null, "Connect");
      t9.setAttribute("type", _s6_);
      t10.clazz$1("btn-sm");
      t10.clazz$1("margin-left");
      _this.connectButton = t10;
      t7.add$1(0, H.setRuntimeTypeInfo([t8, t10], t6));
      t3.add$1(0, H.setRuntimeTypeInfo([t4, t5, t7], t6));
      t1.add$1(0, H.setRuntimeTypeInfo([t2, t3], t6));
      _this.connectButton.click$1(0, new N.ConnectDialog_closure(_this));
      t6 = J.get$onKeyDown$x(_this.textfield.element);
      t3 = H.getTypeArgumentByIndex(t6, 0);
      W._EventStreamSubscription$(t6._html$_target, t6._eventType, H.functionTypeCheck(new N.ConnectDialog_closure0(_this), {func: 1, ret: -1, args: [t3]}), false, t3);
    },
    connectTo$1: function(uri) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this;
      var $async$connectTo$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self._connect$1(0, uri), $async$connectTo$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$connectTo$1, $async$completer);
    },
    _tryConnect$0: function() {
      var handleConnectError, uri, port, t2, exception, _this = this, t1 = {},
        value = J.trim$0$s(H.interceptedTypeCheck(_this.textfield.element, "$isInputElement").value);
      t1.value = value;
      port = H.Primitives_parseInt(value, null);
      handleConnectError = new N.ConnectDialog__tryConnect_handleConnectError(t1, _this);
      _this.framework.messageManager.removeAll$0();
      if (port != null)
        _this._connect$1(0, P.Uri_parse("ws://localhost:" + H.S(port) + "/ws", 0, null)).catchError$1(new N.ConnectDialog__tryConnect_closure(handleConnectError));
      else
        try {
          t2 = t1.value;
          uri = F.getNormalizedTrimmedUri(C.JSString_methods.contains$1(t2, "%3A%2F%2F") ? t1.value = P._Uri__uriDecode(t2, 0, t2.length, C.C_Utf8Codec, false) : t2);
          if (uri != null && uri.get$isAbsolute())
            _this._connect$1(0, uri).catchError$1(new N.ConnectDialog__tryConnect_closure0(handleConnectError));
          else
            handleConnectError.call$0();
        } catch (exception) {
          H.unwrapException(exception);
          handleConnectError.call$0();
        }
    },
    _connect$1: function(_, serviceUri) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, uri, t1, newParams, t2, $async$temp1;
      var $async$_connect$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 2;
              return P._asyncAwait(E.FrameworkCore_initVmService(new N.ConnectDialog__connect_closure(), serviceUri), $async$_connect$1);
            case 2:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                uri = P.Uri_parse(window.location.href, 0, null);
                t1 = P.String;
                newParams = P.LinkedHashMap_LinkedHashMap$of(uri.get$queryParameters(), t1, t1);
                newParams.$indexSet(0, "uri", J.toString$0$(serviceUri));
                t1 = window.history;
                t2 = uri.replace$1$queryParameters(0, newParams).toString$0(0);
                t1.toString;
                t1.pushState(new P._StructuredCloneDart2Js([], []).walk$1(null), null, t2);
                t2 = $async$self.parent.element.style;
                t2.display = "none";
                t1 = $async$self.framework.snapshotMessage.parent.element.style;
                t1.display = "none";
              } else
                throw H.wrapException("not connected");
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_connect$1, $async$completer);
    }
  };
  N.ConnectDialog_closure.prototype = {
    call$0: function() {
      this.$this._tryConnect$0();
    },
    $signature: 0
  };
  N.ConnectDialog_closure0.prototype = {
    call$1: function($event) {
      H.interceptedTypeCheck($event, "$isKeyboardEvent");
      if ($event.keyCode === 13) {
        $event.preventDefault();
        this.$this._tryConnect$0();
      }
    },
    $signature: 14
  };
  N.ConnectDialog__tryConnect_handleConnectError.prototype = {
    call$0: function() {
      this.$this.framework.toast$1("Unable to connect to '" + this._box_0.value + "'.");
    },
    $signature: 1
  };
  N.ConnectDialog__tryConnect_closure.prototype = {
    call$1: function(error) {
      this.handleConnectError.call$0();
    },
    $signature: 2
  };
  N.ConnectDialog__tryConnect_closure0.prototype = {
    call$1: function(error) {
      this.handleConnectError.call$0();
    },
    $signature: 2
  };
  N.ConnectDialog__connect_closure.prototype = {
    call$2: function(title, error) {
    },
    $signature: 25
  };
  N.SnapshotMessage.prototype = {};
  N.AnalyticsOptInDialog.prototype = {
    AnalyticsOptInDialog$1: function(framework) {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, _this = this, _null = null, _s6_ = "button",
        _s8_ = "tabindex",
        t1 = document.querySelector("#ga-dialog");
      _this.parent = new A.CoreElement(t1);
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      t1 = _this.parent;
      t2 = A.h2("Welcome to Dart DevTools");
      t3 = A.CoreElement$("dl", _null, "form-group", _null, _null);
      t4 = A.CoreElement$("dd", _null, _null, _null, _null);
      t5 = [A.CoreElement];
      t4.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", _null, _null, _null, "DevTools reports feature usage statistics and basic crash reports to Google in order to help Google improve the tool over time. See Google's "), A.a("https://www.google.com/intl/en/policies/privacy", "_blank", "privacy policy"), A.CoreElement$("span", _null, _null, _null, "."), A.CoreElement$("p", _null, _null, _null, _null)], t5));
      t6 = A.CoreElement$("dd", _null, _null, _null, _null);
      t7 = A.CoreElement$("p", _null, _null, _null, "Send usage statistics for DevTools?");
      t8 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_, _null), "$isElement");
      t9 = new N.PButton(t8);
      t9.CoreElement$5$attributes$classes$html$text(_s6_, _null, "btn", _null, "Sounds good!");
      t8.setAttribute("type", _s6_);
      t9.clazz$1("btn-sm");
      t8.setAttribute(_s8_, "1");
      _this.acceptButton = t9;
      t8 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_, _null), "$isElement");
      t10 = new N.PButton(t8);
      t10.CoreElement$5$attributes$classes$html$text(_s6_, _null, "btn", _null, "No thanks");
      t8.setAttribute("type", _s6_);
      t10.clazz$1("btn-sm");
      t10.clazz$1("margin-left");
      t8.setAttribute(_s8_, "2");
      _this.dontAcceptButton = t10;
      t6.add$1(0, H.setRuntimeTypeInfo([t7, t9, t10], t5));
      t3.add$1(0, H.setRuntimeTypeInfo([t4, t6], t5));
      t1.add$1(0, H.setRuntimeTypeInfo([t2, t3], t5));
      _this.acceptButton.click$1(0, new N.AnalyticsOptInDialog_closure(_this));
      _this.dontAcceptButton.click$1(0, new N.AnalyticsOptInDialog_closure0(_this));
      t5 = _this.parent.element.style;
      t5.display = "none";
    }
  };
  N.AnalyticsOptInDialog_closure.prototype = {
    call$0: function() {
      var t1 = window.localStorage,
        t2 = self.getDevToolsPropertyID(),
        t3 = self.gaStorageCollect();
      t1.toString;
      t1.setItem(H.stringTypeCheck(t2), H.stringTypeCheck(t3));
      t3 = this.$this.parent.element.style;
      t3.display = "none";
      self._initializeGA();
    },
    $signature: 0
  };
  N.AnalyticsOptInDialog_closure0.prototype = {
    call$0: function() {
      var t1 = window.localStorage,
        t2 = self.getDevToolsPropertyID(),
        t3 = self.gaStorageDontCollect();
      t1.toString;
      t1.setItem(H.stringTypeCheck(t2), H.stringTypeCheck(t3));
      t3 = this.$this.parent.element.style;
      t3.display = "none";
    },
    $signature: 0
  };
  M._invertMap_closure.prototype = {
    call$1: function(entry) {
      var t1 = this.V,
        t2 = this.K;
      H.assertSubtype(entry, "$isMapEntry", [t1, t2], "$asMapEntry");
      return new P.MapEntry(entry.value, entry.key, [t2, t1]);
    },
    $signature: function() {
      var t1 = this.K,
        t2 = this.V;
      return {func: 1, ret: [P.MapEntry, t1, t2], args: [[P.MapEntry, t2, t1]]};
    }
  };
  M.RemoteDiagnosticsNode.prototype = {
    $eq: function(_, other) {
      var _s8_ = "objectId";
      if (other == null)
        return false;
      if (!(other instanceof M.RemoteDiagnosticsNode))
        return false;
      return new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(this.json, _s8_))).$eq(0, new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(other.json, _s8_))));
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(H.stringTypeCheck(J.$index$asx(this.json, "objectId")));
    },
    get$name: function(_) {
      return H.stringTypeCheck(J.$index$asx(this.json, "name"));
    },
    get$tooltip: function() {
      var t1 = H.stringTypeCheck(J.$index$asx(this.json, "tooltip"));
      return t1 == null ? "" : t1;
    },
    get$creationLocation: function() {
      var _this = this,
        _s16_ = "creationLocation",
        t1 = _this._creationLocation;
      if (t1 != null)
        return t1;
      t1 = H.boolConversionCheck(J.containsKey$1$x(_this.json, _s16_));
      if (!t1)
        return;
      return _this._creationLocation = new M.InspectorSourceLocation(H.assertSubtype(J.$index$asx(_this.json, _s16_), "$isMap", [P.String, P.Object], "$asMap"), null);
    },
    getBooleanMember$2: function(memberName, defaultValue) {
      var t1 = this.json,
        t2 = J.getInterceptor$asx(t1);
      if (t2.$index(t1, memberName) == null)
        return defaultValue;
      return H.boolTypeCheck(t2.$index(t1, memberName));
    },
    getLevelMember$2: function(memberName, defaultValue) {
      var level,
        value = H.stringTypeCheck(J.$index$asx(this.json, memberName));
      if (value == null)
        return defaultValue;
      level = C.Map_omyhD.$index(0, value);
      return level == null ? defaultValue : level;
    },
    getStyleMember$2: function(memberName, defaultValue) {
      var value, style,
        t1 = this.json,
        t2 = J.getInterceptor$x(t1);
      if (!H.boolConversionCheck(t2.containsKey$1(t1, memberName)))
        return defaultValue;
      value = H.stringTypeCheck(t2.$index(t1, memberName));
      if (value == null)
        return defaultValue;
      style = C.Map_kT33h.$index(0, value);
      return style == null ? defaultValue : style;
    },
    isEnumProperty$0: function() {
      var t1 = this.json,
        t2 = J.getInterceptor$asx(t1);
      return H.stringTypeCheck(t2.$index(t1, "type")) != null && J.startsWith$1$s(H.stringTypeCheck(t2.$index(t1, "type")), "EnumProperty<");
    },
    get$valueProperties: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, S.InstanceRef]),
        $async$returnValue, $async$self = this, t1, t2, t3, propertyNames;
      var $async$get$valueProperties = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = $async$self._valueProperties == null ? 3 : 4;
                break;
              case 3:
                // then
                t1 = $async$self.json;
                t2 = J.getInterceptor$asx(t1);
                if (H.stringTypeCheck(t2.$index(t1, "propertyType")) != null) {
                  t3 = H.stringTypeCheck(t2.$index(t1, "valueId"));
                  t3 = t3 == null;
                } else
                  t3 = true;
                if (t3) {
                  t1 = new P._Future($.Zone__current, [[P.Map, P.String, S.InstanceRef]]);
                  t1._asyncComplete$1(null);
                  $async$self.set$_valueProperties(t1);
                  $async$returnValue = $async$self._valueProperties;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = $async$self.isEnumProperty$0() ? 5 : 6;
                break;
              case 5:
                // then
                $async$goto = 7;
                return P._asyncAwait($async$self.inspectorService, $async$get$valueProperties);
              case 7:
                // returning from await.
                t3 = $async$result;
                $async$returnValue = t3 == null ? null : t3.getEnumPropertyValues$1(new E.InspectorInstanceRef(H.stringTypeCheck(t2.$index(t1, "valueId"))));
                // goto return
                $async$goto = 1;
                break;
              case 6:
                // join
                switch (H.stringTypeCheck(t2.$index(t1, "propertyType"))) {
                  case "Color":
                    propertyNames = H.setRuntimeTypeInfo(["red", "green", "blue", "alpha"], [P.String]);
                    break;
                  case "IconData":
                    propertyNames = H.setRuntimeTypeInfo(["codePoint"], [P.String]);
                    break;
                  default:
                    t1 = new P._Future($.Zone__current, [[P.Map, P.String, S.InstanceRef]]);
                    t1._asyncComplete$1(null);
                    $async$self.set$_valueProperties(t1);
                    $async$returnValue = $async$self._valueProperties;
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                }
                $async$goto = 8;
                return P._asyncAwait($async$self.inspectorService, $async$get$valueProperties);
              case 8:
                // returning from await.
                t3 = $async$result;
                $async$self.set$_valueProperties(t3 == null ? null : t3.getDartObjectProperties$2(new E.InspectorInstanceRef(H.stringTypeCheck(t2.$index(t1, "valueId"))), propertyNames));
              case 4:
                // join
                $async$returnValue = $async$self._valueProperties;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$get$valueProperties, $async$completer);
    },
    get$hasChildren: function() {
      var children = H.listTypeCheck(J.$index$asx(this.json, "children"));
      if (children != null)
        return J.get$isNotEmpty$asx(children);
      return this.getBooleanMember$2("hasChildren", false);
    },
    get$childrenReady: function() {
      return H.boolConversionCheck(J.containsKey$1$x(this.json, "children")) || this._diagnostics_node$_children != null || !H.boolConversionCheck(this.get$hasChildren());
    },
    _computeChildren$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1;
      var $async$_computeChildren$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._maybePopulateChildren$0();
              if (!H.boolConversionCheck($async$self.get$hasChildren()) || $async$self._diagnostics_node$_children != null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self._childrenFuture;
              $async$goto = t1 != null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait(t1, $async$_computeChildren$0);
            case 5:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              $async$self.set$_childrenFuture($async$self._getChildrenHelper$0());
              $async$handler = 6;
              $async$goto = 9;
              return P._asyncAwait($async$self._childrenFuture, $async$_computeChildren$0);
            case 9:
              // returning from await.
              $async$self.set$_diagnostics_node$_children(0, $async$result);
              $async$next.push(8);
              // goto finally
              $async$goto = 7;
              break;
            case 6:
              // uncaught
              $async$next = [2];
            case 7:
              // finally
              $async$handler = 2;
              if ($async$self._diagnostics_node$_children == null)
                $async$self.set$_diagnostics_node$_children(0, H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]));
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 8:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_computeChildren$0, $async$completer);
    },
    _getChildrenHelper$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
        $async$returnValue, $async$self = this, t2, t3, t1;
      var $async$_getChildrenHelper$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.inspectorService, $async$_getChildrenHelper$0);
            case 3:
              // returning from await.
              t1 = $async$result;
              if (t1 == null)
                t1 = null;
              else {
                t2 = H.stringTypeCheck(J.$index$asx($async$self.json, "objectId"));
                t3 = H.boolConversionCheck($async$self.getBooleanMember$2("summaryTree", false)) ? "getChildrenSummaryTree" : "getChildrenDetailsSubtree";
                t3 = t1.getListHelper$3(new E.InspectorInstanceRef(t2), t3, $async$self);
                t1 = t3;
              }
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_getChildrenHelper$0, $async$completer);
    },
    _maybePopulateChildren$0: function() {
      var t1, jsonArray, nodes, t2, t3, element, child, _this = this;
      if (!H.boolConversionCheck(_this.get$hasChildren()) || _this._diagnostics_node$_children != null)
        return;
      t1 = P.Object;
      jsonArray = H.assertSubtype(J.$index$asx(_this.json, "children"), "$isList", [t1], "$asList");
      if ((jsonArray == null ? null : J.get$isNotEmpty$asx(jsonArray)) === true) {
        nodes = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
        for (t2 = J.get$iterator$ax(jsonArray), t1 = [P.String, t1], t3 = _this.inspectorService; t2.moveNext$0();) {
          element = H.assertSubtype(t2.get$current(t2), "$isMap", t1, "$asMap");
          child = new M.RemoteDiagnosticsNode(_this.parent, t3, element, false);
          child.parent = _this;
          C.JSArray_methods.add$1(nodes, child);
        }
        _this.set$_diagnostics_node$_children(0, nodes);
      }
    },
    get$inlineProperties: function() {
      var t1, t2, t3, element, t4, _this = this,
        _s10_ = "properties";
      if (_this.cachedProperties == null) {
        _this.set$cachedProperties(H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]));
        t1 = _this.json;
        t2 = J.getInterceptor$x(t1);
        if (H.boolConversionCheck(t2.containsKey$1(t1, _s10_))) {
          t3 = P.Object;
          for (t1 = J.get$iterator$ax(H.assertSubtype(t2.$index(t1, _s10_), "$isList", [t3], "$asList")), t3 = [P.String, t3], t2 = _this.inspectorService; t1.moveNext$0();) {
            element = H.assertSubtype(t1.get$current(t1), "$isMap", t3, "$asMap");
            t4 = _this.cachedProperties;
            (t4 && C.JSArray_methods).add$1(t4, new M.RemoteDiagnosticsNode(_this.parent, t2, element, true));
          }
          _this.trackPropertiesMatchingParameters$1(_this.cachedProperties);
        }
      }
      return _this.cachedProperties;
    },
    trackPropertiesMatchingParameters$1: function(nodes) {
      var t1, parameterLocations, names, _i, $location, $name, node, parameterLocation;
      H.assertSubtype(nodes, "$isList", [M.RemoteDiagnosticsNode], "$asList");
      t1 = this.get$creationLocation();
      parameterLocations = t1 == null ? null : t1.getParameterLocations$0();
      if (parameterLocations != null) {
        names = P.LinkedHashMap_LinkedHashMap$_empty(P.String, M.InspectorSourceLocation);
        for (t1 = parameterLocations.length, _i = 0; _i < parameterLocations.length; parameterLocations.length === t1 || (0, H.throwConcurrentModificationError)(parameterLocations), ++_i) {
          $location = parameterLocations[_i];
          $name = H.stringTypeCheck(J.$index$asx($location.json, "name"));
          if ($name != null)
            names.$indexSet(0, $name, $location);
        }
        for (t1 = nodes.length, _i = 0; _i < nodes.length; nodes.length === t1 || (0, H.throwConcurrentModificationError)(nodes), ++_i) {
          node = nodes[_i];
          node.parent = this;
          $name = H.stringTypeCheck(J.$index$asx(node.json, "name"));
          if ($name != null) {
            parameterLocation = names.$index(0, $name);
            if (parameterLocation != null)
              node._creationLocation = parameterLocation;
          }
        }
      }
      return nodes;
    },
    get$icon: function(_) {
      var t1, t2, icon, _this = this,
        _s17_ = "widgetRuntimeType";
      if (_this.isProperty)
        return;
      t1 = $.Catalog__instance;
      if (t1 == null)
        t1 = null;
      else {
        t2 = H.stringTypeCheck(J.$index$asx(_this.json, _s17_));
        t1 = t2 != null ? t1.widgets.$index(0, t2) : null;
      }
      icon = t1 == null ? null : t1.icon;
      t1 = icon == null;
      return t1 && H.stringTypeCheck(J.$index$asx(_this.json, _s17_)) != null ? t1 ? $.$get$RemoteDiagnosticsNode_iconMaker().fromWidgetName$1(H.stringTypeCheck(J.$index$asx(_this.json, _s17_))) : icon : icon;
    },
    debugFillProperties$1: function(properties) {
      var t1, t2, t3, _i, property, t4;
      this.super$Diagnosticable$debugFillProperties(properties);
      for (t1 = this.get$inlineProperties(), t2 = t1.length, t3 = M.RemoteDiagnosticsNode, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        property = t1[_i];
        t4 = H.stringTypeCheck(J.$index$asx(property.json, "name"));
        C.JSArray_methods.add$1(properties.properties, new U.DiagnosticsProperty(null, property, t4, true, true, null, C.DiagnosticsTreeStyle_7, [t3]));
      }
    },
    debugDescribeChildren$0: function() {
      var children, regularChildren, t1;
      this._maybePopulateChildren$0();
      children = this._diagnostics_node$_children;
      if (children == null || J.get$isEmpty$asx(children))
        return C.List_empty2;
      regularChildren = H.setRuntimeTypeInfo([], [U.DiagnosticsNode]);
      for (t1 = J.get$iterator$ax(children); t1.moveNext$0();)
        C.JSArray_methods.add$1(regularChildren, t1.get$current(t1).toDiagnosticsNode$0());
      return regularChildren;
    },
    toDiagnosticsNode$1$style: function(style) {
      var t1 = H.stringTypeCheck(J.$index$asx(this.json, "name"));
      return this.super$DiagnosticableTree$toDiagnosticsNode(t1, style == null ? C.DiagnosticsTreeStyle_0 : style);
    },
    toDiagnosticsNode$0: function() {
      return this.toDiagnosticsNode$1$style(null);
    },
    setSelectionInspector$1: function(uiAlreadyUpdated) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$setSelectionInspector$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.inspectorService, $async$setSelectionInspector$1);
            case 2:
              // returning from await.
              t1 = $async$result;
              $async$goto = 3;
              return P._asyncAwait(t1 == null ? null : t1.setSelectionInspector$2(new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx($async$self.json, "valueId"))), uiAlreadyUpdated), $async$setSelectionInspector$1);
            case 3:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$setSelectionInspector$1, $async$completer);
    },
    set$cachedProperties: function(cachedProperties) {
      this.cachedProperties = H.assertSubtype(cachedProperties, "$isList", [M.RemoteDiagnosticsNode], "$asList");
    },
    set$_valueProperties: function(_valueProperties) {
      this._valueProperties = H.assertSubtype(_valueProperties, "$isFuture", [[P.Map, P.String, S.InstanceRef]], "$asFuture");
    },
    set$_childrenFuture: function(_childrenFuture) {
      this._childrenFuture = H.assertSubtype(_childrenFuture, "$isFuture", [[P.List, M.RemoteDiagnosticsNode]], "$asFuture");
    },
    set$_diagnostics_node$_children: function(_, _children) {
      this._diagnostics_node$_children = H.assertSubtype(_children, "$isList", [M.RemoteDiagnosticsNode], "$asList");
    },
    get$json: function(receiver) {
      return this.json;
    }
  };
  M.InspectorSourceLocation.prototype = {
    getParameterLocations$0: function() {
      var t3, parametersJson, ret, i,
        _s18_ = "parameterLocations",
        t1 = this.json,
        t2 = J.getInterceptor$x(t1);
      if (H.boolConversionCheck(t2.containsKey$1(t1, _s18_))) {
        t3 = P.Object;
        parametersJson = H.assertSubtype(t2.$index(t1, _s18_), "$isList", [t3], "$asList");
        ret = H.setRuntimeTypeInfo([], [M.InspectorSourceLocation]);
        t1 = J.getInterceptor$asx(parametersJson);
        t3 = [P.String, t3];
        i = 0;
        while (true) {
          t2 = t1.get$length(parametersJson);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          C.JSArray_methods.add$1(ret, new M.InspectorSourceLocation(H.assertSubtype(t1.$index(parametersJson, i), "$isMap", t3, "$asMap"), this));
          ++i;
        }
        return ret;
      }
      return;
    },
    get$json: function(receiver) {
      return this.json;
    }
  };
  S.Category.prototype = {};
  S.FlutterWidget.prototype = {
    get$name: function(_) {
      return H.stringTypeCheck(J.$index$asx(this.json, "name"));
    },
    get$json: function(receiver) {
      return this.json;
    }
  };
  S.Catalog.prototype = {};
  D.InspectorScreen.prototype = {
    createContent$1: function(framework) {
      var screenDiv, t1, buttonSection, t2, t3, t4, t5, _this = this, _null = null, _s3_ = "div",
        _s45_ = "btn-group collapsible-1200 nowrap margin-left";
      E.setupDimensions();
      screenDiv = A.CoreElement$(_s3_, _null, "custom-scrollbar inspector-page", _null, _null);
      t1 = screenDiv.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      buttonSection = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t1 = buttonSection.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("horizontal", "");
      t1 = A.CoreElement$(_s3_, _null, "btn-group collapsible-700 nowrap", _null, _null);
      t2 = Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_reb).button;
      t3 = N.PButton$icon("Refresh Tree", $._isDarkTheme ? C.MaterialIcon_6we : C.MaterialIcon_Osx, _null);
      t3.clazz$1("btn-sm");
      t3.attribute$2("disabled", true);
      t3.click$1(0, _this.get$_refreshInspector());
      _this.refreshTreeButton = t3;
      t1.add$1(0, H.setRuntimeTypeInfo([t2, t3], [N.PButton]));
      t3 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t2 = new N.ProgressElement(t3);
      t2.CoreElement$5$attributes$classes$html$text(_s3_, _null, _null, _null, _null);
      t2.clazz$1("progress-element");
      t2.add$1(0, A.CoreElement$(_s3_, _null, "complete", _null, _null));
      t2.clazz$1("margin-left");
      t3 = t3.style;
      t3.display = "none";
      t3 = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t3.flex$0(0);
      t4 = [A.CoreElement];
      buttonSection.add$1(0, H.setRuntimeTypeInfo([t1, t2, t3], t4));
      t3 = A.CoreElement$(_s3_, _null, _s45_, _null, _null);
      t3.add$1(0, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_7N7).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_4uk).button], t4));
      t2 = A.CoreElement$(_s3_, _null, _s45_, _null, _null);
      t2.add$1(0, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_2L7).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_4yw).button], t4));
      t1 = A.CoreElement$(_s3_, _null, _s45_, _null, _null);
      t1.add$1(0, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_iL9).button], t4));
      t5 = A.CoreElement$(_s3_, _null, "btn-group collapsible-1400 nowrap margin-left", _null, _null);
      t5.add$1(0, H.setRuntimeTypeInfo([Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_FEs).button, Y.ServiceExtensionButton$(C.ToggleableServiceExtensionDescription_ACQ).button], t4));
      C.JSArray_methods.forEach$1(H.setRuntimeTypeInfo([t3, t2, t1, t5], t4), buttonSection.get$add(buttonSection));
      t5 = A.CoreElement$(_s3_, _null, "inspector-container bidirectional", _null, _null);
      _this.inspectorContainer = t5;
      screenDiv.add$1(0, H.setRuntimeTypeInfo([buttonSection, t5], t4));
      t4 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
      new P._BroadcastStream(t4, [H.getTypeArgumentByIndex(t4, 0)]).listen$1(_this.get$_inspector$_handleConnectionStart());
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
        _this._inspector$_handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(_this.get$_inspector$_handleConnectionStop());
      return screenDiv;
    },
    _inspector$_handleConnectionStart$1: function(service) {
      H.interceptedTypeCheck(service, "$isVmService");
      return this._handleConnectionStart$body$InspectorScreen(service);
    },
    _handleConnectionStart$body$InspectorScreen: function(service) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, spinner, t1, inspectorTree, detailsInspectorTree, elements, $async$temp1;
      var $async$_inspector$_handleConnectionStart$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.refreshTreeButton.attribute$2("disabled", false);
              spinner = N.Spinner$_(H.setRuntimeTypeInfo(["centered"], [P.String]));
              $async$self.inspectorContainer.add$1(0, spinner);
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait(E.ensureInspectorServiceDependencies(), $async$_inspector$_handleConnectionStart$1);
            case 6:
              // returning from await.
              $async$temp1 = H;
              $async$goto = 7;
              return P._asyncAwait(E.InspectorService_create(service).catchError$1(new D.InspectorScreen__handleConnectionStart_closure()), $async$_inspector$_handleConnectionStart$1);
            case 7:
              // returning from await.
              $async$self.inspectorService = $async$temp1.interceptedTypeCheck($async$result, "$isInspectorService");
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              J.remove$0$ax(spinner.element);
              $async$self.refreshTreeButton.attribute$2("disabled", false);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              t1 = $async$self.inspectorService;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self.inspectorController = Z.InspectorController$(t1, new D.InspectorScreen__handleConnectionStart_closure0(), true, null, C.FlutterTreeType_0);
              inspectorTree = H.interceptedTypeCheck(t1.inspectorTree, "$isInspectorTreeWeb");
              detailsInspectorTree = H.interceptedTypeCheck(t1.details.inspectorTree, "$isInspectorTreeWeb");
              elements = H.setRuntimeTypeInfo([inspectorTree.get$element().element, detailsInspectorTree.get$element().element], [W.Element]);
              $async$self.inspectorContainer.add$1(0, elements);
              t1 = [P.num];
              $async$self.set$splitterSubscription(A.flexSplitBidirectional(elements, 10, H.setRuntimeTypeInfo([35, 65], t1), H.setRuntimeTypeInfo([60, 40], t1)));
              $async$self.inspectorController.setVisibleToUser$1(true);
              $async$self.inspectorController.setActivate$1(true);
              if (!$async$self.displayedWidgetTrackingNotice)
                $async$self.inspectorService.invokeBoolServiceMethodNoArgs$1("isWidgetCreationTracked").then$1$1(new D.InspectorScreen__handleConnectionStart_closure1($async$self), null);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_inspector$_handleConnectionStart$1, $async$completer);
    },
    _inspector$_handleConnectionStop$1: function($event) {
      var t1, _this = this;
      _this.refreshTreeButton.attribute$2("disabled", true);
      t1 = _this.inspectorController;
      if (t1 != null)
        t1.setActivate$1(false);
      t1 = _this.inspectorController;
      if (t1 != null)
        t1.dispose$0();
      _this.inspectorController = null;
      t1 = _this.splitterSubscription;
      if (t1 != null)
        t1.cancel$0(0);
      _this.set$splitterSubscription(null);
    },
    _refreshInspector$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t1;
      var $async$_refreshInspector$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("inspector", "refresh", 0);
              $async$self.refreshTreeButton.attribute$2("disabled", true);
              t1 = $async$self.inspectorController;
              $async$goto = 2;
              return P._asyncAwait(t1 == null ? null : t1.onForceRefresh$0(), $async$_refreshInspector$0);
            case 2:
              // returning from await.
              $async$self.refreshTreeButton.attribute$2("disabled", false);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_refreshInspector$0, $async$completer);
    },
    set$splitterSubscription: function(splitterSubscription) {
      this.splitterSubscription = H.assertSubtype(splitterSubscription, "$isStreamSubscription", [P.Object], "$asStreamSubscription");
    }
  };
  D.InspectorScreen__handleConnectionStart_closure.prototype = {
    call$1: function(e) {
      return;
    },
    $signature: 2
  };
  D.InspectorScreen__handleConnectionStart_closure0.prototype = {
    call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType: function(onExpand, onHover, onNodeAdded, onSelectionChange, summaryTree, treeType) {
      var t1;
      H.functionTypeCheck(onExpand, {func: 1, ret: -1, args: [K.InspectorTreeNode]});
      H.functionTypeCheck(onHover, {func: 1, ret: -1, args: [K.InspectorTreeNode, S.Icon]});
      H.functionTypeCheck(onNodeAdded, {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]});
      H.functionTypeCheck(onSelectionChange, {func: 1, ret: -1});
      t1 = new E.InspectorTreeCanvas(onHover, onExpand, onSelectionChange, onNodeAdded);
      t1._inspector_tree_canvas$_viewportCanvas = T.ViewportCanvas$("inspector-tree inspector-tree-container", t1.get$onMouseLeave(t1), t1.get$onMouseMove(t1), t1.get$_updateForContainerResize(), t1.get$onTap(), t1.get$_inspector_tree_canvas$_paintCallback());
      return t1;
    },
    call$0: function() {
      return this.call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(null, null, null, null, null, null);
    },
    $signature: 109
  };
  D.InspectorScreen__handleConnectionStart_closure1.prototype = {
    call$1: function(value) {
      var t1, t2;
      if (H.boolConversionCheck(H.boolTypeCheck(value)))
        return;
      t1 = this.$this;
      t1.displayedWidgetTrackingNotice = true;
      t1 = t1.framework;
      t2 = $.$get$trackWidgetCreationWarning();
      t1.messageManager.addMessage$2(t2, "inspector");
    },
    $signature: 9
  };
  Z.InspectorController.prototype = {
    InspectorController$5$inspectorService$inspectorTreeFactory$isSummaryTree$parent$treeType: function(inspectorService, inspectorTreeFactory, isSummaryTree, $parent, treeType) {
      var t1, t2, _this = this;
      _this._refreshRateLimiter = new B.RateLimiter(_this.get$refresh(_this), 200);
      t1 = _this.isSummaryTree;
      t2 = _this.treeType;
      _this.inspectorTree = H.interceptedTypeCheck(inspectorTreeFactory.call$6$onExpand$onHover$onNodeAdded$onSelectionChange$summaryTree$treeType(_this.get$_onExpand(), _this.get$highlightShowNode(), _this.get$_inspector_controller$_onNodeAdded(), _this.get$selectionChanged(), t1, t2), "$isInspectorTree");
      if (t1)
        _this.details = Z.InspectorController$(_this.inspectorService, inspectorTreeFactory, false, _this, t2);
      else
        _this.details = null;
      _this.set$flutterIsolateSubscription(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager.getSelectedIsolate$1(new Z.InspectorController_closure(_this)));
    },
    get$selectedDiagnostic: function() {
      var t1 = this.selectedNode;
      return t1 == null ? null : t1._diagnostic;
    },
    setVisibleToUser$1: function(visible) {
      var t1, _this = this;
      if (_this.visibleToUser)
        return;
      _this.visibleToUser = true;
      t1 = _this.details;
      if (t1 != null)
        t1.setVisibleToUser$1(true);
      if (_this.visibleToUser) {
        if (_this.parent == null)
          _this.maybeLoadUI$0();
      } else
        _this.shutdownTree$1(false);
    },
    highlightShowNode$2: function(node, icon) {
      var _this = this;
      H.interceptedTypeCheck(node, "$isInspectorTreeNode");
      H.interceptedTypeCheck(icon, "$isIcon");
      if (node == null && _this.parent != null)
        node = _this.findMatchingInspectorTreeNode$1(_this.parent.get$selectedDiagnostic());
      _this.inspectorTree.set$hover(node);
      return true;
    },
    findMatchingInspectorTreeNode$1: function(node) {
      if ((node == null ? null : new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(node.json, "valueId")))) == null)
        return;
      return this.valueToInspectorTreeNode.$index(0, new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(node.json, "valueId"))));
    },
    getPendingUpdateDone$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$getPendingUpdateDone$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._selectionGroups;
              $async$goto = 2;
              return P._asyncAwait(t1 == null ? null : t1.get$pendingUpdateDone(), $async$getPendingUpdateDone$0);
            case 2:
              // returning from await.
              t1 = $async$self._treeGroups;
              $async$goto = 3;
              return P._asyncAwait(t1 == null ? null : t1.get$pendingUpdateDone(), $async$getPendingUpdateDone$0);
            case 3:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$getPendingUpdateDone$0, $async$completer);
    },
    refresh$0: function(_) {
      var t1, _this = this;
      if (!_this.visibleToUser) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      if (_this.details != null)
        return P.Future_wait(H.setRuntimeTypeInfo([_this.getPendingUpdateDone$0(), _this.details.getPendingUpdateDone$0()], [[P.Future, -1]]), -1);
      else
        return _this.getPendingUpdateDone$0();
    },
    shutdownTree$1: function(isolateStopped) {
      var t1, _this = this;
      _this.programaticSelectionChangeInProgress = true;
      _this._treeGroups.clear$1(0, isolateStopped);
      _this._selectionGroups.clear$1(0, isolateStopped);
      _this.inspectorTree.set$hover(null);
      _this.subtreeRoot = _this.selectedNode = null;
      t1 = _this.inspectorTree;
      t1.set$root(0, t1.createNode$0());
      t1 = _this.details;
      if (t1 != null)
        t1.shutdownTree$1(isolateStopped);
      _this.programaticSelectionChangeInProgress = false;
      _this.valueToInspectorTreeNode.clear$0(0);
    },
    onIsolateStopped$0: function() {
      this.treeLoadStarted = this.flutterAppFrameReady = false;
      this.shutdownTree$1(true);
    },
    onForceRefresh$0: function() {
      var t1, _this = this;
      if (!_this.visibleToUser || _this._disposed) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      _this.recomputeTreeRoot$3(null, null, false);
      return _this.getPendingUpdateDone$0();
    },
    setActivate$1: function(enabled) {
      var _this = this;
      if (!enabled) {
        _this.onIsolateStopped$0();
        _this.isActive = false;
        return;
      }
      if (_this.isActive)
        return;
      _this.isActive = true;
      _this.inspectorService.clients.add$1(0, _this);
      _this.maybeLoadUI$0();
    },
    maybeLoadUI$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, ready;
      var $async$maybeLoadUI$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!$async$self.visibleToUser || !$async$self.isActive) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self.inspectorService;
              $async$goto = H.boolConversionCheck($async$self.flutterAppFrameReady) ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait(t1.inferPubRootDirectoryIfNeeded$0(), $async$maybeLoadUI$0);
            case 6:
              // returning from await.
              $async$goto = 7;
              return P._asyncAwait($async$self.updateSelectionFromService$1$firstFrame(true), $async$maybeLoadUI$0);
            case 7:
              // returning from await.
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = 8;
              return P._asyncAwait(t1.invokeBoolServiceMethodNoArgs$1("isWidgetTreeReady"), $async$maybeLoadUI$0);
            case 8:
              // returning from await.
              ready = $async$result;
              $async$self.flutterAppFrameReady = ready;
              $async$goto = $async$self.isActive && H.boolConversionCheck(ready) ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return P._asyncAwait($async$self.maybeLoadUI$0(), $async$maybeLoadUI$0);
            case 11:
              // returning from await.
            case 10:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$maybeLoadUI$0, $async$completer);
    },
    recomputeTreeRoot$3: function(newSelection, detailsSelection, setSubtreeRoot) {
      return this.recomputeTreeRoot$body$InspectorController(newSelection, detailsSelection, setSubtreeRoot);
    },
    recomputeTreeRoot$body$InspectorController: function(newSelection, detailsSelection, setSubtreeRoot) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, group, node, rootNode, error, t1, exception, $async$exception;
      var $async$recomputeTreeRoot$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._treeGroups.cancelNext$0();
              $async$handler = 4;
              t1 = $async$self._treeGroups;
              group = t1.get$next(t1);
              $async$goto = 7;
              return P._asyncAwait($async$self.parent != null ? group.getDetailsSubtree$1($async$self.subtreeRoot) : group.getRoot$1($async$self.treeType), $async$recomputeTreeRoot$3);
            case 7:
              // returning from await.
              node = $async$result;
              if (node == null || group.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._treeGroups.promoteNext$0();
              $async$self.clearValueToInspectorTreeNodeMapping$0();
              t1 = $async$self.inspectorTree;
              if (node != null) {
                rootNode = t1.setupInspectorTreeNode$4$expandChildren$expandProperties(t1.createNode$0(), node, true, false);
                $async$self.inspectorTree.set$root(0, rootNode);
              } else
                t1.set$root(0, t1.createNode$0());
              $async$self.refreshSelection$3(newSelection, detailsSelection, setSubtreeRoot);
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              error = H.unwrapException($async$exception);
              P.print(error);
              $async$self._treeGroups.cancelNext$0();
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$recomputeTreeRoot$3, $async$completer);
    },
    clearValueToInspectorTreeNodeMapping$0: function() {
      var t1, _this = this;
      if (_this.parent != null) {
        t1 = _this.valueToInspectorTreeNode;
        t1.get$keys(t1).forEach$1(0, _this.parent.get$maybeUpdateValueUI());
      }
      _this.valueToInspectorTreeNode.clear$0(0);
    },
    setSubtreeRoot$2: function(node, selection) {
      var t1, _this = this;
      if (selection == null)
        selection = node;
      t1 = node == null;
      if (!t1 && node.$eq(0, _this.subtreeRoot)) {
        _this.applyNewSelection$3(selection, null, false);
        return;
      }
      _this.subtreeRoot = node;
      if (t1) {
        _this.shutdownTree$1(false);
        return;
      }
      _this.clearValueToInspectorTreeNodeMapping$0();
      _this.recomputeTreeRoot$3(selection, null, false);
    },
    getSubtreeRootNode$0: function() {
      var t1 = this.subtreeRoot;
      if (t1 == null)
        return;
      return this.valueToInspectorTreeNode.$index(0, new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(t1.json, "valueId"))));
    },
    refreshSelection$3: function(newSelection, detailsSelection, setSubtreeRoot) {
      var _this = this;
      if (newSelection == null)
        newSelection = _this.get$selectedDiagnostic();
      _this.setSelectedNode$1(_this.findMatchingInspectorTreeNode$1(newSelection));
      _this.syncSelectionHelper$2(setSubtreeRoot, detailsSelection);
      if (_this.details != null)
        if (_this.subtreeRoot != null && _this.getSubtreeRootNode$0() == null) {
          _this.subtreeRoot = newSelection;
          _this.details.setSubtreeRoot$2(newSelection, detailsSelection);
        }
      _this.syncTreeSelection$0();
    },
    syncTreeSelection$0: function() {
      var _this = this;
      _this.programaticSelectionChangeInProgress = true;
      _this.inspectorTree.set$selection(_this.selectedNode);
      _this.programaticSelectionChangeInProgress = false;
      _this.animateTo$1(_this.selectedNode);
    },
    selectAndShowNode$1: function(node) {
      if (node == null)
        return;
      this.selectAndShowInspectorInstanceRef$1(new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(node.json, "valueId"))));
    },
    selectAndShowInspectorInstanceRef$1: function(ref) {
      var node = this.valueToInspectorTreeNode.$index(0, ref);
      if (node == null)
        return;
      this.setSelectedNode$1(node);
      this.syncTreeSelection$0();
    },
    maybeUpdateValueUI$1: function(valueRef) {
      var node = this.valueToInspectorTreeNode.$index(0, H.interceptedTypeCheck(valueRef, "$isInspectorInstanceRef"));
      if (node == null)
        return;
      this.inspectorTree.nodeChanged$1(node);
    },
    onFlutterFrame$0: function() {
      var _this = this;
      _this.flutterAppFrameReady = true;
      if (!_this.visibleToUser)
        return;
      if (!_this.treeLoadStarted) {
        _this.treeLoadStarted = true;
        _this.maybeLoadUI$0();
      }
      _this._refreshRateLimiter.scheduleRequest$0();
    },
    onInspectorSelectionChanged$0: function() {
      if (!this.visibleToUser)
        return;
      if (this.parent != null)
        return;
      this.updateSelectionFromService$1$firstFrame(false);
    },
    updateSelectionFromService$1$firstFrame: function(firstFrame) {
      return this.updateSelectionFromService$body$InspectorController(firstFrame);
    },
    updateSelectionFromService$body$InspectorController: function(firstFrame) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, group, pendingSelectionFuture, pendingDetailsFuture, newSelection, detailsSelection, error, t2, exception, t1, $async$exception;
      var $async$updateSelectionFromService$1$firstFrame = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._selectionGroups;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.treeLoadStarted = true;
              t1.cancelNext$0();
              t1 = $async$self._selectionGroups;
              group = t1.get$next(t1);
              t1 = $async$self.treeType;
              t2 = $async$self.isSummaryTree;
              pendingSelectionFuture = J.getSelection$3$z(group, $async$self.get$selectedDiagnostic(), t1, t2);
              pendingDetailsFuture = t2 ? J.getSelection$3$z(group, $async$self.get$selectedDiagnostic(), t1, false) : null;
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(pendingSelectionFuture, $async$updateSelectionFromService$1$firstFrame);
            case 7:
              // returning from await.
              newSelection = $async$result;
              if (group.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              detailsSelection = null;
              $async$goto = pendingDetailsFuture != null ? 8 : 9;
              break;
            case 8:
              // then
              $async$goto = 10;
              return P._asyncAwait(pendingDetailsFuture, $async$updateSelectionFromService$1$firstFrame);
            case 10:
              // returning from await.
              detailsSelection = $async$result;
              if (group.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
            case 9:
              // join
              if (!firstFrame) {
                t1 = detailsSelection;
                t1 = t1 == null ? null : new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(t1.json, "valueId")));
                t2 = $async$self.details.get$selectedDiagnostic();
                if (J.$eq$(t1, t2 == null ? null : new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(t2.json, "valueId"))))) {
                  t1 = newSelection;
                  t1 = t1 == null ? null : new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(t1.json, "valueId")));
                  t2 = $async$self.get$selectedDiagnostic();
                  t1 = J.$eq$(t1, t2 == null ? null : new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(t2.json, "valueId"))));
                } else
                  t1 = false;
              } else
                t1 = false;
              if (t1) {
                $async$self._selectionGroups.cancelNext$0();
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._selectionGroups.promoteNext$0();
              $async$self.subtreeRoot = H.interceptedTypeCheck(newSelection, "$isRemoteDiagnosticsNode");
              $async$self.applyNewSelection$3(newSelection, detailsSelection, true);
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              error = H.unwrapException($async$exception);
              t1 = $async$self._selectionGroups;
              t1 = t1.get$next(t1);
              t2 = group;
              if (t1 == null ? t2 == null : t1 === t2) {
                P.print(error);
                $async$self._selectionGroups.cancelNext$0();
              }
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$updateSelectionFromService$1$firstFrame, $async$completer);
    },
    applyNewSelection$3: function(newSelection, detailsSelection, setSubtreeRoot) {
      if (this.findMatchingInspectorTreeNode$1(newSelection) == null)
        this.recomputeTreeRoot$3(newSelection, detailsSelection, setSubtreeRoot);
      this.refreshSelection$3(newSelection, detailsSelection, setSubtreeRoot);
    },
    animateTo$1: function(node) {
      var targets, node0, t1, t2, _i, child, diagnosticsNode;
      if (node == null)
        return;
      targets = H.setRuntimeTypeInfo([node], [K.InspectorTreeNode]);
      while (true) {
        node0 = node._inspector_tree$_parent;
        if (node0 != null) {
          t1 = node._diagnostic;
          t1 = (t1 == null ? null : t1.isProperty) === true;
        } else
          t1 = false;
        if (!t1)
          break;
        node = node0;
      }
      for (t1 = node._children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        diagnosticsNode = child._diagnostic;
        C.JSArray_methods.add$1(targets, child);
        if (child._children.length !== 0 && child._isExpanded)
          break;
        if (diagnosticsNode != null && !diagnosticsNode.isProperty)
          break;
      }
      this.inspectorTree.animateToTargets$1(targets);
    },
    setSelectedNode$1: function(newSelection) {
      var _this = this, _null = null,
        t1 = _this.selectedNode;
      if (newSelection == t1)
        return;
      if (t1 != null)
        if (_this.parent == null)
          _this.inspectorTree.nodeChanged$1(t1._inspector_tree$_parent);
      _this.selectedNode = newSelection;
      _this.highlightShowNode$2(_null, _null);
      t1 = _this.details;
      if (t1 != null)
        t1.highlightShowNode$2(_null, _null);
      else {
        t1 = _this.parent;
        if (t1 != null)
          t1.highlightShowNode$2(_null, _null);
      }
      _this.animateTo$1(_this.selectedNode);
    },
    _onExpand$1: function(node) {
      H.interceptedTypeCheck(node, "$isInspectorTreeNode");
      this.inspectorTree.maybePopulateChildren$1(node);
    },
    selectionChanged$0: function() {
      var t1, node, t2, t3, maybeReroot, _this = this;
      if (!_this.visibleToUser)
        return;
      t1 = _this.inspectorTree;
      node = t1._selection;
      t2 = node != null;
      if (t2)
        t1.maybePopulateChildren$1(node);
      if (_this.programaticSelectionChangeInProgress)
        return;
      if (t2) {
        _this.setSelectedNode$1(node);
        t1 = _this.isSummaryTree;
        if (t1)
          if (_this.details != null) {
            if (_this.get$selectedDiagnostic() != null) {
              t2 = _this.details;
              t3 = H.stringTypeCheck(J.$index$asx(_this.get$selectedDiagnostic().json, "valueId"));
              t3 = !t2.valueToInspectorTreeNode.containsKey$1(0, new E.InspectorInstanceRef(t3));
              t2 = t3;
            } else
              t2 = false;
            maybeReroot = t2;
          } else
            maybeReroot = false;
        else
          maybeReroot = false;
        _this.syncSelectionHelper$2(maybeReroot, null);
        if (!maybeReroot)
          if (t1 && _this.details != null)
            _this.details.selectAndShowNode$1(_this.get$selectedDiagnostic());
          else {
            t1 = _this.parent;
            if (t1 != null)
              t1.selectAndShowNode$1(_this.firstAncestorInParentTree$1(_this.selectedNode));
          }
      }
    },
    firstAncestorInParentTree$1: function(node) {
      var diagnostic, t1, t2;
      if (this.parent == null)
        return node._diagnostic;
      for (; node != null;) {
        diagnostic = node._diagnostic;
        if (diagnostic != null) {
          t1 = this.parent;
          t2 = H.stringTypeCheck(J.$index$asx(diagnostic.json, "valueId"));
          t2 = t1.valueToInspectorTreeNode.containsKey$1(0, new E.InspectorInstanceRef(t2));
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          t1 = this.parent;
          t2 = H.stringTypeCheck(J.$index$asx(diagnostic.json, "valueId"));
          t2 = t1.valueToInspectorTreeNode.$index(0, new E.InspectorInstanceRef(t2));
          return t2 == null ? null : t2._diagnostic;
        }
        node = node._inspector_tree$_parent;
      }
      return;
    },
    syncSelectionHelper$2: function(maybeRerootDetailsTree, detailsSelection) {
      var diagnostic, t1, toSelect, _this = this;
      if (_this.parent == null && _this.selectedNode != null)
        _this.inspectorTree.nodeChanged$1(_this.selectedNode._inspector_tree$_parent);
      diagnostic = _this.get$selectedDiagnostic();
      t1 = diagnostic != null;
      if (t1)
        H.boolConversionCheck(diagnostic.getBooleanMember$2("createdByLocalProject", false));
      if (_this.parent != null || _this.details == null)
        if (t1) {
          toSelect = _this.selectedNode;
          while (true) {
            t1 = toSelect != null;
            if (!(t1 && toSelect._diagnostic.isProperty))
              break;
            toSelect = toSelect._inspector_tree$_parent;
          }
          if (t1)
            toSelect._diagnostic.setSelectionInspector$1(true);
        }
      if (maybeRerootDetailsTree) {
        _this.subtreeRoot = diagnostic;
        t1 = _this.details;
        if (t1 != null)
          t1.setSubtreeRoot$2(diagnostic, detailsSelection);
      } else if (diagnostic != null)
        (detailsSelection == null ? diagnostic : detailsSelection).setSelectionInspector$1(true);
    },
    dispose$0: function() {
      var t1, _this = this;
      _this._disposed = true;
      _this.flutterIsolateSubscription.cancel$0(0);
      if (_this.inspectorService != null)
        _this.shutdownTree$1(false);
      t1 = _this._treeGroups;
      if (t1 != null)
        t1.clear$1(0, false);
      _this._treeGroups = null;
      t1 = _this._selectionGroups;
      if (t1 != null)
        t1.clear$1(0, false);
      _this._selectionGroups = null;
      t1 = _this.details;
      if (t1 != null)
        t1.dispose$0();
    },
    _inspector_controller$_onNodeAdded$2: function(node, diagnosticsNode) {
      var t1, valueRef;
      H.interceptedTypeCheck(node, "$isInspectorTreeNode");
      H.interceptedTypeCheck(diagnosticsNode, "$isRemoteDiagnosticsNode");
      t1 = H.stringTypeCheck(J.$index$asx(diagnosticsNode.json, "valueId"));
      valueRef = new E.InspectorInstanceRef(t1);
      if (t1 != null && !diagnosticsNode.isProperty)
        this.valueToInspectorTreeNode.$indexSet(0, valueRef, node);
      t1 = this.parent;
      if (t1 != null)
        t1.maybeUpdateValueUI$1(valueRef);
    },
    set$flutterIsolateSubscription: function(flutterIsolateSubscription) {
      this.flutterIsolateSubscription = H.assertSubtype(flutterIsolateSubscription, "$isStreamSubscription", [S.IsolateRef], "$asStreamSubscription");
    },
    $isInspectorServiceClient: 1
  };
  Z.InspectorController_closure.prototype = {
    call$1: function(flutterIsolate) {
      H.interceptedTypeCheck(flutterIsolate, "$isIsolateRef");
      this.$this.onIsolateStopped$0();
    },
    $signature: 35
  };
  E.InspectorService.prototype = {
    inferPubRootDirectoryIfNeeded$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, root, children, t1, path, parts, t2, i, pubRootDirectory, group, $async$temp1;
      var $async$inferPubRootDirectoryIfNeeded$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              group = new E.ObjectGroup("temp_" + $.InspectorService_nextGroupId, $async$self);
              $.InspectorService_nextGroupId = $.InspectorService_nextGroupId + 1;
              $async$goto = 3;
              return P._asyncAwait(group.getRoot$1(C.FlutterTreeType_0), $async$inferPubRootDirectoryIfNeeded$0);
            case 3:
              // returning from await.
              root = $async$result;
              $async$goto = root == null ? 4 : 5;
              break;
            case 4:
              // then
              $async$goto = 6;
              return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
            case 6:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 5:
              // join
              root._computeChildren$0();
              $async$goto = 7;
              return P._asyncAwait(root._childrenFuture, $async$inferPubRootDirectoryIfNeeded$0);
            case 7:
              // returning from await.
              children = $async$result;
              if ((children == null ? null : J.get$isNotEmpty$asx(children)) === true) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = H.stringTypeCheck(J.$index$asx(root.json, "objectId"));
              $async$temp1 = J;
              $async$goto = 8;
              return P._asyncAwait(group.getListHelper$3(new E.InspectorInstanceRef(t1), "getChildrenDetailsSubtree", null), $async$inferPubRootDirectoryIfNeeded$0);
            case 8:
              // returning from await.
              t1 = $async$temp1.get$first$ax($async$result).get$creationLocation();
              path = t1 == null ? null : H.stringTypeCheck(J.$index$asx(t1.json, "file"));
              $async$goto = path == null ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
            case 11:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 10:
              // join
              t1 = P.String;
              parts = H.setRuntimeTypeInfo(path.split("/"), [t1]);
              for (t2 = parts.length, i = t2 - 1; i >= 0; --i)
                ;
              if (0 >= t2) {
                $async$returnValue = H.ioore(parts, -1);
                // goto return
                $async$goto = 1;
                break;
              }
              parts.pop();
              pubRootDirectory = C.JSArray_methods.join$1(parts, "/");
              t1 = [t1];
              $async$goto = 12;
              return P._asyncAwait($async$self.invokeServiceMethodDaemonNoGroupArgs$2("setPubRootDirectories", H.assertSubtype(H.setRuntimeTypeInfo([pubRootDirectory], t1), "$isList", t1, "$asList")), $async$inferPubRootDirectoryIfNeeded$0);
            case 12:
              // returning from await.
              $async$goto = 13;
              return P._asyncAwait(group.dispose$0(), $async$inferPubRootDirectoryIfNeeded$0);
            case 13:
              // returning from await.
              $async$returnValue = pubRootDirectory;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$inferPubRootDirectoryIfNeeded$0, $async$completer);
    },
    notifySelectionChanged$0: function() {
      for (var t1 = this.clients, t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
        t1._collection$_current.onInspectorSelectionChanged$0();
    },
    onDebugVmServiceReceived$1: function($event) {
      var t1;
      H.interceptedTypeCheck($event, "$isEvent0");
      if ($event.kind === "Inspect") {
        t1 = new E.ObjectGroup("dummy_" + $.InspectorService_nextGroupId, this);
        $.InspectorService_nextGroupId = $.InspectorService_nextGroupId + 1;
        t1.handleSetSelectionObservatory$2(t1.invokeServiceMethodOnRefObservatory$2("setSelection", $event.inspectee), true);
        this.notifySelectionChanged$0();
      }
    },
    onExtensionVmServiceRecieved$1: function(e) {
      var client, e0, t1, exception;
      if ("Flutter.Frame" === H.interceptedTypeCheck(e, "$isEvent0").extensionKind)
        for (t1 = this.clients, t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();) {
          client = t1._collection$_current;
          try {
            client.onFlutterFrame$0();
          } catch (exception) {
            e0 = H.unwrapException(exception);
          }
        }
    },
    invokeBoolServiceMethodNoArgs$1: function(methodName) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$invokeBoolServiceMethodNoArgs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = J;
              $async$goto = 3;
              return P._asyncAwait($async$self.invokeServiceMethodDaemonNoGroupArgs$1(methodName), $async$invokeBoolServiceMethodNoArgs$1);
            case 3:
              // returning from await.
              t1 = $async$temp1.$eq$($async$result, true);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeBoolServiceMethodNoArgs$1, $async$completer);
    },
    invokeServiceMethodDaemonNoGroupArgs$2: function(methodName, args) {
      var params, i,
        t1 = P.String;
      H.assertSubtype(args, "$isList", [t1], "$asList");
      params = P.LinkedHashMap_LinkedHashMap$_empty(t1, P.Object);
      if (args != null)
        for (i = 0; i < 1; ++i)
          params.$indexSet(0, "arg" + i, args[i]);
      return this.invokeServiceMethodDaemonNoGroup$2(methodName, params);
    },
    invokeServiceMethodDaemonNoGroupArgs$1: function(methodName) {
      return this.invokeServiceMethodDaemonNoGroupArgs$2(methodName, null);
    },
    invokeServiceMethodDaemonNoGroup$2: function(methodName, args) {
      return this.invokeServiceMethodDaemonNoGroup$body$InspectorService(methodName, H.assertSubtype(args, "$isMap", [P.String, P.Object], "$asMap"));
    },
    invokeServiceMethodDaemonNoGroup$body$InspectorService: function(methodName, args) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Object),
        $async$returnValue, $async$self = this, json, t1;
      var $async$invokeServiceMethodDaemonNoGroup$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.vmService.callServiceExtension$3$args$isolateId("ext.flutter.inspector." + methodName, args, $async$self.inspectorLibrary._isolateId), $async$invokeServiceMethodDaemonNoGroup$2);
            case 3:
              // returning from await.
              json = $async$result.json;
              t1 = J.getInterceptor$asx(json);
              if (t1.$index(json, "errorMessage") != null)
                throw H.wrapException(P.Exception_Exception(methodName + " -- " + H.S(t1.$index(json, "errorMessage"))));
              $async$returnValue = t1.$index(json, "result");
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeServiceMethodDaemonNoGroup$2, $async$completer);
    }
  };
  E.InspectorService_create_closure.prototype = {
    call$1: function(_) {
      return H.throwExpression(new E.FlutterInspectorLibraryNotFound(C.List_BmV));
    },
    $signature: 2
  };
  E.InspectorService_create_closure0.prototype = {
    call$1: function(e) {
      return e instanceof B.LibraryNotFound;
    },
    $signature: 30
  };
  E.InspectorService_create_lookupFunctionNames.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Set, P.String]),
        $async$returnValue, $async$self = this, t1, t2, _i, classRef, classObj, functionNames;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.library.classes, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t2)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              classRef = t1[_i];
              $async$goto = "WidgetInspectorService" === classRef.name ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return P._asyncAwait($async$self.inspectorLibrary.getObjHelper$1$2(H.interceptedTypeCheck(classRef, "$isClassRef"), null, S.Class), $async$call$0);
            case 8:
              // returning from await.
              classObj = $async$result;
              functionNames = P.LinkedHashSet_LinkedHashSet(P.String);
              for (t1 = classObj.functions, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
                functionNames.add$1(0, t1[_i].name);
              $async$returnValue = functionNames;
              // goto return
              $async$goto = 1;
              break;
            case 7:
              // join
            case 4:
              // for update
              ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 115
  };
  E.ObjectGroup.prototype = {
    dispose$0: function() {
      var disposeComplete = this.invokeVoidServiceMethod$2("disposeGroup", this.groupName);
      this.disposed = true;
      return disposeComplete;
    },
    getRoot$1: function(type) {
      switch (type) {
        case C.FlutterTreeType_0:
          return this.invokeServiceMethodReturningNode$1("getRootWidgetSummaryTree");
        case C.FlutterTreeType_1:
          return this.invokeServiceMethodReturningNode$1("getRootRenderObject");
      }
      throw H.wrapException(P.Exception_Exception("Unexpected FlutterTreeType"));
    },
    invokeServiceMethodDaemon$2: function(methodName, objectGroup) {
      var t1 = objectGroup == null ? this.groupName : objectGroup,
        t2 = P.String,
        t3 = P.Object;
      t3 = H.assertSubtype(P.LinkedHashMap_LinkedHashMap$_literal(["objectGroup", t1], t2, t3), "$isMap", [t2, t3], "$asMap");
      return this._inspector_service$_callServiceExtension$2("ext.flutter.inspector." + methodName, t3);
    },
    invokeServiceMethodDaemon$1: function(methodName) {
      return this.invokeServiceMethodDaemon$2(methodName, null);
    },
    _inspector_service$_callServiceExtension$2: function(extension, args) {
      var _this = this,
        t1 = P.Object;
      H.assertSubtype(args, "$isMap", [P.String, t1], "$asMap");
      if (_this.disposed) {
        t1 = new P._Future($.Zone__current, [t1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      return _this.inspectorService.inspectorLibrary.addRequest$1$2(_this, new E.ObjectGroup__callServiceExtension_closure(_this, extension, args), t1);
    },
    invokeServiceMethodDaemonInspectorRef$2: function(methodName, arg) {
      var t1 = arg == null ? null : arg.id,
        t2 = P.String,
        args = P.LinkedHashMap_LinkedHashMap$_literal(["objectGroup", this.groupName], t2, t2);
      if (t1 != null)
        args.$indexSet(0, "arg", t1);
      H.assertSubtype(args, "$isMap", [t2, P.Object], "$asMap");
      return this._inspector_service$_callServiceExtension$2("ext.flutter.inspector." + methodName, args);
    },
    invokeServiceMethodObservatoryInspectorRef$2: function(methodName, arg) {
      var t1 = "WidgetInspectorService.instance." + methodName + "('";
      return this.inspectorService.inspectorLibrary.eval$2$isAlive(t1 + H.S(arg == null ? null : arg.id) + "', '" + this.groupName + "')", this);
    },
    invokeServiceMethodOnRefObservatory$2: function(methodName, arg) {
      var t1, _this = this,
        _s32_ = "WidgetInspectorService.instance.";
      if (arg == null)
        return _this.inspectorService.inspectorLibrary.eval$2$isAlive(_s32_ + methodName + "(null, '" + _this.groupName + "')", _this);
      t1 = P.String;
      return _this.inspectorService.inspectorLibrary.eval$3$isAlive$scope(_s32_ + methodName + "(arg1, '" + _this.groupName + "')", _this, P.LinkedHashMap_LinkedHashMap$_literal(["arg1", arg.id], t1, t1));
    },
    getDartObjectProperties$2: function(inspectorInstanceRef, propertyNames) {
      return this.getDartObjectProperties$body$ObjectGroup(inspectorInstanceRef, H.assertSubtype(propertyNames, "$isList", [P.String], "$asList"));
    },
    getDartObjectProperties$body$ObjectGroup: function(inspectorInstanceRef, propertyNames) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, S.InstanceRef]),
        $async$returnValue, $async$self = this, t1, t2, instance, properties, values, i, instanceRef;
      var $async$getDartObjectProperties$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.invokeServiceMethodObservatoryInspectorRef$2("toObject", inspectorInstanceRef), $async$getDartObjectProperties$2);
              case 3:
                // returning from await.
                instanceRef = $async$result;
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = P.String;
                t2 = H.getTypeArgumentByIndex(propertyNames, 0);
                $async$goto = 4;
                return P._asyncAwait($async$self.getInstance$1($async$self.inspectorService.inspectorLibrary.eval$3$isAlive$scope("[" + new H.MappedListIterable(propertyNames, H.functionTypeCheck(new E.ObjectGroup_getDartObjectProperties_closure("that"), {func: 1, ret: t1, args: [t2]}), [t2, t1]).join$1(0, ",") + "]", $async$self, P.LinkedHashMap_LinkedHashMap$_literal(["that", instanceRef.id], t1, t1))), $async$getDartObjectProperties$2);
              case 4:
                // returning from await.
                instance = $async$result;
                if ($async$self.disposed) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t2 = S.InstanceRef;
                properties = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
                t1 = instance.elements;
                t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
                values = H.assertSubtype(t1, "$isList", [t2], "$asList");
                for (i = 0; i < propertyNames.length; ++i) {
                  t1 = propertyNames[i];
                  if (i >= values.length) {
                    $async$returnValue = H.ioore(values, i);
                    // goto return
                    $async$goto = 1;
                    break $async$outer;
                  }
                  properties.$indexSet(0, t1, values[i]);
                }
                $async$returnValue = properties;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$getDartObjectProperties$2, $async$completer);
    },
    getInstance$1: function(instanceRef) {
      return this.getInstance$body$ObjectGroup(H.futureOrCheck(instanceRef, {futureOr: 1, type: S.InstanceRef}));
    },
    getInstance$body$ObjectGroup: function(instanceRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Instance),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$getInstance$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$temp1 = $async$self.inspectorService.inspectorLibrary;
              $async$goto = 3;
              return P._asyncAwait(instanceRef, $async$getInstance$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.getInstance$2($async$result, $async$self);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getInstance$1, $async$completer);
    },
    parseDiagnosticsNodeDaemon$1: function(json) {
      return this.parseDiagnosticsNodeDaemon$body$ObjectGroup(H.assertSubtype(json, "$isFuture", [P.Object], "$asFuture"));
    },
    parseDiagnosticsNodeDaemon$body$ObjectGroup: function(json) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$parseDiagnosticsNodeDaemon$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(json, $async$parseDiagnosticsNodeDaemon$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$self.parseDiagnosticsNodeHelper$1($async$temp1.assertSubtype($async$result, "$isMap", [P.String, P.Object], "$asMap"));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$parseDiagnosticsNodeDaemon$1, $async$completer);
    },
    parseDiagnosticsNodeHelper$1: function(jsonElement) {
      H.assertSubtype(jsonElement, "$isMap", [P.String, P.Object], "$asMap");
      if (this.disposed)
        return;
      if (jsonElement == null)
        return;
      return new M.RemoteDiagnosticsNode(null, this, jsonElement, false);
    },
    parseDiagnosticsNodesHelper$2: function(jsonObject, $parent) {
      var nodes, t2,
        t1 = P.Object;
      H.assertSubtype(jsonObject, "$isList", [t1], "$asList");
      if (this.disposed || jsonObject == null)
        return C.List_empty3;
      nodes = H.setRuntimeTypeInfo([], [M.RemoteDiagnosticsNode]);
      for (t2 = J.get$iterator$ax(jsonObject), t1 = [P.String, t1]; t2.moveNext$0();)
        C.JSArray_methods.add$1(nodes, new M.RemoteDiagnosticsNode($parent, this, H.assertSubtype(t2.get$current(t2), "$isMap", t1, "$asMap"), false));
      return nodes;
    },
    parseDiagnosticsNodesDaemon$2: function(jsonFuture, $parent) {
      return this.parseDiagnosticsNodesDaemon$body$ObjectGroup(H.futureOrCheck(jsonFuture, {futureOr: 1, type: P.Object}), $parent);
    },
    parseDiagnosticsNodesDaemon$body$ObjectGroup: function(jsonFuture, $parent) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
        $async$returnValue, $async$self = this, $async$temp1;
      var $async$parseDiagnosticsNodesDaemon$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed || jsonFuture == null) {
                $async$returnValue = C.List_empty3;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(jsonFuture, $async$parseDiagnosticsNodesDaemon$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$self.parseDiagnosticsNodesHelper$2($async$temp1.assertSubtype($async$result, "$isList", [P.Object], "$asList"), $parent);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$parseDiagnosticsNodesDaemon$2, $async$completer);
    },
    getListHelper$3: function(instanceRef, methodName, $parent) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, M.RemoteDiagnosticsNode]),
        $async$returnValue, $async$self = this, t1;
      var $async$getListHelper$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                $async$returnValue = C.List_empty3;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self.parseDiagnosticsNodesDaemon$2($async$self.invokeServiceMethodDaemonInspectorRef$2(methodName, instanceRef), $parent);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getListHelper$3, $async$completer);
    },
    invokeServiceMethodReturningNode$1: function(methodName) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
        $async$returnValue, $async$self = this, t1;
      var $async$invokeServiceMethodReturningNode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self.parseDiagnosticsNodeDaemon$1($async$self.invokeServiceMethodDaemon$1(methodName));
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeServiceMethodReturningNode$1, $async$completer);
    },
    invokeServiceMethodReturningNodeInspectorRef$2: function(methodName, ref) {
      var t1;
      if (this.disposed)
        return;
      t1 = this.parseDiagnosticsNodeDaemon$1(this.invokeServiceMethodDaemonInspectorRef$2(methodName, ref));
      return t1;
    },
    invokeVoidServiceMethod$2: function(methodName, arg1) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this;
      var $async$invokeVoidServiceMethod$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait($async$self.invokeServiceMethodDaemon$2(methodName, arg1), $async$invokeVoidServiceMethod$2);
            case 3:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$invokeVoidServiceMethod$2, $async$completer);
    },
    getSelection$3: function(_, previousSelection, treeType, localOnly) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
        $async$returnValue, $async$self = this, previousSelectionRef, newSelection;
      var $async$getSelection$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              previousSelectionRef = previousSelection != null ? new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(previousSelection.json, "objectId"))) : null;
            case 3:
              // switch
              switch (treeType) {
                case C.FlutterTreeType_0:
                  // goto case
                  $async$goto = 5;
                  break;
                case C.FlutterTreeType_1:
                  // goto case
                  $async$goto = 6;
                  break;
                default:
                  // goto default
                  $async$goto = 7;
                  break;
              }
              break;
            case 5:
              // case
              $async$goto = 8;
              return P._asyncAwait($async$self.invokeServiceMethodReturningNodeInspectorRef$2(localOnly ? "getSelectedSummaryWidget" : "getSelectedWidget", previousSelectionRef), $async$getSelection$3);
            case 8:
              // returning from await.
              newSelection = $async$result;
              // goto after switch
              $async$goto = 4;
              break;
            case 6:
              // case
              $async$goto = 9;
              return P._asyncAwait($async$self.invokeServiceMethodReturningNodeInspectorRef$2("getSelectedRenderObject", previousSelectionRef), $async$getSelection$3);
            case 9:
              // returning from await.
              newSelection = $async$result;
              // goto after switch
              $async$goto = 4;
              break;
            case 7:
              // default
              newSelection = null;
            case 4:
              // after switch
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (newSelection != null && new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(newSelection.json, "objectId"))).$eq(0, previousSelectionRef)) {
                $async$returnValue = previousSelection;
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = newSelection;
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getSelection$3, $async$completer);
    },
    setSelectionInspector$2: function(selection, uiAlreadyUpdated) {
      var t1;
      H.boolTypeCheck(uiAlreadyUpdated);
      if (this.disposed) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      t1 = this.handleSetSelectionDaemon$2(this.invokeServiceMethodDaemonInspectorRef$2("setSelectionById", selection), uiAlreadyUpdated);
      return t1;
    },
    handleSetSelectionObservatory$2: function(setSelectionResult, uiAlreadyUpdated) {
      return this.handleSetSelectionObservatory$body$ObjectGroup(H.assertSubtype(setSelectionResult, "$isFuture", [S.InstanceRef], "$asFuture"), H.boolTypeCheck(uiAlreadyUpdated));
    },
    handleSetSelectionObservatory$body$ObjectGroup: function(setSelectionResult, uiAlreadyUpdated) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, instanceRef;
      var $async$handleSetSelectionObservatory$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(setSelectionResult, $async$handleSetSelectionObservatory$2);
            case 3:
              // returning from await.
              instanceRef = $async$result;
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.handleSetSelectionHelper$2("true" === (instanceRef == null ? null : instanceRef.valueAsString), uiAlreadyUpdated);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handleSetSelectionObservatory$2, $async$completer);
    },
    handleSetSelectionHelper$2: function(selectionChanged, uiAlreadyUpdated) {
      H.boolTypeCheck(uiAlreadyUpdated);
      if (H.boolConversionCheck(selectionChanged) && !H.boolConversionCheck(uiAlreadyUpdated) && !this.disposed)
        this.inspectorService.notifySelectionChanged$0();
    },
    handleSetSelectionDaemon$2: function(setSelectionResult, uiAlreadyUpdated) {
      return this.handleSetSelectionDaemon$body$ObjectGroup(H.assertSubtype(setSelectionResult, "$isFuture", [P.Object], "$asFuture"), H.boolTypeCheck(uiAlreadyUpdated));
    },
    handleSetSelectionDaemon$body$ObjectGroup: function(setSelectionResult, uiAlreadyUpdated) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, json;
      var $async$handleSetSelectionDaemon$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(setSelectionResult, $async$handleSetSelectionDaemon$2);
            case 3:
              // returning from await.
              json = $async$result;
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.handleSetSelectionHelper$2(H.boolTypeCheck(json), uiAlreadyUpdated);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$handleSetSelectionDaemon$2, $async$completer);
    },
    getEnumPropertyValues$1: function(ref) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String, S.InstanceRef]),
        $async$returnValue, $async$self = this, instance, clazz, properties, t1, t2, _i, field, $name;
      var $async$getEnumPropertyValues$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (ref.id == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 4;
              return P._asyncAwait($async$self.invokeServiceMethodObservatoryInspectorRef$2("toObject", ref), $async$getEnumPropertyValues$1);
            case 4:
              // returning from await.
              $async$goto = 3;
              return P._asyncAwait($async$self.getInstance$1($async$result), $async$getEnumPropertyValues$1);
            case 3:
              // returning from await.
              instance = $async$result;
              if ($async$self.disposed || instance == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait($async$self.inspectorService.inspectorLibrary.getObjHelper$1$2(instance.classRef, $async$self, S.Class), $async$getEnumPropertyValues$1);
            case 5:
              // returning from await.
              clazz = $async$result;
              if ($async$self.disposed || clazz == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              properties = P.LinkedHashMap_LinkedHashMap$_empty(P.String, S.InstanceRef);
              for (t1 = clazz.fields, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                field = t1[_i];
                $name = field.name;
                if (J.startsWith$1$s($name, "_"))
                  continue;
                if ($name === "values")
                  continue;
                if (H.boolConversionCheck(field.isConst) && H.boolConversionCheck(field.isStatic))
                  properties.$indexSet(0, $name, field.declaredType);
              }
              $async$returnValue = properties;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getEnumPropertyValues$1, $async$completer);
    },
    getDetailsSubtree$1: function(node) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(M.RemoteDiagnosticsNode),
        $async$returnValue, $async$self = this;
      var $async$getDetailsSubtree$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (node == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = $async$self.invokeServiceMethodReturningNodeInspectorRef$2("getDetailsSubtree", new E.InspectorInstanceRef(H.stringTypeCheck(J.$index$asx(node.json, "objectId"))));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getDetailsSubtree$1, $async$completer);
    }
  };
  E.ObjectGroup__callServiceExtension_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, json, t1, t2, t3, r;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.inspectorService;
              t3 = $async$self.extension;
              $async$goto = 3;
              return P._asyncAwait(t2.vmService.callServiceExtension$3$args$isolateId(t3, $async$self.args, t2.inspectorLibrary._isolateId), $async$call$0);
            case 3:
              // returning from await.
              r = $async$result;
              if (t1.disposed) {
                // goto return
                $async$goto = 1;
                break;
              }
              json = r.json;
              t1 = J.getInterceptor$asx(json);
              if (t1.$index(json, "errorMessage") != null)
                throw H.wrapException(P.Exception_Exception(t3 + " -- " + H.S(t1.$index(json, "errorMessage"))));
              $async$returnValue = t1.$index(json, "result");
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 10
  };
  E.ObjectGroup_getDartObjectProperties_closure.prototype = {
    call$1: function(propertyName) {
      H.stringTypeCheck(propertyName);
      return this.objectName + "." + H.S(propertyName);
    },
    $signature: 5
  };
  E.FlutterTreeType.prototype = {
    toString$0: function(_) {
      return this._inspector_service$_name;
    }
  };
  E.InspectorServiceClient.prototype = {};
  E.InspectorInstanceRef.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (other instanceof E.InspectorInstanceRef)
        return this.id == other.id;
      return false;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    toString$0: function(_) {
      return "instance-" + H.S(this.id);
    },
    get$id: function(receiver) {
      return this.id;
    }
  };
  E.InspectorObjectGroupManager.prototype = {
    get$pendingUpdateDone: function() {
      var _this = this,
        t1 = _this._pendingNext;
      if (t1 != null)
        return t1.future;
      if (_this._inspector_service$_next == null) {
        t1 = new P._Future($.Zone__current, [-1]);
        t1._asyncComplete$1(null);
        return t1;
      }
      t1 = -1;
      _this.set$_pendingNext(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
      return _this._pendingNext.future;
    },
    get$next: function(_) {
      var t2, _this = this,
        t1 = _this._inspector_service$_next;
      if (t1 == null) {
        t1 = _this.inspectorService;
        t1.toString;
        t2 = _this.debugName + "_" + $.InspectorService_nextGroupId;
        $.InspectorService_nextGroupId = $.InspectorService_nextGroupId + 1;
        t1 = _this._inspector_service$_next = new E.ObjectGroup(t2, t1);
      }
      return t1;
    },
    clear$1: function(_, isolateStopped) {
      var _this = this;
      if (isolateStopped) {
        _this._inspector_service$_current = null;
        _this._setNextNull$0();
      } else {
        _this.clearCurrent$0();
        _this.cancelNext$0();
      }
    },
    promoteNext$0: function() {
      var _this = this;
      _this.clearCurrent$0();
      _this._inspector_service$_current = _this._inspector_service$_next;
      _this._setNextNull$0();
    },
    clearCurrent$0: function() {
      var t1 = this._inspector_service$_current;
      if (t1 != null) {
        t1.dispose$0();
        this._inspector_service$_current = null;
      }
    },
    cancelNext$0: function() {
      var t1 = this._inspector_service$_next;
      if (t1 != null) {
        t1.dispose$0();
        this._setNextNull$0();
      }
    },
    _setNextNull$0: function() {
      this._inspector_service$_next = null;
      var t1 = this._pendingNext;
      if (t1 != null) {
        t1.complete$1(0, null);
        this.set$_pendingNext(null);
      }
    },
    set$_pendingNext: function(_pendingNext) {
      this._pendingNext = H.assertSubtype(_pendingNext, "$isCompleter", [-1], "$asCompleter");
    }
  };
  E.FlutterInspectorLibraryNotFound.prototype = {};
  K.PaintEntry.prototype = {
    attach$1: function(owner) {
    }
  };
  K.InspectorTreeNodeRenderBuilder.prototype = {};
  K.InspectorTreeNodeRender.prototype = {
    attach$2: function(owner, offset) {
      var t1, t2, _i, _this = this;
      if (_this._owner !== owner)
        _this._owner = owner;
      _this._inspector_tree$_offset = offset;
      for (t1 = _this.entries, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].attach$1(owner);
    }
  };
  K.InspectorTreeNode.prototype = {
    get$renderObject: function() {
      var builder, icon, $name, textStyle, propertyType, properties, description, alpha, red, green, blue, color, codePoint, match, t2, _this = this,
        _s21_ = "createdByLocalProject",
        _s8_ = "showName",
        _s13_ = "showSeparator",
        _s11_ = "description",
        t1 = _this._renderObject;
      if (t1 != null || _this._diagnostic == null)
        return t1;
      builder = _this.createRenderBuilder$0();
      t1 = _this._diagnostic;
      icon = t1.get$icon(t1);
      if (_this.get$showExpandCollapse())
        builder.addIcon$1(_this._isExpanded ? $.$get$collapseArrow() : $.$get$expandArrow());
      if (icon != null)
        builder.addIcon$1(icon);
      $name = H.stringTypeCheck(J.$index$asx(_this._diagnostic.json, "name"));
      textStyle = Z.textStyleForLevel(_this._diagnostic.getLevelMember$2("level", C.DiagnosticLevel_3));
      t1 = _this._diagnostic;
      if (t1.isProperty) {
        propertyType = H.stringTypeCheck(J.$index$asx(t1.json, "propertyType"));
        properties = H.assertSubtype(J.$index$asx(_this._diagnostic.json, "valueProperties"), "$isMap", [P.String, P.Object], "$asMap");
        if (H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s21_, false)))
          textStyle = textStyle.merge$1(C.TextStyle_wXq);
        if (($name == null ? null : $name.length !== 0) === true && H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s8_, true))) {
          t1 = H.S($name);
          builder.appendText$2(0, t1 + (H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s13_, true)) ? ":" : "") + " ", textStyle);
        }
        description = H.stringTypeCheck(J.$index$asx(_this._diagnostic.json, _s11_));
        if (propertyType != null && properties != null)
          switch (propertyType) {
            case "Color":
              alpha = B.JsonUtils_getIntMember(properties, "alpha");
              red = B.JsonUtils_getIntMember(properties, "red");
              green = B.JsonUtils_getIntMember(properties, "green");
              blue = B.JsonUtils_getIntMember(properties, "blue");
              t1 = new K.InspectorTreeNode_renderObject_radix();
              description = alpha === 255 ? "#" + H.S(t1.call$1(red)) + H.S(t1.call$1(green)) + H.S(t1.call$1(blue)) : "#" + H.S(t1.call$1(alpha)) + H.S(t1.call$1(red)) + H.S(t1.call$1(green)) + H.S(t1.call$1(blue));
              color = S.Color$fromARGB(alpha, red, green, blue);
              builder.addIcon$1($.$get$_colorIconMaker().getCustomIcon$1(color));
              break;
            case "IconData":
              codePoint = B.JsonUtils_getIntMember(properties, "codePoint");
              if (codePoint > 0) {
                icon = K.FlutterMaterialIcons_getIconForCodePoint(codePoint);
                if (icon != null)
                  builder.addIcon$1(icon);
              }
              break;
          }
        builder.appendText$2(0, description, textStyle);
        if (_this._diagnostic.getLevelMember$2("level", C.DiagnosticLevel_3) === C.DiagnosticLevel_1 && H.boolConversionCheck(J.containsKey$1$x(_this._diagnostic.json, "defaultValue"))) {
          builder.appendText$2(0, " ", textStyle);
          builder.addIcon$1($.$get$defaultIcon());
        }
      } else {
        if (($name == null ? null : $name.length !== 0) === true && H.boolConversionCheck(t1.getBooleanMember$2(_s8_, true)) && $name !== "child") {
          if (J.startsWith$1$s($name, "child "))
            builder.appendText$2(0, $name, $.$get$unimportant());
          else
            builder.appendText$2(0, $name, textStyle);
          if (H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s13_, true))) {
            t1 = H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s13_, true)) ? ":" : "";
            builder.appendText$2(0, t1, $.$get$unimportant());
          } else
            builder.appendText$2(0, " ", $.$get$unimportant());
        }
        if (!H.boolConversionCheck(_this._diagnostic.getBooleanMember$2("summaryTree", false)) && H.boolConversionCheck(_this._diagnostic.getBooleanMember$2(_s21_, false)))
          textStyle = textStyle.merge$1(C.TextStyle_cyO);
        description = H.stringTypeCheck(J.$index$asx(_this._diagnostic.json, _s11_));
        match = $.$get$_primaryDescriptionPattern().firstMatch$1(description);
        if (match != null) {
          t1 = $.$get$unimportant();
          builder.appendText$2(0, " ", t1);
          t2 = match._match;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          builder.appendText$2(0, t2[1], textStyle);
          if (2 >= t2.length)
            return H.ioore(t2, 2);
          if (t2[2].length !== 0) {
            builder.appendText$2(0, " ", textStyle);
            if (2 >= t2.length)
              return H.ioore(t2, 2);
            builder.appendText$2(0, t2[2], t1);
          }
        } else {
          t1 = H.stringTypeCheck(J.$index$asx(_this._diagnostic.json, _s11_));
          if ((t1 == null ? null : t1.length !== 0) === true) {
            builder.appendText$2(0, " ", $.$get$unimportant());
            builder.appendText$2(0, H.stringTypeCheck(J.$index$asx(_this._diagnostic.json, _s11_)), textStyle);
          }
        }
      }
      _this.set$_renderObject(builder.build$0());
      return _this._renderObject;
    },
    get$showExpandCollapse: function() {
      var t1 = this._diagnostic;
      return ((t1 == null ? null : t1.get$hasChildren()) === true || this._children.length !== 0) && this.allowExpandCollapse;
    },
    set$isExpanded: function(value) {
      if (value !== this._isExpanded) {
        this._isExpanded = value;
        this.dirty$0();
      }
    },
    set$parent: function(_, value) {
      H.interceptedTypeCheck(value, "$isInspectorTreeNode");
      this._inspector_tree$_parent = value;
      if (value != null)
        value.dirty$0();
    },
    dirty$0: function() {
      var t1, _this = this;
      _this.set$_renderObject(null);
      if (_this._childrenCount == null)
        return;
      _this._childrenCount = null;
      t1 = _this._inspector_tree$_parent;
      if (t1 != null)
        t1.dirty$0();
    },
    get$childrenCount: function() {
      var t1, t2, count, _i, t3, _this = this;
      if (!_this._isExpanded)
        _this._childrenCount = 0;
      t1 = _this._childrenCount;
      if (t1 != null)
        return t1;
      for (t1 = _this._children, t2 = t1.length, count = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        t3 = t1[_i].get$childrenCount();
        if (typeof t3 !== "number")
          return t3.$add();
        count += t3 + 1;
      }
      return _this._childrenCount = count;
    },
    get$hasPlaceholderChildren: function() {
      var t1 = this._children;
      return t1.length === 1 && C.JSArray_methods.get$first(t1)._diagnostic == null;
    },
    getRowIndex$1: function(node) {
      var index, $parent, t1, t2, _i, sibling, t3;
      for (index = 0; true; node = $parent) {
        $parent = node._inspector_tree$_parent;
        if ($parent == null)
          break;
        for (t1 = $parent._children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          sibling = t1[_i];
          if (sibling === node)
            break;
          t3 = sibling.get$childrenCount();
          if (typeof t3 !== "number")
            return t3.$add();
          index += t3 + 1;
        }
        ++index;
      }
      return index;
    },
    getRow$2$selection: function(index, selection) {
      var highlightDepth, node, current, depth, t2, children, i, child, current0,
        ticks = H.setRuntimeTypeInfo([], [P.int]),
        t1 = this.get$childrenCount();
      if (typeof t1 !== "number")
        return t1.$add();
      if (t1 + 1 <= index)
        return;
      for (highlightDepth = null, node = this, current = 0, depth = 0; true;) {
        t1 = selection === node;
        if (t1)
          highlightDepth = depth;
        if (current === index) {
          t2 = node._diagnostic;
          if (!(t2 == null || t2.isProperty))
            if (index !== 0) {
              t2 = node._inspector_tree$_parent._children;
              if (t2.length > 1) {
                t2 = C.JSArray_methods.get$last(t2)._diagnostic;
                t2 = !(t2 == null || t2.isProperty);
              } else
                t2 = false;
            } else
              t2 = false;
          else
            t2 = false;
          return new K.InspectorTreeRow(node, ticks, depth, index, t2, t1, highlightDepth);
        }
        ++current;
        children = node._children;
        for (i = 0; i < children.length; ++i, current = current0) {
          child = children[i];
          t1 = child.get$childrenCount();
          if (typeof t1 !== "number")
            return t1.$add();
          current0 = current + (t1 + 1);
          if (current0 > index) {
            t1 = children.length;
            if (t1 > 1)
              if (i + 1 !== t1) {
                t1 = C.JSArray_methods.get$last(children)._diagnostic;
                t1 = !(t1 == null || t1.isProperty);
              } else
                t1 = false;
            else
              t1 = false;
            if (t1)
              C.JSArray_methods.add$1(ticks, depth);
            node = child;
            break;
          }
        }
        ++depth;
      }
      return;
    },
    getRow$1: function(index) {
      return this.getRow$2$selection(index, null);
    },
    appendChild$1: function(_, child) {
      C.JSArray_methods.add$1(this._children, child);
      child.set$parent(0, this);
      this.dirty$0();
    },
    set$_renderObject: function(_renderObject) {
      this._renderObject = H.assertSubtype(_renderObject, "$isInspectorTreeNodeRender", [K.PaintEntry], "$asInspectorTreeNodeRender");
    }
  };
  K.InspectorTreeNode_renderObject_radix.prototype = {
    call$1: function(chan) {
      return C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(chan, 16), 2, "0");
    },
    $signature: 33
  };
  K.InspectorTreeRow.prototype = {};
  K.InspectorTree.prototype = {
    set$root: function(_, node) {
      this.setState$1(new K.InspectorTree_root_closure(this, node));
    },
    set$selection: function(node) {
      this.setState$1(new K.InspectorTree_selection_closure(this, node));
    },
    set$hover: function(node) {
      if (node == this._hover)
        return;
      this.setState$1(new K.InspectorTree_hover_closure(this, node));
    },
    onHover$2: function(node, entry) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, diagnostic, properties, lastHover, t1;
      var $async$onHover$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._onHoverCallback;
              if (t1 != null)
                t1.call$2(node, entry == null ? null : entry.get$icon(entry));
              diagnostic = node == null ? null : node._diagnostic;
              lastHover = $async$self._currentHoverDiagnostic;
              $async$self._currentHoverDiagnostic = H.interceptedTypeCheck(diagnostic, "$isRemoteDiagnosticsNode");
              if (diagnostic == null || entry == null) {
                $async$self.set$tooltip("");
                $async$self._computingHover = false;
                // goto return
                $async$goto = 1;
                break;
              }
              if (entry.get$icon(entry) == $.$get$defaultIcon()) {
                $async$self.set$tooltip("Default value");
                $async$self._computingHover = false;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = diagnostic.isEnumProperty$0() ? 3 : 4;
              break;
            case 3:
              // then
              t1 = J.getInterceptor$(lastHover);
              if (t1.$eq(lastHover, diagnostic) && $async$self._computingHover) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._computingHover = true;
              properties = null;
              $async$handler = 5;
              $async$goto = 8;
              return P._asyncAwait(diagnostic.get$valueProperties(), $async$onHover$2);
            case 8:
              // returning from await.
              properties = $async$result;
              $async$next.push(7);
              // goto finally
              $async$goto = 6;
              break;
            case 5:
              // uncaught
              $async$next = [2];
            case 6:
              // finally
              $async$handler = 2;
              $async$self._computingHover = false;
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 7:
              // after finally
              if (!t1.$eq(lastHover, diagnostic)) {
                // goto return
                $async$goto = 1;
                break;
              }
              if (properties == null) {
                $async$self.set$tooltip(diagnostic.get$tooltip());
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.set$tooltip("Allowed values:\n" + J.join$1$ax(J.get$keys$x(properties), "\n"));
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              $async$self.set$tooltip(diagnostic.get$tooltip());
              $async$self._computingHover = false;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$onHover$2, $async$completer);
    },
    nodeChanged$1: function(node) {
      if (node == null)
        return;
      this.setState$1(new K.InspectorTree_nodeChanged_closure(node));
    },
    removeNodeFromParent$1: function(node) {
      this.setState$1(new K.InspectorTree_removeNodeFromParent_closure(node));
    },
    appendChild$2: function(_, node, child) {
      this.setState$1(new K.InspectorTree_appendChild_closure(node, child));
    },
    expandPath$1: function(node) {
      var t1 = {};
      t1.node = node;
      this.setState$1(new K.InspectorTree_expandPath_closure(t1));
    },
    get$numRows: function() {
      var t1 = this._root;
      if (t1 != null) {
        t1 = t1.get$childrenCount();
        if (typeof t1 !== "number")
          return t1.$add();
        ++t1;
      } else
        t1 = 0;
      return t1;
    },
    getRow$1: function(offset) {
      var t2, row,
        t1 = this._root;
      if (t1 == null)
        return;
      t2 = offset._dy;
      if (typeof t2 !== "number")
        return t2.$sub();
      row = C.JSNumber_methods._tdivFast$1(t2 - 10, 24);
      t1 = t1.get$childrenCount();
      if (typeof t1 !== "number")
        return t1.$add();
      return row < t1 + 1 ? this._root.getRow$1(row) : null;
    },
    onTap$1: function(offset) {
      var t1,
        row = this.getRow$1(offset);
      if (row == null)
        return;
      t1 = row.node.get$renderObject();
      t1 = t1 == null ? null : t1.hitTest$1(offset);
      this.onTapIcon$2(row, t1 == null ? null : t1.get$icon(t1));
    },
    onTapIcon$2: function(row, icon) {
      var _this = this;
      if (icon == $.$get$expandArrow()) {
        _this.setState$1(new K.InspectorTree_onTapIcon_closure(_this, row));
        return;
      }
      if (icon == $.$get$collapseArrow()) {
        _this.setState$1(new K.InspectorTree_onTapIcon_closure0(row));
        return;
      }
      _this.set$selection(row.node);
    },
    expandPropertiesByDefault$1: function(style) {
      switch (style) {
        case C.DiagnosticsTreeStyle_7:
        case C.DiagnosticsTreeStyle_8:
        case C.DiagnosticsTreeStyle_9:
          return false;
        case C.DiagnosticsTreeStyle_0:
        case C.DiagnosticsTreeStyle_1:
        case C.DiagnosticsTreeStyle_2:
        case C.DiagnosticsTreeStyle_3:
        case C.DiagnosticsTreeStyle_4:
        case C.DiagnosticsTreeStyle_5:
        case C.DiagnosticsTreeStyle_6:
        case C.DiagnosticsTreeStyle_10:
        case C.DiagnosticsTreeStyle_11:
          return true;
      }
      return true;
    },
    setupInspectorTreeNode$4$expandChildren$expandProperties: function(node, diagnosticsNode, expandChildren, expandProperties) {
      var t1, styleIsMultiline, t2, _this = this;
      node._diagnostic = diagnosticsNode;
      node._isExpanded = diagnosticsNode.get$childrenReady();
      node.dirty$0();
      t1 = _this._onNodeAdded;
      if (t1 != null)
        t1.call$2(node, diagnosticsNode);
      if (H.boolConversionCheck(diagnosticsNode.get$hasChildren()) || diagnosticsNode.get$inlineProperties().length !== 0)
        if (diagnosticsNode.get$childrenReady() || !H.boolConversionCheck(diagnosticsNode.get$hasChildren())) {
          styleIsMultiline = _this.expandPropertiesByDefault$1(diagnosticsNode.getStyleMember$2("style", C.DiagnosticsTreeStyle_0));
          t1 = node._diagnostic;
          t1._maybePopulateChildren$0();
          t1 = t1._diagnostics_node$_children;
          t2 = expandChildren && styleIsMultiline;
          _this.setupChildren$5$expandChildren$expandProperties(diagnosticsNode, node, t1, t2, expandProperties && styleIsMultiline);
        } else {
          C.JSArray_methods.set$length(node._children, 0);
          node.dirty$0();
          node.appendChild$1(0, _this.createNode$0());
        }
      return node;
    },
    setupChildren$5$expandChildren$expandProperties: function($parent, treeNode, children, expandChildren, expandProperties) {
      var t1, inlineProperties, _i, property, t2, _this = this;
      H.assertSubtype(children, "$isList", [M.RemoteDiagnosticsNode], "$asList");
      treeNode.set$isExpanded(expandChildren);
      t1 = treeNode._children;
      if (t1.length !== 0)
        _this.removeNodeFromParent$1(C.JSArray_methods.get$first(t1));
      inlineProperties = $parent.get$inlineProperties();
      if (inlineProperties != null)
        for (t1 = inlineProperties.length, _i = 0; _i < inlineProperties.length; inlineProperties.length === t1 || (0, H.throwConcurrentModificationError)(inlineProperties), ++_i) {
          property = inlineProperties[_i];
          _this.appendChild$2(0, treeNode, _this.setupInspectorTreeNode$4$expandChildren$expandProperties(_this.createNode$0(), property, expandProperties, expandProperties));
        }
      if (children != null)
        for (t1 = J.get$iterator$ax(children); t1.moveNext$0();) {
          t2 = t1.get$current(t1);
          _this.appendChild$2(0, treeNode, _this.setupInspectorTreeNode$4$expandChildren$expandProperties(_this.createNode$0(), t2, expandChildren, expandProperties));
        }
    },
    maybePopulateChildren$1: function(treeNode) {
      return this.maybePopulateChildren$body$InspectorTree(treeNode);
    },
    maybePopulateChildren$body$InspectorTree: function(treeNode) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, children, e, t1, exception, diagnostic, $async$exception;
      var $async$maybePopulateChildren$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              diagnostic = treeNode._diagnostic;
              if (diagnostic != null)
                if (H.boolConversionCheck(diagnostic.get$hasChildren()))
                  t1 = treeNode.get$hasPlaceholderChildren() || treeNode._children.length === 0;
                else
                  t1 = false;
              else
                t1 = false;
              $async$goto = t1 ? 2 : 3;
              break;
            case 2:
              // then
              $async$handler = 5;
              t1 = diagnostic;
              t1._computeChildren$0();
              $async$goto = 8;
              return P._asyncAwait(t1._childrenFuture, $async$maybePopulateChildren$1);
            case 8:
              // returning from await.
              children = $async$result;
              if (treeNode.get$hasPlaceholderChildren() || treeNode._children.length === 0) {
                $async$self.setupChildren$5$expandChildren$expandProperties(diagnostic, treeNode, children, true, false);
                $async$self.nodeChanged$1(treeNode);
                if (treeNode === $async$self._selection)
                  $async$self.expandPath$1(treeNode);
              }
              $async$handler = 1;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              P.print(e);
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 7:
              // after finally
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$maybePopulateChildren$1, $async$completer);
    }
  };
  K.InspectorTree_root_closure.prototype = {
    call$0: function() {
      this.$this._root = this.node;
    },
    $signature: 0
  };
  K.InspectorTree_selection_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.node;
      t1._selection = t2;
      t1.expandPath$1(t2);
      t1._onSelectionChange.call$0();
    },
    $signature: 0
  };
  K.InspectorTree_hover_closure.prototype = {
    call$0: function() {
      this.$this._hover = this.node;
    },
    $signature: 0
  };
  K.InspectorTree_nodeChanged_closure.prototype = {
    call$0: function() {
      this.node.dirty$0();
    },
    $signature: 0
  };
  K.InspectorTree_removeNodeFromParent_closure.prototype = {
    call$0: function() {
      var t1 = this.node,
        t2 = t1._inspector_tree$_parent;
      if (t2 != null) {
        t1.set$parent(0, null);
        C.JSArray_methods.remove$1(t2._children, t1);
        t2.dirty$0();
      }
    },
    $signature: 0
  };
  K.InspectorTree_appendChild_closure.prototype = {
    call$0: function() {
      this.node.appendChild$1(0, this.child);
    },
    $signature: 0
  };
  K.InspectorTree_expandPath_closure.prototype = {
    call$0: function() {
      var t1, t2, t3;
      for (t1 = this._box_0; t2 = t1.node, t2 != null;) {
        t3 = !t2._isExpanded;
        if (t3)
          if (t3) {
            t2._isExpanded = true;
            t2.dirty$0();
          }
        t1.node = t1.node._inspector_tree$_parent;
      }
    },
    $signature: 0
  };
  K.InspectorTree_onTapIcon_closure.prototype = {
    call$0: function() {
      var t1 = this.row.node;
      t1.set$isExpanded(true);
      this.$this.onExpand.call$1(t1);
    },
    $signature: 0
  };
  K.InspectorTree_onTapIcon_closure0.prototype = {
    call$0: function() {
      this.row.node.set$isExpanded(false);
    },
    $signature: 0
  };
  K.InspectorTreeFixedRowHeight.prototype = {
    onMouseMove$1: function(_, offset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, node, t1, row;
      var $async$onMouseMove$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              row = $async$self.getRow$1(offset);
              $async$goto = row != null ? 2 : 4;
              break;
            case 2:
              // then
              node = row.node;
              t1 = node.get$renderObject();
              $async$goto = 5;
              return P._asyncAwait($async$self.onHover$2(node, t1 == null ? null : t1.hitTest$1(offset)), $async$onMouseMove$1);
            case 5:
              // returning from await.
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 6;
              return P._asyncAwait($async$self.onHover$2(null, null), $async$onMouseMove$1);
            case 6:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$onMouseMove$1, $async$completer);
    },
    animateToTargets$1: function(targets) {
      var t1, targetRect, _i, target, t2, row, t3, t4, rowRect;
      H.assertSubtype(targets, "$isList", [K.InspectorTreeNode], "$asList");
      for (t1 = targets.length, targetRect = null, _i = 0; _i < targets.length; targets.length === t1 || (0, H.throwConcurrentModificationError)(targets), ++_i) {
        target = targets[_i];
        t2 = this._root;
        row = t2.getRow$1(t2.getRowIndex$1(target));
        if (row != null) {
          t2 = row.depth;
          t3 = row.index;
          t4 = this._inspector_tree_canvas$_viewportCanvas._viewport._dart_ui$_value;
          rowRect = S.Rect$fromLTWH((t2 + 1) * 16 + 10, 24 * t3 + 10, (t4[2] - t4[0]) * 0.7, 24);
          if (targetRect == null)
            targetRect = rowRect;
          else {
            t2 = targetRect._dart_ui$_value;
            t3 = rowRect._dart_ui$_value;
            targetRect = S.Rect$fromLTRB(Math.min(t2[0], t3[0]), Math.min(t2[1], t3[1]), Math.max(t2[2], t3[2]), Math.max(t2[3], t3[3]));
          }
        }
      }
      if (targetRect != null) {
        t1 = targetRect._dart_ui$_value;
        t1 = t1[0] >= t1[2] || t1[1] >= t1[3];
      } else
        t1 = true;
      if (t1)
        return;
      targetRect = targetRect.inflate$1(20);
      this._inspector_tree_canvas$_viewportCanvas.scrollToRect$1(targetRect);
    }
  };
  E.CanvasPaintEntry.prototype = {};
  E.IconPaintEntry0.prototype = {
    get$icon: function(_) {
      return this.iconRenderer.icon;
    },
    paint$1: function(canvas) {
      var t1 = this.iconRenderer,
        image = t1.get$image(t1);
      if (image != null)
        canvas.drawImage(image, this.x, (24 - t1.get$iconHeight()) / 2, t1.get$iconWidth(), t1.get$iconHeight());
    },
    get$right: function(_) {
      return this.x + this.iconRenderer.icon.get$iconWidth();
    },
    attach$1: function(owner) {
      var t1 = this.iconRenderer;
      if (t1.get$image(t1) == null)
        t1.loadImage$0().then$1$1(new E.IconPaintEntry_attach_closure(owner), null);
    }
  };
  E.IconPaintEntry_attach_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isCanvasImageSource");
      this.owner.setState$1(new E.IconPaintEntry_attach__closure());
    },
    $signature: 47
  };
  E.IconPaintEntry_attach__closure.prototype = {
    call$0: function() {
    },
    $signature: 0
  };
  E.TextPaintEntry.prototype = {
    get$icon: function(_) {
      return;
    },
    paint$1: function(canvas) {
      var _this = this,
        t1 = _this.color;
      if (t1 != null)
        canvas.fillStyle = t1;
      t1 = _this.font;
      if (t1 != null)
        canvas.font = t1;
      C.CanvasRenderingContext2D_methods.fillText$3(canvas, _this.text, _this.x, 17);
    },
    get$right: function(_) {
      var t1 = this.width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return this.x + t1;
    }
  };
  E.InspectorTreeNodeRenderCanvasBuilder.prototype = {
    appendText$2: function(_, text, textStyle) {
      var t1, t2, width, _this = this;
      if (text == null || text.length === 0)
        return;
      if (!J.$eq$(textStyle, _this.lastStyle)) {
        t1 = textStyle.color;
        t2 = _this.lastStyle;
        if (t1 != (t2 == null ? null : t2.color))
          _this.color = Y.colorToCss(t1);
        t1 = Y.fontStyleToCss(textStyle);
        _this.font = t1;
        _this.lastStyle = textStyle;
        $.$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas().font = t1;
      }
      width = $.$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas().measureText(text).width;
      t1 = _this.x;
      C.JSArray_methods.add$1(_this._inspector_tree_canvas$_entries, new E.TextPaintEntry(width, text, _this.color, _this.font, t1));
      t1 = _this.x;
      if (typeof width !== "number")
        return H.iae(width);
      _this.x = t1 + width;
    },
    addIcon$1: function(icon) {
      var t1 = icon.get$iconWidth(),
        t2 = this.x;
      C.JSArray_methods.add$1(this._inspector_tree_canvas$_entries, new E.IconPaintEntry0(Y.getIconRenderer(icon), t2));
      this.x += t1 + 3;
    },
    build$0: function() {
      return new E.InspectorTreeNodeCanvasRender(this._inspector_tree_canvas$_entries, new S.Size(this.x, 24));
    }
  };
  E.InspectorTreeNodeCanvasRender.prototype = {
    paint$2: function(context, visible) {
      var t1, t2, t3, _i, entry, t4, t5;
      for (t1 = this.entries, t2 = t1.length, t3 = visible._dart_ui$_value, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        entry = t1[_i];
        t4 = this._inspector_tree$_offset._dx;
        if (typeof t4 !== "number")
          return H.iae(t4);
        if (entry.x + t4 > t3[2])
          return;
        t4 = entry.get$right(entry);
        t5 = this._inspector_tree$_offset._dx;
        if (typeof t5 !== "number")
          return H.iae(t5);
        if (t4 + t5 >= t3[0])
          entry.paint$1(context);
      }
    },
    hitTest$1: function($location) {
      var t2, t3, _i, entry,
        t1 = this._inspector_tree$_offset;
      if (t1 == null)
        return;
      $location = $location.$sub(0, t1);
      t1 = $location._dy;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (!(t1 < 0)) {
        t2 = this.size._dy;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 >= t2;
        t1 = t2;
      } else
        t1 = true;
      if (t1)
        return;
      for (t1 = this.entries, t2 = t1.length, t3 = $location._dx, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        entry = t1[_i];
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (entry.x <= t3 && entry.get$right(entry) > t3)
          return entry;
      }
      return;
    },
    $asInspectorTreeNodeRender: function() {
      return [E.CanvasPaintEntry];
    }
  };
  E.InspectorTreeNodeCanvas.prototype = {
    createRenderBuilder$0: function() {
      var t1 = this._diagnostic.getLevelMember$2("level", C.DiagnosticLevel_3),
        t2 = this._diagnostic.getStyleMember$2("style", C.DiagnosticsTreeStyle_0);
      return new E.InspectorTreeNodeRenderCanvasBuilder(H.setRuntimeTypeInfo([], [E.CanvasPaintEntry]), t1, t2);
    }
  };
  E.InspectorTreeCanvas.prototype = {
    _updateForContainerResize$1: function(size) {
      this._inspector_tree_canvas$_viewportCanvas.setContentSize$2(this._computeContentWidth$1(size), 24 * this.get$numRows() + 20);
    },
    _inspector_tree_canvas$_paintCallback$2: function(canvas, rect) {
      var i,
        t1 = rect._dart_ui$_value,
        startRow = C.JSNumber_methods._tdivFast$1(t1[1] - 10, 24),
        endRow = Math.min(C.JSNumber_methods._tdivFast$1(t1[3] - 10, 24) + 1, this.get$numRows());
      for (i = startRow; i < endRow; ++i)
        this.paintRow$3(canvas, i, rect);
    },
    setState$1: function(modifyState) {
      H.functionTypeCheck(modifyState, {func: 1, ret: -1}).call$0();
      if (!this._inspector_tree_canvas$_recomputeRows) {
        this._inspector_tree_canvas$_recomputeRows = true;
        C.Window_methods.requestAnimationFrame$1(window, new E.InspectorTreeCanvas_setState_closure(this));
      }
    },
    _computeContentWidth$1: function(size) {
      var t1, row, maxIndent = 0, i = 0;
      while (true) {
        t1 = this._root;
        if (t1 != null) {
          t1 = t1.get$childrenCount();
          if (typeof t1 !== "number")
            return t1.$add();
          ++t1;
        } else
          t1 = 0;
        if (!(i < t1))
          break;
        t1 = this._root;
        row = t1 == null ? null : t1.getRow$2$selection(i, this._selection);
        if (row != null)
          maxIndent = Math.max(maxIndent, (row.depth + 1) * 16 + 10);
        ++i;
      }
      t1 = size._dx;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return maxIndent + t1;
    },
    set$tooltip: function(value) {
      this._inspector_tree_canvas$_viewportCanvas._viewport_canvas$_element.element.title = value;
    },
    onMouseLeave$0: function(_) {
      this.onHover$2(null, null);
    },
    get$element: function() {
      return this._inspector_tree_canvas$_viewportCanvas._viewport_canvas$_element;
    },
    createNode$0: function() {
      return new E.InspectorTreeNodeCanvas(H.setRuntimeTypeInfo([], [K.InspectorTreeNode]));
    },
    paintRow$3: function(canvas, index, visible) {
      var y, isVisible, t1, row, node, showExpandCollapse, renderObject, _endPath, _maybeStart, t2, t3, _i, tick, width, paintBounds, backgroundColor, x, fillStyle, _this = this, _box_0 = {};
      canvas.save();
      y = 24 * index + 10;
      canvas.translate(0, y);
      _box_0.currentX = 0;
      _box_0.currentColor = null;
      isVisible = new E.InspectorTreeCanvas_paintRow_isVisible(_box_0, visible);
      t1 = _this._root;
      row = t1 == null ? null : t1.getRow$2$selection(index, _this._selection);
      if (row == null)
        return;
      node = row.node;
      showExpandCollapse = node.get$showExpandCollapse();
      renderObject = H.interceptedTypeCheck(node.get$renderObject(), "$isInspectorTreeNodeCanvasRender");
      _box_0.hasPath = false;
      _endPath = new E.InspectorTreeCanvas_paintRow__endPath(_box_0, canvas);
      _maybeStart = new E.InspectorTreeCanvas_paintRow__maybeStart(_box_0, _endPath, canvas);
      for (t1 = row.ticks, t2 = t1.length, t3 = row.highlightDepth, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        tick = t1[_i];
        _box_0.currentX = (tick + 1) * 16 + 10 - 8;
        if (H.boolConversionCheck(isVisible.call$1(1))) {
          _maybeStart.call$1(t3 === tick ? C.ThemedColor_Color_4278190080_Color_4291348680 : C.ThemedColor_chs);
          canvas.moveTo(_box_0.currentX, 0);
          canvas.lineTo(_box_0.currentX, 24);
        }
      }
      if (row.lineToParent) {
        t1 = row.depth - 1;
        _box_0.currentX = (t1 + 1) * 16 + 10 - 8;
        width = showExpandCollapse ? 8 : 16;
        if (H.boolConversionCheck(isVisible.call$1(width))) {
          _maybeStart.call$1(t3 === t1 ? C.ThemedColor_Color_4278190080_Color_4291348680 : C.ThemedColor_chs);
          canvas.moveTo(_box_0.currentX, 0);
          canvas.lineTo(_box_0.currentX, 12);
          canvas.lineTo(_box_0.currentX + width, 12);
        }
      }
      _endPath.call$0();
      t1 = (row.depth + 1) * 16 + 10;
      _box_0.currentX = t1 - 16;
      if (!node.get$showExpandCollapse())
        _box_0.currentX += 16;
      if (renderObject == null) {
        canvas.restore();
        return;
      }
      renderObject.attach$2(_this, new S.Offset(_box_0.currentX, y));
      t2 = renderObject._inspector_tree$_offset;
      t3 = renderObject.size;
      paintBounds = S.Rect$fromLTWH(t2._dx, t2._dy, t3._dx, t3._dy);
      if (!paintBounds.overlaps$1(visible)) {
        canvas.restore();
        return;
      }
      t2 = row.isSelected;
      if (t2 || node === _this._hover) {
        backgroundColor = t2 ? C.ThemedColor_Color_4291477317_Color_4284704103 : C.ThemedColor_W3G;
        x = t1 - 2.4;
        t1 = visible._dart_ui$_value;
        if (x <= t1[2]) {
          fillStyle = canvas.fillStyle;
          canvas.fillStyle = Y.colorToCss(backgroundColor);
          canvas.fillRect(x, 0, Math.min(t1[2], paintBounds._dart_ui$_value[2]) - x, 24);
          canvas.fillStyle = fillStyle;
        }
      }
      canvas.translate(_box_0.currentX, 0);
      renderObject.paint$2(canvas, visible);
      canvas.restore();
    },
    $isInspectorTreeWeb: 1,
    $isCoreElementView: 1
  };
  E.InspectorTreeCanvas_setState_closure.prototype = {
    call$1: function(_) {
      var t1, t2, t3;
      H.numTypeCheck(_);
      t1 = this.$this;
      if (t1._inspector_tree_canvas$_recomputeRows) {
        t1._inspector_tree_canvas$_recomputeRows = false;
        t2 = t1._root;
        t3 = t1._inspector_tree_canvas$_viewportCanvas;
        if (t2 != null) {
          t2 = t3._viewport._dart_ui$_value;
          t1._updateForContainerResize$1(new S.Size(t2[2] - t2[0], t2[3] - t2[1]));
        } else
          t3.setContentSize$2(0, 0);
      }
      t1._inspector_tree_canvas$_viewportCanvas.rebuild$1$force(true);
      return;
    },
    $signature: 89
  };
  E.InspectorTreeCanvas_paintRow_isVisible.prototype = {
    call$1: function(width) {
      var t1 = this._box_0.currentX,
        t2 = this.visible._dart_ui$_value;
      return t1 <= t2[2] && t2[0] <= t1 + width;
    },
    $signature: 106
  };
  E.InspectorTreeCanvas_paintRow__endPath.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      if (!t1.hasPath)
        return;
      this.canvas.stroke();
      t1.hasPath = false;
    },
    $signature: 1
  };
  E.InspectorTreeCanvas_paintRow__maybeStart.prototype = {
    call$1: function(color) {
      var t2,
        t1 = this._box_0;
      if (color !== t1.currentColor)
        this._endPath.call$0();
      if (t1.hasPath)
        return;
      t1.hasPath = true;
      t2 = this.canvas;
      t2.beginPath();
      if (t1.currentColor !== color) {
        t1.currentColor = color;
        t2.strokeStyle = Y.colorToCss(color);
      }
      t2.lineWidth = 1;
    },
    call$0: function() {
      return this.call$1(C.MaterialColor_Map_HFpTk_4288585374);
    },
    $signature: 123
  };
  K.HtmlPaintEntry.prototype = {};
  K.IconPaintEntry.prototype = {
    get$icon: function(_) {
      return this.iconRenderer.icon;
    },
    paint$1: function($parent) {
      var t1 = this.iconRenderer.createElement$0(0);
      this.element = t1;
      $parent.appendChild(t1);
    },
    attach$1: function(owner) {
    }
  };
  K.HtmlTextPaintEntry.prototype = {
    get$icon: function(_) {
      return;
    },
    paint$1: function($parent) {
      var t2, t3, _this = this,
        t1 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("span", null), "$isElement");
      t1.textContent = _this.text;
      _this.element = t1;
      t2 = _this.color;
      if (t2 != null) {
        t3 = t1.style;
        t3.color = t2;
      }
      t2 = _this.font;
      if (t2 != null) {
        t3 = t1.style;
        t3.font = t2;
      }
      $parent.appendChild(t1);
    }
  };
  K.InspectorTreeNodeRenderHtmlBuilder.prototype = {
    appendText$2: function(_, text, textStyle) {
      var t1, t2, _this = this;
      if (text == null || text.length === 0)
        return;
      if (!J.$eq$(textStyle, _this.lastStyle)) {
        t1 = textStyle.color;
        t2 = _this.lastStyle;
        if (t1 != (t2 == null ? null : t2.color))
          _this.color = Y.colorToCss(t1);
        _this.font = Y.fontStyleToCss(textStyle);
        _this.lastStyle = textStyle;
      }
      C.JSArray_methods.add$1(_this._entries, new K.HtmlTextPaintEntry(text, _this.color, _this.font));
    },
    addIcon$1: function(icon) {
      C.JSArray_methods.add$1(this._entries, new K.IconPaintEntry(Y.getIconRenderer(icon)));
    },
    build$0: function() {
      var _this = this,
        classes = H.setRuntimeTypeInfo(["inspector-level-" + H.S($.$get$diagnosticLevelToName().$index(0, _this.level)), "inspector-style-" + H.S($.$get$treeStyleToName().$index(0, _this.treeStyle))], [P.String]);
      if (!H.boolConversionCheck(_this.allowWrap))
        C.JSArray_methods.add$1(classes, "inspector-no-wrap");
      return new K.InspectorTreeNodeHtmlRender(classes, _this._entries, C.Size_0_0);
    }
  };
  K.InspectorTreeNodeHtmlRender.prototype = {
    paint$1: function(container) {
      var t1, t2, _i;
      W._ElementCssClassSet__addAll(container, H.assertSubtype(this.cssClasses, "$isIterable", [P.String], "$asIterable"));
      this.element = container;
      for (t1 = this.entries, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].paint$1(container);
    },
    hitTest$1: function($location) {
      throw H.wrapException("Not yet supported by HTML tree");
    },
    $asInspectorTreeNodeRender: function() {
      return [K.HtmlPaintEntry];
    }
  };
  K.InspectorTreeNodeHtml.prototype = {
    createRenderBuilder$0: function() {
      var t1 = this._diagnostic.getLevelMember$2("level", C.DiagnosticLevel_3),
        t2 = this._diagnostic.getStyleMember$2("style", C.DiagnosticsTreeStyle_0);
      return new K.InspectorTreeNodeRenderHtmlBuilder(this._diagnostic.getBooleanMember$2("allowWrap", true), H.setRuntimeTypeInfo([], [K.HtmlPaintEntry]), t1, t2);
    }
  };
  K.InspectorTreeHtml.prototype = {
    _resolveTreeRow$1: function(e) {
      var t1, index;
      while (true) {
        t1 = e == null;
        if (!(!t1 && !J.get$classes$x(e).contains$1(0, "inspector-tree-row")))
          break;
        e = e.parentElement;
      }
      if (t1)
        return;
      t1 = J.get$children$x(e.parentElement);
      index = t1.indexOf$1(t1, e);
      return this._root.getRow$2$selection(index, this._selection);
    },
    _resolveIcon$2: function(row, e) {
      var t1, t2, _i, entry,
        render = H.interceptedTypeCheck(row.node.get$renderObject(), "$isInspectorTreeNodeHtmlRender");
      if (render == null)
        return;
      while (true) {
        t1 = e == null;
        if (!(!t1 && !J.get$classes$x(e).contains$1(0, "flutter-icon")))
          break;
        t1 = render.element;
        if (e == null ? t1 == null : e === t1)
          return;
        e = e.parentElement;
      }
      if (t1)
        return;
      for (t1 = render.entries, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        entry = t1[_i];
        if (entry.element === e)
          return entry.get$icon(entry);
      }
      return;
    },
    setState$1: function(modifyState) {
      H.functionTypeCheck(modifyState, {func: 1, ret: -1}).call$0();
      if (!this._recomputeRows) {
        this._recomputeRows = true;
        C.Window_methods.requestAnimationFrame$1(window, new K.InspectorTreeHtml_setState_closure(this));
      }
    },
    _rebuildData$0: function() {
      var rowCount, t1, i, _this = this;
      if (_this._recomputeRows) {
        _this._recomputeRows = false;
        if (_this._root == null) {
          J.get$children$x(_this._inspector_tree_html$_container.element).clear$0(0);
          return;
        }
        rowCount = _this.get$numRows();
        t1 = _this._inspector_tree_html$_container.element;
        J.get$children$x(t1).clear$0(0);
        for (i = 0; i < rowCount; ++i)
          t1.appendChild(_this.paintRow$2$selection(i, _this._selection));
      }
    },
    onMouseClick$1: function(mouseEvent) {
      var row;
      H.interceptedTypeCheck(mouseEvent, "$isMouseEvent");
      row = this._resolveTreeRow$1(H.interceptedTypeCheck(W._convertNativeToDart_EventTarget(mouseEvent.target), "$isElement"));
      if (row == null)
        return;
      this.onTapIcon$2(row, this._resolveIcon$2(row, H.interceptedTypeCheck(W._convertNativeToDart_EventTarget(mouseEvent.target), "$isElement")));
    },
    onMouseMove$1: function(_, mouseEvent) {
      var t1 = this._resolveTreeRow$1(H.interceptedTypeCheck(W._convertNativeToDart_EventTarget(H.interceptedTypeCheck(mouseEvent, "$isMouseEvent").target), "$isElement"));
      this.onHover$2(t1 == null ? null : t1.node, null);
    },
    onMouseLeave$1: function(_, mouseEvent) {
      H.interceptedTypeCheck(mouseEvent, "$isMouseEvent");
      this.onHover$2(null, null);
    },
    get$element: function() {
      return this._inspector_tree_html$_container;
    },
    createNode$0: function() {
      return new K.InspectorTreeNodeHtml(H.setRuntimeTypeInfo([], [K.InspectorTreeNode]));
    },
    paintRow$2$selection: function(index, selection) {
      var container, currentX, row, node, diagnostic, renderObject, rowContentContainer, rowContent, e, s, t1, t2, t3, exception;
      try {
        t1 = document;
        container = t1.createElement("div");
        container.classList.add("inspector-tree-row");
        currentX = 0;
        t2 = this._root;
        row = t2 == null ? null : t2.getRow$2$selection(index, selection);
        if (row == null)
          return container;
        node = row.node;
        diagnostic = node._diagnostic;
        if (diagnostic != null) {
          t2 = H.stringTypeCheck(J.$index$asx(diagnostic.json, "name"));
          t2 = (t2 == null ? null : t2.length !== 0) === true && H.boolConversionCheck(diagnostic.getBooleanMember$2("showName", true)) && H.boolConversionCheck(diagnostic.getBooleanMember$2("showSeparator", true)) && H.stringTypeCheck(J.$index$asx(diagnostic.json, "description")) != null;
        } else
          t2 = false;
        if (t2)
          container.classList.add("property-value");
        renderObject = H.interceptedTypeCheck(node.get$renderObject(), "$isInspectorTreeNodeHtmlRender");
        if (renderObject == null)
          return container;
        currentX = (row.depth + 1) * 16 + 10 - 16;
        if (!row.node.get$showExpandCollapse()) {
          t2 = currentX;
          if (typeof t2 !== "number")
            return t2.$add();
          currentX = t2 + 16;
        }
        rowContentContainer = t1.createElement("div");
        rowContentContainer.classList.add("inspector-tree-row-content");
        t2 = rowContentContainer.style;
        t3 = H.S(currentX) + "px";
        t2.paddingLeft = t3;
        rowContent = t1.createElement("div");
        J.append$1$x(rowContentContainer, rowContent);
        renderObject.paint$1(rowContent);
        J.append$1$x(container, rowContentContainer);
        return container;
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        P.print(s);
        t1 = document.createElement("div");
        t1.textContent = "Error: " + H.S(e) + ", " + H.S(s);
        return t1;
      }
    },
    animateToTargets$1: function(targets) {
      H.assertSubtype(targets, "$isList", [K.InspectorTreeNode], "$asList");
      C.Window_methods.requestAnimationFrame$1(window, new K.InspectorTreeHtml_animateToTargets_closure(targets));
    },
    set$tooltip: function(value) {
      this._inspector_tree_html$_container.element.title = value;
    },
    $isInspectorTreeWeb: 1,
    $isCoreElementView: 1
  };
  K.InspectorTreeHtml_setState_closure.prototype = {
    call$1: function(_) {
      H.numTypeCheck(_);
      return this.$this._rebuildData$0();
    },
    $signature: 89
  };
  K.InspectorTreeHtml_animateToTargets_closure.prototype = {
    call$1: function(_) {
      var t1, t2, renderObject;
      H.numTypeCheck(_);
      for (t1 = this.targets, t2 = H.getTypeArgumentByIndex(t1, 0), t1 = new H.ReversedListIterable(t1, [t2]), t2 = new H.ListIterator(t1, t1.get$length(t1), [t2]); t2.moveNext$0();) {
        renderObject = H.interceptedTypeCheck(t2.__internal$_current.get$renderObject(), "$isInspectorTreeNodeHtmlRender");
        t1 = renderObject == null ? null : renderObject.element;
        if (t1 != null)
          C.DivElement_methods.scrollIntoView$0(t1);
      }
    },
    $signature: 64
  };
  M.InspectorTreeWeb.prototype = {$isInspectorTree: 1, $isCoreElementView: 1};
  Y.LoggingScreen.prototype = {
    createContent$1: function(framework) {
      var screenDiv, t1, t2, t3, t4, t5, t6, t7, _this = this, _null = null, _s3_ = "div", _s6_ = "layout",
        _s8_ = "vertical",
        _s10_ = "horizontal",
        _s6_0 = "button",
        _s9_ = "full-size";
      E.setupDimensions();
      screenDiv = A.CoreElement$(_s3_, _null, "custom-scrollbar", _null, _null);
      t1 = screenDiv.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute(_s8_, "");
      _this.framework = framework;
      t1 = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t2 = A.CoreElement$("form", _null, _null, _null, _null);
      t2.clazz$1("align-items-center");
      t3 = t2.element;
      t3.setAttribute(_s6_, "");
      t3.setAttribute(_s10_, "");
      t3 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_0, _null), "$isElement");
      t4 = new N.PButton(t3);
      t4.CoreElement$5$attributes$classes$html$text(_s6_0, _null, "btn", _null, "Clear logs");
      t3.setAttribute("type", _s6_0);
      t4.clazz$1("btn-sm");
      t4.click$1(0, _this.get$_clear(_this));
      t3 = [A.CoreElement];
      t2.add$1(0, H.setRuntimeTypeInfo([t4], t3));
      t1.add$1(0, H.setRuntimeTypeInfo([t2], t3));
      t2 = A.CoreElement$(_s3_, _null, "section log-area bidirectional", _null, _null);
      t2.flex$0(0);
      t4 = Y.LogData;
      _this.set$loggingTable(Q.Table$virtual(false, 29, t4));
      t5 = _this.loggingTable;
      t6 = new Y.LogWhenColumn("When", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t6.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("When", C.ColumnAlignment_0, _null, _null, false, _null, false, t4);
      t5.toString;
      H.assertSubtype(t6, "$isColumn", [H.getTypeArgumentByIndex(t5, 0)], "$asColumn");
      C.JSArray_methods.add$1(t5.columns, t6);
      t6 = _this.loggingTable;
      t5 = new Y.LogKindColumn("Kind", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t5.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Kind", C.ColumnAlignment_0, _null, _null, false, _null, false, t4);
      t6.toString;
      H.assertSubtype(t5, "$isColumn", [H.getTypeArgumentByIndex(t6, 0)], "$asColumn");
      C.JSArray_methods.add$1(t6.columns, t5);
      t5 = _this.loggingTable;
      t5.toString;
      t6 = H.assertSubtype(new Y.LogMessageColumn("Message", _null, 100, C.ColumnAlignment_0, false, _null, false), "$isColumn", [H.getTypeArgumentByIndex(t5, 0)], "$asColumn");
      C.JSArray_methods.add$1(t5.columns, t6);
      _this.loggingTable.setRows$1(_this.data);
      t6 = _this.loggingTable.element;
      t5 = t6.element;
      t5.setAttribute(_s6_, "");
      t5.setAttribute(_s10_, "");
      t6.clazz$1("section");
      t6.clazz$1(_s9_);
      t6.flex$0(0);
      t5 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t4 = new Y.LogDetailsUI(t5);
      t4.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s9_, _null, _null);
      t5.setAttribute(_s6_, "");
      t5.setAttribute(_s8_, "");
      t4.flex$0(0);
      t5 = A.CoreElement$(_s3_, _null, "log-details table-border", _null, _null);
      t5.flex$0(0);
      t7 = A.CoreElement$(_s3_, _null, "pre-wrap monospace", _null, _null);
      t4.message = t7;
      t5.add$1(0, t7);
      t4.content = t5;
      t4.add$1(0, H.setRuntimeTypeInfo([t5], t3));
      _this.logDetailsUI = t4;
      t2.add$1(0, H.setRuntimeTypeInfo([t6, t4], t3));
      screenDiv.add$1(0, H.setRuntimeTypeInfo([t1, t2], t3));
      t3 = [P.num];
      A.flexSplitBidirectional([_this.loggingTable.element.element, _this.logDetailsUI.element], 10, H.setRuntimeTypeInfo([60, 40], t3), H.setRuntimeTypeInfo([70, 30], t3));
      t3 = _this.loggingTable._selectController;
      new P._BroadcastStream(t3, [H.getTypeArgumentByIndex(t3, 0)]).listen$1(new Y.LoggingScreen_createContent_closure(_this));
      _this._updateStatus$0();
      t3 = _this.loggingTable._rowsChangedController;
      new P._BroadcastStream(t3, [H.getTypeArgumentByIndex(t3, 0)]).listen$1(new Y.LoggingScreen_createContent_closure0(_this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("reload.end").listen$1(new Y.LoggingScreen_createContent_closure1(_this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus").onEvent$1$type("restart.end").listen$1(new Y.LoggingScreen_createContent_closure2(_this));
      return screenDiv;
    },
    entering$0: function() {
      var _this = this;
      if (_this.hasPendingDomUpdates) {
        _this.loggingTable.setRows$1(_this.data);
        _this.hasPendingDomUpdates = false;
      }
    },
    _updateStatus$0: function() {
      var t1 = this.loggingTable,
        count = t1.get$rowCount(t1),
        label = count >= 5000 ? $.$get$nf().format$1(5000) + "+" : $.$get$nf().format$1(count);
      this.logCountStatus.element.element.textContent = label + " events";
    },
    _clear$0: function(_) {
      var t1, _this = this;
      F.select("logging", "clearLogs", 0);
      C.JSArray_methods.set$length(_this.data, 0);
      t1 = _this.logDetailsUI;
      if (t1 != null)
        t1.setData$1(0, null);
      _this.loggingTable.setRows$1(_this.data);
    },
    _handleConnectionStart$1: function(service) {
      return this._handleConnectionStart$body$LoggingScreen(H.interceptedTypeCheck(service, "$isVmServiceWrapper"));
    },
    _handleConnectionStart$body$LoggingScreen: function(service) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t2, t1;
      var $async$_handleConnectionStart$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = service._vmService._getEventController$1("Stdout");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new Y._StdoutEventHandler($async$self, "stdout", false).get$handle());
              t1 = service._vmService._getEventController$1("Stderr");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new Y._StdoutEventHandler($async$self, "stderr", true).get$handle());
              t1 = service._vmService._getEventController$1("GC");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self.get$_logging$_handleGCEvent());
              t1 = service._vmService._getEventController$1("_Logging");
              t2 = $async$self.get$_handleDeveloperLogEvent();
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(t2);
              t1 = service._vmService._getEventController$1("Logging");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(t2);
              t2 = service._vmService._getEventController$1("Extension");
              new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1($async$self.get$_logging$_handleExtensionEvent());
              $async$goto = 2;
              return P._asyncAwait(E.ensureInspectorServiceDependencies(), $async$_handleConnectionStart$1);
            case 2:
              // returning from await.
              $async$self.set$objectGroup(E.InspectorService_createGroup(service, "console-group").catchError$2$test(new Y.LoggingScreen__handleConnectionStart_closure(), new Y.LoggingScreen__handleConnectionStart_closure0()));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleConnectionStart$1, $async$completer);
    },
    _logging$_handleExtensionEvent$1: function(e) {
      return this._handleExtensionEvent$body$LoggingScreen(H.interceptedTypeCheck(e, "$isEvent0"));
    },
    _handleExtensionEvent$body$LoggingScreen: function(e) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t2, t3, t4, frameInfo, classes, pixelWidth, div, node, t1;
      var $async$_logging$_handleExtensionEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = e.extensionKind;
              if (t1 === "Flutter.Frame") {
                t1 = H.assertSubtype(e.extensionData.data, "$isMap", [P.String, null], "$asMap");
                t2 = J.getInterceptor$asx(t1);
                t3 = H.intTypeCheck(t2.$index(t1, "number"));
                t4 = H.numTypeCheck(J.$div$n(t2.$index(t1, "elapsed"), 1000));
                H.numTypeCheck(J.$div$n(t2.$index(t1, "startTime"), 1000));
                frameInfo = '<span class="pre">' + ("#" + H.S(t3)) + " " + C.JSString_methods.padLeft$1(C.JSNumber_methods.toStringAsFixed$1(t4, 1), 4) + "ms </span>";
                classes = t4 >= 16.666666666666668 ? "frame-bar over-budget" : "frame-bar";
                pixelWidth = C.JSNumber_methods.round$0(t4 * 3);
                div = '<div class="' + classes + '" style="width: ' + pixelWidth + 'px"/>';
                $async$self._logging$_log$1(Y.LogData$(e.extensionKind.toLowerCase(), C.C_JsonCodec.encode$2$toEncodable(e.extensionData.data, null), e.timestamp, null, false, null, null, frameInfo + div));
              } else if (t1 === "Flutter.Error") {
                t2 = H.assertSubtype(e.extensionData.data, "$isMap", [P.String, P.Object], "$asMap");
                node = new M.RemoteDiagnosticsNode(null, $async$self.objectGroup, t2, false);
                $async$self._logging$_log$1(Y.LogData$(t1.toLowerCase(), C.C_JsonCodec.encode$2$toEncodable(e.json, null), e.timestamp, null, false, node, node.toDiagnosticsNode$0().toString$0(0), null));
              } else {
                t1 = t1.toLowerCase();
                t2 = e.json;
                $async$self._logging$_log$1(Y.LogData$(t1, C.C_JsonCodec.encode$2$toEncodable(t2, null), e.timestamp, null, false, null, J.toString$0$(t2), null));
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_logging$_handleExtensionEvent$1, $async$completer);
    },
    _logging$_handleGCEvent$1: function(e) {
      var t1, t2, t3, t4, t5, newSpace, oldSpace, isolateRef, t6, t7, t8, t9, time, summary, _null = null;
      H.interceptedTypeCheck(e, "$isEvent0");
      t1 = e.json;
      t2 = J.getInterceptor$asx(t1);
      t3 = P.String;
      t4 = [t3, null];
      t5 = H.assertSubtype(t2.$index(t1, "new"), "$isMap", t4, "$asMap");
      newSpace = t5 == null ? _null : S.HeapSpace$_fromJson(t5);
      t4 = H.assertSubtype(t2.$index(t1, "old"), "$isMap", t4, "$asMap");
      oldSpace = t4 == null ? _null : S.HeapSpace$_fromJson(t4);
      isolateRef = H.interceptedTypeCheck(t2.$index(t1, "isolate"), "$isMap");
      t4 = newSpace.used;
      t5 = oldSpace.used;
      if (typeof t4 !== "number")
        return t4.$add();
      if (typeof t5 !== "number")
        return H.iae(t5);
      t6 = newSpace.capacity;
      t7 = oldSpace.capacity;
      if (typeof t6 !== "number")
        return t6.$add();
      if (typeof t7 !== "number")
        return H.iae(t7);
      t8 = newSpace.time;
      t9 = oldSpace.time;
      if (typeof t8 !== "number")
        return t8.$add();
      if (typeof t9 !== "number")
        return H.iae(t9);
      time = C.JSNumber_methods.round$0((t8 + t9) * 1000);
      summary = H.S(J.$index$asx(isolateRef, "name")) + " \u2022 " + H.S(t2.$index(t1, "reason")) + " collection in " + time + " ms \u2022 " + B.printMb(t4 + t5) + " MB used of " + B.printMb(t6 + t7) + " MB";
      this._logging$_log$1(Y.LogData$("gc", C.C_JsonCodec.encode$2$toEncodable(P.LinkedHashMap_LinkedHashMap$_literal(["reason", t2.$index(t1, "reason"), "new", newSpace.json, "old", oldSpace.json, "isolate", isolateRef], t3, _null), _null), e.timestamp, _null, false, _null, summary, _null));
    },
    _handleDeveloperLogEvent$1: function(e) {
      var service, logRecord, t1, t2, t3, t4, loggerName, level, messageRef, summary, error, stackTrace, detailsComputer, isError, _null = null;
      H.interceptedTypeCheck(e, "$isEvent0");
      service = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      logRecord = J.$index$asx(e.json, "logRecord");
      t1 = J.getInterceptor$asx(logRecord);
      t2 = P.String;
      t3 = [t2, null];
      t4 = H.assertSubtype(t1.$index(logRecord, "loggerName"), "$isMap", t3, "$asMap");
      loggerName = Y._valueAsString(t4 == null ? _null : S.InstanceRef$_fromJson(t4));
      if (loggerName == null || loggerName.length === 0)
        loggerName = "log";
      level = H.intTypeCheck(t1.$index(logRecord, "level"));
      t4 = H.assertSubtype(t1.$index(logRecord, "message"), "$isMap", t3, "$asMap");
      messageRef = t4 == null ? _null : S.InstanceRef$_fromJson(t4);
      summary = Y._valueAsString(messageRef);
      if (messageRef.valueAsStringIsTruncated)
        summary = J.$add$ansx(summary, "...");
      t4 = H.assertSubtype(t1.$index(logRecord, "error"), "$isMap", t3, "$asMap");
      error = t4 == null ? _null : S.InstanceRef$_fromJson(t4);
      t1 = H.assertSubtype(t1.$index(logRecord, "stackTrace"), "$isMap", t3, "$asMap");
      stackTrace = t1 == null ? _null : S.InstanceRef$_fromJson(t1);
      detailsComputer = messageRef.valueAsStringIsTruncated || Y._isNotNull(error) || Y._isNotNull(stackTrace) ? P.Future_Future(new Y.LoggingScreen__handleDeveloperLogEvent_closure(this, service, e, messageRef, error, stackTrace), t2) : _null;
      isError = level != null && level >= 1000 && true;
      this._logging$_log$1(Y.LogData$(loggerName, summary, e.timestamp, detailsComputer, isError, _null, summary, _null));
    },
    _logging$_retrieveFullStringValue$3: function(service, isolateRef, stringRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, t1, t2, result;
      var $async$_logging$_retrieveFullStringValue$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!stringRef.valueAsStringIsTruncated) {
                $async$returnValue = stringRef.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = isolateRef.id;
              t2 = stringRef.id;
              $async$goto = 3;
              return P._asyncAwait(service._trackFuture$1$2("getObject", service._vmService.getObject$2(0, t1, t2), P.Object), $async$_logging$_retrieveFullStringValue$3);
            case 3:
              // returning from await.
              result = $async$result;
              if (result instanceof S.Instance) {
                $async$returnValue = result.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              } else {
                $async$returnValue = H.S(stringRef.valueAsString) + "...";
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_logging$_retrieveFullStringValue$3, $async$completer);
    },
    _handleConnectionStop$1: function($event) {
    },
    _logging$_log$1: function(log) {
      var t1, t2, itemsToRemove, smoothScroll, _this = this;
      C.JSArray_methods.add$1(_this.data, log);
      t1 = _this.data;
      t2 = t1.length;
      if (t2 > 5500) {
        itemsToRemove = t2 - 5000;
        _this.set$data(0, C.JSArray_methods.sublist$1(t1, C.JSInt_methods.$mod(itemsToRemove, 2) === 1 ? itemsToRemove - 1 : itemsToRemove));
      }
      if (_this._visible._utils$_value && _this.loggingTable != null) {
        _this.loggingTable.setRows$1(_this.data);
        t1 = Date.now();
        t2 = _this._lastScrollTime;
        smoothScroll = t2 == null || C.JSInt_methods._tdivFast$1(P.Duration$(0, t2._value - t1, 0, 0)._duration, 1000000) > 1;
        _this._lastScrollTime = new P.DateTime(t1, false);
        t1 = _this.loggingTable;
        t2 = C.JSArray_methods.get$last(_this.data);
        t1.scrollTo$2$scrollBehavior(0, t2, smoothScroll ? "smooth" : "auto");
      } else
        _this.hasPendingDomUpdates = true;
    },
    set$loggingTable: function(loggingTable) {
      this.loggingTable = H.assertSubtype(loggingTable, "$isTable", [Y.LogData], "$asTable");
    },
    set$objectGroup: function(objectGroup) {
      this.objectGroup = H.assertSubtype(objectGroup, "$isFuture", [E.ObjectGroup], "$asFuture");
    },
    set$data: function(_, data) {
      this.data = H.assertSubtype(data, "$isList", [Y.LogData], "$asList");
    }
  };
  Y.LoggingScreen_createContent_closure.prototype = {
    call$1: function(selection) {
      H.interceptedTypeCheck(selection, "$isLogData");
      this.$this.logDetailsUI.setData$1(0, selection);
    },
    $signature: 126
  };
  Y.LoggingScreen_createContent_closure0.prototype = {
    call$1: function(_) {
      this.$this._updateStatus$0();
    },
    $signature: 62
  };
  Y.LoggingScreen_createContent_closure1.prototype = {
    call$1: function($event) {
      var _null = null;
      this.$this._logging$_log$1(Y.LogData$("hot.reload", H.interceptedTypeCheck($event, "$isBusEvent").data, Date.now(), _null, false, _null, _null, _null));
    },
    $signature: 21
  };
  Y.LoggingScreen_createContent_closure2.prototype = {
    call$1: function($event) {
      var _null = null;
      this.$this._logging$_log$1(Y.LogData$("hot.restart", H.interceptedTypeCheck($event, "$isBusEvent").data, Date.now(), _null, false, _null, _null, _null));
    },
    $signature: 21
  };
  Y.LoggingScreen__handleConnectionStart_closure.prototype = {
    call$1: function(e) {
      return;
    },
    $signature: 2
  };
  Y.LoggingScreen__handleConnectionStart_closure0.prototype = {
    call$1: function(e) {
      return e instanceof E.FlutterInspectorLibraryNotFound;
    },
    $signature: 30
  };
  Y.LoggingScreen__handleDeveloperLogEvent_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t5, t6, toStringResult, t1, t2, t3, result, t4, $async$temp1, $async$temp2, $async$temp3;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.service;
              t3 = $async$self.e;
              $async$goto = 3;
              return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t3.isolate, $async$self.messageRef), $async$call$0);
            case 3:
              // returning from await.
              result = $async$result;
              t4 = $async$self.error;
              $async$goto = Y._isNotNull(t4) ? 4 : 5;
              break;
            case 4:
              // then
              t5 = t4.valueAsString;
              t6 = t3.isolate;
              $async$goto = t5 != null ? 6 : 8;
              break;
            case 6:
              // then
              $async$temp1 = J;
              $async$temp2 = result;
              $async$temp3 = H;
              $async$goto = 9;
              return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t6, t4), $async$call$0);
            case 9:
              // returning from await.
              result = $async$temp1.$add$ansx($async$temp2, "\n\n" + $async$temp3.S($async$result));
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              $async$goto = 10;
              return P._asyncAwait(t2.invoke$5$disableBreakpoints(t6.id, t4.id, "toString", H.setRuntimeTypeInfo([], [P.String]), true), $async$call$0);
            case 10:
              // returning from await.
              toStringResult = $async$result;
              t5 = J.getInterceptor$(toStringResult);
              $async$goto = !!t5.$isErrorRef ? 11 : 13;
              break;
            case 11:
              // then
              result = J.$add$ansx(result, "\n\n" + H.S(Y._valueAsString(t4)));
              // goto join
              $async$goto = 12;
              break;
            case 13:
              // else
              $async$goto = !!t5.$isInstanceRef ? 14 : 15;
              break;
            case 14:
              // then
              $async$temp1 = J;
              $async$temp2 = result;
              $async$temp3 = H;
              $async$goto = 16;
              return P._asyncAwait(t1._logging$_retrieveFullStringValue$3(t2, t3.isolate, toStringResult), $async$call$0);
            case 16:
              // returning from await.
              result = $async$temp1.$add$ansx($async$temp2, "\n\n" + $async$temp3.S($async$result));
            case 15:
              // join
            case 12:
              // join
            case 7:
              // join
            case 5:
              // join
              t1 = $async$self.stackTrace;
              $async$returnValue = Y._isNotNull(t1) ? J.$add$ansx(result, "\n\n" + H.S(Y._valueAsString(t1))) : result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 128
  };
  Y._StdoutEventHandler.prototype = {
    handle$1: function(e) {
      var message, t1, t2, t3, t4, summary, data, _this = this, _null = null;
      H.interceptedTypeCheck(e, "$isEvent0");
      message = C.C_Utf8Codec.decode$1(0, C.C_Base64Decoder.convert$1(e.bytes));
      if (_this.buffer != null) {
        t1 = _this.timer;
        if (t1 != null)
          t1.cancel$0(0);
        if (message === "\n") {
          t1 = _this.buffer;
          t2 = t1.kind;
          t1 = J.$add$ansx(t1._details, message);
          t3 = _this.buffer;
          t4 = t3.timestamp;
          t3 = J.$add$ansx(t3.summary, message);
          _this.loggingScreen._logging$_log$1(Y.LogData$(t2, t1, t4, _null, _this.buffer.isError, _null, t3, _null));
          return _this.buffer = null;
        }
        _this.loggingScreen._logging$_log$1(_this.buffer);
        _this.buffer = null;
      }
      summary = message.length > 200 ? C.JSString_methods.substring$2(message, 0, 200) + "\u2026" : message;
      data = Y.LogData$(_this.name, message, e.timestamp, _null, _this.isError, _null, summary, _null);
      if (message === "\n")
        _this.loggingScreen._logging$_log$1(data);
      else {
        _this.buffer = data;
        _this.timer = P.Timer_Timer(C.Duration_1000, new Y._StdoutEventHandler_handle_closure(_this));
      }
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  Y._StdoutEventHandler_handle_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.loggingScreen._logging$_log$1(t1.buffer);
      t1.buffer = null;
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  Y.LogData.prototype = {
    compute$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, $async$temp1;
      var $async$compute$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 2;
              return P._asyncAwait($async$self.detailsComputer, $async$compute$0);
            case 2:
              // returning from await.
              $async$self._details = $async$temp1.stringTypeCheck($async$result);
              $async$self.set$detailsComputer(null);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$compute$0, $async$completer);
    },
    set$detailsComputer: function(detailsComputer) {
      this.detailsComputer = H.assertSubtype(detailsComputer, "$isFuture", [P.String], "$asFuture");
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  Y.LogKindColumn.prototype = {
    get$supportsSorting: function() {
      return false;
    },
    get$usesHtml: function() {
      return true;
    },
    get$cssClass: function() {
      return "log-label-column";
    },
    getValue$1: function(dataObject) {
      var t1, cssClass;
      H.interceptedTypeCheck(dataObject, "$isLogData");
      t1 = dataObject.kind;
      if (t1 === "stderr" || dataObject.isError)
        cssClass = "stderr";
      else if (t1 === "stdout")
        cssClass = "stdout";
      else if (t1 === "flutter.error")
        cssClass = "stderr";
      else if (C.JSString_methods.startsWith$1(t1, "flutter"))
        cssClass = "flutter";
      else
        cssClass = t1 === "gc" ? "gc" : "";
      return '<span class="label ' + cssClass + '">' + t1 + "</span>";
    },
    render$1: function(value) {
      return H.stringTypeCheck(value);
    },
    $asColumn: function() {
      return [Y.LogData];
    }
  };
  Y.LogWhenColumn.prototype = {
    get$cssClass: function() {
      return "pre monospace";
    },
    get$supportsSorting: function() {
      return false;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isLogData").timestamp;
    },
    render$1: function(value) {
      var t1, t2;
      if (value == null)
        t1 = "";
      else {
        t1 = $.$get$timeFormat();
        H.intTypeCheck(value);
        t2 = new P.DateTime(value, false);
        t2.DateTime$_withValue$2$isUtc(value, false);
        t2 = t1.format$1(t2);
        t1 = t2;
      }
      return t1;
    },
    $asColumn: function() {
      return [Y.LogData];
    }
  };
  Y.LogMessageColumn.prototype = {
    get$cssClass: function() {
      return "pre-wrap monospace";
    },
    get$usesHtml: function() {
      return true;
    },
    get$supportsSorting: function() {
      return false;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isLogData");
    },
    render$1: function(value) {
      var t1;
      H.interceptedTypeCheck(value, "$isLogData");
      t1 = value.summaryHtml;
      if (t1 != null)
        return t1;
      else {
        t1 = value.summary;
        if (t1 == null)
          t1 = value._details;
        return t1 == null ? "" : C.C_HtmlEscape.convert$1(t1);
      }
    },
    $asColumn: function() {
      return [Y.LogData];
    }
  };
  Y.LogDetailsUI.prototype = {
    setData$1: function(_, data) {
      var t2, root, _this = this, _null = null,
        t1 = _this.content.element;
      t1.toString;
      t1.scrollTop = 0;
      _this.data = data;
      _this.tree = null;
      if (data == null) {
        _this.message.element.textContent = "";
        return;
      }
      t1 = data.node;
      if (t1 != null) {
        J.get$children$x(_this.message.element).clear$0(0);
        t2 = K.InspectorTreeHtml$(_null, _null, _null, new Y.LogDetailsUI_setData_closure(_this), false, C.FlutterTreeType_0);
        _this.tree = t2;
        root = t2.setupInspectorTreeNode$4$expandChildren$expandProperties(new K.InspectorTreeNodeHtml(H.setRuntimeTypeInfo([], [K.InspectorTreeNode])), t1, true, true);
        root.allowExpandCollapse = false;
        _this.tree.set$root(0, root);
        _this.message.add$1(0, _this.tree._inspector_tree_html$_container);
        return;
      }
      if (data.detailsComputer != null) {
        _this.message.element.textContent = "";
        data.compute$0().then$1$1(new Y.LogDetailsUI_setData_closure0(_this, data), _null);
      } else
        _this._updateUIFromData$0();
    },
    _updateUIFromData$0: function() {
      var result, t2, exception, _this = this,
        t1 = _this.data._details;
      if (J.getInterceptor$s(t1).startsWith$1(t1, "{") && C.JSString_methods.endsWith$1(t1, "}"))
        try {
          result = C.C_JsonCodec.decode$2$reviver(0, t1, null);
          t1 = _this.message;
          t2 = P._JsonStringStringifier_stringify(result, null, "  ");
          t1.element.textContent = t2;
        } catch (exception) {
          H.unwrapException(exception);
          t1 = _this.message;
          t2 = _this.data._details;
          t1.element.textContent = t2;
        }
      else
        _this.message.element.textContent = t1;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  Y.LogDetailsUI_setData_closure.prototype = {
    call$0: function() {
      var t1 = this.$this.tree,
        node = t1._selection;
      if (node != null)
        t1.maybePopulateChildren$1(node);
      node._diagnostic.setSelectionInspector$1(false);
    },
    $signature: 0
  };
  Y.LogDetailsUI_setData_closure0.prototype = {
    call$1: function(_) {
      var t1 = this.$this;
      if (t1.data === this.data)
        t1._updateUIFromData$0();
    },
    $signature: 49
  };
  F.PerfToolFramework.prototype = {
    _gAReportExceptions$1: function(e) {
      H.interceptedTypeCast(e, "$isErrorEvent");
      F.error(H.S(e.message) + "\n" + H.S(e.filename) + "@" + H.S(e.lineno) + ":" + H.S(e.colno) + "\n" + H.S(e.error), true);
    },
    initGlobalUI$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, mainNav, t4, _i, $screen, link, t5, t6, t7, t8, t9, t1, t2, t3;
      var $async$initGlobalUI$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = document;
              t2 = J.get$onClick$x(t1.querySelector("#send-feedback-button"));
              t3 = H.getTypeArgumentByIndex(t2, 0);
              W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new F.PerfToolFramework_initGlobalUI_closure(), {func: 1, ret: -1, args: [t3]}), false, t3);
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").serviceAvailable.future, $async$initGlobalUI$0);
            case 2:
              // returning from await.
              $async$goto = 3;
              return P._asyncAwait($async$self.addScreens$0(), $async$initGlobalUI$0);
            case 3:
              // returning from await.
              $async$self.screensReady.complete$0(0);
              t1 = t1.querySelector("#main-nav");
              mainNav = new A.CoreElement(t1);
              J.get$children$x(t1).clear$0(0);
              for (t1 = $async$self.screens, t2 = t1.length, t3 = -1, t4 = [A.CoreElement], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                $screen = t1[_i];
                link = A.CoreElement$("a", null, null, null, null);
                link.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", null, "octicon " + H.S($screen.iconClass), null, null), A.CoreElement$("span", null, "optional-950", null, " " + $screen.name)], t4));
                if (H.boolConversionCheck($screen.disabled)) {
                  t5 = link.get$onClick(link);
                  t6 = H.getRuntimeTypeArgument(t5, "_ForwardingStream", 1);
                  t7 = H.functionTypeCheck(new F.PerfToolFramework_initGlobalUI_closure0($async$self, link), {func: 1, ret: -1, args: [t6]});
                  t8 = $.Zone__current;
                  t9 = new P._ForwardingStreamSubscription(t5, t8, 0, [H.getRuntimeTypeArgument(t5, "_ForwardingStream", 0), t6]);
                  H.functionTypeCheck(t7, {func: 1, ret: -1, args: [t6]});
                  t9.set$_onData(t8.registerUnaryCallback$2$1(t7, null, t6));
                  t9.onError$1(0, null);
                  t9.set$_onDone(t8.registerCallback$1$1(P.async___nullDoneHandler$closure(), t3));
                  t9.set$_subscription(t5._async$_source.listen$3$onDone$onError(t9.get$_handleData(), t9.get$_handleDone(), t9.get$_handleError()));
                  t5 = link.element;
                  J.get$classes$x(t5).toggle$2(0, "disabled", true);
                  t5.title = $screen.disabledTooltip;
                } else {
                  t5 = link.element;
                  t5.toString;
                  t6 = $screen.id;
                  t5.setAttribute("href", t6.length === 0 ? t6 : "#" + t6);
                  t5 = link.get$onClick(link);
                  t6 = H.getRuntimeTypeArgument(t5, "_ForwardingStream", 1);
                  t7 = H.functionTypeCheck(new F.PerfToolFramework_initGlobalUI_closure1($async$self, $screen), {func: 1, ret: -1, args: [t6]});
                  t8 = $.Zone__current;
                  t9 = new P._ForwardingStreamSubscription(t5, t8, 0, [H.getRuntimeTypeArgument(t5, "_ForwardingStream", 0), t6]);
                  H.functionTypeCheck(t7, {func: 1, ret: -1, args: [t6]});
                  t9.set$_onData(t8.registerUnaryCallback$2$1(t7, null, t6));
                  t9.onError$1(0, null);
                  t9.set$_onDone(t8.registerCallback$1$1(P.async___nullDoneHandler$closure(), t3));
                  t9.set$_subscription(t5._async$_source.listen$3$onDone$onError(t9.get$_handleData(), t9.get$_handleDone(), t9.get$_handleError()));
                }
                mainNav.add$1(0, link);
              }
              t1 = new N.StatusItem(A.CoreElement$("span", null, null, null, null));
              $async$self.isolateSelectStatus = t1;
              t2 = $async$self.globalStatus;
              C.JSArray_methods.add$1(t2._framework$_items, t1);
              t2._rebuild$0();
              t2 = new N.PSelect(H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("select", null), "$isElement"));
              t2.CoreElement$5$attributes$classes$html$text("select", null, "form-select", null, null);
              t2.clazz$1("select-sm");
              t2.change$1($async$self.get$_handleIsolateSelect());
              $async$self.isolateSelect = t2;
              $async$self.isolateSelectStatus.element.add$1(0, t2);
              $async$self._rebuildIsolateSelect$0();
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolateCreatedController;
              t1 = $async$self.get$_rebuildIsolateSelect();
              new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1);
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolateExitedController;
              new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1);
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolateController;
              new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1);
              $async$self._initHotReloadRestartServiceListeners$0();
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._stateController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new F.PerfToolFramework_initGlobalUI_closure2($async$self));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$initGlobalUI$0, $async$completer);
    },
    disableAppWithError$2: function(title, error) {
      var t1 = document,
        t2 = J.get$children$x(t1.getElementById("header"));
      t2.removeWhere$1(t2, new F.PerfToolFramework_disableAppWithError_closure());
      J.get$children$x(t1.getElementById("content")).clear$0(0);
      this.showError$2(title, error);
    },
    addScreens$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2, t3, t4, t5, t6, t7, t8, element, t9, element0, t10, t11, t12, t13, t14, t15, _isFlutterApp, _isFlutterWebApp, _isProfileBuild, _isAnyFlutterApp;
      var $async$addScreens$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isFlutterApp(), $async$addScreens$0);
            case 2:
              // returning from await.
              _isFlutterApp = $async$result;
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isFlutterWebApp(), $async$addScreens$0);
            case 3:
              // returning from await.
              _isFlutterWebApp = $async$result;
              $async$goto = 4;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isProfileBuild(), $async$addScreens$0);
            case 4:
              // returning from await.
              _isProfileBuild = $async$result;
              $async$goto = 5;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").connectedApp.get$isAnyFlutterApp(), $async$addScreens$0);
            case 5:
              // returning from await.
              _isAnyFlutterApp = $async$result;
              E.setupDimensions();
              H.boolConversionCheck(_isAnyFlutterApp);
              t1 = !_isAnyFlutterApp || H.boolConversionCheck(_isProfileBuild);
              t2 = !_isAnyFlutterApp ? "This screen is disabled because you are not running a Flutter application" : "This screen is disabled because you are running a profile build of your application";
              t3 = P.bool;
              t4 = [t3];
              t5 = [t3];
              t6 = [N.StatusItem];
              t7 = H.setRuntimeTypeInfo([], t6);
              t8 = A.CoreElement$("span", null, null, null, null);
              t8.add$1(0, A.CoreElement$("span", null, "optional-700", null, "Flutter Inspector"));
              t8.add$1(0, A.CoreElement$("span", null, null, null, " Docs"));
              element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0);
              t9 = element.style;
              t9.verticalAlign = "text-bottom";
              t9.marginBottom = "0";
              element0 = A.CoreElement$("a", null, null, null, null);
              t9 = [A.CoreElement];
              element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), t8], t9));
              t8 = element0.element;
              t8.setAttribute("href", "https://flutter.github.io/devtools/inspector");
              t8.setAttribute("target", "_blank");
              t8.title = "Documentation on using the Flutter Inspector page";
              t8 = A.CoreElement$("span", null, null, null, null);
              t8.add$1(0, element0);
              if (Y.hiddenPages().contains$1(0, "none"))
                t1 = false;
              t10 = $async$self.screens;
              C.JSArray_methods.add$1(t10, new D.InspectorScreen(new N.SetStateMixin(), "Flutter Inspector", "inspector", "octicon-device-mobile", new N.StatusItem(t8), t2, t1, null, new B.Property(new P._AsyncBroadcastStreamController(null, null, t4), false, t5), t7));
              t7 = !H.boolConversionCheck(_isFlutterApp);
              H.boolConversionCheck(_isFlutterWebApp);
              t1 = _isFlutterWebApp ? "This screen is disabled because it is not yet ready for Flutter Web" : "This screen is disabled because you are not running a Flutter application";
              t2 = [Q.TimelineFrame];
              t2 = new Y.TimelineController(new P._AsyncBroadcastStreamController(null, null, t2), new P._AsyncBroadcastStreamController(null, null, t2), new P._AsyncBroadcastStreamController(null, null, [Q.TimelineEvent0]), new P._AsyncBroadcastStreamController(null, null, [Q.OfflineTimelineData]), new N.CpuProfileProtocol());
              t8 = new N.TimelineService(t2);
              t8._initListeners$0();
              t2.timelineService = t8;
              t8 = H.setRuntimeTypeInfo([], t6);
              t11 = A.CoreElement$("span", null, null, null, null);
              t11.add$1(0, A.CoreElement$("span", null, "optional-700", null, "Timeline"));
              t11.add$1(0, A.CoreElement$("span", null, null, null, " Docs"));
              t11 = Y.createLinkStatusItem(t11, "https://flutter.github.io/devtools/timeline", "Documentation on using the Timeline page");
              if (Y.hiddenPages().contains$1(0, "none"))
                t7 = false;
              C.JSArray_methods.add$1(t10, new X.TimelineScreen(t2, "Timeline", "timeline", "octicon-pulse", t11, t1, t7, null, new B.Property(new P._AsyncBroadcastStreamController(null, null, t4), false, t5), t8));
              t1 = A.CoreElement$("div", null, "allocation-hover-card", null, null);
              t2 = [Q.Table, P.Object];
              t7 = new P.ListQueue([t2]);
              t8 = new Array(8);
              t8.fixed$length = Array;
              t7.set$_collection$_table(H.setRuntimeTypeInfo(t8, [t2]));
              t2 = H.setRuntimeTypeInfo([], [V.NavigationState]);
              t8 = P.String;
              t11 = H.setRuntimeTypeInfo([], [t8]);
              t12 = H.setRuntimeTypeInfo([], t6);
              t13 = A.CoreElement$("span", null, null, null, null);
              t13.add$1(0, A.CoreElement$("span", null, "optional-700", null, "Memory"));
              t13.add$1(0, A.CoreElement$("span", null, null, null, " Docs"));
              element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0);
              t14 = element.style;
              t14.verticalAlign = "text-bottom";
              t14.marginBottom = "0";
              element0 = A.CoreElement$("a", null, null, null, null);
              element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), t13], t9));
              t13 = element0.element;
              t13.setAttribute("href", "https://flutter.github.io/devtools/memory");
              t13.setAttribute("target", "_blank");
              t13.title = "Documentation on using the Memory page";
              t13 = A.CoreElement$("span", null, null, null, null);
              t13.add$1(0, element0);
              t14 = Y.hiddenPages().contains$1(0, "none") ? false : _isFlutterWebApp;
              t14 = new V.MemoryScreen(new T.MemoryController(new P._AsyncBroadcastStreamController(null, null, [T.MemoryTracker]), new P._AsyncBroadcastStreamController(null, null, [-1])), t1, t7, new V.NavigationPath(t2), t11, "Memory", "memory", "octicon-package", new N.StatusItem(t13), "This screen is disabled because it is not yet ready for Flutter Web", t14, null, new B.Property(new P._AsyncBroadcastStreamController(null, null, t4), false, t5), t12);
              t14.set$shortcutCallback(t14.get$memoryShortcuts());
              t13 = new N.StatusItem(A.CoreElement$("span", null, null, null, null));
              t14.classCountStatus = t13;
              C.JSArray_methods.add$1(t12, t13);
              t13 = new N.StatusItem(A.CoreElement$("span", null, null, null, null));
              t14.objectCountStatus = t13;
              C.JSArray_methods.add$1(t12, t13);
              C.JSArray_methods.add$1(t10, t14);
              t1 = _isFlutterWebApp || H.boolConversionCheck(_isProfileBuild) || Y.hiddenPages().contains$1(0, "debugger");
              t2 = new F.PerfToolFramework_addScreens_getDebuggerDisabledTooltip(_isFlutterWebApp, _isProfileBuild).call$0();
              t7 = U.BehaviorSubject_BehaviorSubject$seeded(false, t3);
              t3 = U.BehaviorSubject_BehaviorSubject$seeded(false, t3);
              t11 = U.BehaviorSubject_BehaviorSubject$seeded(H.setRuntimeTypeInfo([], [S.Breakpoint]), [P.List, S.Breakpoint]);
              t12 = U.BehaviorSubject_BehaviorSubject(t8);
              t13 = H.setRuntimeTypeInfo([], t6);
              t14 = A.CoreElement$("span", null, null, null, null);
              t14.add$1(0, A.CoreElement$("span", null, "optional-700", null, "Debugger"));
              t14.add$1(0, A.CoreElement$("span", null, null, null, " Docs"));
              element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0);
              t15 = element.style;
              t15.verticalAlign = "text-bottom";
              t15.marginBottom = "0";
              element0 = A.CoreElement$("a", null, null, null, null);
              element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), t14], t9));
              t14 = element0.element;
              t14.setAttribute("href", "https://flutter.github.io/devtools/debugger");
              t14.setAttribute("target", "_blank");
              t14.title = "Documentation on using the Debugger page";
              t14 = A.CoreElement$("span", null, null, null, null);
              t14.add$1(0, element0);
              if (Y.hiddenPages().contains$1(0, "none"))
                t1 = false;
              t1 = new X.DebuggerScreen(new S.DebuggerState(P.LinkedHashMap_LinkedHashMap$_empty(t8, S.Script), t7, t3, t11, t12), "Debugger", "debugger", "octicon-bug", new N.StatusItem(t14), t2, t1, null, new B.Property(new P._AsyncBroadcastStreamController(null, null, t4), false, t5), t13);
              t1.set$shortcutCallback(t1.get$debuggerShortcuts());
              t2 = new N.StatusItem(A.CoreElement$("span", null, null, null, null));
              t1.deviceStatus = t2;
              C.JSArray_methods.add$1(t13, t2);
              C.JSArray_methods.add$1(t10, t1);
              t1 = H.setRuntimeTypeInfo([], [Y.LogData]);
              t2 = H.setRuntimeTypeInfo([], t6);
              t3 = A.CoreElement$("span", null, null, null, null);
              t3.add$1(0, A.CoreElement$("span", null, "optional-700", null, "Logging"));
              t3.add$1(0, A.CoreElement$("span", null, null, null, " Docs"));
              element = Y.getIconRenderer(C.MaterialIcon_RgB).createElement$0(0);
              t6 = element.style;
              t6.verticalAlign = "text-bottom";
              t6.marginBottom = "0";
              element0 = A.CoreElement$("a", null, null, null, null);
              element0.add$1(0, H.setRuntimeTypeInfo([new A.CoreElement(element), t3], t9));
              t3 = element0.element;
              t3.setAttribute("href", "https://flutter.github.io/devtools/logging");
              t3.setAttribute("target", "_blank");
              t3.title = "Documentation on using the Logging page";
              t3 = A.CoreElement$("span", null, null, null, null);
              t3.add$1(0, element0);
              Y.hiddenPages().contains$1(0, "none");
              t1 = new Y.LoggingScreen(new N.SetStateMixin(), t1, "Logging", "logging", "octicon-clippy", new N.StatusItem(t3), "This screen is not available", false, null, new B.Property(new P._AsyncBroadcastStreamController(null, null, t4), false, t5), t2);
              t3 = A.CoreElement$("span", null, null, null, null);
              t4 = new N.StatusItem(t3);
              t1.logCountStatus = t4;
              t3.element.textContent = "";
              C.JSArray_methods.add$1(t2, t4);
              t4 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
              new P._BroadcastStream(t4, [H.getTypeArgumentByIndex(t4, 0)]).listen$1(t1.get$_handleConnectionStart());
              if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
                t1._handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
              new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1.get$_handleConnectionStop());
              C.JSArray_methods.add$1(t10, t1);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$addScreens$0, $async$completer);
    },
    _handleIsolateSelect$0: function() {
      H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager.selectIsolate$1(H.interceptedTypeCheck(this.isolateSelect.element, "$isSelectElement").value);
    },
    _rebuildIsolateSelect$1: function(_) {
      var t1, t2, t3, _i, ref, t4, $name, t5, e, _this = this;
      H.interceptedTypeCheck(_, "$isIsolateRef");
      J.get$children$x(_this.isolateSelect.element).clear$0(0);
      for (t1 = S.IsolateRef, t2 = P.List_List$unmodifiable(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolates, t1), t3 = t2.length, _i = 0; _i < t3; ++_i) {
        ref = t2[_i];
        t4 = _this.isolateSelect;
        $name = ref.name;
        $name.length;
        $name = H.stringReplaceFirstUnchecked($name, ".snapshot", "", 0);
        if (H.stringContainsUnchecked($name, ".dart$", 0))
          $name += "()";
        t5 = ref.id;
        t4.toString;
        e = A.CoreElement$("option", null, null, null, $name);
        if (t5 != null)
          H.interceptedTypeCheck(e.element, "$isOptionElement").value = t5;
        t4.add$1(0, e);
      }
      _this.isolateSelect.attribute$2("disabled", P.List_List$unmodifiable(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolates, t1).length === 0);
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate != null) {
        t2 = _this.isolateSelect;
        t1 = C.JSArray_methods.indexOf$1(P.List_List$unmodifiable(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._isolates, t1), H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate);
        H.interceptedTypeCheck(t2.element, "$isSelectElement").selectedIndex = t1;
      }
    },
    _rebuildIsolateSelect$0: function() {
      return this._rebuildIsolateSelect$1(null);
    },
    _initHotReloadRestartServiceListeners$0: function() {
      H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").hasRegisteredService$2("reloadSources", new F.PerfToolFramework__initHotReloadRestartServiceListeners_closure(this));
      H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").hasRegisteredService$2("hotRestart", new F.PerfToolFramework__initHotReloadRestartServiceListeners_closure0(this));
    },
    _buildReloadButton$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, reloadAction, t1;
      var $async$_buildReloadButton$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              reloadAction = N.ActionButton$("reload-action", C.UrlIcon_EOZ, "Hot Reload");
              t1 = H.functionTypeCheck(new F.PerfToolFramework__buildReloadButton_closure($async$self, reloadAction), {func: 1, ret: -1});
              reloadAction._custom$_element.click$1(0, t1);
              $async$self.globalActions.addAction$1(reloadAction);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_buildReloadButton$0, $async$completer);
    },
    _buildRestartButton$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, restartAction, t1;
      var $async$_buildRestartButton$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              restartAction = N.ActionButton$("restart-action", C.UrlIcon_ifH, "Hot Restart");
              t1 = H.functionTypeCheck(new F.PerfToolFramework__buildRestartButton_closure($async$self, restartAction), {func: 1, ret: -1});
              restartAction._custom$_element.click$1(0, t1);
              $async$self.globalActions.addAction$1(restartAction);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_buildRestartButton$0, $async$completer);
    }
  };
  F.PerfToolFramework_initGlobalUI_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isMouseEvent");
      F.select("main", "feedback", 0);
      C.Window_methods.open$2(window, "https://github.com/flutter/devtools/issues", "_feedback");
    },
    $signature: 3
  };
  F.PerfToolFramework_initGlobalUI_closure0.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isMouseEvent").preventDefault();
      this.$this.toast$1(this.link.element.title);
    },
    $signature: 3
  };
  F.PerfToolFramework_initGlobalUI_closure1.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isMouseEvent").preventDefault();
      this.$this.navigateTo$1(this.screen.id);
    },
    $signature: 3
  };
  F.PerfToolFramework_initGlobalUI_closure2.prototype = {
    call$1: function(_) {
      var t2, t3, _null = null,
        t1 = this.$this;
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null) {
        t2 = t1.connectionStatus;
        if (t2 != null) {
          t3 = t1.auxiliaryStatus;
          C.JSArray_methods.remove$1(t3._framework$_items, t2);
          t3._rebuild$0();
          t1.connectionStatus = null;
        }
      } else {
        if (t1.connectionStatus == null) {
          t2 = new N.StatusItem(A.CoreElement$("span", _null, _null, _null, _null));
          t1.connectionStatus = t2;
          t3 = t1.auxiliaryStatus;
          C.JSArray_methods.add$1(t3._framework$_items, t2);
          t3._rebuild$0();
        }
        t1.connectionStatus.element.element.textContent = "no device connected";
      }
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service == null)
        t1.toast$1("Device connection lost.");
    },
    $signature: 62
  };
  F.PerfToolFramework_disableAppWithError_closure.prototype = {
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isElement").id !== "title";
    },
    $signature: 42
  };
  F.PerfToolFramework_addScreens_getDebuggerDisabledTooltip.prototype = {
    call$0: function() {
      if (H.boolConversionCheck(this._isFlutterWebApp))
        return "This screen is disabled because it is not yet ready for Flutter Web";
      if (H.boolConversionCheck(this._isProfileBuild))
        return "This screen is disabled because you are running a profile build of your application";
      return "This screen is disabled because it provides functionality already available in your code editor";
    },
    $signature: 131
  };
  F.PerfToolFramework__initHotReloadRestartServiceListeners_closure.prototype = {
    call$1: function(reloadServiceAvailable) {
      var t1 = this.$this;
      if (H.boolConversionCheck(H.boolTypeCheck(reloadServiceAvailable)))
        t1._buildReloadButton$0();
      else
        t1.globalActions.removeAction$1("reload-action");
    },
    $signature: 9
  };
  F.PerfToolFramework__initHotReloadRestartServiceListeners_closure0.prototype = {
    call$1: function(reloadServiceAvailable) {
      var t1 = this.$this;
      if (H.boolConversionCheck(H.boolTypeCheck(reloadServiceAvailable)))
        t1._buildRestartButton$0();
      else
        t1.globalActions.removeAction$1("restart-action");
    },
    $signature: 9
  };
  F.PerfToolFramework__buildReloadButton_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, $status, timer, message, message0, t3, timer0, exception, t1, t2, $async$exception;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.reloadStatus;
              if (t2 != null) {
                t3 = t2.statusLine;
                t2 = t2.item;
                C.JSArray_methods.remove$1(t3._framework$_items, t2);
                t3._rebuild$0();
              }
              $status = F.Status$(t1.auxiliaryStatus, "reloading...");
              t1.reloadStatus = H.interceptedTypeCheck($status, "$isStatus");
              timer0 = new P.Stopwatch();
              if ($.Stopwatch__frequency == null) {
                H.Primitives_initTicker();
                $.Stopwatch__frequency = $.Primitives_timerFrequency;
              }
              timer0.start$0(0);
              timer = timer0;
              $async$handler = 3;
              $async$self.reloadAction._custom$_element.attribute$2("disabled", true);
              $async$goto = 6;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").performHotReload$0(), $async$call$0);
            case 6:
              // returning from await.
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("reload.start", null));
              J.stop$0$z(timer);
              message = "reloaded in " + F._renderDuration(P.Duration$(timer.get$elapsedMicroseconds(), 0, 0, 0));
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("reload.end", message));
              t1 = H.stringTypeCheck(message);
              $status.item.element.element.textContent = t1;
              F.select("main", "hotReload", C.JSInt_methods._tdivFast$1(P.Duration$(timer.get$elapsedMicroseconds(), 0, 0, 0)._duration, 1000));
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              H.unwrapException($async$exception);
              message0 = "error performing reload";
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("reload.end", message0));
              t1 = H.stringTypeCheck(message0);
              $status.item.element.element.textContent = t1;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              $async$self.reloadAction._custom$_element.attribute$2("disabled", false);
              P.Timer_Timer(C.Duration_3000000, $status.get$dispose());
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 17
  };
  F.PerfToolFramework__buildRestartButton_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, $status, timer, message, message0, t3, timer0, exception, t1, t2, $async$exception;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.reloadStatus;
              if (t2 != null) {
                t3 = t2.statusLine;
                t2 = t2.item;
                C.JSArray_methods.remove$1(t3._framework$_items, t2);
                t3._rebuild$0();
              }
              $status = F.Status$(t1.auxiliaryStatus, "restarting...");
              t1.reloadStatus = H.interceptedTypeCheck($status, "$isStatus");
              timer0 = new P.Stopwatch();
              if ($.Stopwatch__frequency == null) {
                H.Primitives_initTicker();
                $.Stopwatch__frequency = $.Primitives_timerFrequency;
              }
              timer0.start$0(0);
              timer = timer0;
              $async$handler = 3;
              $async$self.restartAction._custom$_element.attribute$2("disabled", true);
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("restart.start", null));
              $async$goto = 6;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").performHotRestart$0(), $async$call$0);
            case 6:
              // returning from await.
              J.stop$0$z(timer);
              message = "restarted in " + F._renderDuration(P.Duration$(timer.get$elapsedMicroseconds(), 0, 0, 0));
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("restart.end", message));
              t1 = H.stringTypeCheck(message);
              $status.item.element.element.textContent = t1;
              F.select("main", "hotRestart", C.JSInt_methods._tdivFast$1(P.Duration$(timer.get$elapsedMicroseconds(), 0, 0, 0)._duration, 1000));
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              H.unwrapException($async$exception);
              message0 = "error performing restart";
              H.interceptedTypeCheck($.globals.$index(0, C.Type_MessageBus_MAi), "$isMessageBus")._controller.add$1(0, new A.BusEvent("restart.end", message0));
              t1 = H.stringTypeCheck(message0);
              $status.item.element.element.textContent = t1;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              $async$self.restartAction._custom$_element.attribute$2("disabled", false);
              P.Timer_Timer(C.Duration_3000000, $status.get$dispose());
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 17
  };
  F.NotFoundScreen.prototype = {
    createContent$1: function(framework) {
      return A.CoreElement$("p", null, null, null, "Page not found: " + H.S(window.location.pathname));
    }
  };
  F.Status.prototype = {
    dispose$0: function() {
      var t1 = this.statusLine,
        t2 = this.item;
      C.JSArray_methods.remove$1(t1._framework$_items, t2);
      t1._rebuild$0();
    }
  };
  V.MemoryScreen.prototype = {
    memoryShortcuts$4: function(ctrlKey, shiftKey, altKey, key) {
      if (H.boolConversionCheck(ctrlKey) && key === "f") {
        this._search$0();
        return true;
      }
      return false;
    },
    entering$0: function() {
      this._updateListeningState$0();
    },
    createContent$1: function(framework) {
      var screenDiv, t1, t2, t3, t4, t5, t6, t7, t8, _this = this, _null = null, _s3_ = "div", _s6_ = "layout", _s6_0 = "btn-sm",
        _s8_ = "disabled",
        _s10_ = "horizontal";
      E.setupDimensions();
      screenDiv = A.CoreElement$(_s3_, _null, "custom-scrollbar", _null, _null);
      t1 = screenDiv.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute("vertical", "");
      t1 = N.PButton$icon("Resume", C.UrlIcon_JmU, _null);
      t1.clazz$1("btn-primary");
      t1.clazz$1(_s6_0);
      t1.attribute$2(_s8_, true);
      _this.resumeButton = t1;
      t1 = N.PButton$icon("Pause", C.UrlIcon_lyL, _null);
      t1.clazz$1(_s6_0);
      _this.pauseButton = t1;
      _this.set$heapPopupList(E.PopupListView$(P.String));
      t1 = A.CoreElement$("input", _null, "search-text", _null, _null);
      t2 = t1.element;
      t2.setAttribute("type", "text");
      t2.setAttribute("placeholder", "search");
      t2.setAttribute("id", "popup_search_memory");
      _this.vmSearchField = t1;
      t1 = N.PButton$icon("", C.UrlIcon_QOR, "Memory Search");
      t1.clazz$1(_s6_0);
      t1.click$1(0, _this.get$_search());
      t1.attribute$2(_s8_, true);
      _this.vmMemorySearchButton = t1;
      t1 = N.PButton$icon("Snapshot", C.UrlIcon_gTM, "Memory Snapshot");
      t1.clazz$1("margin-left");
      t1.clazz$1(_s6_0);
      t1.click$1(0, _this.get$_loadAllocationProfile());
      t1.attribute$2(_s8_, true);
      _this.vmMemorySnapshotButton = t1;
      t1 = N.PButton$icon("Reset", C.UrlIcon_omH, "Reset Accumulators");
      t1.clazz$1(_s6_0);
      t1.click$1(0, _this.get$_resetAllocatorCounts());
      t1.attribute$2(_s8_, true);
      _this.resetAccumulatorsButton = t1;
      t1 = N.PButton$icon("Filter", C.UrlIcon_k6U, "Filter");
      t1.clazz$1(_s6_0);
      t1.attribute$2(_s8_, true);
      _this.filterLibrariesButton = t1;
      t1 = new E.PopupAutoCompleteView(_this.heapPopupList, screenDiv, _this.vmSearchField, _this.get$_callbackPopupSelectClass(), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      t1.CoreElement$5$attributes$classes$html$text(_s3_, _null, "popup-view", _null, _null);
      t1._popup$_initialize$0();
      _this.heapAutoCompletePopup = t1;
      t1 = N.PButton$icon("GC", C.UrlIcon_m7u, "Manual Garbage Collect");
      t1.clazz$1(_s6_0);
      t1.click$1(0, _this.get$_gcNow());
      t1.attribute$2(_s8_, true);
      _this.gcNowButton = t1;
      _this.resumeButton.click$1(0, new V.MemoryScreen_createContent_closure(_this));
      _this.pauseButton.click$1(0, new V.MemoryScreen_createContent_closure0(_this));
      t1 = _this.hoverPopup;
      t1.get$onMouseOver(t1).listen$1(new V.MemoryScreen_createContent_closure1(_this));
      t1.get$onMouseLeave(t1).listen$1(new V.MemoryScreen_createContent_closure2(_this));
      _this.history = A.CoreElement$(_s3_, _null, "history-navigation hidden", _null, _null);
      t2 = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t3 = A.CoreElement$("form", _null, _null, _null, _null);
      t4 = t3.element;
      t4.setAttribute(_s6_, "");
      t4.setAttribute(_s10_, "");
      t3.clazz$1("align-items-center");
      t4 = A.CoreElement$(_s3_, _null, "btn-group flex-no-wrap", _null, _null);
      t5 = [A.CoreElement];
      t4.add$1(0, H.setRuntimeTypeInfo([_this.pauseButton, _this.resumeButton], t5));
      t6 = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t6.flex$0(0);
      t7 = A.CoreElement$(_s3_, _null, "btn-group collapsible-700 flex-no-wrap margin-left", _null, _null);
      t7.add$1(0, H.setRuntimeTypeInfo([_this.vmSearchField, _this.vmMemorySearchButton, _this.vmMemorySnapshotButton, _this.resetAccumulatorsButton, _this.filterLibrariesButton, _this.gcNowButton], t5));
      t3.add$1(0, H.setRuntimeTypeInfo([t4, t6, t7], t5));
      t2.add$1(0, H.setRuntimeTypeInfo([t3], t5));
      t3 = _this.heapAutoCompletePopup;
      t7 = _this.memoryController;
      t6 = A.MemoryChart$(t7);
      t6.attribute$2(_s8_, true);
      _this.memoryChart = t6;
      t4 = A.CoreElement$(_s3_, _null, "section overflow-auto", _null, _null);
      t8 = t4.element;
      t8.setAttribute(_s6_, "");
      t8.setAttribute(_s10_, "");
      t4.flex$0(0);
      _this.tableContainer = t4;
      screenDiv.add$1(0, H.setRuntimeTypeInfo([t2, t3, t1, t6, t4, _this.history], t5));
      t7 = t7._disconnectController;
      new P._BroadcastStream(t7, [H.getTypeArgumentByIndex(t7, 0)]).listen$1(new V.MemoryScreen_createContent_closure3(_this));
      Y.maybeAddDebugMessage(framework, "memory");
      _this._pushNextTable$2(_null, _this._createHeapStatsTableView$0());
      _this._memory$_updateStatus$1(_null);
      return screenDiv;
    },
    _selectClass$2: function(className, record) {
      var t2, row, _i, t3,
        t1 = this.tableStack,
        classesData = H.assertSubtype(t1.get$first(t1).data, "$isList", [T.ClassHeapDetailStats], "$asList");
      for (t2 = classesData.length, row = 0, _i = 0; _i < t2; ++_i) {
        if (classesData[_i].classRef.name == className) {
          t2 = t1._head;
          if (t2 === t1._tail)
            H.throwExpression(H.IterableElementError_noElement());
          t3 = t1._collection$_table;
          if (t2 >= t3.length)
            return H.ioore(t3, t2);
          t3[t2].selectByIndex$2$scrollBehavior(row, "auto");
          if (record)
            this.memoryPath.add$1(0, new V.NavigationState(className, null));
          return;
        }
        ++row;
      }
      this.framework.toast$2$title("Unable to find class " + H.S(className), "Error");
    },
    _selectClass$1: function(className) {
      return this._selectClass$2(className, true);
    },
    _selectInstanceInFieldHashCode$2: function(fieldName, instanceHashCode) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.int),
        $async$returnValue, $async$self = this, instances, t1, t2, row, _i, instanceTable, spinner, $async$temp1;
      var $async$_selectInstanceInFieldHashCode$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              instanceTable = $async$self.tableStack.elementAt$1(0, 1);
              spinner = N.Spinner$_(H.setRuntimeTypeInfo(["centered"], [P.String]));
              instanceTable.element.add$1(0, spinner);
              instances = H.assertSubtype(instanceTable.data, "$isList", [T.InstanceSummary], "$asList");
              t1 = instances.length, t2 = $async$self.memoryController, row = 0, _i = 0;
            case 3:
              // for condition
              if (!(_i < instances.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait(t2.matchObject$3(instances[_i]._objectRef, fieldName, instanceHashCode), $async$_selectInstanceInFieldHashCode$2);
            case 6:
              // returning from await.
              if ($async$temp1.boolConversionCheck($async$result)) {
                instanceTable.selectByIndex$2$scrollBehavior(row, "auto");
                t1 = spinner.element;
                t2 = t1.parentNode;
                if (t2 != null)
                  t2.removeChild(t1);
                $async$returnValue = row;
                // goto return
                $async$goto = 1;
                break;
              }
              ++row;
            case 4:
              // for update
              instances.length === t1 || (0, H.throwConcurrentModificationError)(instances), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              J.remove$0$ax(spinner.element);
              $async$self.framework.toast$2$title("Unable to find instance for field " + fieldName + " [" + H.Primitives_objectHashCode($async$self) + "]", "Error");
              $async$returnValue = -1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_selectInstanceInFieldHashCode$2, $async$completer);
    },
    _resetHistory$0: function() {
      var t1 = this.history;
      t1.clazz$2$removeOthers("history-navigation", true);
      t1.clazz$1("hidden");
      J.get$children$x(this.history.element).clear$0(0);
      this.memoryPath = new V.NavigationPath(H.setRuntimeTypeInfo([], [V.NavigationState]));
    },
    _callbackPopupSelectClass$1: function(cancel) {
      var selectedClass, t1, t2, inputElement, _this = this;
      if (cancel) {
        _this.heapAutoCompletePopup._popup$_matcher.reset$0(0);
        _this.heapPopupList.set$highlightedItem(null);
      } else {
        _this._resetHistory$0();
        selectedClass = _this.heapPopupList.highlightedItem;
        if (selectedClass != null)
          _this._selectClass$1(selectedClass);
      }
      t1 = _this.heapAutoCompletePopup;
      t2 = t1.element.style;
      t2.display = "none";
      inputElement = H.interceptedTypeCheck(t1._popup$_popupTextfield.element, "$isInputElement");
      inputElement.value = "";
      t1 = inputElement.style;
      t1.visibility = "hidden";
    },
    _callbackPopupSelectClass$0: function() {
      return this._callbackPopupSelectClass$1(null);
    },
    _selectInstanceByHashCode$1: function(instanceHashCode) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, row, _i, $eval, t1, instanceTable, instances;
      var $async$_selectInstanceByHashCode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.tableStack;
              instanceTable = t1.get$last(t1);
              instances = H.assertSubtype(instanceTable.data, "$isList", [T.InstanceSummary], "$asList");
              t1 = instances.length, row = 0, _i = 0;
            case 3:
              // for condition
              if (!(_i < instances.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$goto = 6;
              return P._asyncAwait(O.evaluate(instances[_i]._objectRef, "hashCode"), $async$_selectInstanceByHashCode$1);
            case 6:
              // returning from await.
              $eval = $async$result;
              if (P.int_parse($eval == null ? null : $eval.valueAsString, null, null) == instanceHashCode) {
                instanceTable.selectByIndex$2$scrollBehavior(row, "auto");
                // goto return
                $async$goto = 1;
                break;
              }
              ++row;
            case 4:
              // for update
              instances.length === t1 || (0, H.throwConcurrentModificationError)(instances), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$self.framework.toast$2$title("Unable to find instance [" + H.S(instanceHashCode) + "]", "Error");
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_selectInstanceByHashCode$1, $async$completer);
    },
    get$_isClassSelectedAndInstancesReady: function() {
      var t1 = this.tableStack;
      return t1.get$first(t1)._selectedObject != null && t1.get$length(t1) === 2 && t1.get$last(t1).data.length !== 0;
    },
    selectClassInstance$2: function(className, instanceHashCode) {
      var _this = this,
        t1 = _this.tableStack;
      t1.get$first(t1)._select$3(null, null, null);
      P.Timer_Timer$periodic(C.Duration_100000, new V.MemoryScreen_selectClassInstance_closure(_this));
      _this._selectClass$2(className, false);
      P.Timer_Timer$periodic(C.Duration_100000, new V.MemoryScreen_selectClassInstance_closure0(_this, instanceHashCode));
    },
    selectClassAndInstanceInField$3: function(className, field, instanceHashCode) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t1;
      var $async$selectClassAndInstanceInField$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.fromMemoryHover = true;
              t1 = $async$self.tableStack;
              t1.get$first(t1)._select$3(null, null, null);
              P.Timer_Timer$periodic(C.Duration_100000, new V.MemoryScreen_selectClassAndInstanceInField_closure($async$self));
              $async$self._selectClass$2(className, false);
              P.Timer_Timer$periodic(C.Duration_100000, new V.MemoryScreen_selectClassAndInstanceInField_closure0($async$self, field, instanceHashCode));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$selectClassAndInstanceInField$3, $async$completer);
    },
    _pushNextTable$2: function(current, next) {
      var t2, t3, t4, result, t5, t6, newTable, split,
        t1 = this.tableStack;
      while (true) {
        if (!((t1._tail - t1._head & t1._collection$_table.length - 1) >>> 0 > 1 && !J.$eq$(t1.get$last(t1), current)))
          break;
        t2 = t1._head;
        t3 = t1._tail;
        if (t2 === t3)
          H.throwExpression(H.IterableElementError_noElement());
        ++t1._modificationCount;
        t2 = t1._collection$_table;
        t4 = t2.length;
        t3 = t1._tail = (t3 - 1 & t4 - 1) >>> 0;
        if (t3 < 0 || t3 >= t4)
          return H.ioore(t2, t3);
        result = t2[t3];
        C.JSArray_methods.$indexSet(t2, t3, null);
        t3 = result.element.element;
        t2 = t3.parentNode;
        if (t2 != null)
          t2.removeChild(t3);
      }
      if (next != null) {
        t2 = t1._head;
        t3 = t1._tail;
        t4 = H.getTypeArgumentByIndex(t1, 0);
        H.assertSubtypeOfRuntimeType(next, t4);
        C.JSArray_methods.$indexSet(t1._collection$_table, t3, next);
        t5 = t1._tail;
        t6 = t1._collection$_table.length;
        t5 = (t5 + 1 & t6 - 1) >>> 0;
        t1._tail = t5;
        if (t1._head === t5) {
          t5 = new Array(t6 * 2);
          t5.fixed$length = Array;
          newTable = H.setRuntimeTypeInfo(t5, [t4]);
          t4 = t1._collection$_table;
          t5 = t1._head;
          split = t4.length - t5;
          C.JSArray_methods.setRange$4(newTable, 0, split, t4, t5);
          C.JSArray_methods.setRange$4(newTable, split, split + t1._head, t1._collection$_table, 0);
          t1._head = 0;
          t1._tail = t1._collection$_table.length;
          t1.set$_collection$_table(newTable);
        }
        ++t1._modificationCount;
        t1 = this.tableContainer;
        t4 = next.element;
        t1.add$1(0, t4);
        if (t2 !== t3)
          t4.clazz$1("margin-left");
        t1 = this.tableContainer.element;
        J.scrollTo$1$x(t1, P.LinkedHashMap_LinkedHashMap$_literal(["left", C.JSNumber_methods.round$0(t1.scrollWidth), "top", 0, "behavior", "smooth"], P.String, null));
      }
    },
    _resetAllocatorCounts$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, spinner, heapStats, e, t1, t2, t3, t4, capacityTrace, timestamp, exception, $async$exception;
      var $async$_resetAllocatorCounts$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "reset", 0);
              t1 = $async$self.memoryChart;
              t2 = t1.element;
              t3 = t2.style;
              t4 = t3.height;
              t1.toString;
              if (t4 !== "230px") {
                t3.height = "230px";
                t2.dispatchEvent(W.Event_Event$eventType("Event", "resize", true, true));
              }
              t1 = t1._plotlyChart;
              if (t1.eventTimeline == null)
                t1.createEventTimeline$0();
              capacityTrace = H.interceptedTypeCheck(J.$index$asx(H.listTypeCheck(t1._memoryChart.element.data), 3), "$isData");
              t2 = J.getInterceptor$x(capacityTrace);
              t3 = t2.get$x(capacityTrace);
              t2 = J.get$length$asx(t2.get$x(capacityTrace));
              if (typeof t2 !== "number") {
                $async$returnValue = t2.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              timestamp = H.intTypeCheck(J.$index$asx(t3, t2 - 1));
              t1 = t1.eventTimeline;
              t2 = t1._domName;
              t3 = t1.resetTraceIndex;
              self.extendTraces1(t2, [timestamp], [1], [t3]);
              t1.displayDuration$2(timestamp, "r");
              $async$self.resetAccumulatorsButton.attribute$2("disabled", true);
              t1 = $async$self.tableStack;
              t3 = t1.get$first(t1).element.element.style;
              t3.display = "";
              spinner = H.interceptedTypeCheck(t1.get$first(t1).element.add$1(0, N.Spinner$_(H.setRuntimeTypeInfo(["centered"], [P.String]))), "$isSpinner");
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self.memoryController.getAllocationProfile$1$reset(true), $async$_resetAllocatorCounts$0);
            case 7:
              // returning from await.
              heapStats = $async$result;
              t1.get$first(t1).setRows$1(heapStats);
              $async$self._memory$_updateStatus$1(heapStats);
              J.remove$0$ax(spinner.element);
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              $async$self.framework.toast$2$title("Reset failed " + H.S(J.toString$0$(e)), "Error");
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              $async$self.resetAccumulatorsButton.attribute$2("disabled", false);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_resetAllocatorCounts$0, $async$completer);
    },
    getKnownSnapshotClasses$0: function() {
      var t2, classesData, _i,
        t1 = this._knownSnapshotClasses;
      if (t1.length === 0) {
        t2 = this.tableStack;
        classesData = H.assertSubtype(t2.get$first(t2).data, "$isList", [T.ClassHeapDetailStats], "$asList");
        for (t2 = classesData.length, _i = 0; _i < classesData.length; classesData.length === t2 || (0, H.throwConcurrentModificationError)(classesData), ++_i)
          C.JSArray_methods.add$1(t1, classesData[_i].classRef.name);
      }
      return t1;
    },
    _search$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2, r, nameHeight, leftPosition, t3;
      var $async$_search$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "search", 0);
              if (J.get$isEmpty$asx($async$self.heapPopupList.items.items))
                $async$self.heapPopupList.setList$1($async$self.getKnownSnapshotClasses$0());
              t1 = $async$self.vmSearchField.element;
              t2 = t1.style;
              if (t2.visibility !== "visible") {
                t2.visibility = "visible";
                J.focus$0$x(t1);
                t1 = $async$self.heapAutoCompletePopup;
                t1.add$1(0, t1._listView);
                t1._popup$_matcher.selectFirstItem$0();
                r = t1._containerElement.element.getBoundingClientRect();
                t2 = t1._popup$_popupTextfield.element;
                nameHeight = C.JSNumber_methods.round$0(t2.getBoundingClientRect().height);
                leftPosition = C.JSNumber_methods.round$0(t2.getBoundingClientRect().left);
                t2 = t1.element.style;
                t3 = H.S(r.top + nameHeight) + "px";
                t2.top = t3;
                t3 = "" + leftPosition + "px";
                t2.left = t3;
                t2.display = "inline";
                t1._popup$_matcher.displayMatchingItems$1("");
              } else
                $async$self.heapAutoCompletePopup._popup$_matcher.finish$1(0, false);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_search$0, $async$completer);
    },
    _loadAllocationProfile$1$reset: function(reset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, spinner, heapStats, e, t1, t2, t3, t4, capacityTrace, timestamp, exception, $async$exception;
      var $async$_loadAllocationProfile$1$reset = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "snapshot", 0);
              t1 = $async$self.memoryChart;
              t2 = t1.element;
              t3 = t2.style;
              t4 = t3.height;
              t1.toString;
              if (t4 !== "230px") {
                t3.height = "230px";
                t2.dispatchEvent(W.Event_Event$eventType("Event", "resize", true, true));
              }
              t1 = t1._plotlyChart;
              if (t1.eventTimeline == null)
                t1.createEventTimeline$0();
              capacityTrace = H.interceptedTypeCheck(J.$index$asx(H.listTypeCheck(t1._memoryChart.element.data), 3), "$isData");
              t2 = J.getInterceptor$x(capacityTrace);
              t3 = t2.get$x(capacityTrace);
              t2 = J.get$length$asx(t2.get$x(capacityTrace));
              if (typeof t2 !== "number") {
                $async$returnValue = t2.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              timestamp = H.intTypeCheck(J.$index$asx(t3, t2 - 1));
              t1 = t1.eventTimeline;
              t2 = t1._domName;
              t3 = t1.snapshotTraceIndex;
              self.extendTraces1(t2, [timestamp], [1], [t3]);
              t1.displayDuration$2(timestamp, "s");
              t1 = [P.String];
              $async$self.heapPopupList.setList$1(H.setRuntimeTypeInfo([], t1));
              $async$self.vmMemorySnapshotButton.attribute$2("disabled", true);
              t3 = $async$self.tableStack;
              t2 = t3.get$first(t3).element.element.style;
              t2.display = "";
              spinner = H.interceptedTypeCheck(t3.get$first(t3).element.add$1(0, N.Spinner$_(H.setRuntimeTypeInfo(["centered"], t1))), "$isSpinner");
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self.memoryController.getAllocationProfile$0(), $async$_loadAllocationProfile$1$reset);
            case 7:
              // returning from await.
              heapStats = $async$result;
              C.JSArray_methods.set$length($async$self._knownSnapshotClasses, 0);
              t3.get$first(t3).setRows$1(heapStats);
              $async$self._memory$_updateStatus$1(heapStats);
              J.remove$0$ax(spinner.element);
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              $async$self.framework.toast$2$title("Snapshot failed " + H.S(J.toString$0$(e)), "Error");
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              $async$self.vmMemorySnapshotButton.attribute$2("disabled", false);
              $async$self.vmMemorySearchButton.attribute$2("disabled", false);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_loadAllocationProfile$1$reset, $async$completer);
    },
    _loadAllocationProfile$0: function() {
      return this._loadAllocationProfile$1$reset(false);
    },
    _gcNow$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, e, exception, $async$exception;
      var $async$_gcNow$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "gc", 0);
              $async$self.gcNowButton.attribute$2("disabled", true);
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait($async$self.memoryController.gc$0(), $async$_gcNow$0);
            case 6:
              // returning from await.
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              $async$self.framework.toast$2$title("Unable to GC " + H.S(J.toString$0$(e)), "Error");
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              $async$self.gcNowButton.attribute$2("disabled", false);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_gcNow$0, $async$completer);
    },
    _updateListeningState$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this;
      var $async$_updateListeningState$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").serviceAvailable.future, $async$_updateListeningState$0);
            case 2:
              // returning from await.
              $async$goto = $async$self.get$isCurrentScreen() && $async$self.memoryController._memoryTracker == null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.memoryController.startTimeline$0(), $async$_updateListeningState$0);
            case 5:
              // returning from await.
              $async$self.pauseButton.attribute$2("disabled", false);
              $async$self.resumeButton.attribute$2("disabled", true);
              $async$self.vmMemorySnapshotButton.attribute$2("disabled", false);
              $async$self.resetAccumulatorsButton.attribute$2("disabled", false);
              $async$self.gcNowButton.attribute$2("disabled", false);
              $async$self.memoryChart.attribute$2("disabled", false);
            case 4:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_updateListeningState$0, $async$completer);
    },
    _removeInstanceView$0: function() {
      var t1 = J.get$children$x(this.tableContainer.element);
      if (t1.get$length(t1) === 3)
        J.get$children$x(this.tableContainer.element).removeLast$0(0);
    },
    _createHeapStatsTableView$0: function() {
      var t4, _null = null,
        _s11_ = "Accumulator",
        t1 = T.ClassHeapDetailStats,
        table = Q.Table$virtual(false, 29, t1),
        t2 = table.element,
        t3 = t2.element.style;
      t3.display = "none";
      t2.clazz$1("memory-table");
      t2 = new Z.MemoryColumnSize("Size", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t2.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Size", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      t3 = [H.getTypeArgumentByIndex(table, 0)];
      t4 = table.columns;
      C.JSArray_methods.add$1(t4, H.assertSubtype(t2, "$isColumn", t3, "$asColumn"));
      t2 = new Z.MemoryColumnInstanceCount("Count", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t2.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Count", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      C.JSArray_methods.add$1(t4, H.assertSubtype(t2, "$isColumn", t3, "$asColumn"));
      t2 = new Z.MemoryColumnInstanceAccumulatedCount(_s11_, _null, _null, C.ColumnAlignment_0, false, _null, false);
      t2.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml(_s11_, C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      C.JSArray_methods.add$1(t4, H.assertSubtype(t2, "$isColumn", t3, "$asColumn"));
      C.JSArray_methods.add$1(t4, H.assertSubtype(new Z.MemoryColumnClassName("Class", _null, 100, C.ColumnAlignment_0, false, _null, false), "$isColumn", t3, "$asColumn"));
      table.set$sortColumn(C.JSArray_methods.get$first(t4));
      t4 = table._selectController;
      new P._BroadcastStream(t4, [H.getTypeArgumentByIndex(t4, 0)]).listen$1(new V.MemoryScreen__createHeapStatsTableView_closure(this, table));
      return table;
    },
    _createInstanceListTableView$1: function(row) {
      return this._createInstanceListTableView$body$MemoryScreen(row);
    },
    _createInstanceListTableView$body$MemoryScreen: function(row) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([Q.Table, T.InstanceSummary]),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, table, instanceRows, e, t2, t3, exception, t1, table0, $async$exception;
      var $async$_createInstanceListTableView$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = T.InstanceSummary;
              table0 = Q.Table$virtual(false, 29, t1);
              table0.element.clazz$1("memory-table");
              table = table0;
              $async$handler = 4;
              t2 = row.classRef;
              $async$goto = 7;
              return P._asyncAwait($async$self.memoryController.getInstances$3(t2.id, t2.name, row.instancesCurrent), $async$_createInstanceListTableView$1);
            case 7:
              // returning from await.
              instanceRows = $async$result;
              t2 = table;
              t3 = H.assertSubtype(Z.MemoryColumnSimple$(H.S(J.get$length$asx(instanceRows)) + " Instances of " + H.S(row.classRef.name), new V.MemoryScreen__createInstanceListTableView_closure(), null, false, false, t1), "$isColumn", [H.getTypeArgumentByIndex(t2, 0)], "$asColumn");
              C.JSArray_methods.add$1(t2.columns, t3);
              t3 = table;
              t1 = H.assertSubtype(Z.MemoryColumnSimple$("", new V.MemoryScreen__createInstanceListTableView_closure0(), "allocation", true, true, t1), "$isColumn", [H.getTypeArgumentByIndex(t3, 0)], "$asColumn");
              C.JSArray_methods.add$1(t3.columns, t1);
              table.setRows$1(instanceRows);
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              $async$self.framework.toast$2$title("Problem fetching instances of " + H.S(row.classRef.name) + ": " + H.S(e), "Error");
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
              t1 = table._selectElementController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self.get$hoverInstanceAllocations());
              t1 = table._selectController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self.get$select($async$self));
              $async$returnValue = table;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_createInstanceListTableView$1, $async$completer);
    },
    select$1: function(_, row) {
      H.interceptedTypeCheck(row, "$isInstanceSummary");
      return this.select$body$MemoryScreen(_, row);
    },
    select$body$MemoryScreen: function(_, row) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, instance, theObject, e, $eval, evalResult, exception, t1, t2, $async$exception;
      var $async$select$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "inspectInstance", 0);
              $async$self._removeInstanceView$0();
              instance = null;
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait($async$self.memoryController.getObject$1(0, row._objectRef), $async$select$1);
            case 6:
              // returning from await.
              theObject = $async$result;
              if (theObject instanceof S.Instance)
                instance = theObject;
              else if (theObject instanceof S.Sentinel) {
                instance = null;
                $async$self.framework.toast$2$title("Sentinel " + H.S(row._objectRef), "Warning");
              }
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              F.error("Memory select: " + H.S(e), false);
              instance = null;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 4:
              // finally
              $async$handler = 1;
              t1 = $async$self.tableContainer;
              t2 = instance != null ? row._objectRef : "Unable to fetch instance " + H.S(row._objectRef);
              t1.add$1(0, $async$self._createInstanceView$2(t2, row._memory_protocol$_className));
              t2 = $async$self.tableContainer.element;
              J.scrollTo$1$x(t2, P.LinkedHashMap_LinkedHashMap$_literal(["left", C.JSNumber_methods.round$0(t2.scrollWidth), "top", 0, "behavior", "smooth"], P.String, null));
              t2 = $async$self.memoryDataView;
              t1 = instance != null ? instance.fields : H.setRuntimeTypeInfo([], [S.BoundField]);
              t2.toString;
              H.assertSubtype(t1, "$isList", [S.BoundField], "$asList");
              t2._memory_data_view$_items.setItems$1(t1);
              $async$goto = 7;
              return P._asyncAwait(O.evaluate(row._objectRef, "hashCode"), $async$select$1);
            case 7:
              // returning from await.
              $eval = $async$result;
              t1 = $eval;
              evalResult = P.int_parse(t1 == null ? null : t1.valueAsString, null, null);
              if (!$async$self.fromMemoryHover) {
                t1 = $async$self.memoryPath._path;
                if (!(t1.length !== 0 && C.JSArray_methods.get$last(t1).get$isInbound())) {
                  t1 = $async$self.memoryPath._path;
                  t1 = t1.length !== 0 && C.JSArray_methods.get$last(t1).get$isInstance();
                } else
                  t1 = true;
              } else
                t1 = false;
              if (t1)
                $async$self._resetHistory$0();
              $async$self.memoryPath.add$1(0, new V.NavigationState(row._memory_protocol$_className, evalResult));
              t1 = $async$self.memoryPath._path;
              if (t1.length !== 0 && C.JSArray_methods.get$last(t1).get$isInbound()) {
                J.get$children$x($async$self.history.element).clear$0(0);
                $async$self.memoryPath.displayPathsAsLinks$2($async$self.history, $async$self.get$_handleHistoryClicks());
                $async$self.history.clazz$2$removeOthers("history-navigation", true);
              }
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$select$1, $async$completer);
    },
    _handleHistoryClicks$1: function(element) {
      var dataIndex, state, _this = this, _null = null,
        t1 = element.element;
      if (J.get$classes$x(t1).contains$1(0, "history-link")) {
        dataIndex = P.int_parse(t1.getAttribute("data-index"), _null, _null);
        t1.getAttribute("data-class");
        t1.getAttribute("data-field");
        P.int_parse(t1.getAttribute("data-hashcode"), _null, _null);
        state = C.JSArray_methods.$index(_this.memoryPath._path, dataIndex);
        _this.memoryPath.remove$1(0, state);
        if (state.get$isClass())
          _this._selectClass$1(state._className);
        else if (state.get$isInstance())
          _this.selectClassInstance$2(state._className, state._memory$_hashCode);
        else if (state.get$isInbound()) {
          _this.memoryPath._inboundFieldName = state.field;
          _this.selectClassInstance$2(state._className, state._memory$_hashCode);
        }
        J.get$children$x(_this.history.element).clear$0(0);
        P.Timer_Timer(C.Duration_100000, new V.MemoryScreen__handleHistoryClicks_closure(_this));
      }
    },
    _closeHover$1: function(newCurrent) {
      var t1;
      H.assertSubtype(newCurrent, "$isHoverCellData", [T.InstanceSummary], "$asHoverCellData");
      t1 = this.hoverPopup.element;
      J.get$children$x(t1).clear$0(0);
      t1 = t1.style;
      t1.display = "none";
      this.set$_currentHoverSummary(newCurrent);
    },
    _maybeCloseHover$0: function() {
      var t1 = this._currentHoverSummary;
      t1 = t1 == null ? null : t1.data;
      P.Timer_Timer(C.Duration_50000, new V.MemoryScreen__maybeCloseHover_closure(this, t1 == null ? null : t1._objectRef));
    },
    hoverInstanceAllocations$1: function(hover) {
      return this.hoverInstanceAllocations$body$MemoryScreen(H.assertSubtype(hover, "$isHoverCellData", [T.InstanceSummary], "$asHoverCellData"));
    },
    hoverInstanceAllocations$body$MemoryScreen: function(hover) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t2, t3, t4, t5, t6, ulElem, refs, t1;
      var $async$hoverInstanceAllocations$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = hover.cell;
              if (t1 == null) {
                $async$self._maybeCloseHover$0();
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = hover.data;
              t3 = $async$self._currentHoverSummary;
              if (!J.$eq$(t2, t3 == null ? null : t3.data))
                $async$self._closeHover$1(hover);
              t3 = $async$self.hoverPopup;
              t4 = t3.element;
              t5 = J.getInterceptor$x(t4);
              t6 = t5.get$children(t4);
              if (!t6.get$isEmpty(t6)) {
                // goto return
                $async$goto = 1;
                break;
              }
              ulElem = A.ul(null);
              t2 = t2._objectRef;
              $async$goto = 3;
              return P._asyncAwait(O.getInboundReferences(t2, 1000), $async$hoverInstanceAllocations$1);
            case 3:
              // returning from await.
              refs = $async$result;
              if (refs == null) {
                $async$self.framework.toast$2$title("Instance " + H.S(t2) + " - Sentinel/Expired.", "Warning");
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = A.CoreElement$("li", null, "allocation-li-title", null, null);
              t2.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", null, "allocated-by-class-title", null, "Allocated"), A.CoreElement$("span", null, "ref-by-title", null, "Referenced")], [A.CoreElement]));
              ulElem.add$1(0, t2);
              t2 = $async$self.tableStack;
              O.computeInboundRefs(H.assertSubtype(t2.get$first(t2).data, "$isList", [T.ClassHeapDetailStats], "$asList"), refs, new V.MemoryScreen_hoverInstanceAllocations_closure($async$self, hover, ulElem));
              t2 = J.get$classes$x(t1.element).contains$1(0, "allocation");
              if (t2) {
                t1 = t1.element;
                t2 = C.JSNumber_methods.round$0(t1.getBoundingClientRect().top);
                t1 = C.JSNumber_methods.round$0(t1.getBoundingClientRect().left);
                t5.get$children(t4).clear$0(0);
                t3.add$1(0, ulElem);
                t3 = t4.style;
                t3.display = "block";
                t3 = t4.style;
                t2 = "" + (t2 + 10) + "px";
                t3.top = t2;
                t2 = t4.style;
                t1 = "" + (t1 + 21) + "px";
                t2.left = t1;
                t1 = t4.style;
                t1.height = "";
              }
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$hoverInstanceAllocations$1, $async$completer);
    },
    _createInstanceView$2: function(objectRef, className) {
      var t1, t2, _null = null;
      this.memoryDataView = A.MemoryDataView$(this.memoryController, new V.MemoryScreen__createInstanceView_closure(objectRef));
      t1 = A.CoreElement$("div", _null, "table-border table-virtual memory-table margin-left debugger-menu", _null, _null);
      t2 = t1.element;
      t2.setAttribute("layout", "");
      t2.setAttribute("vertical", "");
      t1.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("div", _null, "memory-inspector", _null, H.S(className) + " instance " + H.S(objectRef)), this.memoryDataView._memory_data_view$_items], [A.CoreElement]));
      return t1;
    },
    _memory$_updateStatus$1: function(data) {
      var t1, t2, objectCount;
      H.assertSubtype(data, "$isList", [T.ClassHeapDetailStats], "$asList");
      t1 = this.classCountStatus;
      if (data == null) {
        t1.element.element.textContent = "";
        this.objectCountStatus.element.element.textContent = "";
      } else {
        t2 = J.getInterceptor$asx(data);
        t1.element.element.textContent = $.$get$nf().format$1(t2.get$length(data)) + " classes";
        for (t1 = t2.get$iterator(data), objectCount = 0; t1.moveNext$0();) {
          t2 = t1.get$current(t1).instancesCurrent;
          if (typeof t2 !== "number")
            return H.iae(t2);
          objectCount += t2;
        }
        this.objectCountStatus.element.element.textContent = $.$get$nf().format$1(objectCount) + " objects";
      }
    },
    set$heapPopupList: function(heapPopupList) {
      this.heapPopupList = H.assertSubtype(heapPopupList, "$isPopupListView", [P.String], "$asPopupListView");
    },
    set$_currentHoverSummary: function(_currentHoverSummary) {
      this._currentHoverSummary = H.assertSubtype(_currentHoverSummary, "$isHoverCellData", [T.InstanceSummary], "$asHoverCellData");
    }
  };
  V.MemoryScreen_createContent_closure.prototype = {
    call$0: function() {
      var t1,
        _s8_ = "disabled";
      F.select("memory", "resume", 0);
      t1 = this.$this;
      t1.resumeButton.attribute$2(_s8_, true);
      t1.pauseButton.attribute$2(_s8_, false);
      t1.memoryChart._plotlyChart.liveUpdate = true;
    },
    $signature: 0
  };
  V.MemoryScreen_createContent_closure0.prototype = {
    call$0: function() {
      var t1,
        _s8_ = "disabled";
      F.select("memory", "pause", 0);
      t1 = this.$this;
      t1.pauseButton.attribute$2(_s8_, true);
      t1.resumeButton.attribute$2(_s8_, false);
      t1.memoryChart._plotlyChart.liveUpdate = false;
    },
    $signature: 0
  };
  V.MemoryScreen_createContent_closure1.prototype = {
    call$1: function(evt) {
      var t1, t2, cell;
      H.interceptedTypeCheck(evt, "$isMouseEvent");
      t1 = this.$this;
      t2 = t1._currentHoverSummary;
      cell = t2 == null ? null : t2.cell;
      if (cell != null)
        t1._tdCellHover = cell;
      t2 = t1._tdCellHover;
      if (t2 != null)
        t2.clazz$2$removeOthers("allocation-hover", true);
      t1 = t1._tdCellHover;
      if (t1 != null)
        t1.clazz$1("left");
    },
    $signature: 3
  };
  V.MemoryScreen_createContent_closure2.prototype = {
    call$1: function(evt) {
      var t1, t2;
      H.interceptedTypeCheck(evt, "$isMouseEvent");
      t1 = this.$this;
      t2 = t1._tdCellHover;
      if (t2 != null)
        t2.clazz$2$removeOthers("allocation", true);
      t2 = t1._tdCellHover;
      if (t2 != null)
        t2.clazz$1("left");
      if (t1._tdCellHover != null)
        t1._tdCellHover = null;
      t1.set$_currentHoverSummary(null);
      t1 = t1.hoverPopup.element;
      J.get$children$x(t1).clear$0(0);
      t1 = t1.style;
      t1.display = "none";
    },
    $signature: 3
  };
  V.MemoryScreen_createContent_closure3.prototype = {
    call$1: function(__) {
      var _s8_ = "disabled",
        t1 = this.$this;
      t1.pauseButton.attribute$2(_s8_, true);
      t1.resumeButton.attribute$2(_s8_, true);
      t1.vmMemorySnapshotButton.attribute$2(_s8_, true);
      t1.resetAccumulatorsButton.attribute$2(_s8_, true);
      t1.filterLibrariesButton.attribute$2(_s8_, true);
      t1.gcNowButton.attribute$2(_s8_, true);
      t1.memoryChart.attribute$2(_s8_, true);
    },
    $signature: 49
  };
  V.MemoryScreen_selectClassInstance_closure.prototype = {
    call$1: function(timer) {
      var t1;
      H.interceptedTypeCheck(timer, "$isTimer");
      t1 = this.$this.tableStack;
      if (t1.get$first(t1)._selectedObject == null)
        timer.cancel$0(0);
    },
    $signature: 50
  };
  V.MemoryScreen_selectClassInstance_closure0.prototype = {
    call$1: function(timer) {
      return this.$call$body$MemoryScreen_selectClassInstance_closure(H.interceptedTypeCheck(timer, "$isTimer"));
    },
    $call$body$MemoryScreen_selectClassInstance_closure: function(timer) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = t1.get$_isClassSelectedAndInstancesReady() ? 2 : 3;
              break;
            case 2:
              // then
              timer.cancel$0(0);
              $async$goto = 4;
              return P._asyncAwait(t1._selectInstanceByHashCode$1($async$self.instanceHashCode), $async$call$1);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 51
  };
  V.MemoryScreen_selectClassAndInstanceInField_closure.prototype = {
    call$1: function(timer) {
      var t1;
      H.interceptedTypeCheck(timer, "$isTimer");
      t1 = this.$this.tableStack;
      if (t1.get$first(t1)._selectedObject == null)
        timer.cancel$0(0);
    },
    $signature: 50
  };
  V.MemoryScreen_selectClassAndInstanceInField_closure0.prototype = {
    call$1: function(timer) {
      return this.$call$body$MemoryScreen_selectClassAndInstanceInField_closure(H.interceptedTypeCheck(timer, "$isTimer"));
    },
    $call$body$MemoryScreen_selectClassAndInstanceInField_closure: function(timer) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t2, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = t1.get$_isClassSelectedAndInstancesReady() ? 2 : 3;
              break;
            case 2:
              // then
              timer.cancel$0(0);
              t2 = $async$self.field;
              $async$goto = 4;
              return P._asyncAwait(t1._selectInstanceInFieldHashCode$2(t2, $async$self.instanceHashCode), $async$call$1);
            case 4:
              // returning from await.
              if ($async$result !== -1)
                t1.memoryPath._inboundFieldName = t2;
              P.Timer_Timer$periodic(C.Duration_100000, new V.MemoryScreen_selectClassAndInstanceInField__closure(t1));
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 51
  };
  V.MemoryScreen_selectClassAndInstanceInField__closure.prototype = {
    call$1: function(timer) {
      return this.$call$body$MemoryScreen_selectClassAndInstanceInField__closure(H.interceptedTypeCheck(timer, "$isTimer"));
    },
    $call$body$MemoryScreen_selectClassAndInstanceInField__closure: function(timer) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, t2;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1.tableStack;
              if (t2.get$length(t2) === 2 && t2.elementAt$1(0, 1)._selectedObject != null) {
                timer.cancel$0(0);
                t1.fromMemoryHover = false;
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 51
  };
  V.MemoryScreen__createHeapStatsTableView_closure.prototype = {
    call$1: function(row) {
      return this.$call$body$MemoryScreen__createHeapStatsTableView_closure(H.interceptedTypeCheck(row, "$isClassHeapDetailStats"));
    },
    $call$body$MemoryScreen__createHeapStatsTableView_closure: function(row) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1, newTable;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              F.select("memory", "inspectClass", 0);
              t1 = $async$self.$this;
              t1._removeInstanceView$0();
              if (!t1.fromMemoryHover)
                t1._resetHistory$0();
              $async$goto = row == null ? 2 : 4;
              break;
            case 2:
              // then
              $async$result = null;
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 5;
              return P._asyncAwait(t1._createInstanceListTableView$1(row), $async$call$1);
            case 5:
              // returning from await.
            case 3:
              // join
              newTable = $async$result;
              t1._pushNextTable$2($async$self.table, newTable);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 139
  };
  V.MemoryScreen__createInstanceListTableView_closure.prototype = {
    call$1: function(row) {
      H.interceptedTypeCheck(row, "$isInstanceSummary");
      return row._objectRef;
    },
    $signature: 66
  };
  V.MemoryScreen__createInstanceListTableView_closure0.prototype = {
    call$1: function(expand) {
      H.interceptedTypeCheck(expand, "$isInstanceSummary");
      return '<div class="alloc-image"> </div>';
    },
    $signature: 66
  };
  V.MemoryScreen__handleHistoryClicks_closure.prototype = {
    call$0: function() {
      var t3,
        t1 = this.$this,
        t2 = t1.memoryPath._path;
      t2 = t2.length !== 0 && C.JSArray_methods.get$last(t2).get$isInbound();
      t3 = t1.history;
      if (!t2) {
        t3.clazz$2$removeOthers("history-navigation", true);
        t3.clazz$1("hidden");
      } else
        t1.memoryPath.displayPathsAsLinks$2(t3, t1.get$_handleHistoryClicks());
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  V.MemoryScreen__maybeCloseHover_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this;
      if (t1._tdCellHover == null) {
        t2 = t1._currentHoverSummary;
        t2 = t2 == null ? null : t2.data;
        t2 = t2 == null ? null : t2._objectRef;
        t2 = this.hoverToClose == t2;
      } else
        t2 = false;
      if (t2)
        t1._closeHover$1(null);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  V.MemoryScreen_hoverInstanceAllocations_closure.prototype = {
    call$3: function(referenceName, owningAllocator, owningAllocatorIsAbstract) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, classAllocation, fieldAllocation, liElem, hashCodeResult, t1, t2;
      var $async$call$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.boolConversionCheck(owningAllocatorIsAbstract);
              classAllocation = owningAllocatorIsAbstract ? "allocation-abstract allocated-by-class" : "allocated-by-class";
              fieldAllocation = owningAllocatorIsAbstract ? "allocation-abstract ref-by" : "ref-by";
              liElem = A.CoreElement$("li", null, "allocation-li", null, null);
              liElem.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", null, classAllocation, null, "class " + H.S(owningAllocator)), A.CoreElement$("span", null, fieldAllocation, null, "field " + H.S(referenceName))], [A.CoreElement]));
              if (owningAllocatorIsAbstract)
                liElem.clazz$1("li-allocation-abstract");
              $async$goto = !owningAllocatorIsAbstract && owningAllocator.length !== 0 ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return P._asyncAwait(O.evaluate($async$self.hover.data._objectRef, "hashCode"), $async$call$3);
            case 4:
              // returning from await.
              hashCodeResult = $async$result;
              t1 = hashCodeResult == null ? null : hashCodeResult.valueAsString;
              t2 = liElem.element;
              t2.setAttribute("data-hashcode", t1);
              t2.setAttribute("data-owning-class", owningAllocator);
              t2.setAttribute("data-ref", referenceName);
            case 3:
              // join
              liElem.get$onClick(liElem).listen$1(new V.MemoryScreen_hoverInstanceAllocations__closure($async$self.$this));
              $async$self.ulElem.add$1(0, liElem);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$3, $async$completer);
    },
    $signature: 141
  };
  V.MemoryScreen_hoverInstanceAllocations__closure.prototype = {
    call$1: function(evt) {
      var refName, objectHashCode, instanceHashCode, t1,
        _s17_ = "data-owning-class",
        _s8_ = "data-ref",
        _s13_ = "data-hashcode",
        e = H.interceptedTypeCheck(W._convertNativeToDart_EventTarget(H.interceptedTypeCheck(evt, "$isMouseEvent").currentTarget), "$isElement"),
        className = e.getAttribute(_s17_);
      if (className == null || className.length === 0)
        className = e.parentElement.getAttribute(_s17_);
      refName = e.getAttribute(_s8_);
      if (refName == null || refName.length === 0)
        refName = e.parentElement.getAttribute(_s8_);
      objectHashCode = e.getAttribute(_s13_);
      instanceHashCode = P.int_parse(objectHashCode == null || objectHashCode.length === 0 ? e.parentElement.getAttribute(_s13_) : objectHashCode, null, null);
      t1 = this.$this;
      t1._closeHover$1(null);
      if (className.length !== 0 && refName.length !== 0 && instanceHashCode != null)
        t1.selectClassAndInstanceInField$3(className, refName, instanceHashCode);
    },
    $signature: 3
  };
  V.MemoryScreen__createInstanceView_closure.prototype = {
    call$1: function(field) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, value, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              value = field.value;
              t1 = J.getInterceptor$(value);
              if (!!t1.$isSentinel) {
                $async$returnValue = value.valueAsString;
                // goto return
                $async$goto = 1;
                break;
              }
              if (!!t1.$isTypeArgumentsRef) {
                $async$returnValue = value.name;
                // goto return
                $async$goto = 1;
                break;
              }
              H.interceptedTypeCheck(value, "$isInstanceRef");
              t1 = value.valueAsString;
              if (t1 != null && !value.valueAsStringIsTruncated) {
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              } else
                F.error("Memory _createInstanceView: UNKNOWN BoundField " + H.S($async$self.objectRef), false);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 142
  };
  V.NavigationState.prototype = {
    get$isClass: function() {
      return this._className.length !== 0 && this.field.length === 0 && this._memory$_hashCode == null;
    },
    get$isInstance: function() {
      return this._className.length !== 0 && this.field.length === 0 && this._memory$_hashCode != null;
    },
    get$isInbound: function() {
      return this._className.length !== 0 && this.field.length !== 0 && this._memory$_hashCode != null;
    }
  };
  V.NavigationPath.prototype = {
    add$1: function(_, state) {
      var t1, lastState, _this = this;
      if (state.get$isInbound())
        throw H.wrapException(P.Exception_Exception("Inbound use not valid here."));
      if (state.get$isInstance() && _this._inboundFieldName.length !== 0)
        state.field = _this._inboundFieldName;
      _this._inboundFieldName = "";
      t1 = _this._path;
      if (t1.length !== 0) {
        lastState = C.JSArray_methods.get$last(t1);
        if (lastState.get$isClass() && state.get$isClass() && lastState._className == state._className)
          return;
      }
      C.JSArray_methods.add$1(t1, state);
    },
    remove$1: function(_, stateToRemove) {
      var t1, t2, row;
      for (t1 = this._path, t2 = t1.length, row = 0; row < t2; ++row)
        if (stateToRemove === t1[row]) {
          P.RangeError_checkValidRange(row, t2, t2);
          t1.splice(row, t2 - row);
          return;
        }
    },
    displayPathsAsLinks$2: function($parent, clickHandler) {
      var t1, index, t2, state, lastLink, spanText, t3, spanElem, _null = null;
      for (t1 = this._path, index = 0; t2 = t1.length, index < t2; ++index) {
        state = t1[index];
        lastLink = t2 - 1 === index;
        if (state.field.length !== 0) {
          t2 = state._className;
          spanText = H.S(t2) + "." + state.field;
        } else {
          t2 = state._className;
          if (t2.length !== 0)
            t3 = state._memory$_hashCode != null;
          else
            t3 = false;
          spanText = t3 ? H.S(t2) + " (instance)" : t2;
        }
        spanElem = A.CoreElement$("span", _null, lastLink ? "history-link-last" : "history-link", _null, spanText);
        t3 = spanElem.element;
        t3.setAttribute("data-index", "" + index);
        t3.setAttribute("data-class", t2);
        t2 = state.field;
        if (t2.length !== 0)
          t3.setAttribute("data-field", t2);
        t2 = state._memory$_hashCode;
        if (t2 != null)
          t3.setAttribute("data-hashcode", C.JSInt_methods.toString$0(t2));
        spanElem.click$1(0, new V.NavigationPath_displayPathsAsLinks_closure(spanElem, clickHandler));
        $parent.add$1(0, spanElem);
        if (!lastLink)
          $parent.add$1(0, A.CoreElement$("span", _null, "history-separator", _null, ">"));
      }
    }
  };
  V.NavigationPath_displayPathsAsLinks_closure.prototype = {
    call$0: function() {
      this.clickHandler.call$1(this.link);
    },
    $signature: 0
  };
  V._MemoryScreen_Screen_SetStateMixin.prototype = {};
  A.MemoryChart.prototype = {
    MemoryChart$1: function(_memoryController) {
      var t1 = this.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      t1.id = "memory_timeline";
      t1 = t1.style;
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "box-sizing"), "content-box", "");
      t1.height = "140px";
      t1.width = "100%";
      t1 = this._memoryController._memoryTrackerController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new A.MemoryChart_closure(this));
    },
    updateChart$1: function(data) {
      var t1, memoryTraces, t2, t3, t4, t5, _i, newSample, gcTimeStamp, t6, t7, t8, t9, t10, t11, t12, _this = this;
      if (!_this._chartCreated) {
        t1 = new M.MemoryPlotly("memory_timeline", _this);
        memoryTraces = t1.createMemoryTraces$0();
        t2 = t1.getMemoryLayout$2("", false);
        t3 = {displayModeBar: false, responsive: true, displaylogo: false};
        self.Plotly.newPlot("memory_timeline", memoryTraces, t2, t3);
        t3 = P.allowInterop(t1.get$_doubleClick(), P.Function);
        self.hookupPlotlyDoubleClick("memory_timeline", t3);
        _this._plotlyChart = t1;
        _this._chartCreated = true;
      }
      for (t1 = data.samples, t2 = t1.length, t3 = [P.int], t4 = [P.num], t5 = [O.Data], _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        newSample = t1[_i];
        if (newSample.isGC) {
          gcTimeStamp = newSample.timestamp;
          if (gcTimeStamp - _this.lastGcTimestamp > 500) {
            t6 = _this._plotlyChart;
            t7 = H.setRuntimeTypeInfo([gcTimeStamp], t3);
            t8 = H.setRuntimeTypeInfo([newSample.capacity], t4);
            t6.toString;
            H.assertSubtype(t7, "$isList", t3, "$asList");
            H.assertSubtype(t8, "$isList", t4, "$asList");
            t6 = t6._domName;
            self.extendTraces1(t6, t7, t8, [0]);
          }
          _this.lastGcTimestamp = gcTimeStamp;
        }
        t6 = _this._plotlyChart;
        t7 = H.setRuntimeTypeInfo([newSample.timestamp], t3);
        t8 = H.setRuntimeTypeInfo([newSample.rss], t4);
        t9 = H.setRuntimeTypeInfo([newSample.capacity], t4);
        t10 = H.setRuntimeTypeInfo([newSample.used], t4);
        t11 = H.setRuntimeTypeInfo([newSample.external], t4);
        t6.toString;
        H.assertSubtype(t7, "$isList", t3, "$asList");
        H.assertSubtype(t8, "$isList", t4, "$asList");
        H.assertSubtype(t9, "$isList", t4, "$asList");
        H.assertSubtype(t10, "$isList", t4, "$asList");
        H.assertSubtype(t11, "$isList", t4, "$asList");
        t12 = t6._domName;
        self.extendTraces4(t12, t7, t7, t7, t7, t8, t9, t11, t10, [4, 3, 1, 2]);
        if (t6.liveUpdate) {
          if (0 >= t7.length)
            return H.ioore(t7, 0);
          t8 = t7[0];
          if (typeof t8 !== "number")
            return H.iae(t8);
          new P.DateTime(t8, false).DateTime$_withValue$2$isUtc(t8, false);
          t8 = P.DateTime$_withValue(t8 - 120000, false);
          if (0 >= t7.length)
            return H.ioore(t7, 0);
          t7 = H.intTypeCheck(t7[0]);
          t9 = H.setRuntimeTypeInfo([{}], t5);
          t7 = {xaxis: t6.getXAxisLayout$2(t8._value, t7)};
          self.Plotly.update(t12, t9, t7);
        }
      }
      C.JSArray_methods.set$length(t1, 0);
    }
  };
  A.MemoryChart_closure.prototype = {
    call$1: function(memoryTracker) {
      var t1;
      H.interceptedTypeCheck(memoryTracker, "$isMemoryTracker");
      t1 = this.$this;
      if (t1._memoryController._memoryTracker.service != null)
        t1.updateChart$1(memoryTracker);
    },
    $signature: 143
  };
  T.MemoryController.prototype = {
    _memory_controller$_handleConnectionStart$1: function(service) {
      var t1, t2;
      H.interceptedTypeCheck(service, "$isVmServiceWrapper");
      t1 = this._memoryTracker = new T.MemoryTracker(service, new P._AsyncBroadcastStreamController(null, null, [P.Null]), H.setRuntimeTypeInfo([], [T.HeapSample]), P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List, S.HeapSpace]));
      t1._memory_protocol$_pollingTimer = P.Timer_Timer(C.Duration_500000, t1.get$_pollMemory());
      t2 = t1.service._vmService._getEventController$1("GC");
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(t1.get$_handleGCEvent());
      t1 = this._memoryTracker._memory_protocol$_changeController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new T.MemoryController__handleConnectionStart_closure(this));
    },
    _memory_controller$_handleConnectionStop$1: function($event) {
      var t2, _this = this,
        t1 = _this._memoryTracker;
      if (t1 != null) {
        t2 = t1._memory_protocol$_pollingTimer;
        if (t2 != null)
          t2.cancel$0(0);
        t1.service = null;
      }
      _this._memoryTrackerController.add$1(0, _this._memoryTracker);
      _this._disconnectController.add$1(0, C.Type_Null_Yyn);
    },
    startTimeline$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$startTimeline$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolateController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new T.MemoryController_startTimeline_closure($async$self));
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self.get$_memory_controller$_handleConnectionStart());
              if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
                $async$self._memory_controller$_handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self.get$_memory_controller$_handleConnectionStop());
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$startTimeline$0, $async$completer);
    },
    getAllocationProfile$1$reset: function(reset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, T.ClassHeapDetailStats]),
        $async$returnValue, t1, t2, t3;
      var $async$getAllocationProfile$1$reset = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.getAllocationProfile$2$reset(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id, reset), $async$getAllocationProfile$1$reset);
            case 3:
              // returning from await.
              t1 = $async$result.members;
              t2 = T.ClassHeapDetailStats;
              t3 = H.getTypeArgumentByIndex(t1, 0);
              t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new T.MemoryController_getAllocationProfile_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).super$Iterable$where(0, H.functionTypeCheck(new T.MemoryController_getAllocationProfile_closure0(), {func: 1, ret: P.bool, args: [t2]}));
              $async$returnValue = P.List_List$from(t2, true, H.getTypeArgumentByIndex(t2, 0));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getAllocationProfile$1$reset, $async$completer);
    },
    getAllocationProfile$0: function() {
      return this.getAllocationProfile$1$reset(false);
    },
    getInstances$3: function(classRef, className, maxInstances) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, T.InstanceSummary]),
        $async$returnValue, t1, t2, t3;
      var $async$getInstances$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.getInstances$4$classId(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id, classRef, maxInstances, classRef), $async$getInstances$3);
            case 3:
              // returning from await.
              t1 = $async$result.instances;
              t2 = T.InstanceSummary;
              t3 = H.getTypeArgumentByIndex(t1, 0);
              $async$returnValue = new H.MappedListIterable(t1, H.functionTypeCheck(new T.MemoryController_getInstances_closure(classRef, className), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getInstances$3, $async$completer);
    },
    getObject$1: function(_, objectRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, t1, t2;
      var $async$getObject$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
              t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getObject", t1._vmService.getObject$2(0, t2, objectRef), P.Object), $async$getObject$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getObject$1, $async$completer);
    },
    gc$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$gc$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.getAllocationProfile$2$gc(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id, true), $async$gc$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$gc$0, $async$completer);
    },
    matchObject$3: function(objectRef, fieldName, instanceHashCode) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, fields, t2, _i, field, evalResult, object, t1;
      var $async$matchObject$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.getObject$1(0, objectRef), $async$matchObject$3);
            case 3:
              // returning from await.
              object = $async$result;
              t1 = J.getInterceptor$(object);
              $async$goto = !!t1.$isInstance ? 4 : 5;
              break;
            case 4:
              // then
              fields = object.fields;
              t2 = fields.length, _i = 0;
            case 6:
              // for condition
              if (!(_i < fields.length)) {
                // goto after for
                $async$goto = 8;
                break;
              }
              field = fields[_i];
              $async$goto = field.decl.name === fieldName ? 9 : 10;
              break;
            case 9:
              // then
              $async$goto = 11;
              return P._asyncAwait(O.evaluate(H.interceptedTypeCheck(field.value, "$isInstanceRef").id, "hashCode"), $async$matchObject$3);
            case 11:
              // returning from await.
              evalResult = $async$result;
              if (P.int_parse(evalResult == null ? null : evalResult.valueAsString, null, null) === instanceHashCode) {
                $async$returnValue = true;
                // goto return
                $async$goto = 1;
                break;
              }
            case 10:
              // join
            case 7:
              // for update
              fields.length === t2 || (0, H.throwConcurrentModificationError)(fields), ++_i;
              // goto for condition
              $async$goto = 6;
              break;
            case 8:
              // after for
            case 5:
              // join
              if (!!t1.$isSentinel)
                P.print("Trying to matchObject with a Sentinel " + H.S(objectRef));
              $async$returnValue = false;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$matchObject$3, $async$completer);
    }
  };
  T.MemoryController__handleConnectionStart_closure.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isNull");
      t1 = this.$this;
      t1._memoryTrackerController.add$1(0, t1._memoryTracker);
    },
    $signature: 67
  };
  T.MemoryController_startTimeline_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isIsolateRef");
    },
    $signature: 35
  };
  T.MemoryController_getAllocationProfile_closure.prototype = {
    call$1: function(stats) {
      var t1 = H.interceptedTypeCheck(stats, "$isClassHeapStats").json,
        t2 = new T.ClassHeapDetailStats(t1),
        t3 = J.getInterceptor$asx(t1),
        t4 = H.assertSubtype(t3.$index(t1, "class"), "$isMap", [P.String, null], "$asMap");
      t2.classRef = t4 == null ? null : S.ClassRef$_fromJson(t4);
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.protocolVersionLessThan$2$major$minor(3, 18)) {
        t2._update$1(0, H.listTypeCheck(t3.$index(t1, "new")));
        t2._update$1(0, H.listTypeCheck(t3.$index(t1, "old")));
      } else {
        t2.instancesCurrent = H.intTypeCheck(t3.$index(t1, "instancesCurrent"));
        t2.instancesAccumulated = H.intTypeCheck(t3.$index(t1, "instancesAccumulated"));
        t2.bytesCurrent = H.intTypeCheck(t3.$index(t1, "bytesCurrent"));
        t2.bytesAccumulated = H.intTypeCheck(t3.$index(t1, "bytesAccumulated"));
      }
      return t2;
    },
    $signature: 145
  };
  T.MemoryController_getAllocationProfile_closure0.prototype = {
    call$1: function(stats) {
      var t1;
      H.interceptedTypeCheck(stats, "$isClassHeapDetailStats");
      t1 = stats.instancesCurrent;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 <= 0) {
        t1 = stats.instancesAccumulated;
        if (typeof t1 !== "number")
          return t1.$gt();
        t1 = t1 > 0;
      } else
        t1 = true;
      return t1;
    },
    $signature: 146
  };
  T.MemoryController_getInstances_closure.prototype = {
    call$1: function(ref) {
      return new T.InstanceSummary(this.classRef, H.interceptedTypeCheck(ref, "$isObjRef").id, this.className);
    },
    $signature: 147
  };
  A.MemoryDataView.prototype = {
    MemoryDataView$2: function(_memoryController, variableDescriber) {
      var _this = this,
        t1 = N.SelectableTree$(S.BoundField);
      t1.flex$0(0);
      t1.clazz$1("menu-item-bottom-border");
      t1.clazz$1("debugger-items-list");
      t1.clazz$1("memory-inspector-items-list");
      _this.set$_memory_data_view$_items(t1);
      t1 = _this._memory_data_view$_items;
      t1.set$childProvider(H.assertSubtype(new A.MemoryDataChildProvider(_this._memory_data_view$_memoryController), "$isChildProvider", [H.getTypeArgumentByIndex(t1, 0)], "$asChildProvider"));
      t1 = _this._memory_data_view$_items;
      t1.set$renderer(H.functionTypeCheck(new A.MemoryDataView_closure(variableDescriber), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    get$element: function() {
      return this._memory_data_view$_items;
    },
    set$_memory_data_view$_items: function(_items) {
      this._memory_data_view$_items = H.assertSubtype(_items, "$isSelectableTree", [S.BoundField], "$asSelectableTree");
    },
    $isCoreElementView: 1
  };
  A.MemoryDataView_closure.prototype = {
    call$1: function(field) {
      var $name, value, t1, valueStr, element, t2, _null = null, _box_0 = {};
      H.interceptedTypeCheck(field, "$isBoundField");
      $name = field.decl.name;
      value = field.value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isInstanceRef) {
        valueStr = value.valueAsString;
        if (valueStr == null)
          valueStr = value.classRef.name;
        else {
          if (value.valueAsStringIsTruncated)
            valueStr += "...";
          if (value.kind === "String")
            valueStr = "'" + valueStr + "'";
        }
        t1 = value.kind;
        switch (t1) {
          case "List":
            valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
            break;
          case "Map":
            valueStr = "{ " + H.S(value.length) + " } " + H.S(valueStr);
            break;
          default:
            if (t1 != null && C.JSString_methods.endsWith$1(t1, "List"))
              valueStr = "[" + H.S(value.length) + "] " + H.S(valueStr);
        }
      } else if (!!t1.$isSentinel)
        valueStr = value.valueAsString;
      else
        valueStr = !!t1.$isTypeArgumentsRef ? value.name : t1.toString$0(value);
      element = A.CoreElement$("li", _null, "memory-instance-data-list-item", _null, _null);
      element.add$1(0, H.setRuntimeTypeInfo([A.CoreElement$("span", _null, _null, _null, $name), A.CoreElement$("span", _null, "subtle", _null, " " + H.S(valueStr))], [A.CoreElement]));
      _box_0.sub = null;
      t1 = J.get$onMouseOver$x(element.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      _box_0.sub = W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new A.MemoryDataView__closure(_box_0, this.variableDescriber, field, element), {func: 1, ret: -1, args: [t2]}), false, t2);
      return element;
    },
    $signature: 148
  };
  A.MemoryDataView__closure.prototype = {
    call$1: function(e) {
      var _this = this;
      H.interceptedTypeCheck(e, "$isMouseEvent");
      _this._box_0.sub.cancel$0(0);
      _this.variableDescriber.call$1(_this.field).then$1$1(new A.MemoryDataView___closure(_this.element), null);
    },
    $signature: 3
  };
  A.MemoryDataView___closure.prototype = {
    call$1: function(desc) {
      this.element.element.title = H.stringTypeCheck(desc);
    },
    $signature: 19
  };
  A.MemoryDataChildProvider.prototype = {
    hasChildren$1: function(item) {
      var t1 = H.interceptedTypeCheck(item, "$isBoundField").value;
      return t1 instanceof S.InstanceRef && t1.valueAsString == null;
    },
    getChildren$1: function(item) {
      return this.getChildren$body$MemoryDataChildProvider(H.interceptedTypeCheck(item, "$isBoundField"));
    },
    getChildren$body$MemoryDataChildProvider: function(item) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, S.BoundField]),
        $async$returnValue, $async$self = this, object, result, t2, index, _i, value, t3, t4, t5, t1;
      var $async$getChildren$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          $async$outer:
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = item.value;
                $async$goto = t1 != null && t1 instanceof S.InstanceRef ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait($async$self._memory_data_view$_memoryController.getObject$1(0, H.stringTypeCheck(J.get$id$x(t1))), $async$getChildren$1);
              case 5:
                // returning from await.
                object = $async$result;
                t1 = J.getInterceptor$(object);
                if (!!t1.$isInstance)
                  switch (J.get$kind$x(item.value)) {
                    case "PlainInstance":
                      $async$returnValue = object.fields;
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case "List":
                      result = H.setRuntimeTypeInfo([], [S.BoundField]);
                      for (t1 = object.elements, t2 = t1.length, index = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                        value = t1[_i];
                        t3 = new S.BoundField();
                        t4 = new S.FieldRef(null);
                        t4.name = "[" + index + "]";
                        t3.decl = t4;
                        t3.value = value;
                        C.JSArray_methods.add$1(result, t3);
                        ++index;
                      }
                      $async$returnValue = result;
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case "Map":
                      result = H.setRuntimeTypeInfo([], [S.BoundField]);
                      for (t1 = object.associations, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
                        value = t1[_i];
                        t3 = new S.BoundField();
                        t4 = new S.FieldRef(null);
                        t5 = J.getInterceptor$x(value);
                        t4.name = "['" + H.S(J.get$valueAsString$x(t5.get$key(value))) + "']";
                        t3.decl = t4;
                        t3.value = J.get$valueAsString$x(t5.get$value(value));
                        C.JSArray_methods.add$1(result, t3);
                      }
                      $async$returnValue = result;
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case "StackTrace":
                      break;
                    case "Closure":
                      break;
                  }
                else if (!!t1.$isSentinel)
                  P.print("ERROR: Sentinel encountered " + H.S(J.get$id$x(item.value)) + ".");
              case 4:
                // join
                $async$returnValue = H.setRuntimeTypeInfo([], [S.BoundField]);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
      });
      return P._asyncStartSync($async$getChildren$1, $async$completer);
    },
    $asChildProvider: function() {
      return [S.BoundField];
    }
  };
  Z.MemoryColumnClassName.prototype = {
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isClassHeapDetailStats").classRef.name;
    },
    $asColumn: function() {
      return [T.ClassHeapDetailStats];
    }
  };
  Z.MemoryColumnSize.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isClassHeapDetailStats").bytesCurrent;
    },
    render$1: function(value) {
      var t1 = J.getInterceptor$n(value);
      if (t1.$lt(value, 1024))
        return " " + Q.Column_fastIntl(H.numTypeCheck(value));
      else
        return " " + Q.Column_fastIntl(t1.$tdiv(value, 1024)) + "k";
    },
    $asColumn: function() {
      return [T.ClassHeapDetailStats];
    }
  };
  Z.MemoryColumnInstanceCount.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isClassHeapDetailStats").instancesCurrent;
    },
    render$1: function(value) {
      return Q.Column_fastIntl(H.numTypeCheck(value));
    },
    $asColumn: function() {
      return [T.ClassHeapDetailStats];
    }
  };
  Z.MemoryColumnInstanceAccumulatedCount.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isClassHeapDetailStats").instancesAccumulated;
    },
    render$1: function(value) {
      return Q.Column_fastIntl(H.numTypeCheck(value));
    },
    $asColumn: function() {
      return [T.ClassHeapDetailStats];
    }
  };
  Z.MemoryColumnSimple.prototype = {
    getValue$1: function(dataObject) {
      H.assertSubtypeOfRuntimeType(dataObject, H.getTypeArgumentByIndex(this, 0));
      return this.getter.call$1(dataObject);
    }
  };
  M.MemoryPlotly.prototype = {
    getXAxisLayout$2: function(startTime, endTime) {
      var t4, t5,
        t1 = {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)},
        t2 = {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)},
        t3 = ($._isDarkTheme ? C.Color_4290493371 : C.Color_4278190080).value;
      t3 = Y.colorToCss(S.Color$fromARGB(50, (16711680 & t3) >>> 16, (65280 & t3) >>> 8, (255 & t3) >>> 0));
      t4 = startTime === -1;
      t5 = [P.num];
      t5 = t4 ? H.setRuntimeTypeInfo([], t5) : H.setRuntimeTypeInfo([startTime, endTime], t5);
      t4 = t4 ? {} : {autorange: true};
      return {tickformat: "%-I:%M:%S %p", type: "date", range: t5, rangeslider: t4, showgrid: true, tickfont: t2, hoverformat: "%H:%M:%S.%L %p", titlefont: t1, gridcolor: t3, gridwidth: 1};
    },
    getXAxisLayout$0: function() {
      return this.getXAxisLayout$2(-1, -1);
    },
    getMemoryLayout$2: function(chartTitle, addEventTimeline) {
      var t4, t5, t6, t7, layout,
        t1 = new M.MemoryPlotly_getMemoryLayout_getYAxis(),
        t2 = new M.MemoryPlotly_getMemoryLayout_getLegend(),
        margins = {l: 80, r: 5, b: 5, t: 5, pad: 5},
        t3 = [P.num];
      if (addEventTimeline) {
        t4 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
        t5 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
        t6 = this.getXAxisLayout$0();
        t1 = t1.call$1(H.setRuntimeTypeInfo([0, 0.9], t3));
        t7 = H.setRuntimeTypeInfo([0.9, 1], t3);
        t3 = H.setRuntimeTypeInfo([0.5, 1.5], t3);
        t7 = {ticks: "", title: {text: "Events", font: {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371), size: 10}}, type: "linear", range: t3, showgrid: false, showticklabels: false, domain: t7, zeroline: false, anchor: "y", side: "right", showline: false};
        t2 = t2.call$1(true);
        layout = {title: chartTitle, xaxis: t6, yaxis: t1, yaxis2: t7, margin: margins, shapes: H.setRuntimeTypeInfo([{type: "rect", xref: "paper", yref: "y2", layer: "below", x0: 0, y0: 0, x1: 1, y1: 2, line: {width: 0}, fillcolor: "#ccc", opacity: 0.5}], [O.Shape]), legend: t2, plot_bgcolor: t4, paper_bgcolor: t5};
      } else {
        t4 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
        t5 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
        t2 = t2.call$0();
        layout = {title: chartTitle, xaxis: this.getXAxisLayout$0(), yaxis: t1.call$1(H.setRuntimeTypeInfo([], t3)), margin: margins, legend: t2, plot_bgcolor: t4, paper_bgcolor: t5};
      }
      return layout;
    },
    _createTrace$6$color$dash$group$size$symbol: function($name, color, dash, group, size, symbol) {
      var widthValue, modeName, line, marker, t1, t2;
      if (color != null) {
        if (dash != null) {
          widthValue = 2;
          modeName = "lines";
        } else {
          widthValue = 0;
          modeName = "";
        }
        line = {color: color, dash: dash, width: widthValue};
      } else {
        modeName = "";
        line = null;
      }
      if (symbol != null) {
        marker = {color: color, symbol: symbol, size: size};
        modeName = "markers";
      } else
        marker = null;
      t1 = [P.String];
      if (marker == null) {
        t1 = H.setRuntimeTypeInfo([], t1);
        t2 = group != null ? "one" : "";
        return {x: [C.Type_Null_Yyn], y: [C.Type_Null_Yyn], type: "scatter", mode: modeName, line: line, name: $name, text: t1, stackgroup: t2, hoverinfo: "y+name"};
      } else {
        t1 = H.setRuntimeTypeInfo([], t1);
        t2 = group != null ? "one" : "";
        return {x: [C.Type_Null_Yyn], y: [C.Type_Null_Yyn], type: "scatter", mode: modeName, marker: marker, name: $name, text: t1, stackgroup: t2, hoverinfo: "y+name"};
      }
    },
    _createTrace$4$color$size$symbol: function($name, color, size, symbol) {
      return this._createTrace$6$color$dash$group$size$symbol($name, color, null, null, size, symbol);
    },
    _createTrace$3$color$group: function($name, color, group) {
      return this._createTrace$6$color$dash$group$size$symbol($name, color, null, group, null, null);
    },
    _createTrace$3$color$dash: function($name, color, dash) {
      return this._createTrace$6$color$dash$group$size$symbol($name, color, dash, null, null, null);
    },
    createMemoryTraces$0: function() {
      var externalTrace, usedTrace, capacityTrace, rssTrace, _this = this,
        gcTrace = _this._createTrace$4$color$size$symbol("GC", $.$get$MemoryPlotly_gcColor(), 10, "circle");
      J.set$hoverinfo$x(gcTrace, "x+name");
      externalTrace = _this._createTrace$3$color$group("External", $.$get$MemoryPlotly_externalColor(), "one");
      usedTrace = _this._createTrace$3$color$group("Used", $.$get$MemoryPlotly_usedColor(), "one");
      capacityTrace = _this._createTrace$3$color$dash("Capacity", $.$get$MemoryPlotly_capacityColor(), "dot");
      rssTrace = _this._createTrace$3$color$dash("RSS", $.$get$MemoryPlotly_rssColor(), "dash");
      J.set$visible$x(rssTrace, "legendonly");
      return H.setRuntimeTypeInfo([gcTrace, externalTrace, usedTrace, capacityTrace, rssTrace], [O.Data]);
    },
    _doubleClick$1: function(data) {
      H.interceptedTypeCheck(data, "$isDataEvent");
      this._memoryChart._plotlyChart.liveUpdate = true;
      return;
    },
    createEventTimeline$0: function() {
      var eventTraces, t3, _this = this,
        memoryTraces = _this.createMemoryTraces$0(),
        t1 = _this._domName,
        t2 = new M.EventTimeline(Y.colorToCss(C.ThemedColor_Color_4278190335_Color_4279786209), Y.colorToCss(C.ThemedColor_Color_4278190335_Color_4279786209), Y.colorToCss(C.ThemedColor_Color_4289450719_Color_4286166774), t1, _this._memoryChart.element);
      _this.eventTimeline = t2;
      eventTraces = t2.getEventTimelineTraces$0();
      t2 = _this.eventTimeline;
      t2.toString;
      t3 = H.assertSubtype(memoryTraces, "$isList", [O.Data], "$asList").length;
      t2.resetTraceIndex = t3;
      t2.snapshotTraceIndex = t3 + 1;
      t3 = _this.getMemoryLayout$2("", true);
      self.Plotly.relayout(t1, t3);
      t3 = _this.eventTimeline;
      t3 = H.setRuntimeTypeInfo([t3.resetTraceIndex, t3.snapshotTraceIndex], [P.int]);
      self.Plotly.addTraces(t1, eventTraces, t3);
    }
  };
  M.MemoryPlotly_getMemoryLayout_getYAxis.prototype = {
    call$1: function(range) {
      var t1;
      H.assertSubtype(range, "$isList", [P.num], "$asList");
      t1 = {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)};
      return {fixedrange: true, showgrid: false, tickfont: {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}, titlefont: t1, domain: range, zeroline: false};
    },
    $signature: 150
  };
  M.MemoryPlotly_getMemoryLayout_getLegend.prototype = {
    call$1: function(events) {
      return events ? {orientation: "v", x: 1.03, y: 1.1, font: {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}, xanchor: "left"} : {font: {family: "sans-serif", color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}};
    },
    call$0: function() {
      return this.call$1(false);
    },
    $signature: 151
  };
  M.EventTimeline.prototype = {
    getEventTimelineTraces$0: function() {
      var t1 = this._eventBgColorCss;
      return H.setRuntimeTypeInfo([{x: [C.Type_Null_Yyn], y: [C.Type_Null_Yyn], type: "scatter", mode: "markers", marker: {color: this._resetColorCss, symbol: "hexagon2-open-dot", size: 5, line: {color: t1, width: 2}}, name: "Reset", hoverinfo: "name+x", showlegend: true, yaxis: "y2"}, {x: [C.Type_Null_Yyn], y: [C.Type_Null_Yyn], type: "scatter", mode: "markers", marker: {color: this._snapshotColorCss, symbol: "hexagon2-open", size: 10, line: {color: t1, width: 2}}, name: "Snapshot", hoverinfo: "name+x", showlegend: true, yaxis: "y2"}], [O.Data]);
    },
    displayDuration$2: function(time, eventType) {
      var nextShape, t1, t2, jsShape, _this = this;
      if (eventType === "s") {
        _this.lastEventType = eventType;
        _this.lastEventTime = time;
        return;
      }
      nextShape = J.get$length$asx(J.get$shapes$x(H.interceptedTypeCheck(_this._chart.layout, "$isLayout")));
      t1 = "mem: " + _this.lastEventType + " > " + eventType;
      t2 = _this.lastEventTime;
      jsShape = self.createEventShape(t1, nextShape, t2, time);
      self.Plotly.relayout(_this._domName, jsShape);
      _this.lastEventTime = time;
      _this.lastEventType = eventType;
    }
  };
  T.MemoryTracker.prototype = {
    _handleGCEvent$1: function($event) {
      var t1, t2, t3, t4, heaps;
      H.interceptedTypeCheck($event, "$isEvent0");
      t1 = $event.json;
      t2 = J.getInterceptor$asx(t1);
      t3 = [P.String, null];
      t4 = H.assertSubtype(t2.$index(t1, "new"), "$isMap", t3, "$asMap");
      t4 = t4 == null ? null : S.HeapSpace$_fromJson(t4);
      t3 = H.assertSubtype(t2.$index(t1, "old"), "$isMap", t3, "$asMap");
      t1 = t3 == null ? null : S.HeapSpace$_fromJson(t3);
      t2 = [S.HeapSpace];
      heaps = H.setRuntimeTypeInfo([t4, t1], t2);
      this.isolateHeaps.$indexSet(0, $event.isolate.id, H.assertSubtype(heaps, "$isList", t2, "$asList"));
      this._recalculate$1(true);
    },
    _pollMemory$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$returnValue, $async$self = this, t2, vm, t3, t1, $async$temp1;
      var $async$_pollMemory$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.service;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = S.VM;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getVM", t1._vmService._call$1$1(0, "getVM", t2), t2), $async$_pollMemory$0);
            case 3:
              // returning from await.
              vm = $async$result;
              t2 = vm.isolates;
              t1 = [P.Future, S.Isolate];
              t3 = H.getTypeArgumentByIndex(t2, 0);
              $async$temp1 = vm;
              $async$goto = 4;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(t2, H.functionTypeCheck(new T.MemoryTracker__pollMemory_closure($async$self), {func: 1, ret: t1, args: [t3]}), [t3, t1]), S.Isolate), $async$_pollMemory$0);
            case 4:
              // returning from await.
              $async$self._update$2(0, $async$temp1, $async$result);
              $async$self._memory_protocol$_pollingTimer = P.Timer_Timer(C.Duration_200000, $async$self.get$_pollMemory());
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_pollMemory$0, $async$completer);
    },
    _update$2: function(_, vm, isolates) {
      var t1, t2, t3, heaps;
      H.assertSubtype(isolates, "$isList", [S.Isolate], "$asList");
      this.processRss = H.intTypeCheck(J.$index$asx(vm.json, "_currentRSS"));
      t1 = this.isolateHeaps;
      t1.clear$0(0);
      for (t2 = J.get$iterator$ax(isolates); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        heaps = T.MemoryTracker_getHeaps(t3).toList$0(0);
        t1.$indexSet(0, t3.id, heaps);
      }
      this._recalculate$0();
    },
    _recalculate$1: function(fromGC) {
      var t1, t2, total, used, capacity, $external, t3, t4, t5, t6, time, _this = this;
      for (t1 = _this.isolateHeaps, t1 = t1.get$values(t1), t1 = t1.get$iterator(t1), t2 = P.int, total = 0, used = 0, capacity = 0, $external = 0; t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        t4 = J.getInterceptor$ax(t3);
        t5 = t4.fold$1$2(t3, 0, new T.MemoryTracker__recalculate_closure(), t2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        used += t5;
        t5 = t4.fold$1$2(t3, 0, new T.MemoryTracker__recalculate_closure0(), t2);
        if (typeof t5 !== "number")
          return H.iae(t5);
        t6 = t4.fold$1$2(t3, 0, new T.MemoryTracker__recalculate_closure1(), t2);
        if (typeof t6 !== "number")
          return H.iae(t6);
        $external += t6;
        capacity = capacity + t5 + $external;
        t3 = t4.fold$1$2(t3, 0, new T.MemoryTracker__recalculate_closure2(), t2);
        if (typeof t3 !== "number")
          return H.iae(t3);
        total += t3;
      }
      time = Date.now();
      t1 = _this.samples;
      if (t1.length !== 0)
        time = Math.max(time, C.JSArray_methods.get$last(t1).timestamp);
      C.JSArray_methods.add$1(t1, new T.HeapSample(time, _this.processRss, capacity, used, $external, fromGC));
      _this._memory_protocol$_changeController.add$1(0, null);
    },
    _recalculate$0: function() {
      return this._recalculate$1(false);
    }
  };
  T.MemoryTracker__pollMemory_closure.prototype = {
    call$1: function(ref) {
      return this.$call$body$MemoryTracker__pollMemory_closure(H.interceptedTypeCheck(ref, "$isIsolateRef"));
    },
    $call$body$MemoryTracker__pollMemory_closure: function(ref) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Isolate),
        $async$returnValue, $async$self = this, t1, t2, t3, $async$temp1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this.service;
              t2 = ref.id;
              t3 = t1._vmService;
              t3.toString;
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t3._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.futureOrCheck($async$result, {futureOr: 1, type: S.Isolate});
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 152
  };
  T.MemoryTracker__recalculate_closure.prototype = {
    call$2: function(i, heap) {
      var t1;
      H.intTypeCheck(i);
      t1 = H.interceptedTypeCheck(heap, "$isHeapSpace").used;
      if (typeof i !== "number")
        return i.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return i + t1;
    },
    $signature: 36
  };
  T.MemoryTracker__recalculate_closure0.prototype = {
    call$2: function(i, heap) {
      var t1;
      H.intTypeCheck(i);
      t1 = H.interceptedTypeCheck(heap, "$isHeapSpace").capacity;
      if (typeof i !== "number")
        return i.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return i + t1;
    },
    $signature: 36
  };
  T.MemoryTracker__recalculate_closure1.prototype = {
    call$2: function(i, heap) {
      var t1;
      H.intTypeCheck(i);
      t1 = H.interceptedTypeCheck(heap, "$isHeapSpace").external;
      if (typeof i !== "number")
        return i.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      return i + t1;
    },
    $signature: 36
  };
  T.MemoryTracker__recalculate_closure2.prototype = {
    call$2: function(i, heap) {
      var t1, t2;
      H.intTypeCheck(i);
      H.interceptedTypeCheck(heap, "$isHeapSpace");
      t1 = heap.capacity;
      if (typeof i !== "number")
        return i.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = heap.external;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return i + t1 + t2;
    },
    $signature: 36
  };
  T.MemoryTracker_getHeaps_closure.prototype = {
    call$1: function(json) {
      H.assertSubtype(json, "$isMap", [P.String, null], "$asMap");
      return json == null ? null : S.HeapSpace$_fromJson(json);
    },
    $signature: 154
  };
  T.HeapSample.prototype = {};
  T.ClassHeapDetailStats.prototype = {
    _update$1: function(_, stats) {
      var _this = this,
        t1 = _this.instancesAccumulated,
        t2 = J.getInterceptor$asx(stats),
        t3 = H.numTypeCheck(t2.$index(stats, 6));
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t3 !== "number")
        return H.iae(t3);
      _this.instancesAccumulated = H.intTypeCheck(t1 + t3);
      t3 = _this.bytesAccumulated;
      t1 = H.numTypeCheck(t2.$index(stats, 7));
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t1 !== "number")
        return H.iae(t1);
      _this.bytesAccumulated = H.intTypeCheck(t3 + t1);
      t1 = _this.instancesCurrent;
      t3 = H.numTypeCheck(J.$add$ansx(t2.$index(stats, 2), t2.$index(stats, 4)));
      if (typeof t1 !== "number")
        return t1.$add();
      _this.instancesCurrent = H.intTypeCheck(t1 + t3);
      t3 = _this.bytesCurrent;
      t2 = H.numTypeCheck(J.$add$ansx(t2.$index(stats, 3), t2.$index(stats, 5)));
      if (typeof t3 !== "number")
        return t3.$add();
      _this.bytesCurrent = H.intTypeCheck(t3 + t2);
    },
    toString$0: function(_) {
      var _this = this;
      return "[ClassHeapStats type: " + H.S(H.stringTypeCheck(J.$index$asx(_this.json, "type"))) + ", class: " + H.S(_this.classRef.name) + ", count: " + H.S(_this.instancesCurrent) + ", bytes: " + H.S(_this.bytesCurrent) + "]";
    },
    get$json: function(receiver) {
      return this.json;
    },
    get$classRef: function() {
      return this.classRef;
    }
  };
  T.InstanceSummary.prototype = {
    get$classRef: function() {
      return this._classRef;
    },
    toString$0: function(_) {
      return "[InstanceSummary id: " + H.S(this._objectRef) + ", class: " + H.S(this._classRef) + "]";
    }
  };
  O.InboundReferences.prototype = {
    InboundReferences$1: function(json) {
      var t1 = O.InboundReference;
      this.set$elements(0, H.assertSubtype(J.toList$0$ax(J.map$1$1$ax(J.$index$asx(json, "references"), new O.InboundReferences_closure(), t1)), "$isIterable", [t1], "$asIterable"));
    },
    set$elements: function(_, elements) {
      this.elements = H.assertSubtype(elements, "$isIterable", [O.InboundReference], "$asIterable");
    }
  };
  O.InboundReferences_closure.prototype = {
    call$1: function(rmap) {
      var t1, t2;
      H.assertSubtype(rmap, "$isMap", [P.String, null], "$asMap");
      if (rmap == null)
        t1 = null;
      else {
        t1 = new O.InboundReference(null);
        t2 = J.getInterceptor$asx(rmap);
        t1.parentField = S.createServiceObject(t2.$index(rmap, "parentField"));
        H.intTypeCheck(t2.$index(rmap, "parentListIndex"));
        H.intTypeCheck(t2.$index(rmap, "_parentWordOffset"));
      }
      return t1;
    },
    $signature: 155
  };
  O.InboundReference.prototype = {
    get$classRef: function() {
      return J.get$runtimeType$(this.parentField).$eq(0, C.Type_FieldRef_EkK) ? H.interceptedTypeCast(this.parentField, "$isClassRef") : null;
    }
  };
  O._searchClass_closure.prototype = {
    call$1: function(stat) {
      return J.get$name$x(stat.get$classRef()) == this.className;
    },
    $signature: 11
  };
  O._searchClass_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  X.MessageManager.prototype = {
    _showMessage$1: function(message) {
      H.interceptedTypeCheck(message, "$isMessage");
      if (C.JSArray_methods.contains$1(this._dismissedMessageIds, message.id))
        return;
      this._container.add$1(0, message.flash);
    },
    removeAll$0: function() {
      J.get$children$x(this._container.element).clear$0(0);
      var t1 = this._messages.$index(0, "general");
      if (t1 != null)
        J.removeWhere$1$ax(t1, new X.MessageManager_removeAll_closure());
    },
    addMessage$2: function(message, screenId) {
      var t1 = message._dismissController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new X.MessageManager_addMessage_closure(this, screenId));
      J.add$1$ax(this._messages.putIfAbsent$2(0, screenId, new X.MessageManager_addMessage_closure0()), message);
      this._showMessage$1(message);
    }
  };
  X.MessageManager_removeAll_closure.prototype = {
    call$1: function(m) {
      return H.interceptedTypeCheck(m, "$isMessage").messageType === C.MessageType_2;
    },
    $signature: 157
  };
  X.MessageManager_addMessage_closure.prototype = {
    call$1: function(_message) {
      var t1;
      H.interceptedTypeCheck(_message, "$isMessage");
      t1 = _message.id;
      if (t1 != null)
        C.JSArray_methods.add$1(this.$this._dismissedMessageIds, t1);
      t1 = this.$this._messages.$index(0, this.screenId);
      if (t1 != null)
        J.remove$1$ax(t1, _message);
    },
    $signature: 158
  };
  X.MessageManager_addMessage_closure0.prototype = {
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(X.Message);
    },
    $signature: 159
  };
  X.Message.prototype = {
    _buildFlash$0: function() {
      var t2, t3, _i, _this = this, _null = null,
        t1 = _this.messageType;
      if (t1 === C.MessageType_1)
        _this.flash.clazz$1("flash-warn");
      else if (t1 === C.MessageType_2)
        _this.flash.clazz$1("flash-error");
      t1 = _this.flash;
      H.interceptedTypeCheck(t1.add$1(0, A.CoreElement$("span", _null, "octicon octicon-x flash-close js-flash-close", _null, _null)), "$isCoreElement").click$1(0, new X.Message__buildFlash_closure(_this));
      t2 = _this.title;
      if (t2 != null)
        t1.add$1(0, A.label(t2));
      t2 = _this.message;
      if (t2 != null)
        for (t2 = t2.split("\n\n"), t3 = t2.length, _i = 0; _i < t3; ++_i)
          t1.add$1(0, A.CoreElement$("div", _null, _null, _null, t2[_i]));
      t2 = _this.children;
      if (t2 != null)
        C.JSArray_methods.forEach$1(t2, t1.get$add(t1));
    },
    get$id: function(receiver) {
      return this.id;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  X.Message__buildFlash_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      J.remove$0$ax(t1.flash.element);
      t1._dismissController.add$1(0, t1);
    },
    $signature: 0
  };
  X.MessageType.prototype = {
    toString$0: function(_) {
      return this._message_manager$_name;
    }
  };
  R.App.prototype = {
    _bind$0: function() {
      var binding = P.JsObject_JsObject$jsify(P.LinkedHashMap__makeEmpty());
      binding.$indexSet(0, "send", new R.App__bind_closure(this));
      $.$get$context().$indexSet(0, "devtools", binding);
    },
    devToolsReady$1: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$devToolsReady$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._sendNotification$2("app.devToolsReady", message);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$devToolsReady$1, $async$completer);
    },
    echo$1: function(message) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$echo$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._sendNotification$2("app.echo", message);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$echo$1, $async$completer);
    },
    switchPage$1: function(pageId) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, $screen, t1;
      var $async$switchPage$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.framework;
              H.stringTypeCheck(pageId);
              $screen = t1.getScreen$1(pageId);
              if ($screen == null)
                throw H.wrapException("page " + H.S(pageId) + " not found");
              t1.load$1(0, $screen);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$switchPage$1, $async$completer);
    },
    currentPageId$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1;
      var $async$currentPageId$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.framework.current;
              $async$returnValue = t1 == null ? null : t1.id;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$currentPageId$1, $async$completer);
    },
    currentPageId$0: function() {
      return this.currentPageId$1(null);
    },
    connectDialogIsVisible$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this;
      var $async$connectDialogIsVisible$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.framework.connectDialog.parent.element.style.display !== "none";
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$connectDialogIsVisible$1, $async$completer);
    },
    connectDialogIsVisible$0: function() {
      return this.connectDialogIsVisible$1(null);
    },
    connectDialogConnectTo$1: function(uri) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this;
      var $async$connectDialogConnectTo$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.framework.connectDialog.connectTo$1(P.Uri_parse(H.stringTypeCheck(uri), 0, null));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$connectDialogConnectTo$1, $async$completer);
    },
    connectDialogConnectTo$0: function() {
      return this.connectDialogConnectTo$1(null);
    },
    logsClearLogs$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$logsClearLogs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.interceptedTypeCheck($async$self.framework.getScreen$1("logging"), "$isLoggingScreen").loggingTable.setRows$1(H.setRuntimeTypeInfo([], [Y.LogData]));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$logsClearLogs$1, $async$completer);
    },
    logsClearLogs$0: function() {
      return this.logsClearLogs$1(null);
    },
    logsLogCount$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.int),
        $async$returnValue, $async$self = this, t1;
      var $async$logsLogCount$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($async$self.framework.getScreen$1("logging"), "$isLoggingScreen").loggingTable;
              $async$returnValue = t1.get$rowCount(t1);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$logsLogCount$1, $async$completer);
    },
    logsLogCount$0: function() {
      return this.logsLogCount$1(null);
    },
    debuggerGetState$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this;
      var $async$debuggerGetState$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = H.boolConversionCheck(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState._paused._wrapper.latestValue) ? "paused" : "running";
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetState$1, $async$completer);
    },
    debuggerGetState$0: function() {
      return this.debuggerGetState$1(null);
    },
    debuggerGetConsoleContents$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this;
      var $async$debuggerGetConsoleContents$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = H.stringTypeCheck(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").consoleArea._editor.getDoc$0().jsProxy.callMethod$2("getValue", [null]));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetConsoleContents$1, $async$completer);
    },
    debuggerGetConsoleContents$0: function() {
      return this.debuggerGetConsoleContents$1(null);
    },
    debuggerGetLocation$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.String),
        $async$returnValue, $async$self = this, t1, t2, scriptAndPos;
      var $async$debuggerGetLocation$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              scriptAndPos = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").sourceEditor.executionPoint;
              if (scriptAndPos == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = H.S(scriptAndPos.script.uri) + ":";
              t2 = scriptAndPos.position.line;
              if (typeof t2 !== "number") {
                $async$returnValue = t2.$sub();
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = t1 + (t2 - 1);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetLocation$1, $async$completer);
    },
    debuggerGetLocation$0: function() {
      return this.debuggerGetLocation$1(null);
    },
    debuggerResume$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$debuggerResume$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState;
              $async$goto = 2;
              return P._asyncAwait(t1._service.resume$1(0, t1.isolateRef.id), $async$debuggerResume$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerResume$1, $async$completer);
    },
    debuggerResume$0: function() {
      return this.debuggerResume$1(null);
    },
    debuggerPause$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t3, t4, t1, t2;
      var $async$debuggerPause$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState;
              t2 = t1._service;
              t1 = t1.isolateRef.id;
              t3 = t2._vmService;
              t3.toString;
              t4 = S.Success;
              $async$goto = 2;
              return P._asyncAwait(t2._trackFuture$1$2("pause", t3._call$1$2(0, "pause", P.LinkedHashMap__makeLiteral(["isolateId", t1]), t4), t4), $async$debuggerPause$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerPause$1, $async$completer);
    },
    debuggerPause$0: function() {
      return this.debuggerPause$1(null);
    },
    debuggerStep$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$debuggerStep$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.stepOver$0(), $async$debuggerStep$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerStep$1, $async$completer);
    },
    debuggerStep$0: function() {
      return this.debuggerStep$1(null);
    },
    debuggerClearBreakpoints$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$debuggerClearBreakpoints$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.clearBreakpoints$0(), $async$debuggerClearBreakpoints$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerClearBreakpoints$1, $async$completer);
    },
    debuggerClearBreakpoints$0: function() {
      return this.debuggerClearBreakpoints$1(null);
    },
    debuggerGetBreakpoints$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
        $async$returnValue, $async$self = this;
      var $async$debuggerGetBreakpoints$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState._breakpoints._wrapper.latestValue, new R.App_debuggerGetBreakpoints_closure(), P.String).toList$0(0);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetBreakpoints$1, $async$completer);
    },
    debuggerGetBreakpoints$0: function() {
      return this.debuggerGetBreakpoints$1(null);
    },
    debuggerSupportsScripts$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue;
      var $async$debuggerSupportsScripts$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").get$serviceCapabilities(), $async$debuggerSupportsScripts$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result.get$supportsGetScripts();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerSupportsScripts$1, $async$completer);
    },
    debuggerSupportsScripts$0: function() {
      return this.debuggerSupportsScripts$1(null);
    },
    debuggerGetScripts$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
        $async$returnValue, $async$self = this;
      var $async$debuggerGetScripts$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").scriptsView._scripts_view$_items.items, new R.App_debuggerGetScripts_closure(), P.String).toList$0(0);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetScripts$1, $async$completer);
    },
    debuggerGetScripts$0: function() {
      return this.debuggerGetScripts$1(null);
    },
    debuggerGetCallStackFrames$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
        $async$returnValue, $async$self = this;
      var $async$debuggerGetCallStackFrames$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = J.map$1$1$ax(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").callStackView._callstack_view$_items.items, new R.App_debuggerGetCallStackFrames_closure(), P.String).toList$0(0);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetCallStackFrames$1, $async$completer);
    },
    debuggerGetCallStackFrames$0: function() {
      return this.debuggerGetCallStackFrames$1(null);
    },
    debuggerGetVariables$1: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.List, P.String]),
        $async$returnValue, $async$self = this, t3, t1, t2;
      var $async$debuggerGetVariables$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").variablesView._items.items;
              t2 = P.String;
              t1.toString;
              t3 = H.getTypeArgumentByIndex(t1, 0);
              $async$returnValue = new H.MappedListIterable(t1, H.functionTypeCheck(new R.App_debuggerGetVariables_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]).toList$0(0);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerGetVariables$1, $async$completer);
    },
    debuggerGetVariables$0: function() {
      return this.debuggerGetVariables$1(null);
    },
    debuggerAddBreakpoint$1: function(params) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, path, line;
      var $async$debuggerAddBreakpoint$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$asx(params);
              path = H.stringTypeCheck(t1.$index(params, 0));
              line = H.intTypeCheck(J.$add$ansx(t1.$index(params, 1), 1));
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState.addBreakpointByPathFragment$2(path, line), $async$debuggerAddBreakpoint$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerAddBreakpoint$1, $async$completer);
    },
    debuggerAddBreakpoint$0: function() {
      return this.debuggerAddBreakpoint$1(null);
    },
    debuggerSetExceptionPauseMode$1: function(params) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2;
      var $async$debuggerSetExceptionPauseMode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              H.stringTypeCheck(params);
              t1 = H.interceptedTypeCheck($async$self.framework.getScreen$1("debugger"), "$isDebuggerScreen").debuggerState;
              t2 = t1._service;
              t1 = t1.isolateRef.id;
              $async$goto = 2;
              return P._asyncAwait(t2._trackFuture$1$2("setExceptionPauseMode", t2._vmService.setExceptionPauseMode$2(t1, params), S.Success), $async$debuggerSetExceptionPauseMode$1);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$debuggerSetExceptionPauseMode$1, $async$completer);
    },
    debuggerSetExceptionPauseMode$0: function() {
      return this.debuggerSetExceptionPauseMode$1(null);
    },
    _sendNotification$2: function($event, params) {
      var map = P.LinkedHashMap_LinkedHashMap$_literal(["event", $event], P.String, null);
      if (params != null)
        map.$indexSet(0, "params", params);
      P.print("[" + C.C_JsonCodec.encode$2$toEncodable(map, null) + "]");
    },
    _sendReponseError$3: function(id, error, stackTrace) {
      var t1;
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      t1 = P.String;
      P.print("[" + C.C_JsonCodec.encode$2$toEncodable(P.LinkedHashMap_LinkedHashMap$_literal(["id", id, "error", P.LinkedHashMap_LinkedHashMap$_literal(["message", J.toString$0$(error), "stackTrace", J.toString$0$(stackTrace)], t1, t1)], t1, null), null) + "]");
    },
    _dispatch$3: function(method, id, arg) {
      var handler = this._handlers.$index(0, method);
      if (handler != null)
        return handler.call$1(arg);
      else {
        P.print("handler not found for " + H.S(method) + "()");
        throw H.wrapException("no handler found for " + H.S(method) + "()");
      }
    },
    _register$1$2: function(idMethod, fn, $T) {
      this._handlers.$indexSet(0, idMethod, H.functionTypeCheck(fn, {func: 1, ret: [P.Future, $T], args: [,]}));
    }
  };
  R.App__bind_closure.prototype = {
    call$3: function(method, id, arg) {
      var result, error, stackTrace, t1, t2, exception;
      H.stringTypeCheck(method);
      H.intTypeCheck(id);
      try {
        t1 = this.$this;
        result = t1._dispatch$3(method, id, arg);
        t2 = new P._Future($.Zone__current, [null]);
        t2._asyncComplete$1(result);
        t2.then$1$1(new R.App__bind__closure(t1, id), null).catchError$1(new R.App__bind__closure0(t1, id));
      } catch (exception) {
        error = H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        this.$this._sendReponseError$3(id, error, stackTrace);
      }
    },
    "call*": "call$3",
    $requiredArgCount: 3,
    $signature: 166
  };
  R.App__bind__closure.prototype = {
    call$1: function(result) {
      var map = P.LinkedHashMap_LinkedHashMap$_literal(["id", this.id], P.String, null);
      if (result != null)
        map.$indexSet(0, "result", result);
      P.print("[" + C.C_JsonCodec.encode$2$toEncodable(map, null) + "]");
    },
    $signature: 2
  };
  R.App__bind__closure0.prototype = {
    call$2: function(error, stackTrace) {
      H.interceptedTypeCheck(stackTrace, "$isStackTrace");
      this.$this._sendReponseError$3(this.id, error, stackTrace);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 31
  };
  R.App_debuggerGetBreakpoints_closure.prototype = {
    call$1: function(breakpoint) {
      return H.interceptedTypeCheck(breakpoint, "$isBreakpoint").id;
    },
    $signature: 167
  };
  R.App_debuggerGetScripts_closure.prototype = {
    call$1: function(script) {
      return H.interceptedTypeCheck(script, "$isScriptRef").uri;
    },
    $signature: 168
  };
  R.App_debuggerGetCallStackFrames_closure.prototype = {
    call$1: function(frame) {
      var t1, $name, desc;
      H.interceptedTypeCheck(frame, "$isFrame");
      t1 = frame.code;
      $name = t1 == null ? null : t1.name;
      if ($name == null)
        $name = "<none>";
      if (C.JSString_methods.startsWith$1($name, "[Unoptimized] "))
        $name = C.JSString_methods.substring$1($name, 14);
      if (frame.kind === "AsyncSuspensionMarker") {
        $name = "<async break>";
        desc = "";
      } else {
        desc = H.S(frame.location.script.uri);
        desc = ":" + (C.JSString_methods.contains$1(desc, "/") ? C.JSString_methods.substring$1(desc, C.JSString_methods.lastIndexOf$1(desc, "/") + 1) : desc);
      }
      return $name + desc;
    },
    $signature: 169
  };
  R.App_debuggerGetVariables_closure.prototype = {
    call$1: function(variable) {
      var value, t1, valueStr;
      H.interceptedTypeCheck(variable, "$isBoundVariable");
      value = variable.value;
      t1 = J.getInterceptor$(value);
      if (!!t1.$isInstanceRef) {
        valueStr = value.valueAsString;
        if (valueStr == null)
          valueStr = value.classRef.name;
      } else
        valueStr = !!t1.$isSentinel ? value.valueAsString : t1.toString$0(value);
      return H.S(variable.name) + ":" + H.S(valueStr);
    },
    $signature: 170
  };
  V.PerformanceScreen.prototype = {
    createContent$1: function(framework) {
      var container, t2, t3, t4, t5, t6, t7, _this = this, _null = null, _s3_ = "div", _s6_ = "layout",
        _s8_ = "vertical",
        _s7_ = "section",
        _s6_0 = "button",
        screenDiv = A.CoreElement$(_s3_, _null, "custom-scrollbar", _null, _null),
        t1 = screenDiv.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute(_s8_, "");
      container = A.CoreElement$(_s3_, _null, "section perf-chart table-border", _null, _null);
      t1 = container.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute(_s8_, "");
      t1 = new V.CpuChart(container, new N.SetStateMixin());
      t1.LineChart$2$classes(container, "perf-chart", V.CpuTracker);
      t2 = H.interceptedTypeCheck(container.add$1(0, A.CoreElement$(_s3_, _null, "perf-label", _null, _null)), "$isCoreElement");
      t1.usageLabel = t2;
      t2 = t2.element.style;
      t2.right = "0";
      _this.cpuChart = t1;
      container.attribute$2("disabled", true);
      t1 = A.CoreElement$(_s3_, _null, _s7_, _null, _null);
      t2 = A.CoreElement$(_s3_, _null, _s7_, _null, _null);
      t3 = A.CoreElement$("form", _null, _null, _null, _null);
      t4 = t3.element;
      t4.setAttribute(_s6_, "");
      t4.setAttribute("horizontal", "");
      t3.clazz$1("align-items-center");
      t4 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_0, _null), "$isElement");
      t5 = new N.PButton(t4);
      t5.CoreElement$5$attributes$classes$html$text(_s6_0, _null, "btn", _null, "Load snapshot");
      t4.setAttribute("type", _s6_0);
      t5.clazz$1("btn-sm");
      t5.clazz$1("btn-primary");
      t5.click$1(0, _this.get$_loadSnapshot());
      _this.loadSnapshotButton = t5;
      t4 = A.CoreElement$("span", _null, "margin-left text-gray", _null, _null);
      t4.flex$0(0);
      _this.progressElement = t4;
      t6 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s6_0, _null), "$isElement");
      t7 = new N.PButton(t6);
      t7.CoreElement$5$attributes$classes$html$text(_s6_0, _null, "btn", _null, "Reset VM counters");
      t6.setAttribute("type", _s6_0);
      t7.clazz$1("btn-sm");
      t7.click$1(0, _this.get$_reset());
      _this.resetButton = t7;
      t6 = [A.CoreElement];
      t3.add$1(0, H.setRuntimeTypeInfo([t5, t4, t7], t6));
      t2.add$1(0, H.setRuntimeTypeInfo([t3], t6));
      t3 = _this._createTableView$0();
      t3.clazz$1(_s7_);
      screenDiv.add$1(0, H.setRuntimeTypeInfo([container, t1, t2, t3], t6));
      _this._performance$_updateStatus$1(_null);
      t6 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolateController;
      new P._BroadcastStream(t6, [H.getTypeArgumentByIndex(t6, 0)]).listen$1(new V.PerformanceScreen_createContent_closure(_this));
      t6 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
      new P._BroadcastStream(t6, [H.getTypeArgumentByIndex(t6, 0)]).listen$1(_this.get$_performance$_handleConnectionStart());
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
        _this._performance$_handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(_this.get$_performance$_handleConnectionStop());
      return screenDiv;
    },
    _loadSnapshot$0: function() {
      var t1, t2, t3, t4, _this = this;
      _this.loadSnapshotButton.attribute$2("disabled", true);
      _this.progressElement.element.textContent = "Loading snapshot\u2026";
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id;
      t3 = t1._vmService;
      t3.toString;
      t4 = S.CpuProfile;
      t1._trackFuture$1$2("getCpuProfile", t3._call$1$2(0, "_getCpuProfile", P.LinkedHashMap__makeLiteral(["isolateId", t2, "tags", "UserVM"]), t4), t4).then$1$1(new V.PerformanceScreen__loadSnapshot_closure(_this), P.Null).catchError$1(new V.PerformanceScreen__loadSnapshot_closure0(_this)).whenComplete$1(new V.PerformanceScreen__loadSnapshot_closure1(_this));
    },
    _reset$0: function() {
      var t1, t2, t3, t4, _this = this;
      _this.resetButton.attribute$2("disabled", true);
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id;
      t3 = t1._vmService;
      t3.toString;
      t4 = S.Success;
      t1._trackFuture$1$2("clearCpuProfile", t3._call$1$2(0, "_clearCpuProfile", P.LinkedHashMap__makeLiteral(["isolateId", t2]), t4), t4).then$1$1(new V.PerformanceScreen__reset_closure(_this), null).catchError$1(new V.PerformanceScreen__reset_closure0(_this)).whenComplete$1(new V.PerformanceScreen__reset_closure1(_this));
    },
    _createTableView$0: function() {
      var t2, t3, _this = this, _null = null,
        t1 = V.PerfData;
      _this.set$perfTable(Q.Table$virtual(false, 29, t1));
      t2 = _this.perfTable;
      t3 = new V.PerfColumnInclusive("Total", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Total", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      t2.toString;
      H.assertSubtype(t3, "$isColumn", [H.getTypeArgumentByIndex(t2, 0)], "$asColumn");
      C.JSArray_methods.add$1(t2.columns, t3);
      t3 = _this.perfTable;
      t2 = new V.PerfColumnSelf("Self", _null, _null, C.ColumnAlignment_0, false, _null, false);
      t2.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Self", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      t3.toString;
      H.assertSubtype(t2, "$isColumn", [H.getTypeArgumentByIndex(t3, 0)], "$asColumn");
      C.JSArray_methods.add$1(t3.columns, t2);
      t2 = _this.perfTable;
      t2.toString;
      t3 = H.assertSubtype(new V.PerfColumnMethodName("Method", _null, 100, C.ColumnAlignment_0, false, _null, false), "$isColumn", [H.getTypeArgumentByIndex(t2, 0)], "$asColumn");
      C.JSArray_methods.add$1(t2.columns, t3);
      t3 = _this.perfTable;
      t3.set$sortColumn(C.JSArray_methods.get$first(t3.columns));
      _this.perfTable.setRows$1(H.setRuntimeTypeInfo([], [t1]));
      t1 = _this.perfTable._selectController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new V.PerformanceScreen__createTableView_closure());
      return _this.perfTable.element;
    },
    _performance$_updateStatus$1: function(profile) {
      var s, _this = this;
      if (profile == null) {
        _this.sampleCountStatus.element.element.textContent = "";
        _this.sampleFreqStatus.element.element.textContent = "";
      } else {
        s = P.Duration$(0, 0, 0, J.round$0$n(profile.timeSpan)).toString$0(0);
        s = C.JSString_methods.substring$2(s, 0, s.length - 7);
        _this.sampleCountStatus.element.element.textContent = $.$get$nf().format$1(profile.sampleCount) + " samples over " + s;
        _this.sampleFreqStatus.element.element.textContent = H.S(profile.stackDepth) + " frames per sample @ " + H.S(profile.samplePeriod) + "Hz";
        _this._performance$_process$1(profile);
      }
    },
    _performance$_process$1: function(profile) {
      var t1 = this.perfTable,
        t2 = profile.functions,
        t3 = H.getTypeArgumentByIndex(t2, 0),
        t4 = V.PerfData;
      t1.setRows$1(P.List_List$from(new H.MappedIterable(new H.WhereIterable(t2, H.functionTypeCheck(new V.PerformanceScreen__process_closure(), {func: 1, ret: P.bool, args: [t3]}), [t3]), H.functionTypeCheck(new V.PerformanceScreen__process_closure0(profile), {func: 1, ret: t4, args: [t3]}), [t3, t4]), true, t4));
    },
    _performance$_handleConnectionStart$1: function(service) {
      var t1, _this = this;
      H.interceptedTypeCheck(service, "$isVmServiceWrapper");
      _this.cpuChart.parent.attribute$2("disabled", false);
      t1 = _this.cpuTracker = new V.CpuTracker(service, new P._AsyncBroadcastStreamController(null, null, [P.Null]), H.setRuntimeTypeInfo([], [P.int]));
      t1._pollingTimer = P.Timer_Timer(C.Duration_100000, t1.get$_pollCpu());
      t1 = _this.cpuTracker._performance$_changeController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new V.PerformanceScreen__handleConnectionStart_closure(_this));
    },
    _performance$_handleConnectionStop$1: function($event) {
      var t1, t2;
      this.cpuChart.parent.attribute$2("disabled", true);
      t1 = this.cpuTracker;
      if (t1 != null) {
        t2 = t1._pollingTimer;
        if (t2 != null)
          t2.cancel$0(0);
        t1.service = null;
      }
    },
    set$perfTable: function(perfTable) {
      this.perfTable = H.assertSubtype(perfTable, "$isTable", [V.PerfData], "$asTable");
    }
  };
  V.PerformanceScreen_createContent_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isIsolateRef");
    },
    $signature: 35
  };
  V.PerformanceScreen__loadSnapshot_closure.prototype = {
    call$1: function(profile) {
      return this.$call$body$PerformanceScreen__loadSnapshot_closure(H.interceptedTypeCheck(profile, "$isCpuProfile"));
    },
    $call$body$PerformanceScreen__loadSnapshot_closure: function(profile) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(new V._CalcProfile().calc$0(), $async$call$1);
            case 2:
              // returning from await.
              $async$self.$this._performance$_updateStatus$1(profile);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 171
  };
  V.PerformanceScreen__loadSnapshot_closure0.prototype = {
    call$1: function(e) {
      this.$this.framework.showError$2("Error loading snapshot", e);
    },
    $signature: 2
  };
  V.PerformanceScreen__loadSnapshot_closure1.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.loadSnapshotButton.attribute$2("disabled", false);
      t1.progressElement.element.textContent = "";
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  V.PerformanceScreen__reset_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isSuccess");
      this.$this.framework.toast$1("VM counters reset.");
    },
    $signature: 172
  };
  V.PerformanceScreen__reset_closure0.prototype = {
    call$1: function(e) {
      this.$this.framework.showError$2("Error resetting counters", e);
    },
    $signature: 2
  };
  V.PerformanceScreen__reset_closure1.prototype = {
    call$0: function() {
      this.$this.resetButton.attribute$2("disabled", false);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  V.PerformanceScreen__createTableView_closure.prototype = {
    call$1: function(data) {
      P.print(H.interceptedTypeCheck(data, "$isPerfData"));
    },
    $signature: 173
  };
  V.PerformanceScreen__process_closure.prototype = {
    call$1: function(f) {
      var t1;
      H.interceptedTypeCheck(f, "$isProfileFunction");
      t1 = f.inclusiveTicks;
      if (typeof t1 !== "number")
        return t1.$gt();
      if (t1 <= 0) {
        t1 = f.exclusiveTicks;
        if (typeof t1 !== "number")
          return t1.$gt();
        t1 = t1 > 0;
      } else
        t1 = true;
      return t1;
    },
    $signature: 174
  };
  V.PerformanceScreen__process_closure0.prototype = {
    call$1: function(f) {
      var count, t1, t2, t3, t4;
      H.interceptedTypeCheck(f, "$isProfileFunction");
      count = Math.max(1, H.checkNum(this.profile.sampleCount));
      t1 = f.kind;
      t2 = B.funcRefName(f.$function);
      t2 = t2 == null ? "" : C.C_HtmlEscape.convert$1(t2);
      t3 = f.exclusiveTicks;
      if (typeof t3 !== "number")
        return t3.$div();
      t4 = f.inclusiveTicks;
      if (typeof t4 !== "number")
        return t4.$div();
      return new V.PerfData(t1, t2, t3 / count, t4 / count);
    },
    $signature: 175
  };
  V.PerformanceScreen__handleConnectionStart_closure.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isNull");
      t1 = this.$this;
      t1.cpuChartStateMixin.setState$1(new V.PerformanceScreen__handleConnectionStart__closure(t1));
    },
    $signature: 67
  };
  V.PerformanceScreen__handleConnectionStart__closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1.cpuChart;
      t1 = t1.cpuTracker;
      t2.toString;
      H.assertSubtypeOfRuntimeType(t1, H.getRuntimeTypeArgument(t2, "LineChart", 0));
      t2.set$data(0, t1);
      t2.update$1(0, t1);
    },
    $signature: 0
  };
  V.CpuChart.prototype = {
    update$1: function(_, data) {
      data.samples;
      return;
    },
    $asLineChart: function() {
      return [V.CpuTracker];
    }
  };
  V.CpuTracker.prototype = {
    _pollCpu$0: function() {
      if (this.service == null)
        return;
      this._pollingTimer = P.Timer_Timer(C.Duration_1000000, this.get$_pollCpu());
    }
  };
  V.PerfData.prototype = {
    toString$0: function(_) {
      return "[" + H.S(this.kind) + "] " + this.name;
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  V.PerfColumnInclusive.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isPerfData").inclusive;
    },
    render$1: function(value) {
      H.doubleTypeCheck(value);
      if (typeof value !== "number")
        return value.$mul();
      return C.JSNumber_methods.toStringAsFixed$1(value * 100, 2) + "%";
    },
    $asColumn: function() {
      return [V.PerfData];
    }
  };
  V.PerfColumnSelf.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isPerfData").self;
    },
    render$1: function(value) {
      H.doubleTypeCheck(value);
      if (typeof value !== "number")
        return value.$mul();
      return C.JSNumber_methods.toStringAsFixed$1(value * 100, 2) + "%";
    },
    $asColumn: function() {
      return [V.PerfData];
    }
  };
  V.PerfColumnMethodName.prototype = {
    get$usesHtml: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      var t1;
      H.interceptedTypeCheck(dataObject, "$isPerfData");
      t1 = dataObject.kind;
      if (t1 === "Dart")
        return dataObject.name;
      return dataObject.name + ' <span class="function-kind ' + H.S(t1) + '">' + H.S(t1) + "</span>";
    },
    $asColumn: function() {
      return [V.PerfData];
    }
  };
  V._CalcProfile.prototype = {
    calc$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1);
      var $async$calc$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$calc$0, $async$completer);
    }
  };
  E.ListDirection0.prototype = {
    toString$0: function(_) {
      return this._popup$_name;
    }
  };
  E.PopupListView.prototype = {
    PopupListView$0: function($T) {
      var _null = null,
        t1 = H.setRuntimeTypeInfo([], [$T]),
        t2 = [$T];
      t1 = new N.SelectableList(t1, new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, [-1]), H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement"), [$T]);
      t1.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t1.flex$0(0);
      t1.clazz$1("popup-items-list");
      this.set$items(0, t1);
      t1 = this.items;
      t1.set$renderer(H.functionTypeCheck(new E.PopupListView_closure(this, $T), {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(t1, 0)]}));
    },
    scrollAndHighlight$3$top: function(row, topPosition, $top) {
      var newElement, t1, _this = this;
      _this.set$highlightedItem(J.$index$asx(_this.items.items, row));
      newElement = H.functionTypeCheck(_this.items.renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(_this, 0)]}).call$1(_this.highlightedItem);
      _this.items.setReplace$2(row, _this.highlightedItem);
      if (topPosition !== -1) {
        t1 = _this.items.element;
        t1.toString;
        t1.scrollTop = C.JSInt_methods.round$0(topPosition);
      }
      if (newElement != null)
        newElement.scrollIntoView$2$bottom$top(0, false, $top);
    },
    scrollAndHighlight$2: function(row, topPosition) {
      return this.scrollAndHighlight$3$top(row, topPosition, false);
    },
    page$2: function(_, direction, startRow) {
      var itemsVis, itemIndex, childToScrollTo, _this = this,
        t1 = _this.items.element,
        listHeight = t1.clientHeight,
        itemHeight = J.get$children$x(t1).$index(0, 0).clientHeight;
      if (typeof listHeight !== "number")
        return listHeight.$div();
      if (typeof itemHeight !== "number")
        return H.iae(itemHeight);
      itemsVis = C.JSDouble_methods.toInt$0(listHeight / itemHeight) - 1;
      switch (direction) {
        case C.ListDirection_10:
          if (typeof startRow !== "number")
            return startRow.$add();
          itemIndex = startRow + itemsVis;
          t1 = J.get$length$asx(_this.items.items);
          if (typeof t1 !== "number")
            return t1.$sub();
          if (itemIndex > t1 - 1) {
            t1 = J.get$length$asx(_this.items.items);
            if (typeof t1 !== "number")
              return t1.$sub();
            itemIndex = t1 - 1;
          }
          _this.scrollAndHighlight$3$top(itemIndex, startRow > 0 ? startRow * itemHeight : 0, true);
          childToScrollTo = itemIndex;
          break;
        case C.ListDirection_00:
          if (typeof startRow !== "number")
            return startRow.$sub();
          itemIndex = startRow - itemsVis;
          if (itemIndex < 0)
            itemIndex = 0;
          _this.scrollAndHighlight$3$top(itemIndex, itemIndex > 0 ? itemIndex * itemHeight : 0, true);
          childToScrollTo = itemIndex;
          break;
        case C.ListDirection_20:
          _this.scrollAndHighlight$2(0, 0);
          childToScrollTo = 0;
          break;
        case C.ListDirection_30:
          t1 = J.get$length$asx(_this.items.items);
          if (typeof t1 !== "number")
            return t1.$sub();
          childToScrollTo = t1 - 1;
          _this.scrollAndHighlight$2(childToScrollTo, childToScrollTo > 0 ? (childToScrollTo - itemsVis) * itemHeight : 0);
          break;
        default:
          childToScrollTo = null;
      }
      return childToScrollTo;
    },
    page$1: function($receiver, direction) {
      return this.page$2($receiver, direction, 0);
    },
    get$element: function() {
      return this.items;
    },
    setList$2$select: function(theItems, select) {
      var selection, _this = this;
      H.assertSubtype(theItems, "$isList", _this.$ti, "$asList");
      H.assertSubtypeOfRuntimeType(select, H.getTypeArgumentByIndex(_this, 0));
      J.sort$1$ax(theItems, new E.PopupListView_setList_closure(_this));
      selection = select != null ? select : null;
      _this.items.setItems$3$scrollSelectionIntoView$selection(theItems, true, selection);
    },
    setList$1: function(theItems) {
      return this.setList$2$select(theItems, null);
    },
    set$items: function(_, items) {
      this.items = H.assertSubtype(items, "$isSelectableList", this.$ti, "$asSelectableList");
    },
    set$highlightedItem: function(highlightedItem) {
      this.highlightedItem = H.assertSubtypeOfRuntimeType(highlightedItem, H.getTypeArgumentByIndex(this, 0));
    },
    $isCoreElementView: 1
  };
  E.PopupListView_closure.prototype = {
    call$1: function(item) {
      var matchPart, startIndex, firstPart, endBoldIndex, boldPart, endPart, element, _null = null,
        _s9_ = "list-item",
        $name = J.toString$0$(H.assertSubtypeOfRuntimeType(item, this.T)),
        t1 = this.$this._popupAutoCompleteView._popup$_matcher;
      if (t1 != null && t1._popup$_subscription != null) {
        matchPart = H.interceptedTypeCast(t1._textField.element, "$isInputElement").value;
        startIndex = J.getInterceptor$s($name).lastIndexOf$1($name, matchPart);
        firstPart = C.JSString_methods.substring$2($name, 0, startIndex);
        endBoldIndex = startIndex + matchPart.length;
        boldPart = C.JSString_methods.substring$2($name, startIndex, endBoldIndex);
        endPart = C.JSString_methods.substring$1($name, endBoldIndex);
        element = A.CoreElement$("li", _null, _s9_, J.get$innerHtml$x(W.Element_Element$html("<div>" + firstPart + '<strong class="strong-match">' + boldPart + "</strong>" + endPart + "</div>", _null, _null)), _null);
      } else
        element = A.CoreElement$("li", _null, _s9_, _null, $name);
      return element;
    },
    $signature: function() {
      return {func: 1, ret: A.CoreElement, args: [this.T]};
    }
  };
  E.PopupListView_setList_closure.prototype = {
    call$2: function(item1, item2) {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      H.assertSubtypeOfRuntimeType(item1, t1);
      H.assertSubtypeOfRuntimeType(item2, t1);
      return J.compareTo$1$ns(J.toString$0$(item1), J.toString$0$(item2));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  E.PopupAutoCompleteView.prototype = {
    _popup$_initialize$0: function() {
      var t1, t2, _this = this;
      _this._listView._popupAutoCompleteView = _this;
      _this._popup$_hookupListeners$0();
      t1 = _this._popup$_popupTextfield;
      t1.focus$1(0, new E.PopupAutoCompleteView__initialize_closure(_this));
      t1.blur$1(0, new E.PopupAutoCompleteView__initialize_closure0(_this));
      t1 = J.get$onKeyUp$x(t1.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new E.PopupAutoCompleteView__initialize_closure1(_this), {func: 1, ret: -1, args: [t2]}), false, t2);
    },
    _popup$_hookupListeners$0: function() {
      var t1 = this._listView.items._selectionController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new E.PopupAutoCompleteView__hookupListeners_closure(this));
    }
  };
  E.PopupAutoCompleteView__initialize_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._popup$_matcher;
      if (t2 == null)
        t2 = t1._popup$_matcher = new E.AutoCompleteMatcher(P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List,,]), [null]);
      if (t2._popup$_subscription == null)
        t2.start$4(0, "", t1._listView, t1._popup$_popupTextfield, t1._completeAction);
    },
    $signature: 0
  };
  E.PopupAutoCompleteView__initialize_closure0.prototype = {
    call$0: function() {
      P.Timer_Timer(C.Duration_200000, new E.PopupAutoCompleteView__initialize__closure(this.$this));
    },
    $signature: 0
  };
  E.PopupAutoCompleteView__initialize__closure.prototype = {
    call$0: function() {
      var t1 = this.$this._popup$_matcher;
      return t1 == null ? null : t1.finish$1(0, true);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  E.PopupAutoCompleteView__initialize_closure1.prototype = {
    call$1: function(e) {
      var t1, value;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      switch (e.keyCode) {
        case 13:
        case 27:
        case 33:
        case 34:
        case 35:
        case 36:
        case 38:
        case 40:
          return;
        default:
          if (H.boolConversionCheck(e.ctrlKey) || e.key === "Control")
            e.preventDefault();
          else {
            t1 = this.$this;
            value = J.trim$0$s(H.interceptedTypeCheck(t1._popup$_popupTextfield.element, "$isInputElement").value);
            t1._popup$_matcher.displayMatchingItems$1(value);
          }
      }
    },
    $signature: 14
  };
  E.PopupAutoCompleteView__hookupListeners_closure.prototype = {
    call$1: function(classSelected) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t4, t1, t2, t3;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = t1._listView;
              t3 = t2.items._hadClicked;
              if (t3) {
                t4 = t1._popup$_matcher;
                t4 = t4 != null && t4._popup$_subscription != null;
              } else
                t4 = false;
              if (t4) {
                if (t3) {
                  t2.set$highlightedItem(classSelected);
                  t2 = t1._popup$_matcher;
                  if (t2 != null)
                    t2.finish$1(0, false);
                }
                t1._popup$_matcher.reset$0(0);
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 176
  };
  E.AutoCompleteMatcher.prototype = {
    finish$1: function(_, cancel) {
      var t1 = this._popup$_finishCallback;
      if (t1 != null)
        t1.call$1(cancel);
    },
    finish$0: function($receiver) {
      return this.finish$1($receiver, false);
    },
    start$4: function(_, revert, listView, textfield, finishCallback) {
      var t1, t2, _this = this;
      H.assertSubtypeOfRuntimeType(revert, H.getTypeArgumentByIndex(_this, 0));
      H.assertSubtype(listView, "$isPopupListView", _this.$ti, "$asPopupListView");
      H.functionTypeCheck(finishCallback, {func: 1, ret: -1, opt: [P.bool]});
      _this._listView = listView;
      _this._textField = textfield;
      _this.set$_popup$_finishCallback(finishCallback);
      _this._popup$_startMatching$2(revert, true);
      if (_this._popup$_subscription == null) {
        t1 = J.get$onKeyDown$x(_this._textField.element);
        t2 = H.getTypeArgumentByIndex(t1, 0);
        _this._popup$_subscription = W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new E.AutoCompleteMatcher_start_closure(_this, listView), {func: 1, ret: -1, args: [t2]}), false, t2);
      }
    },
    selectFirstItem$0: function() {
      this._popup$_selectRow = 0;
      this._listView.scrollAndHighlight$2(0, -1);
    },
    reset$0: function(_) {
      var originals, _this = this,
        t1 = _this._listView,
        t2 = t1.items,
        selected = t2._hadClicked ? H.stringTypeCheck(t2.selectedItem$0()) : H.stringTypeCheck(t1.highlightedItem);
      t1 = _this._popup$_subscription;
      if (t1 != null) {
        t1.cancel$0(0);
        _this._popup$_subscription = null;
      }
      t1 = _this.matchingState;
      originals = t1.$index(0, "");
      _this._listView.setList$2$select(originals, selected);
      t1.clear$0(0);
      t1.putIfAbsent$2(0, "", new E.AutoCompleteMatcher_reset_closure(_this, originals));
      H.interceptedTypeCast(_this._textField.element, "$isInputElement").value = "";
      _this._listView.set$highlightedItem(null);
      _this._popup$_selectRow = -1;
    },
    _popup$_startMatching$2: function(original, initialize) {
      var _this = this;
      _this.set$_popup$_original(H.assertSubtypeOfRuntimeType(original, H.getTypeArgumentByIndex(_this, 0)));
      _this._popup$_originalScrollTop = C.JSNumber_methods.round$0(_this._listView.items.element.scrollTop);
      H.interceptedTypeCheck(_this._textField.element, "$isInputElement");
      _this.matchingState.putIfAbsent$2(0, "", new E.AutoCompleteMatcher__startMatching_closure(_this));
    },
    displayMatchingItems$1: function(charsToMatch) {
      var t2, matchingItems, _this = this,
        charsMatchLen = charsToMatch.length,
        previousMatch = charsMatchLen > 0 ? C.JSString_methods.substring$2(charsToMatch, 0, charsMatchLen - 1) : "",
        t1 = _this.matchingState,
        lastMatchingItems = t1.$index(0, previousMatch);
      if (lastMatchingItems == null)
        lastMatchingItems = t1.$index(0, "");
      t2 = J.where$1$ax(lastMatchingItems, new E.AutoCompleteMatcher_displayMatchingItems_closure(_this, charsToMatch));
      matchingItems = P.List_List$from(t2, true, H.getTypeArgumentByIndex(t2, 0));
      t1.putIfAbsent$2(0, charsToMatch, new E.AutoCompleteMatcher_displayMatchingItems_closure0(_this, matchingItems));
      t1 = _this._listView.items;
      t1.setItems$1(H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(t1, 0)]));
      _this._listView.setList$1(matchingItems);
      _this.selectFirstItem$0();
      t1 = _this._listView.items.element;
      t1.toString;
      t1.scrollTop = 0;
    },
    set$_popup$_original: function(_original) {
      this._popup$_original = H.assertSubtypeOfRuntimeType(_original, H.getTypeArgumentByIndex(this, 0));
    },
    set$_popup$_finishCallback: function(_finishCallback) {
      this._popup$_finishCallback = H.functionTypeCheck(_finishCallback, {func: 1, ret: -1, opt: [P.bool]});
    }
  };
  E.AutoCompleteMatcher_start_closure.prototype = {
    call$1: function(e) {
      var t1, preventDefault, t2, t3, _this = this;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      switch (e.keyCode) {
        case 13:
          t1 = _this.$this;
          t1.finish$0(0);
          t1.reset$0(0);
          t1._listView.set$highlightedItem(null);
          preventDefault = true;
          break;
        case 27:
          t1 = _this.$this;
          t1.reset$0(0);
          t1._listView.setList$2$select(t1.matchingState.$index(0, ""), t1._popup$_original);
          if (t1._popup$_original != null)
            if (t1._listView.items.selectedItem$0() != null) {
              t2 = t1._listView.items;
              t3 = t1._popup$_originalScrollTop;
              t2 = t2.element;
              t2.toString;
              t2.scrollTop = J.round$0$n(t3);
            }
          t1.finish$0(0);
          preventDefault = false;
          break;
        case 33:
          t1 = _this.$this;
          t1._popup$_selectRow = t1._listView.page$2(0, C.ListDirection_00, t1._popup$_selectRow);
          preventDefault = true;
          break;
        case 34:
          t1 = _this.$this;
          t1._popup$_selectRow = t1._listView.page$2(0, C.ListDirection_10, t1._popup$_selectRow);
          preventDefault = true;
          break;
        case 35:
          t1 = _this.$this;
          t1._popup$_selectRow = t1._listView.page$1(0, C.ListDirection_30);
          preventDefault = true;
          break;
        case 36:
          t1 = _this.$this;
          t1._popup$_selectRow = t1._listView.page$1(0, C.ListDirection_20);
          preventDefault = true;
          break;
        case 38:
          t1 = _this.$this;
          t2 = t1._popup$_selectRow;
          if (typeof t2 !== "number")
            return t2.$gt();
          if (t2 > 0) {
            --t2;
            t1._popup$_selectRow = t2;
            t1._listView.scrollAndHighlight$2(t2, -1);
          }
          preventDefault = true;
          break;
        case 40:
          t1 = _this.$this;
          t2 = t1._popup$_selectRow;
          t3 = J.get$length$asx(_this.listView.items.items);
          if (typeof t3 !== "number")
            return t3.$sub();
          if (typeof t2 !== "number")
            return t2.$lt();
          if (t2 < t3 - 1) {
            t2 = t1._popup$_selectRow;
            if (typeof t2 !== "number")
              return t2.$add();
            ++t2;
            t1._popup$_selectRow = t2;
            t1._listView.scrollAndHighlight$2(t2, -1);
          }
          preventDefault = true;
          break;
        default:
          preventDefault = false;
      }
      if (preventDefault)
        e.preventDefault();
    },
    $signature: 14
  };
  E.AutoCompleteMatcher_reset_closure.prototype = {
    call$0: function() {
      return this.originals;
    },
    $signature: function() {
      return {func: 1, ret: [P.List, H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  E.AutoCompleteMatcher__startMatching_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      return H.assertSubtype(t1._listView.items.items, "$isList", [H.getTypeArgumentByIndex(t1, 0)], "$asList");
    },
    $signature: function() {
      return {func: 1, ret: [P.List, H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  E.AutoCompleteMatcher_displayMatchingItems_closure.prototype = {
    call$1: function(item) {
      return J.lastIndexOf$1$s(J.toString$0$(H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(this.$this, 0))), this.charsToMatch) >= 0;
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  E.AutoCompleteMatcher_displayMatchingItems_closure0.prototype = {
    call$0: function() {
      return this.matchingItems;
    },
    $signature: function() {
      return {func: 1, ret: [P.List, H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  R.connect_closure.prototype = {
    call$1: function(_) {
      var t3, t4, service, _null = null,
        t1 = this.ws,
        t2 = W.MessageEvent,
        inStream = R.convertBroadcastToSingleSubscriber(new W._EventStream(t1, "message", false, [t2]), t2).asyncMap$1$1(new R.connect__closure(), _null);
      t2 = P.String;
      t3 = P.LinkedHashSet_LinkedHashSet([U.TrackedFuture, P.Object]);
      t4 = P.bool;
      t4 = new P._AsyncCompleter(new P._Future($.Zone__current, [t4]), [t4]);
      t4.complete$1(0, true);
      service = new U.VmServiceWrapper(P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.Future, S.Success]), t3, t4);
      t3 = [t2];
      t2 = new S.VmService(P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.Completer,,]), P.LinkedHashMap_LinkedHashMap$_empty(t2, t2), P.LinkedHashMap_LinkedHashMap$_empty(t2, {func: 1, ret: [P.Future, [P.Map, P.String,,]], args: [[P.Map, P.String,,]]}), new P._SyncBroadcastStreamController(_null, _null, t3), new P._SyncBroadcastStreamController(_null, _null, t3), P.LinkedHashMap_LinkedHashMap$_empty(t2, [P.StreamController, S.Event0]));
      t2._streamSub = inStream.listen$1(t2.get$_processMessage());
      t2._writeMessage = new R.connect__closure0(t1);
      t2._log = new S._NullLog();
      t2.set$_disposeHandler(_null);
      service._vmService = t2;
      t2 = W.CloseEvent;
      W._EventStreamSubscription$(t1, "close", H.functionTypeCheck(new R.connect__closure1(this.finishedCompleter, service), {func: 1, ret: -1, args: [t2]}), false, t2);
      this.connectedCompleter.complete$1(0, service);
    },
    $signature: 6
  };
  R.connect__closure.prototype = {
    call$1: function(e) {
      var t1, fileReader;
      H.interceptedTypeCheck(e, "$isMessageEvent");
      t1 = new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(e.data, true);
      if (typeof t1 === "string")
        return new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(e.data, true);
      else {
        fileReader = new FileReader();
        fileReader.readAsArrayBuffer(H.interceptedTypeCheck(new P._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy(e.data, true), "$isBlob"));
        t1 = new W._EventStream(fileReader, "loadend", false, [W.ProgressEvent]);
        return t1.get$first(t1).then$1$1(new R.connect___closure(fileReader), P.ByteData);
      }
    },
    $signature: 177
  };
  R.connect___closure.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isProgressEvent");
      t1 = H.interceptedTypeCheck(C.FileReader_methods.get$result(this.fileReader), "$isUint8List").buffer;
      t1.toString;
      return H.NativeByteData_NativeByteData$view(t1, 0, null);
    },
    $signature: 178
  };
  R.connect__closure0.prototype = {
    call$1: function(message) {
      return this.ws.send(message);
    },
    $signature: 75
  };
  R.connect__closure1.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isCloseEvent");
      this.finishedCompleter.complete$0(0);
      this.service._vmService.dispose$0();
    },
    $signature: 180
  };
  R.connect_closure0.prototype = {
    call$1: function(e) {
      var t1 = this.connectedCompleter;
      if (t1.future._state === 0)
        t1.completeError$1(e);
    },
    $signature: 2
  };
  R.convertBroadcastToSingleSubscriber_closure.prototype = {
    call$0: function() {
      var _this = this,
        t1 = _this.stream,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return _this._box_0.subscription = W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new R.convertBroadcastToSingleSubscriber__closure(_this.controller, _this.T), {func: 1, ret: -1, args: [t2]}), false, t2);
    },
    $signature: function() {
      return {func: 1, ret: [P.StreamSubscription, this.T]};
    }
  };
  R.convertBroadcastToSingleSubscriber__closure.prototype = {
    call$1: function(e) {
      return this.controller.add$1(0, H.assertSubtypeOfRuntimeType(e, this.T));
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [this.T]};
    }
  };
  R.convertBroadcastToSingleSubscriber_closure0.prototype = {
    call$0: function() {
      return this._box_0.subscription.cancel$0(0);
    },
    $signature: 10
  };
  E.ToggleableServiceExtensionDescription.prototype = {
    get$extension: function() {
      return this.extension;
    }
  };
  E.closure.prototype = {
    call$1: function(extension) {
      return H.stringTypeCheck(extension.get$extension());
    },
    $signature: 181
  };
  E.closure0.prototype = {
    call$1: function(extension) {
      return H.interceptedTypeCheck(extension, "$isToggleableServiceExtensionDescription");
    },
    $signature: 182
  };
  R.ServiceConnectionManager.prototype = {
    get$serviceCapabilities: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(R.VmServiceCapabilities),
        $async$returnValue, $async$self = this, t2, t1, $async$temp1;
      var $async$get$serviceCapabilities = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._serviceCapabilities;
              $async$goto = t1 == null ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self.serviceAvailable.future, $async$get$serviceCapabilities);
            case 5:
              // returning from await.
              t1 = $async$self.service;
              t2 = S.Version;
              $async$temp1 = R;
              $async$goto = 6;
              return P._asyncAwait(t1._trackFuture$1$2("getVersion", t1._vmService._call$1$1(0, "getVersion", t2), t2), $async$get$serviceCapabilities);
            case 6:
              // returning from await.
              t2 = $async$self._serviceCapabilities = new $async$temp1.VmServiceCapabilities($async$result);
              t1 = t2;
            case 4:
              // join
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$get$serviceCapabilities, $async$completer);
    },
    callService$2$isolateId: function($name, isolateId) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Response),
        $async$returnValue, $async$self = this, registered;
      var $async$callService$2$isolateId = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              registered = $async$self._registeredMethodsForService.$index(0, $name);
              if (registered == null)
                registered = C.List_empty0;
              if (registered.length === 0)
                throw H.wrapException(P.Exception_Exception('There are no registered methods for service "' + $name + '"'));
              $async$returnValue = $async$self.service.callMethod$3$args$isolateId(C.JSArray_methods.get$first(registered), null, isolateId);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$callService$2$isolateId, $async$completer);
    },
    hasRegisteredService$2: function($name, onData) {
      var streamController;
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [P.bool]});
      if (this._registeredMethodsForService.containsKey$1(0, $name) && true)
        onData.call$1(true);
      streamController = this._getServiceRegistrationController$1($name);
      return streamController.get$stream(streamController).listen$1(onData);
    },
    _getServiceRegistrationController$1: function($name) {
      return R._getStreamController($name, this._serviceRegistrationController, new R.ServiceConnectionManager__getServiceRegistrationController_closure(this, $name), P.bool);
    },
    vmServiceOpened$2$onClosed: function(service, onClosed) {
      return this.vmServiceOpened$body$ServiceConnectionManager(service, H.assertSubtype(onClosed, "$isFuture", [-1], "$asFuture"));
    },
    vmServiceOpened$body$ServiceConnectionManager: function(service, onClosed) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, streamIds, t2, t1, vm, $async$temp1;
      var $async$vmServiceOpened$2$onClosed = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = S.VM;
              $async$goto = 2;
              return P._asyncAwait(service._trackFuture$1$2("getVM", service._vmService._call$1$1(0, "getVM", t1), t1), $async$vmServiceOpened$2$onClosed);
            case 2:
              // returning from await.
              vm = $async$result;
              t1 = $async$self.sdkVersion = vm.version;
              if (J.getInterceptor$asx(t1).contains$1(t1, " "))
                $async$self.sdkVersion = C.JSString_methods.substring$2(t1, 0, C.JSString_methods.indexOf$1(t1, " "));
              $async$self.service = service;
              $async$self.serviceAvailable.complete$0(0);
              $async$self.connectedApp = new L.ConnectedApp();
              t1 = service._vmService._getEventController$1("_Service");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new R.ServiceConnectionManager_vmServiceOpened_closure($async$self));
              $async$self._isolateManager._service_manager$_service = service;
              $async$self._serviceExtensionManager._service_manager$_service = service;
              $async$self._stateController.add$1(0, null);
              $async$self._connectionAvailableController.add$1(0, service);
              $async$goto = 3;
              return P._asyncAwait($async$self._isolateManager._initIsolates$1(vm.isolates), $async$vmServiceOpened$2$onClosed);
            case 3:
              // returning from await.
              t1 = service._vmService._getEventController$1("Isolate");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self._isolateManager.get$_handleIsolateEvent());
              t1 = service._vmService._getEventController$1("Extension");
              new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1($async$self._serviceExtensionManager.get$_handleExtensionEvent());
              onClosed.then$1$1(new R.ServiceConnectionManager_vmServiceOpened_closure0($async$self), -1);
              t1 = [P.String];
              streamIds = H.setRuntimeTypeInfo(["Stdout", "Stderr", "VM", "Isolate", "Debug", "GC", "Timeline", "Extension", "_Service"], t1);
              $async$temp1 = H;
              $async$goto = 4;
              return P._asyncAwait($async$self.connectedApp.get$isFlutterWebApp(), $async$vmServiceOpened$2$onClosed);
            case 4:
              // returning from await.
              if (!$async$temp1.boolConversionCheck($async$result))
                C.JSArray_methods.addAll$1(streamIds, H.setRuntimeTypeInfo(["_Graph", "_Logging", "Logging"], t1));
              t1 = [P.Future, P.Null];
              t2 = H.getTypeArgumentByIndex(streamIds, 0);
              $async$goto = 5;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(streamIds, H.functionTypeCheck(new R.ServiceConnectionManager_vmServiceOpened_closure1(service), {func: 1, ret: t1, args: [t2]}), [t2, t1]), P.Null), $async$vmServiceOpened$2$onClosed);
            case 5:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$vmServiceOpened$2$onClosed, $async$completer);
    },
    performHotReload$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$performHotReload$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.callService$2$isolateId("reloadSources", $async$self._isolateManager._selectedIsolate.id), $async$performHotReload$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$performHotReload$0, $async$completer);
    },
    performHotRestart$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$performHotRestart$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait($async$self.callService$2$isolateId("hotRestart", $async$self._isolateManager._selectedIsolate.id), $async$performHotRestart$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$performHotRestart$0, $async$completer);
    }
  };
  R.ServiceConnectionManager__getServiceRegistrationController_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.name;
      J.add$1$ax(t1._serviceRegistrationController.$index(0, t2), t1._registeredMethodsForService.containsKey$1(0, t2));
    },
    $signature: 0
  };
  R.ServiceConnectionManager_vmServiceOpened_closure.prototype = {
    call$1: function(e) {
      var t1, t2;
      H.interceptedTypeCheck(e, "$isEvent0");
      if (e.kind === "ServiceRegistered") {
        t1 = this.$this;
        t2 = t1._registeredMethodsForService;
        if (!t2.containsKey$1(0, e.service)) {
          t2.$indexSet(0, e.service, H.setRuntimeTypeInfo([e.method], [P.String]));
          t1._getServiceRegistrationController$1(e.service).add$1(0, true);
        } else {
          t1 = t2.$index(0, e.service);
          (t1 && C.JSArray_methods).add$1(t1, e.method);
        }
      }
    },
    $signature: 34
  };
  R.ServiceConnectionManager_vmServiceOpened_closure0.prototype = {
    call$1: function(_) {
      var t1 = this.$this;
      t1.connectedApp = t1.sdkVersion = t1.service = null;
      t1._stateController.add$1(0, null);
      t1._connectionClosedController.add$1(0, null);
      return;
    },
    $signature: 183
  };
  R.ServiceConnectionManager_vmServiceOpened_closure1.prototype = {
    call$1: function(id) {
      H.stringTypeCheck(id);
      return this.$call$body$ServiceConnectionManager_vmServiceOpened_closure(id);
    },
    $call$body$ServiceConnectionManager_vmServiceOpened_closure: function(id) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, e, exception, $async$exception;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 3;
              $async$goto = 6;
              return P._asyncAwait($async$self.service.streamListen$1(id), $async$call$1);
            case 6:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 5;
              break;
            case 3:
              // catch
              $async$handler = 2;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              if (!J.endsWith$1$s(id, "Logging"))
                P.print("Service client stream not supported: '" + H.S(id) + "'\n  " + H.S(e));
              // goto after finally
              $async$goto = 5;
              break;
            case 2:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 5:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 184
  };
  R.IsolateManager.prototype = {
    selectIsolate$1: function(isolateRefId) {
      this._setSelectedIsolate$1(C.JSArray_methods.firstWhere$2$orElse(this._isolates, new R.IsolateManager_selectIsolate_closure(isolateRefId), new R.IsolateManager_selectIsolate_closure0()));
    },
    _initIsolates$1: function(isolates) {
      return this._initIsolates$body$IsolateManager(H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList"));
    },
    _initIsolates$body$IsolateManager: function(isolates) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$_initIsolates$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.set$_isolates(isolates);
              $async$goto = 2;
              return P._asyncAwait($async$self._initSelectedIsolate$1(isolates), $async$_initIsolates$1);
            case 2:
              // returning from await.
              t1 = $async$self._selectedIsolate;
              $async$goto = t1 != null ? 3 : 4;
              break;
            case 3:
              // then
              $async$self._isolateCreatedController.add$1(0, t1);
              $async$self._selectedIsolateController.add$1(0, $async$self._selectedIsolate);
              $async$goto = 5;
              return P._asyncAwait($async$self._serviceExtensionManager._addRegisteredExtensionRPCs$1($async$self._selectedIsolate), $async$_initIsolates$1);
            case 5:
              // returning from await.
            case 4:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_initIsolates$1, $async$completer);
    },
    _handleIsolateEvent$1: function($event) {
      return this._handleIsolateEvent$body$IsolateManager(H.interceptedTypeCheck($event, "$isEvent0"));
    },
    _handleIsolateEvent$body$IsolateManager: function($event) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1;
      var $async$_handleIsolateEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $event.kind;
              $async$goto = t1 === "IsolateStart" ? 2 : 4;
              break;
            case 2:
              // then
              C.JSArray_methods.add$1($async$self._isolates, $event.isolate);
              $async$self._isolateCreatedController.add$1(0, $event.isolate);
              $async$goto = $async$self._selectedIsolate == null ? 5 : 6;
              break;
            case 5:
              // then
              $async$goto = 7;
              return P._asyncAwait($async$self._setSelectedIsolate$1($event.isolate), $async$_handleIsolateEvent$1);
            case 7:
              // returning from await.
            case 6:
              // join
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = t1 === "ServiceExtensionAdded" ? 8 : 10;
              break;
            case 8:
              // then
              $async$goto = 11;
              return P._asyncAwait($async$self._serviceExtensionManager._maybeAddServiceExtension$1($event.extensionRPC), $async$_handleIsolateEvent$1);
            case 11:
              // returning from await.
              $async$goto = $async$self._selectedIsolate == null && J.startsWith$1$s($event.extensionRPC, "ext.flutter.") ? 12 : 13;
              break;
            case 12:
              // then
              $async$goto = 14;
              return P._asyncAwait($async$self._setSelectedIsolate$1($event.isolate), $async$_handleIsolateEvent$1);
            case 14:
              // returning from await.
            case 13:
              // join
              // goto join
              $async$goto = 9;
              break;
            case 10:
              // else
              if (t1 === "IsolateExit") {
                C.JSArray_methods.remove$1($async$self._isolates, $event.isolate);
                $async$self._isolateExitedController.add$1(0, $event.isolate);
                if (J.$eq$($async$self._selectedIsolate, $event.isolate)) {
                  t1 = $async$self._isolates;
                  t1 = H.interceptedTypeCheck(t1.length === 0 ? null : C.JSArray_methods.get$first(t1), "$isIsolateRef");
                  $async$self._selectedIsolate = t1;
                  if (t1 == null) {
                    t1 = P.Null;
                    $async$self.set$selectedIsolateAvailable(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
                  }
                  $async$self._selectedIsolateController.add$1(0, $async$self._selectedIsolate);
                  $async$self._serviceExtensionManager.resetAvailableExtensions$0();
                }
              }
            case 9:
              // join
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleIsolateEvent$1, $async$completer);
    },
    _initSelectedIsolate$1: function(isolates) {
      return this._initSelectedIsolate$body$IsolateManager(H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList"));
    },
    _initSelectedIsolate$body$IsolateManager: function(isolates) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, _i, ref, t2, t3, t4, _i0, t1, $async$temp1;
      var $async$_initSelectedIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = isolates.length;
              if (t1 === 0) {
                // goto return
                $async$goto = 1;
                break;
              }
              _i = 0;
            case 3:
              // for condition
              if (!(_i < isolates.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              ref = isolates[_i];
              $async$goto = $async$self._selectedIsolate == null ? 6 : 7;
              break;
            case 6:
              // then
              t2 = $async$self._service_manager$_service;
              t3 = ref.id;
              t4 = t2._vmService;
              t4.toString;
              $async$temp1 = H;
              $async$goto = 8;
              return P._asyncAwait(t2._trackFuture$1$2("getIsolate", t4._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t3]), null), null), $async$_initSelectedIsolate$1);
            case 8:
              // returning from await.
              t2 = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate").extensionRPCs;
              $async$goto = t2 != null ? 9 : 10;
              break;
            case 9:
              // then
              t3 = t2.length, _i0 = 0;
            case 11:
              // for condition
              if (!(_i0 < t3)) {
                // goto after for
                $async$goto = 13;
                break;
              }
              $async$goto = J.startsWith$1$s(H.stringTypeCheck(t2[_i0]), "ext.flutter.") ? 14 : 15;
              break;
            case 14:
              // then
              $async$goto = 16;
              return P._asyncAwait($async$self._setSelectedIsolate$1(ref), $async$_initSelectedIsolate$1);
            case 16:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 15:
              // join
            case 12:
              // for update
              ++_i0;
              // goto for condition
              $async$goto = 11;
              break;
            case 13:
              // after for
            case 10:
              // join
            case 7:
              // join
            case 4:
              // for update
              isolates.length === t1 || (0, H.throwConcurrentModificationError)(isolates), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              ref = C.JSArray_methods.firstWhere$2$orElse(isolates, new R.IsolateManager__initSelectedIsolate_closure(), new R.IsolateManager__initSelectedIsolate_closure0());
              $async$goto = 17;
              return P._asyncAwait($async$self._setSelectedIsolate$1(ref == null ? C.JSArray_methods.get$first(isolates) : ref), $async$_initSelectedIsolate$1);
            case 17:
              // returning from await.
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_initSelectedIsolate$1, $async$completer);
    },
    _setSelectedIsolate$1: function(ref) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2, t3, $async$temp1;
      var $async$_setSelectedIsolate$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (J.$eq$($async$self._selectedIsolate, ref)) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = $async$self._service_manager$_service;
              t2 = ref.id;
              t3 = t1._vmService;
              t3.toString;
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t3._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null), $async$_setSelectedIsolate$1);
            case 3:
              // returning from await.
              $async$self.set$selectedIsolateLibraries($async$temp1.interceptedTypeCheck($async$result, "$isIsolate").libraries);
              $async$self._selectedIsolate = ref;
              t1 = $async$self.selectedIsolateAvailable;
              if (t1.future._state === 0)
                t1.complete$0(0);
              $async$self._selectedIsolateController.add$1(0, ref);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_setSelectedIsolate$1, $async$completer);
    },
    getSelectedIsolate$1: function(onData) {
      var t1;
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [S.IsolateRef]});
      t1 = this._selectedIsolate;
      if (t1 != null)
        onData.call$1(t1);
      t1 = this._selectedIsolateController;
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(onData);
    },
    set$_isolates: function(_isolates) {
      this._isolates = H.assertSubtype(_isolates, "$isList", [S.IsolateRef], "$asList");
    },
    set$selectedIsolateAvailable: function(selectedIsolateAvailable) {
      this.selectedIsolateAvailable = H.assertSubtype(selectedIsolateAvailable, "$isCompleter", [P.Null], "$asCompleter");
    },
    set$selectedIsolateLibraries: function(selectedIsolateLibraries) {
      this.selectedIsolateLibraries = H.assertSubtype(selectedIsolateLibraries, "$isList", [S.LibraryRef], "$asList");
    }
  };
  R.IsolateManager_selectIsolate_closure.prototype = {
    call$1: function(ref) {
      return H.interceptedTypeCheck(ref, "$isIsolateRef").id == this.isolateRefId;
    },
    $signature: 77
  };
  R.IsolateManager_selectIsolate_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  R.IsolateManager__initSelectedIsolate_closure.prototype = {
    call$1: function(ref) {
      return J.contains$1$asx(H.interceptedTypeCheck(ref, "$isIsolateRef").name, ":main(");
    },
    $signature: 77
  };
  R.IsolateManager__initSelectedIsolate_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  R.ServiceExtensionManager.prototype = {
    _handleExtensionEvent$1: function($event) {
      return this._handleExtensionEvent$body$ServiceExtensionManager(H.interceptedTypeCheck($event, "$isEvent0"));
    },
    _handleExtensionEvent$body$ServiceExtensionManager: function($event) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, t2, $name, valueFromJson, extension, value;
      var $async$_handleExtensionEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
            case 2:
              // switch
              switch ($event.extensionKind) {
                case "Flutter.FirstFrame":
                  // goto case
                  $async$goto = 4;
                  break;
                case "Flutter.Frame":
                  // goto case
                  $async$goto = 5;
                  break;
                case "Flutter.ServiceExtensionStateChanged":
                  // goto case
                  $async$goto = 6;
                  break;
                default:
                  // goto after switch
                  $async$goto = 3;
                  break;
              }
              break;
            case 4:
              // case
            case 5:
              // case
              $async$goto = 7;
              return P._asyncAwait($async$self._onFrameEventReceived$0(), $async$_handleExtensionEvent$1);
            case 7:
              // returning from await.
              // goto after switch
              $async$goto = 3;
              break;
            case 6:
              // case
              t1 = $event.json;
              t2 = J.getInterceptor$asx(t1);
              $name = J.toString$0$(J.$index$asx(t2.$index(t1, "extensionData"), "extension"));
              valueFromJson = J.toString$0$(J.$index$asx(t2.$index(t1, "extensionData"), "value"));
              extension = $.$get$toggleableExtensionsWhitelist().$index(0, $name);
              $async$goto = extension != null ? 8 : 9;
              break;
            case 8:
              // then
              value = $async$self._getExtensionValueFromJson$2($name, valueFromJson);
              $async$goto = 10;
              return P._asyncAwait($async$self.setServiceExtensionState$4$callExtension($name, value === extension.enabledValue, value, false), $async$_handleExtensionEvent$1);
            case 10:
              // returning from await.
            case 9:
              // join
              // goto after switch
              $async$goto = 3;
              break;
            case 3:
              // after switch
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleExtensionEvent$1, $async$completer);
    },
    _getExtensionValueFromJson$2: function($name, valueFromJson) {
      switch (J.get$runtimeType$($.$get$toggleableExtensionsWhitelist().$index(0, $name).enabledValue)) {
        case C.Type_bool_lhE:
          return valueFromJson === "true" && true;
        case C.Type_int_tHn:
        case C.Type_double_K1J:
          return P.num_parse(valueFromJson);
        default:
          return valueFromJson;
      }
    },
    _onFrameEventReceived$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1, t2;
      var $async$_onFrameEventReceived$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._firstFrameEventReceived) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self._firstFrameEventReceived = true;
              t1 = $async$self._pendingServiceExtensions, t2 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0));
            case 3:
              // for condition
              if (!t2.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$goto = 5;
              return P._asyncAwait($async$self._addServiceExtension$1(t2._collection$_current), $async$_onFrameEventReceived$0);
            case 5:
              // returning from await.
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$self.extensionStatesUpdated.complete$0(0);
              t1.clear$0(0);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_onFrameEventReceived$0, $async$completer);
    },
    _addRegisteredExtensionRPCs$1: function(isolateRef) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t2, t3, _i, value, didSendFirstFrameEvent, t1, $async$temp1;
      var $async$_addRegisteredExtensionRPCs$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._service_manager$_service;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              t2 = isolateRef.id;
              t3 = t1._vmService;
              t3.toString;
              $async$temp1 = H;
              $async$goto = 3;
              return P._asyncAwait(t1._trackFuture$1$2("getIsolate", t3._call$1$2(0, "getIsolate", P.LinkedHashMap__makeLiteral(["isolateId", t2]), null), null), $async$_addRegisteredExtensionRPCs$1);
            case 3:
              // returning from await.
              t1 = $async$temp1.interceptedTypeCheck($async$result, "$isIsolate").extensionRPCs;
              $async$goto = t1 != null ? 4 : 5;
              break;
            case 4:
              // then
              t2 = t1.length, _i = 0;
            case 6:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 8;
                break;
              }
              $async$goto = 9;
              return P._asyncAwait($async$self._maybeAddServiceExtension$1(t1[_i]), $async$_addRegisteredExtensionRPCs$1);
            case 9:
              // returning from await.
            case 7:
              // for update
              t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 6;
              break;
            case 8:
              // after for
              if ($async$self._pendingServiceExtensions._collection$_length === 0)
                $async$self.extensionStatesUpdated.complete$0(0);
              $async$goto = !$async$self._firstFrameEventReceived ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = $async$self.isServiceExtensionAvailable$1("ext.flutter.didSendFirstFrameEvent") ? 12 : 14;
              break;
            case 12:
              // then
              $async$goto = 15;
              return P._asyncAwait($async$self._service_manager$_service.callServiceExtension$2$isolateId("ext.flutter.didSendFirstFrameEvent", $async$self._isolateManager._selectedIsolate.id), $async$_addRegisteredExtensionRPCs$1);
            case 15:
              // returning from await.
              value = $async$result;
              didSendFirstFrameEvent = value != null && J.$eq$(J.$index$asx(value.json, "enabled"), "true");
              // goto join
              $async$goto = 13;
              break;
            case 14:
              // else
              $async$goto = 16;
              return P._asyncAwait(B.EvalOnDartLibrary$(H.setRuntimeTypeInfo(["package:flutter/src/widgets/binding.dart", "package:flutter_web/src/widgets/binding.dart"], [P.String]), $async$self._service_manager$_service).eval$2$isAlive("WidgetsBinding.instance.debugDidSendFirstFrameEvent", null), $async$_addRegisteredExtensionRPCs$1);
            case 16:
              // returning from await.
              value = $async$result;
              didSendFirstFrameEvent = value != null && value.valueAsString === "true";
            case 13:
              // join
              $async$goto = didSendFirstFrameEvent ? 17 : 18;
              break;
            case 17:
              // then
              $async$goto = 19;
              return P._asyncAwait($async$self._onFrameEventReceived$0(), $async$_addRegisteredExtensionRPCs$1);
            case 19:
              // returning from await.
            case 18:
              // join
            case 11:
              // join
            case 5:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_addRegisteredExtensionRPCs$1, $async$completer);
    },
    _maybeAddServiceExtension$1: function($name) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$_maybeAddServiceExtension$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = $async$self._firstFrameEventReceived ? 2 : 4;
              break;
            case 2:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self._addServiceExtension$1($name), $async$_maybeAddServiceExtension$1);
            case 5:
              // returning from await.
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$self._pendingServiceExtensions.add$1(0, $name);
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_maybeAddServiceExtension$1, $async$completer);
    },
    _addServiceExtension$1: function($name) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t1, streamController;
      var $async$_addServiceExtension$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              streamController = $async$self._getServiceExtensionController$1($name);
              $async$self._serviceExtensions.add$1(0, $name);
              streamController.add$1(0, true);
              $async$goto = 2;
              return P._asyncAwait($async$self._restoreExtensionFromDevice$1($name), $async$_addServiceExtension$1);
            case 2:
              // returning from await.
              t1 = $async$self._enabledServiceExtensions;
              $async$goto = t1.containsKey$1(0, $name) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return P._asyncAwait($async$self._callServiceExtension$2($name, t1.$index(0, $name).value), $async$_addServiceExtension$1);
            case 5:
              // returning from await.
            case 4:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_addServiceExtension$1, $async$completer);
    },
    _restoreExtensionFromDevice$1: function($name) {
      return this._restoreExtensionFromDevice$body$ServiceExtensionManager($name);
    },
    _restoreExtensionFromDevice$body$ServiceExtensionManager: function($name) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, expectedValueType, response, enabled, value, value0, exception, t1, $async$exception;
      var $async$_restoreExtensionFromDevice$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.$get$toggleableExtensionsWhitelist();
              if (!t1.containsKey$1(0, $name)) {
                // goto return
                $async$goto = 1;
                break;
              }
              expectedValueType = J.get$runtimeType$(t1.$index(0, $name).enabledValue);
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait($async$self._service_manager$_service.callServiceExtension$2$isolateId($name, $async$self._isolateManager._selectedIsolate.id), $async$_restoreExtensionFromDevice$1);
            case 7:
              // returning from await.
              response = $async$result;
            case 8:
              // switch
              switch (expectedValueType) {
                case C.Type_bool_lhE:
                  // goto case
                  $async$goto = 10;
                  break;
                case C.Type_String_k8F:
                  // goto case
                  $async$goto = 11;
                  break;
                case C.Type_int_tHn:
                  // goto case
                  $async$goto = 12;
                  break;
                case C.Type_double_K1J:
                  // goto case
                  $async$goto = 13;
                  break;
                default:
                  // goto default
                  $async$goto = 14;
                  break;
              }
              break;
            case 10:
              // case
              enabled = J.$eq$(J.$index$asx(response.json, "enabled"), "true") && true;
              $async$goto = 15;
              return P._asyncAwait($async$self._maybeRestoreExtension$2($name, enabled), $async$_restoreExtensionFromDevice$1);
            case 15:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 11:
              // case
              value = H.stringTypeCheck(J.$index$asx(response.json, "value"));
              $async$goto = 16;
              return P._asyncAwait($async$self._maybeRestoreExtension$2($name, value), $async$_restoreExtensionFromDevice$1);
            case 16:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 12:
              // case
            case 13:
              // case
              value0 = P.num_parse(H.stringTypeCheck(J.$index$asx(response.json, C.JSString_methods.substring$1($name, J.lastIndexOf$1$s($name, ".") + 1))));
              $async$goto = 17;
              return P._asyncAwait($async$self._maybeRestoreExtension$2($name, value0), $async$_restoreExtensionFromDevice$1);
            case 17:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 14:
              // default
              // goto return
              $async$goto = 1;
              break;
            case 9:
              // after switch
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              H.unwrapException($async$exception);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_restoreExtensionFromDevice$1, $async$completer);
    },
    _maybeRestoreExtension$2: function($name, value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$_maybeRestoreExtension$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = value === $.$get$toggleableExtensionsWhitelist().$index(0, $name).enabledValue ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return P._asyncAwait($async$self.setServiceExtensionState$4$callExtension($name, true, value, false), $async$_maybeRestoreExtension$2);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_maybeRestoreExtension$2, $async$completer);
    },
    _callServiceExtension$2: function($name, value) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t2, t1;
      var $async$_callServiceExtension$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._service_manager$_service;
              if (t1 == null) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = typeof value === "boolean" ? 3 : 5;
              break;
            case 3:
              // then
              t2 = $async$self._isolateManager._selectedIsolate.id;
              $async$goto = 6;
              return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral(["enabled", value]), t2), $async$_callServiceExtension$2);
            case 6:
              // returning from await.
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = typeof value === "string" ? 7 : 9;
              break;
            case 7:
              // then
              t2 = $async$self._isolateManager._selectedIsolate.id;
              $async$goto = 10;
              return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral(["value", value]), t2), $async$_callServiceExtension$2);
            case 10:
              // returning from await.
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = typeof value === "number" ? 11 : 12;
              break;
            case 11:
              // then
              t2 = $async$self._isolateManager._selectedIsolate.id;
              $async$goto = 13;
              return P._asyncAwait(t1.callServiceExtension$3$args$isolateId($name, P.LinkedHashMap__makeLiteral([C.JSString_methods.substring$1($name, J.getInterceptor$s($name).lastIndexOf$1($name, ".") + 1), value]), t2), $async$_callServiceExtension$2);
            case 13:
              // returning from await.
            case 12:
              // join
            case 8:
              // join
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_callServiceExtension$2, $async$completer);
    },
    resetAvailableExtensions$0: function() {
      var _this = this,
        t1 = P.Null;
      _this.set$extensionStatesUpdated(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
      _this._firstFrameEventReceived = false;
      _this._serviceExtensions.clear$0(0);
      _this._serviceExtensionController.forEach$1(0, new R.ServiceExtensionManager_resetAvailableExtensions_closure());
    },
    setServiceExtensionState$4$callExtension: function($name, enabled, value, callExtension) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, streamController, t1;
      var $async$setServiceExtensionState$4$callExtension = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = callExtension ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return P._asyncAwait($async$self._callServiceExtension$2($name, value), $async$setServiceExtensionState$4$callExtension);
            case 4:
              // returning from await.
            case 3:
              // join
              streamController = $async$self._getServiceExtensionStateController$1($name);
              streamController.add$1(0, new R.ServiceExtensionState(enabled, value));
              t1 = $async$self._enabledServiceExtensions;
              if (enabled)
                t1.$indexSet(0, $name, new R.ServiceExtensionState(true, value));
              else
                t1.remove$1(0, $name);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$setServiceExtensionState$4$callExtension, $async$completer);
    },
    setServiceExtensionState$3: function($name, enabled, value) {
      return this.setServiceExtensionState$4$callExtension($name, enabled, value, true);
    },
    isServiceExtensionAvailable$1: function($name) {
      return this._serviceExtensions.contains$1(0, $name) || this._pendingServiceExtensions.contains$1(0, $name);
    },
    _getServiceExtensionController$1: function($name) {
      return R._getStreamController($name, this._serviceExtensionController, new R.ServiceExtensionManager__getServiceExtensionController_closure(this, $name), P.bool);
    },
    _getServiceExtensionStateController$1: function($name) {
      return R._getStreamController($name, this._serviceExtensionStateController, new R.ServiceExtensionManager__getServiceExtensionStateController_closure(this, $name), R.ServiceExtensionState);
    },
    set$extensionStatesUpdated: function(extensionStatesUpdated) {
      this.extensionStatesUpdated = H.assertSubtype(extensionStatesUpdated, "$isCompleter", [P.Null], "$asCompleter");
    }
  };
  R.ServiceExtensionManager_resetAvailableExtensions_closure.prototype = {
    call$2: function($name, stream) {
      H.stringTypeCheck($name);
      H.assertSubtype(stream, "$isStreamController", [P.bool], "$asStreamController").add$1(0, false);
    },
    $signature: 187
  };
  R.ServiceExtensionManager__getServiceExtensionController_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = this.name;
      J.add$1$ax(t1._serviceExtensionController.$index(0, t2), t1._serviceExtensions.contains$1(0, t2));
    },
    $signature: 0
  };
  R.ServiceExtensionManager__getServiceExtensionStateController_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._enabledServiceExtensions,
        t3 = this.name;
      t1 = t1._serviceExtensionStateController;
      if (t2.containsKey$1(0, t3))
        J.add$1$ax(t1.$index(0, t3), t2.$index(0, t3));
      else {
        t1 = t1.$index(0, t3);
        J.add$1$ax(t1, new R.ServiceExtensionState(false, null));
      }
    },
    $signature: 0
  };
  R._getStreamController_closure.prototype = {
    call$0: function() {
      return new P._AsyncBroadcastStreamController(this.onFirstListenerSubscribed, null, [this.T]);
    },
    $signature: function() {
      return {func: 1, ret: [P.StreamController, this.T]};
    }
  };
  R.ServiceExtensionState.prototype = {
    get$value: function(receiver) {
      return this.value;
    }
  };
  R.VmServiceCapabilities.prototype = {
    get$supportsGetScripts: function() {
      var t1 = this.version,
        t2 = t1.major;
      if (typeof t2 !== "number")
        return t2.$gt();
      if (t2 <= 3)
        if (t2 === 3) {
          t1 = t1.minor;
          if (typeof t1 !== "number")
            return t1.$ge();
          t1 = t1 >= 12;
        } else
          t1 = false;
      else
        t1 = true;
      return t1;
    }
  };
  Q.HoverCellData.prototype = {};
  Q.Table.prototype = {
    Table$virtual$2$overflowAuto$rowHeight: function(overflowAuto, rowHeight, $T) {
      var t1, t2, _this = this, _null = null;
      _this._tables$_init$0();
      _this._spacerBeforeVisibleRows = A.CoreElement$("tr", _null, _null, _null, _null);
      _this._spacerAfterVisibleRows = A.CoreElement$("tr", _null, _null, _null, _null);
      t1 = J.get$onScroll$x(_this.element.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new Q.Table$virtual_closure(_this), {func: 1, ret: -1, args: [t2]}), false, t2);
    },
    get$rowCount: function(_) {
      var t1 = this.data;
      t1 = t1 == null ? null : t1.length;
      return t1 == null ? 0 : t1;
    },
    set$sortColumn: function(column) {
      H.assertSubtype(column, "$isColumn", this.$ti, "$asColumn");
      this.set$_sortColumn(column);
      this._sortDirection = column.get$numeric() ? C.SortOrder_1 : C.SortOrder_0;
    },
    _tables$_init$0: function() {
      var t2,
        t1 = this._table;
      this.element.add$1(0, t1);
      t1 = J.get$onKeyDown$x(t1.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new Q.Table__init_closure(this), {func: 1, ret: -1, args: [t2]}), false, t2);
    },
    _handleLeftKey$0: function() {
    },
    _handleRightKey$0: function() {
    },
    setRows$1: function(data) {
      var t1, t2, t3, t4, t5, column, _this = this, _null = null;
      H.assertSubtype(data, "$isList", _this.$ti, "$asList");
      t1 = J.getInterceptor$asx(data);
      if (!t1.contains$1(data, _this._selectedObject)) {
        if (_this.get$rowCount(_this) > 0)
          _this._scrollToIndex$2$scrollBehavior(0, "auto");
        _this._select$3(_null, _null, _null);
      }
      _this.set$data(0, t1.toList$0(data));
      _this._rowsChangedController.add$1(0, _null);
      if (_this._thead == null) {
        t1 = A.CoreElement$("thead", _null, _null, _null, _null);
        t2 = A.CoreElement$("tr", _null, _null, _null, _null);
        t3 = _this.columns;
        t4 = A.CoreElement;
        t5 = H.getTypeArgumentByIndex(t3, 0);
        t2.add$1(0, new H.MappedListIterable(t3, H.functionTypeCheck(new Q.Table_setRows_closure(_this), {func: 1, ret: t4, args: [t5]}), [t5, t4]));
        t1.add$1(0, t2);
        _this._thead = t1;
        _this._table.add$1(0, t1);
      }
      if (_this._tbody == null) {
        t1 = A.CoreElement$("tbody", _null, "selectable", _null, _null);
        _this._tbody = t1;
        _this._table.add$1(0, t1);
      }
      if (_this._sortColumn == null) {
        column = C.JSArray_methods.firstWhere$2$orElse(_this.columns, new Q.Table_setRows_closure0(_this), new Q.Table_setRows_closure1());
        if (column != null)
          _this.set$sortColumn(column);
      }
      if (_this._sortColumn != null)
        _this._doSort$0();
      _this._scheduleRebuild$0();
    },
    scrollTo$2$scrollBehavior: function(_, row, scrollBehavior) {
      var t1, index, _this = this;
      H.assertSubtypeOfRuntimeType(row, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this.data;
      index = (t1 && C.JSArray_methods).indexOf$1(t1, row);
      if (index === -1)
        return;
      if (_this._hasPendingRebuild) {
        _this.setState$1(new Q.Table_scrollTo_closure(_this, index, scrollBehavior));
        return;
      }
      _this._scrollToIndex$2$scrollBehavior(index, scrollBehavior);
    },
    _scheduleRebuild$0: function() {
      var _this = this;
      if (!_this._hasPendingRebuild) {
        _this._hasPendingRebuild = true;
        _this.setState$1(new Q.Table__scheduleRebuild_closure(_this));
      }
    },
    _doSort$0: function() {
      var t1, t2, t3, _i, c, s, t4, t5, t6, _this = this,
        column = _this._sortColumn,
        direction = _this._sortDirection === C.SortOrder_0 ? 1 : -1;
      for (t1 = _this.columns, t2 = t1.length, t3 = _this._spanForColumn, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        c = t1[_i];
        s = t3.$index(0, c);
        if (c === _this._sortColumn) {
          t4 = _this._sortDirection;
          t5 = s.element;
          t6 = J.getInterceptor$x(t5);
          t6.get$classes(t5).toggle$2(0, "up", t4 === C.SortOrder_0);
          t4 = _this._sortDirection;
          t6.get$classes(t5).toggle$2(0, "down", t4 !== C.SortOrder_0);
        } else {
          t4 = s.element;
          t5 = J.getInterceptor$x(t4);
          t5.get$classes(t4).toggle$2(0, "up", false);
          t5.get$classes(t4).toggle$2(0, "down", false);
        }
      }
      _this._sortData$2(column, direction);
    },
    _sortData$2: function(column, direction) {
      var t1 = this.data;
      (t1 && C.JSArray_methods).sort$1(t1, new Q.Table__sortData_closure(this, column, direction));
    },
    _compareData$4: function(a, b, column, direction) {
      var t1 = H.getTypeArgumentByIndex(this, 0);
      H.assertSubtypeOfRuntimeType(a, t1);
      H.assertSubtypeOfRuntimeType(b, t1);
      return J.compareTo$1$ns(column.render$1(column.getValue$1(a)), column.render$1(column.getValue$1(b))) * direction;
    },
    _rebuildTable$0: function() {
      if (this.data == null)
        return;
      this._rebuildVirtualTable$0();
    },
    _rebuildVirtualTable$0: function() {
      var totalRows, firstVisibleRow, numVisibleRows, firstRenderedRowInclusive, lastRenderedRowExclusive, spacerBeforeHeight, t3, currentRowIndex, _this = this,
        t1 = _this.data,
        t2 = t1 == null;
      t2;
      totalRows = t2 ? null : t1.length;
      if (totalRows == null)
        totalRows = 0;
      t1 = _this.element.element;
      t2 = _this.rowHeight;
      firstVisibleRow = C.JSDouble_methods.floor$0((C.JSNumber_methods.round$0(t1.scrollTop) - C.JSNumber_methods.round$0(_this._thead.element.offsetHeight)) / t2);
      numVisibleRows = C.JSDouble_methods.ceil$0(C.JSNumber_methods.round$0(t1.offsetHeight) / t2) + 1;
      firstRenderedRowInclusive = H.intTypeCheck(C.JSInt_methods.clamp$2(firstVisibleRow, 0, H.intTypeCheck(C.JSInt_methods.clamp$2(totalRows - (numVisibleRows + 1), 0, totalRows))));
      lastRenderedRowExclusive = H.intTypeCheck(C.JSInt_methods.clamp$2(firstRenderedRowInclusive + numVisibleRows + 2, 0, totalRows));
      spacerBeforeHeight = firstRenderedRowInclusive * t2;
      t1 = _this._spacerBeforeVisibleRows;
      t3 = "" + spacerBeforeHeight + "px";
      t1 = t1.element.style;
      t1.height = t3;
      t1 = _this._spacerBeforeVisibleRows;
      t3 = spacerBeforeHeight === 0 ? "none" : null;
      t1 = t1.element.style;
      t1.toString;
      t1.display = t3 == null ? "" : t3;
      t1 = J.get$children$x(_this._tbody.element);
      if (!t1.get$isEmpty(t1)) {
        t1 = J.get$children$x(_this._tbody.element);
        t1 = !J.$eq$(t1.get$first(t1), _this._spacerBeforeVisibleRows.element);
      } else
        t1 = true;
      if (t1)
        J.get$children$x(_this._tbody.element).insert$2(0, 0, _this._spacerBeforeVisibleRows.element);
      t1 = J.get$children$x(_this._tbody.element);
      if (!t1.get$isEmpty(t1)) {
        t1 = J.get$children$x(_this._tbody.element);
        t1 = J.$eq$(t1.get$last(t1), _this._spacerAfterVisibleRows.element);
      } else
        t1 = false;
      if (t1)
        J.get$children$x(_this._tbody.element).removeLast$0(0);
      currentRowIndex = _this._buildTableRows$3$currentRowIndex$firstRenderedRowInclusive$lastRenderedRowExclusive(1, firstRenderedRowInclusive, lastRenderedRowExclusive);
      if (currentRowIndex > 0) {
        t1 = J.get$children$x(_this._tbody.element);
        t1 = t1.get$length(t1);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = currentRowIndex < t1;
      } else
        t1 = false;
      if (t1) {
        t1 = J.get$children$x(_this._tbody.element);
        t1.removeWhere$1(t1, new Q.Table__rebuildVirtualTable_closure(_this));
      }
      t1 = _this.data.length;
      t3 = _this._spacerAfterVisibleRows;
      t2 = "" + (t1 - lastRenderedRowExclusive) * t2 + "px";
      t3 = t3.element.style;
      t3.height = t2;
      J.get$children$x(_this._tbody.element).add$1(0, _this._spacerAfterVisibleRows.element);
    },
    _buildTableRows$3$currentRowIndex$firstRenderedRowInclusive$lastRenderedRowExclusive: function(currentRowIndex, firstRenderedRowInclusive, lastRenderedRowExclusive) {
      var t2, t3, t4, t5, index, t6, dataObject, isReusableRow, tableRow, hoverCell, t7, t8, t9, currentColumnIndex, _i, column, t10, isReusableColumn, tableCell, t11, t12, _this = this, _null = null,
        _s10_ = "overflow-y",
        _s33_ = "spaces not allowed in class names",
        t1 = _this._dummyRowToForceAlternatingColor.element;
      J.get$children$x(_this._tbody.element).remove$1(0, t1);
      if (C.JSInt_methods.$mod(firstRenderedRowInclusive, 2) === 1) {
        J.get$children$x(_this._tbody.element).insert$2(0, 0, t1);
        ++currentRowIndex;
      }
      t1 = _this._rowForIndex;
      t1.clear$0(0);
      for (t2 = _this.columns, t3 = [P.String], t4 = _this.rowHeight, t5 = _this._dataForRow, index = firstRenderedRowInclusive; index < lastRenderedRowExclusive; ++index) {
        t6 = _this.data;
        if (index < 0 || index >= t6.length)
          return H.ioore(t6, index);
        dataObject = t6[index];
        t6 = J.get$children$x(_this._tbody.element);
        t6 = t6.get$length(t6);
        if (typeof t6 !== "number")
          return H.iae(t6);
        isReusableRow = currentRowIndex < t6;
        tableRow = isReusableRow ? new A.CoreElement(J.get$children$x(_this._tbody.element).$index(0, currentRowIndex)) : A.CoreElement$("tr", _null, _null, _null, _null);
        ++currentRowIndex;
        t6 = tableRow.element;
        t5.$indexSet(0, t6, dataObject);
        hoverCell = new Q.Table__buildTableRows_hoverCell(_this);
        t1.$indexSet(0, index, tableRow);
        t7 = !isReusableRow;
        if (t7)
          tableRow.click$1(0, new Q.Table__buildTableRows_closure(new Q.Table__buildTableRows_selectRow(_this), tableRow, index));
        t8 = "" + t4 + "px";
        t9 = t6.style;
        t9.height = t8;
        if (H.stringContainsUnchecked(_s10_, " ", 0))
          H.throwExpression(P.ArgumentError$(_s33_));
        J.get$classes$x(t6).add$1(0, _s10_);
        for (t8 = t2.length, t9 = J.getInterceptor$x(t6), currentColumnIndex = 0, _i = 0; _i < t2.length; t2.length === t8 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          column = t2[_i];
          t10 = t9.get$children(t6);
          t10 = t10.get$length(t10);
          if (typeof t10 !== "number")
            return H.iae(t10);
          isReusableColumn = currentColumnIndex < t10;
          tableCell = isReusableColumn ? new A.CoreElement(t9.get$children(t6).$index(0, currentColumnIndex)) : A.CoreElement$("td", _null, _null, _null, _null);
          ++currentColumnIndex;
          if (column.hover) {
            if (!J.$eq$(tableCell.get$over(), hoverCell))
              tableCell.over$1(new Q.Table__buildTableRows_closure0(hoverCell, tableRow, tableCell, index));
            if (!J.$eq$(tableCell.get$leave(), hoverCell))
              tableCell.leave$1(new Q.Table__buildTableRows_closure1(hoverCell, tableRow, index));
          }
          t10 = tableCell.element;
          t11 = J.getInterceptor$x(t10);
          t11.get$classes(t10).clear$0(0);
          if (column.get$cssClass() != null)
            C.JSArray_methods.forEach$1(H.setRuntimeTypeInfo(column.get$cssClass().split(" "), t3), tableCell.get$clazz());
          t12 = column._getAlignmentCss$1(column._alignment);
          if (H.stringContainsUnchecked(t12, " ", 0))
            H.throwExpression(P.ArgumentError$(_s33_));
          t11.get$classes(t10).add$1(0, t12);
          column.renderToElement$2(tableCell, dataObject);
          if (!isReusableColumn)
            tableRow.add$1(0, tableCell);
        }
        if (J.$eq$(dataObject, _this._selectedObject))
          _this._select$3(t6, _this._selectedObject, index);
        else
          t9.get$classes(t6).remove$1(0, "selected");
        if (t7)
          J.get$children$x(_this._tbody.element).add$1(0, t6);
      }
      return currentRowIndex;
    },
    _select$3: function(row, object, index) {
      var t1, t2, _this = this,
        _s8_ = "selected";
      H.assertSubtypeOfRuntimeType(object, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._tbody;
      if (t1 != null)
        for (t1 = t1.element, t2 = W.Element, t1.toString, H.assertIsSubtype(t2, t2, "The type argument '", "' is not a subtype of the type variable bound '", "' of type variable 'T' in 'querySelectorAll'."), t1 = new W._FrozenElementList(t1.querySelectorAll(".selected"), [t2]), t2 = new H.ListIterator(t1, t1.get$length(t1), [t2]); t2.moveNext$0();)
          J.get$classes$x(t2.__internal$_current).remove$1(0, _s8_);
      if (row != null)
        J.get$classes$x(row).add$1(0, _s8_);
      if (!J.$eq$(_this._selectedObject, object))
        _this._selectController.add$1(0, object);
      _this.set$_selectedObject(object);
      _this._selectedObjectIndex = index;
    },
    selectByIndex$2$scrollBehavior: function(newIndex, scrollBehavior) {
      var dataObject, _this = this,
        row = _this._rowForIndex.$index(0, newIndex),
        t1 = _this.data;
      if (newIndex < 0 || newIndex >= t1.length)
        return H.ioore(t1, newIndex);
      dataObject = t1[newIndex];
      _this._select$3(row == null ? null : row.element, dataObject, newIndex);
      _this._scrollToIndex$2$scrollBehavior(newIndex, scrollBehavior);
    },
    selectByIndex$1: function(newIndex) {
      return this.selectByIndex$2$scrollBehavior(newIndex, "smooth");
    },
    _scrollToIndex$2$scrollBehavior: function(rowIndex, scrollBehavior) {
      var newScrollTop,
        t1 = this.rowHeight,
        rowOffsetPixels = rowIndex * t1 + C.JSNumber_methods.round$0(this._thead.element.offsetHeight),
        t2 = this.element.element,
        visibleStartOffsetPixels = C.JSNumber_methods.round$0(t2.scrollTop),
        t3 = C.JSNumber_methods.round$0(t2.scrollTop),
        t4 = C.JSNumber_methods.round$0(t2.offsetHeight);
      if (rowOffsetPixels >= visibleStartOffsetPixels + t1 && rowOffsetPixels <= t3 + t4 - t1 * 2)
        return;
      newScrollTop = H.intTypeCheck(C.JSInt_methods.clamp$2(C.JSNumber_methods.round$0(rowOffsetPixels - C.JSNumber_methods.round$0(t2.offsetHeight) / 2), 0, C.JSNumber_methods.round$0(t2.scrollHeight)));
      J.scrollTo$1$x(t2, P.LinkedHashMap_LinkedHashMap$_literal(["left", C.JSNumber_methods.round$0(t2.scrollLeft), "top", newScrollTop, "behavior", scrollBehavior], P.String, null));
    },
    _columnClicked$1: function(column) {
      var _this = this;
      H.assertSubtype(column, "$isColumn", _this.$ti, "$asColumn");
      if (!column.get$supportsSorting())
        return;
      if (_this._sortColumn === column)
        _this._sortDirection = _this._sortDirection === C.SortOrder_0 ? C.SortOrder_1 : C.SortOrder_0;
      else
        _this.set$sortColumn(column);
      _this._doSort$0();
      _this._scheduleRebuild$0();
    },
    set$data: function(_, data) {
      this.data = H.assertSubtype(data, "$isList", this.$ti, "$asList");
    },
    set$_sortColumn: function(_sortColumn) {
      this._sortColumn = H.assertSubtype(_sortColumn, "$isColumn", this.$ti, "$asColumn");
    },
    set$_selectedObject: function(_selectedObject) {
      this._selectedObject = H.assertSubtypeOfRuntimeType(_selectedObject, H.getTypeArgumentByIndex(this, 0));
    }
  };
  Q.Table$virtual_closure.prototype = {
    call$1: function(_) {
      return this.$this._scheduleRebuild$0();
    },
    $signature: 23
  };
  Q.Table__init_closure.prototype = {
    call$1: function(e) {
      var indexOffset, t1, currentIndex, newIndex, t2, _null = null;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      switch (e.keyCode) {
        case 38:
          indexOffset = -1;
          break;
        case 40:
          indexOffset = 1;
          break;
        case 37:
          this.$this._handleLeftKey$0();
          indexOffset = _null;
          break;
        case 39:
          this.$this._handleRightKey$0();
          indexOffset = _null;
          break;
        default:
          indexOffset = _null;
          break;
      }
      if (indexOffset == null)
        return;
      e.preventDefault();
      t1 = this.$this;
      currentIndex = t1._selectedObjectIndex;
      newIndex = currentIndex == null ? 0 : currentIndex + indexOffset;
      t2 = t1.data;
      t2 = t2 == null ? _null : t2.length;
      t1.selectByIndex$1(H.intTypeCheck(C.JSInt_methods.clamp$2(newIndex, 0, (t2 == null ? 1 : t2) - 1)));
    },
    $signature: 14
  };
  Q.Table_setRows_closure.prototype = {
    call$1: function(column) {
      var t2, s, header, _null = null,
        t1 = this.$this;
      H.assertSubtype(column, "$isColumn", [H.getTypeArgumentByIndex(t1, 0)], "$asColumn");
      t2 = column.title;
      s = A.CoreElement$("span", _null, "interactable" + (column.get$supportsSorting() ? " sortable" : ""), _null, t2);
      s.click$1(0, new Q.Table_setRows__closure(t1, column));
      t1._spanForColumn.$indexSet(0, column, s);
      header = A.CoreElement$("th", _null, "sticky-top " + column._getAlignmentCss$1(column._alignment), _null, _null);
      header.add$1(0, s);
      t1 = column.fixedWidthPx;
      if (t1 != null) {
        t2 = header.element.style;
        t1 = H.S(t1) + "px";
        t2.width = t1;
      } else {
        t1 = column.percentWidth;
        if (t1 != null) {
          t2 = header.element.style;
          t1 = H.S(t1) + "%";
          t2.width = t1;
        }
      }
      return header;
    },
    $signature: function() {
      return {func: 1, ret: A.CoreElement, args: [[Q.Column, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  Q.Table_setRows__closure.prototype = {
    call$0: function() {
      return this.$this._columnClicked$1(this.column);
    },
    $signature: 1
  };
  Q.Table_setRows_closure0.prototype = {
    call$1: function(c) {
      return H.assertSubtype(c, "$isColumn", [H.getTypeArgumentByIndex(this.$this, 0)], "$asColumn").get$supportsSorting();
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [[Q.Column, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  Q.Table_setRows_closure1.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  Q.Table_scrollTo_closure.prototype = {
    call$0: function() {
      this.$this._scrollToIndex$2$scrollBehavior(this.index, this.scrollBehavior);
    },
    $signature: 0
  };
  Q.Table__scheduleRebuild_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._hasPendingRebuild = false;
      t1._rebuildTable$0();
    },
    $signature: 0
  };
  Q.Table__sortData_closure.prototype = {
    call$2: function(a, b) {
      var t1 = this.$this,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return t1._compareData$4(H.assertSubtypeOfRuntimeType(a, t2), H.assertSubtypeOfRuntimeType(b, t2), this.column, this.direction);
    },
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  Q.Table__rebuildVirtualTable_closure.prototype = {
    call$1: function(e) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(e, "$isElement");
      t1 = this.$this;
      t2 = t1._rowForIndex;
      t2 = t2.get$values(t2);
      t3 = W.Element;
      t4 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
      t3 = H.MappedIterable_MappedIterable(t2, H.functionTypeCheck(new Q.Table__rebuildVirtualTable__closure(), {func: 1, ret: t3, args: [t4]}), t4, t3);
      if (!C.JSArray_methods.contains$1(P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0)), e)) {
        t1 = t1._spacerBeforeVisibleRows.element;
        t1 = e == null ? t1 != null : e !== t1;
      } else
        t1 = false;
      return t1;
    },
    $signature: 42
  };
  Q.Table__rebuildVirtualTable__closure.prototype = {
    call$1: function(el) {
      return H.interceptedTypeCheck(el, "$isCoreElement").element;
    },
    $signature: 74
  };
  Q.Table__buildTableRows_selectRow.prototype = {
    call$2: function(row, index) {
      var t1 = this.$this;
      t1._select$3(row, t1._dataForRow.$index(0, row), index);
    },
    $signature: 188
  };
  Q.Table__buildTableRows_hoverCell.prototype = {
    call$3: function(row, cell, rowIndex) {
      var t1, t2;
      H.interceptedTypeCheck(row, "$isCoreElement");
      H.interceptedTypeCheck(cell, "$isCoreElement");
      H.intTypeCheck(rowIndex);
      t1 = this.$this;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      t1._selectElementController.add$1(0, new Q.HoverCellData(cell, H.assertSubtypeOfRuntimeType(t1._dataForRow.$index(0, row.element), t2), [t2]));
    },
    "call*": "call$3",
    $requiredArgCount: 3,
    $signature: 189
  };
  Q.Table__buildTableRows_closure.prototype = {
    call$0: function() {
      return this.selectRow.call$2(this.tableRow.element, this.index);
    },
    $signature: 1
  };
  Q.Table__buildTableRows_closure0.prototype = {
    call$0: function() {
      var _this = this;
      return _this.hoverCell.call$3(_this.tableRow, _this.tableCell, _this.index);
    },
    $signature: 1
  };
  Q.Table__buildTableRows_closure1.prototype = {
    call$0: function() {
      return this.hoverCell.call$3(this.tableRow, null, this.index);
    },
    $signature: 1
  };
  Q.TreeTable.prototype = {
    _handleLeftKey$0: function() {
      var t2, _this = this,
        t1 = _this._selectedObject;
      if (t1 != null)
        if (t1.isExpanded)
          _this.collapseNode$1(t1);
        else {
          t2 = _this.data;
          _this.selectByIndex$1((t2 && C.JSArray_methods).indexOf$1(t2, t1.parent));
        }
    },
    _handleRightKey$0: function() {
      var t2, _this = this,
        t1 = _this._selectedObject;
      if (t1 != null)
        if (t1.isExpanded) {
          t2 = _this.data;
          _this.selectByIndex$1((t2 && C.JSArray_methods).indexOf$1(t2, C.JSArray_methods.get$first(t1.children)));
        } else if (t1.children.length !== 0)
          _this.expandNode$1(t1);
    },
    _sortData$2: function(column, direction) {
      var t2, _this = this,
        sortedData = H.setRuntimeTypeInfo([], _this.$ti),
        t1 = _this.data;
      t1.toString;
      t2 = H.getTypeArgumentByIndex(t1, 0);
      t2 = P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new Q.TreeTable__sortData_closure(_this), {func: 1, ret: P.bool, args: [t2]}), [t2]), true, t2);
      C.JSArray_methods.sort$1(t2, new Q.TreeTable__sortData_closure0(_this, column, direction));
      C.JSArray_methods.forEach$1(t2, new Q.TreeTable__sortData__addToSortedData(_this, sortedData, column, direction));
      _this.set$data(0, sortedData);
    },
    collapseNode$1: function(dataObject) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(dataObject, H.getTypeArgumentByIndex(_this, 0));
      C.JSArray_methods.forEach$1(dataObject.children, new Q.TreeTable_collapseNode_cascadingRemove(_this));
      dataObject.isExpanded = false;
      _this.setRows$1(_this.data);
    },
    expandNode$1: function(dataObject) {
      var _this = this;
      new Q.TreeTable_expandNode_expand(_this).call$1(H.assertSubtypeOfRuntimeType(dataObject, H.getTypeArgumentByIndex(_this, 0)));
      _this.setRows$1(_this.data);
    }
  };
  Q.TreeTable__sortData__addToSortedData.prototype = {
    call$1: function(dataObject) {
      var t2, _this = this,
        t1 = _this.$this;
      H.assertSubtypeOfRuntimeType(dataObject, H.getTypeArgumentByIndex(t1, 0));
      C.JSArray_methods.add$1(_this.sortedData, dataObject);
      if (dataObject.isExpanded) {
        t2 = dataObject.children;
        C.JSArray_methods.sort$1(t2, new Q.TreeTable__sortData__addToSortedData_closure(t1, _this.column, _this.direction));
        C.JSArray_methods.forEach$1(t2, _this);
      }
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  Q.TreeTable__sortData__addToSortedData_closure.prototype = {
    call$2: function(a, b) {
      var t1 = this.$this,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return t1._compareData$4(H.assertSubtypeOfRuntimeType(a, t2), H.assertSubtypeOfRuntimeType(b, t2), this.column, this.direction);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  Q.TreeTable__sortData_closure.prototype = {
    call$1: function(dataObject) {
      return J.get$level$x(H.assertSubtypeOfRuntimeType(dataObject, H.getTypeArgumentByIndex(this.$this, 0))) === 0;
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  Q.TreeTable__sortData_closure0.prototype = {
    call$2: function(a, b) {
      var t1 = this.$this,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return t1._compareData$4(H.assertSubtypeOfRuntimeType(a, t2), H.assertSubtypeOfRuntimeType(b, t2), this.column, this.direction);
    },
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: P.int, args: [t1, t1]};
    }
  };
  Q.TreeTable_collapseNode_cascadingRemove.prototype = {
    call$1: function(_dataObject) {
      var t2,
        t1 = this.$this;
      H.assertSubtypeOfRuntimeType(_dataObject, H.getTypeArgumentByIndex(t1, 0));
      t2 = t1.data;
      if (!(t2 && C.JSArray_methods).contains$1(t2, _dataObject))
        return;
      t1 = t1.data;
      (t1 && C.JSArray_methods).remove$1(t1, _dataObject);
      C.JSArray_methods.forEach$1(_dataObject.children, this);
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  Q.TreeTable_expandNode_expand.prototype = {
    call$1: function(node) {
      var t2, insertIndex, child, t3,
        t1 = this.$this;
      H.assertSubtypeOfRuntimeType(node, H.getTypeArgumentByIndex(t1, 0));
      t2 = t1.data;
      insertIndex = (t2 && C.JSArray_methods).indexOf$1(t2, node) + 1;
      for (t2 = C.JSArray_methods.get$iterator(node.children); t2.moveNext$0();) {
        child = t2.get$current(t2);
        t3 = t1.data;
        (t3 && C.JSArray_methods).insert$2(t3, insertIndex, child);
        if (child.isExpanded)
          this.call$1(child);
        ++insertIndex;
      }
      node.isExpanded = true;
    },
    $signature: function() {
      return {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  Q.Column.prototype = {
    Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml: function(title, alignment, cssClass, fixedWidthPx, hover, percentWidth, usesHtml, $T) {
      var t1 = this.percentWidth;
      if (t1 != null)
        C.JSInt_methods.clamp$2(t1, 0, 100);
    },
    get$numeric: function() {
      return false;
    },
    get$supportsSorting: function() {
      return this.get$numeric();
    },
    getDisplayValue$1: function(dataObject) {
      return this.getValue$1(H.assertSubtypeOfRuntimeType(dataObject, H.getRuntimeTypeArgument(this, "Column", 0)));
    },
    getTooltip$1: function(dataObject) {
      H.assertSubtypeOfRuntimeType(dataObject, H.getRuntimeTypeArgument(this, "Column", 0));
      return "";
    },
    render$1: function(value) {
      if (typeof value === "number")
        return Q.Column_fastIntl(value);
      return J.toString$0$(value);
    },
    toString$0: function(_) {
      return this.title;
    },
    renderToElement$2: function(cell, dataObject) {
      var $content, t1, _this = this;
      H.assertSubtypeOfRuntimeType(dataObject, H.getRuntimeTypeArgument(_this, "Column", 0));
      $content = _this.render$1(_this.getDisplayValue$1(dataObject));
      t1 = cell.element;
      if (_this.get$usesHtml())
        J.setInnerHtml$2$treeSanitizer$x(t1, $content, C.C_TrustedHtmlTreeSanitizer);
      else
        t1.textContent = $content;
      t1.title = _this.getTooltip$1(dataObject);
    },
    _getAlignmentCss$1: function(alignment) {
      switch (alignment) {
        case C.ColumnAlignment_0:
          return "left";
        case C.ColumnAlignment_1:
          return "right";
        case C.ColumnAlignment_2:
          return "center";
        default:
          throw H.wrapException(P.Exception_Exception("Invalid column alignment: " + alignment.toString$0(0)));
      }
    },
    get$usesHtml: function() {
      return this.usesHtml;
    },
    get$cssClass: function() {
      return this.cssClass;
    }
  };
  Q.TreeColumn.prototype = {
    renderToElement$2: function(cell, dataObject) {
      var container, t1, t2, t3, indentWidth, t4, treeToggle, _this = this, _null = null;
      H.assertSubtypeOfRuntimeType(dataObject, H.getRuntimeTypeArgument(_this, "TreeColumn", 0));
      container = A.CoreElement$("div", _null, _null, _null, _null);
      t1 = container.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("horizontal", "");
      container.flex$0(0);
      t1 = A.CoreElement$("div", _null, _null, _null, _null);
      t2 = t1.element.style;
      t3 = J.get$level$x(dataObject);
      if (typeof t3 !== "number")
        return t3.$mul();
      indentWidth = t3 * 14;
      t3 = dataObject.children;
      t4 = "" + (t3.length === 0 ? indentWidth + 14 : indentWidth) + "px";
      t2.minWidth = t4;
      container.add$1(0, t1);
      if (t3.length !== 0) {
        treeToggle = N.TreeToggle$(false, dataObject.isExpanded);
        t1 = treeToggle._openController;
        new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new Q.TreeColumn_renderToElement_closure(_this, dataObject));
        container.add$1(0, treeToggle);
      }
      container.add$1(0, A.CoreElement$("div", _null, _null, _null, _this.render$1(_this.getDisplayValue$1(dataObject))));
      t1 = cell.element;
      J.get$children$x(t1).clear$0(0);
      cell.add$1(0, container);
      t1.title = H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").name;
    }
  };
  Q.TreeColumn_renderToElement_closure.prototype = {
    call$1: function(isOpen) {
      var t1 = this.$this,
        t2 = this.dataObject;
      if (H.boolConversionCheck(H.boolTypeCheck(isOpen)))
        t1._nodeExpandedController.add$1(0, t2);
      else
        t1._nodeCollapsedController.add$1(0, t2);
    },
    $signature: 9
  };
  Q.ColumnAlignment.prototype = {
    toString$0: function(_) {
      return this._tables$_name;
    }
  };
  Q.SortOrder.prototype = {
    toString$0: function(_) {
      return this._tables$_name;
    }
  };
  Q._Table_Object_SetStateMixin.prototype = {};
  R.CpuFlameChart.prototype = {
    rebuildView$0: function() {
      var _this = this,
        t1 = _this.timelineController.timelineData.cpuProfileData,
        t2 = _this.element,
        t3 = t2.clientWidth;
      t2 = t2.clientHeight;
      if (typeof t2 !== "number")
        return t2.$sub();
      t3 = F.FlameChartCanvas$(t1, Math.max(t2 - 27, (t1._cpuProfileRoot.get$depth() + 1) * 27), t3);
      _this.canvas = t3;
      t3 = t3._stackFrameSelectedController;
      new P._BroadcastStream(t3, [H.getTypeArgumentByIndex(t3, 0)]).listen$1(new R.CpuFlameChart_rebuildView_closure(_this));
      _this.add$1(0, _this.canvas._viewportCanvas._viewport_canvas$_element);
      t3 = _this.stackFrameDetails;
      t3.element.textContent = "[No stack frame selected]";
      t3.attribute$2("hidden", false);
    },
    update$0: function(_) {
      this.reset$0(0);
      this.super$CpuProfilerView$update(0);
    },
    updateForContainerResize$0: function() {
      var t1, t2, _this = this;
      if (_this.canvas == null)
        return;
      t1 = _this.element;
      if (!H.boolConversionCheck(t1.hasAttribute("hidden")) && _this.timelineController.timelineData.cpuProfileData != null) {
        t2 = _this.canvas;
        t2.forceRebuildForSize$2(t2.getFlameChartWidth$0() + 140, Math.max(C.JSNumber_methods.round$0(t1.scrollHeight) - 27, (_this.timelineController.timelineData.cpuProfileData._cpuProfileRoot.get$depth() + 1) * 27));
      } else
        _this.viewNeedsRebuild = true;
    },
    reset$0: function(_) {
      var t1 = this.canvas,
        t2 = t1 == null ? null : t1._viewportCanvas._viewport_canvas$_element;
      if ((t2 == null ? null : t2.element) != null)
        J.remove$0$ax(t1._viewportCanvas._viewport_canvas$_element.element);
      this.canvas = null;
      t1 = this.stackFrameDetails;
      t1.element.textContent = "[No stack frame selected]";
      t1.attribute$2("hidden", true);
    }
  };
  R.CpuFlameChart_rebuildView_closure.prototype = {
    call$1: function(stackFrame) {
      var t1, t2;
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      t1 = this.$this.stackFrameDetails;
      t2 = J.toString$0$(stackFrame);
      t1.element.textContent = t2;
    },
    $signature: 190
  };
  E.CpuProfileData.prototype = {
    get$json: function(_) {
      var _this = this,
        t1 = _this.time,
        t2 = t1._utils$_start._duration;
      return P.LinkedHashMap_LinkedHashMap$_literal(["type", "_CpuProfileTimeline", "samplePeriod", _this.samplePeriod, "sampleCount", _this.sampleCount, "timeOriginMicros", t2, "timeExtentMicros", t1._utils$_end._duration - t2, "stackFrames", _this.stackFramesJson, "traceEvents", _this.stackTraceEvents], P.String, null);
    }
  };
  E.CpuProfileData_subProfile_closure.prototype = {
    call$1: function(trace) {
      var t1 = this.subTimeRange,
        t2 = P.Duration$(H.intTypeCheck(J.$index$asx(H.assertSubtype(trace, "$isMap", [P.String, null], "$asMap"), "ts")), 0, 0, 0)._duration;
      return t2 >= t1._utils$_start._duration && t2 <= t1._utils$_end._duration;
    },
    $signature: 191
  };
  E.CpuStackFrame.prototype = {
    get$inclusiveSampleCount: function() {
      var t1 = this._inclusiveSampleCount;
      return t1 == null ? this._calculateInclusiveSampleCount$0() : t1;
    },
    get$totalTimeRatio: function() {
      var t2, _this = this,
        t1 = _this._totalTimeRatio;
      if (t1 == null) {
        t1 = _this.get$inclusiveSampleCount();
        t2 = _this.profileSampleCount;
        if (typeof t1 !== "number")
          return t1.$div();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = _this._totalTimeRatio = t1 / t2;
        t1 = t2;
      }
      return t1;
    },
    get$totalTime: function() {
      var t2, t3, _this = this,
        t1 = _this._totalTime;
      if (t1 == null) {
        t1 = _this.get$totalTimeRatio();
        t2 = _this.profileTime;
        t3 = t2._utils$_end;
        t2 = t2._utils$_start;
        t2 = _this._totalTime = P.Duration$(C.JSNumber_methods.round$0(t1 * (t3._duration - t2._duration)), 0, 0, 0);
        t1 = t2;
      }
      return t1;
    },
    get$selfTimeRatio: function() {
      var t2, _this = this,
        t1 = _this._selfTimeRatio;
      if (t1 == null) {
        t1 = _this.exclusiveSampleCount;
        t2 = _this.profileSampleCount;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = _this._selfTimeRatio = t1 / t2;
        t1 = t2;
      }
      return t1;
    },
    _calculateInclusiveSampleCount$0: function() {
      var t1, t2, _i, child, t3,
        count = this.exclusiveSampleCount;
      for (t1 = this.children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        t3 = child._inclusiveSampleCount;
        if (t3 == null)
          t3 = child._calculateInclusiveSampleCount$0();
        if (typeof t3 !== "number")
          return H.iae(t3);
        count += t3;
      }
      return this._inclusiveSampleCount = count;
    },
    shallowCopy$1$resetInclusiveSampleCount: function(resetInclusiveSampleCount) {
      var _this = this,
        copy = E.CpuStackFrame$(_this.category, _this.id, _this.name, _this.profileSampleCount, _this.profileTime, _this.url);
      copy.exclusiveSampleCount = _this.exclusiveSampleCount;
      copy._inclusiveSampleCount = resetInclusiveSampleCount ? null : _this.get$inclusiveSampleCount();
      return copy;
    },
    shallowCopy$0: function() {
      return this.shallowCopy$1$resetInclusiveSampleCount(false);
    },
    deepCopy$0: function() {
      var t1, t2, t3, t4, _i, t5,
        copy = this.shallowCopy$0();
      for (t1 = this.children, t2 = t1.length, t3 = H.getRuntimeTypeArgument(copy, "TreeNode0", 0), t4 = copy.children, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        t5 = H.assertSubtypeOfRuntimeType(t1[_i].deepCopy$0(), t3);
        C.JSArray_methods.add$1(t4, t5);
        t5.set$parent(0, H.assertSubtypeOfRuntimeType(copy, t3));
        t5.index = t4.length - 1;
      }
      return copy;
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.name + " ";
      _this.get$totalTime();
      t1 += "- " + B.msText(_this.get$totalTime(), 2) + " ";
      t1 += "(" + H.S(_this.get$inclusiveSampleCount()) + " ";
      t1 = t1 + (_this.get$inclusiveSampleCount() === 1 ? "sample" : "samples") + (", " + (C.JSNumber_methods.toStringAsFixed$1(_this.get$totalTimeRatio() * 100, 2) + "%") + ")");
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asTreeNode0: function() {
      return [E.CpuStackFrame];
    },
    get$id: function(receiver) {
      return this.id;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  N.CpuProfileProtocol.prototype = {
    processData$1: function(cpuProfileData) {
      if (cpuProfileData.processed)
        return;
      J.forEach$1$ax(cpuProfileData.stackFramesJson, new N.CpuProfileProtocol_processData_closure(this, cpuProfileData));
      this._setExclusiveSampleCounts$1(cpuProfileData);
      cpuProfileData.processed = true;
    },
    _setExclusiveSampleCounts$1: function(cpuProfileData) {
      var t1, t2, t3;
      for (t1 = J.get$iterator$ax(cpuProfileData.stackTraceEvents), t2 = cpuProfileData.stackFrames; t1.moveNext$0();) {
        t3 = t2.$index(0, J.$index$asx(t1.get$current(t1), "sf"));
        if (t3 != null)
          ++t3.exclusiveSampleCount;
      }
    }
  };
  N.CpuProfileProtocol_processData_closure.prototype = {
    call$2: function(k, v) {
      var t1, t2, t3, stackFrame;
      H.stringTypeCheck(k);
      t1 = J.getInterceptor$asx(v);
      t2 = B.getSimpleStackFrameName(H.stringTypeCheck(t1.$index(v, "name")));
      t3 = this.cpuProfileData;
      stackFrame = E.CpuStackFrame$(H.stringTypeCheck(t1.$index(v, "category")), k, t2, t3.sampleCount, t3.time, H.stringTypeCheck(t1.$index(v, "resolvedUrl")));
      t2 = t3.stackFrames;
      t1 = t2.$index(0, t1.$index(v, "parent"));
      t2.$indexSet(0, stackFrame.id, stackFrame);
      if (t1 == null)
        t3._cpuProfileRoot.addChild$1(stackFrame);
      else
        t1.addChild$1(stackFrame);
    },
    $signature: 25
  };
  N.BottomUpProfileProcessor.prototype = {
    getRoots$3: function(node, currentBottomUpRoot, bottomUpRoots) {
      var copy, t1, t2, _i;
      H.assertSubtype(bottomUpRoots, "$isList", [E.CpuStackFrame], "$asList");
      copy = node.shallowCopy$1$resetInclusiveSampleCount(true);
      if (currentBottomUpRoot != null)
        copy.addChild$1(currentBottomUpRoot.deepCopy$0());
      if (node.exclusiveSampleCount > 0)
        C.JSArray_methods.add$1(bottomUpRoots, copy);
      for (t1 = node.children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        this.getRoots$3(t1[_i], copy, bottomUpRoots);
      return bottomUpRoots;
    },
    cascadeSampleCounts$1: function(stackFrame) {
      var t1, t2, _i, child;
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      stackFrame._inclusiveSampleCount = stackFrame.exclusiveSampleCount;
      for (t1 = stackFrame.children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        child.exclusiveSampleCount = stackFrame.exclusiveSampleCount;
        this.cascadeSampleCounts$1(child);
      }
    },
    mergeRoots$1: function(roots) {
      var rootsCopy, t2, t3, t4, _i, root, matchingRoots, t5, _i0, duplicate, t6, t7,
        t1 = E.CpuStackFrame;
      H.assertSubtype(roots, "$isList", [t1], "$asList");
      rootsCopy = P.List_List$from(roots, true, t1);
      for (t1 = rootsCopy.length, t2 = H.getTypeArgumentByIndex(roots, 0), t3 = {func: 1, ret: P.bool, args: [t2]}, t4 = [t2], _i = 0; _i < rootsCopy.length; rootsCopy.length === t1 || (0, H.throwConcurrentModificationError)(rootsCopy), ++_i) {
        root = rootsCopy[_i];
        if (!C.JSArray_methods.contains$1(roots, root))
          continue;
        matchingRoots = P.List_List$from(new H.WhereIterable(roots, H.functionTypeCheck(new N.BottomUpProfileProcessor_mergeRoots_closure(root), t3), t4), true, t2);
        t5 = matchingRoots.length;
        if (t5 === 0)
          continue;
        for (_i0 = 0; _i0 < matchingRoots.length; matchingRoots.length === t5 || (0, H.throwConcurrentModificationError)(matchingRoots), ++_i0) {
          duplicate = matchingRoots[_i0];
          C.JSArray_methods.forEach$1(duplicate.children, root.get$addChild());
          root.exclusiveSampleCount = root.exclusiveSampleCount + duplicate.exclusiveSampleCount;
          t6 = root._inclusiveSampleCount;
          if (t6 == null)
            t6 = root._calculateInclusiveSampleCount$0();
          t7 = duplicate._inclusiveSampleCount;
          if (t7 == null)
            t7 = duplicate._calculateInclusiveSampleCount$0();
          if (typeof t6 !== "number")
            return t6.$add();
          if (typeof t7 !== "number")
            return H.iae(t7);
          root._inclusiveSampleCount = t6 + t7;
          C.JSArray_methods.remove$1(roots, duplicate);
          this.mergeRoots$1(root.children);
        }
      }
    }
  };
  N.BottomUpProfileProcessor_mergeRoots_closure.prototype = {
    call$1: function(other) {
      var t1;
      H.interceptedTypeCheck(other, "$isCpuStackFrame");
      t1 = this.root;
      return other.name === t1.name && other.url == t1.url && other.category == t1.category && other != t1;
    },
    $signature: 193
  };
  Y.CpuCallTree.prototype = {
    _cpu_profile_tables$_init$0: function() {
      var t5, t6, t7, _this = this, _null = null,
        _s10_ = "Total Time",
        _s9_ = "Self Time",
        t1 = E.CpuStackFrame,
        t2 = [t1],
        t3 = new P._AsyncBroadcastStreamController(_null, _null, t2),
        t4 = new P._AsyncBroadcastStreamController(_null, _null, t2),
        methodNameColumn = new Y.MethodNameColumn(t3, t4, "Method", _null, _null, C.ColumnAlignment_0, false, _null, false);
      methodNameColumn.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Method", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      new P._BroadcastStream(t3, [t1]).listen$1(new Y.CpuCallTree__init_closure(_this));
      new P._BroadcastStream(t4, [t1]).listen$1(new Y.CpuCallTree__init_closure0(_this));
      t3 = [Q.Column, E.CpuStackFrame];
      t4 = H.setRuntimeTypeInfo([], [t3]);
      t5 = A.CoreElement$("table", _null, _null, _null, _null);
      t5.clazz$1("full-width");
      t5.element.setAttribute("tabIndex", "0");
      t6 = A.CoreElement$("tr", _null, _null, _null, _null);
      t7 = t6.element.style;
      t7.display = "none";
      t7 = A.CoreElement;
      t2 = new Q.TreeTable(A.CoreElement$("div", "flex", "overflow-auto table-border table-virtual", _null, _null), 29, t4, t5, t6, P.LinkedHashMap_LinkedHashMap$_empty(t3, t7), P.LinkedHashMap_LinkedHashMap$_empty(W.Element, t1), P.LinkedHashMap_LinkedHashMap$_empty(P.int, t7), new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, [P.Null]), new P._AsyncBroadcastStreamController(_null, _null, [[Q.HoverCellData, t1]]), [t1]);
      t2.Table$virtual$2$overflowAuto$rowHeight(true, 29, t1);
      t3 = new Y.TotalTimeColumn(_s10_, 145, _null, C.ColumnAlignment_0, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml(_s10_, C.ColumnAlignment_0, _null, 145, false, _null, false, t1);
      t5 = [t1];
      C.JSArray_methods.add$1(t4, H.assertSubtype(t3, "$isColumn", t5, "$asColumn"));
      t3 = new Y.SelfTimeColumn(_s9_, 145, _null, C.ColumnAlignment_0, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml(_s9_, C.ColumnAlignment_0, _null, 145, false, _null, false, t1);
      C.JSArray_methods.add$1(t4, H.assertSubtype(t3, "$isColumn", t5, "$asColumn"));
      C.JSArray_methods.add$1(t4, H.assertSubtype(methodNameColumn, "$isColumn", t5, "$asColumn"));
      t3 = new Y.SourceColumn("Source", _null, _null, C.ColumnAlignment_1, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Source", C.ColumnAlignment_1, _null, _null, false, _null, false, t1);
      C.JSArray_methods.add$1(t4, H.assertSubtype(t3, "$isColumn", t5, "$asColumn"));
      _this.set$callTreeTable(t2);
      t2 = _this.callTreeTable;
      t2.set$sortColumn(C.JSArray_methods.get$first(t2.columns));
      t2.setRows$1(H.setRuntimeTypeInfo([], [t1]));
      _this.add$1(0, _this.callTreeTable.element);
    },
    rebuildView$0: function() {
      var t1, rows, t2,
        root = this.timelineController.timelineData.cpuProfileData._cpuProfileRoot.deepCopy$0();
      root.isExpanded = true;
      t1 = E.CpuStackFrame;
      rows = H.setRuntimeTypeInfo([root], [t1]);
      t2 = root.children;
      C.JSArray_methods.addAll$1(rows, new H.CastList(t2, [H.getTypeArgumentByIndex(t2, 0), t1]));
      this.callTreeTable.setRows$1(rows);
    },
    set$callTreeTable: function(callTreeTable) {
      this.callTreeTable = H.assertSubtype(callTreeTable, "$isTreeTable", [E.CpuStackFrame], "$asTreeTable");
    }
  };
  Y.CpuCallTree__init_closure.prototype = {
    call$1: function(stackFrame) {
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      return this.$this.callTreeTable.expandNode$1(stackFrame);
    },
    $signature: 27
  };
  Y.CpuCallTree__init_closure0.prototype = {
    call$1: function(stackFrame) {
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      return this.$this.callTreeTable.collapseNode$1(stackFrame);
    },
    $signature: 27
  };
  Y.CpuBottomUp.prototype = {
    _cpu_profile_tables$_init$0: function() {
      var selfTimeColumn, t5, t6, t7, _this = this, _null = null,
        _s9_ = "Self Time",
        _s10_ = "Total Time",
        t1 = E.CpuStackFrame,
        t2 = [t1],
        t3 = new P._AsyncBroadcastStreamController(_null, _null, t2),
        t4 = new P._AsyncBroadcastStreamController(_null, _null, t2),
        methodNameColumn = new Y.MethodNameColumn(t3, t4, "Method", _null, _null, C.ColumnAlignment_0, false, _null, false);
      methodNameColumn.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Method", C.ColumnAlignment_0, _null, _null, false, _null, false, t1);
      new P._BroadcastStream(t3, [t1]).listen$1(new Y.CpuBottomUp__init_closure(_this));
      new P._BroadcastStream(t4, [t1]).listen$1(new Y.CpuBottomUp__init_closure0(_this));
      selfTimeColumn = new Y.SelfTimeColumn(_s9_, 145, _null, C.ColumnAlignment_0, false, _null, false);
      selfTimeColumn.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml(_s9_, C.ColumnAlignment_0, _null, 145, false, _null, false, t1);
      t3 = [Q.Column, E.CpuStackFrame];
      t4 = H.setRuntimeTypeInfo([], [t3]);
      t5 = A.CoreElement$("table", _null, _null, _null, _null);
      t5.clazz$1("full-width");
      t5.element.setAttribute("tabIndex", "0");
      t6 = A.CoreElement$("tr", _null, _null, _null, _null);
      t7 = t6.element.style;
      t7.display = "none";
      t7 = A.CoreElement;
      t2 = new Q.TreeTable(A.CoreElement$("div", "flex", "overflow-auto table-border table-virtual", _null, _null), 29, t4, t5, t6, P.LinkedHashMap_LinkedHashMap$_empty(t3, t7), P.LinkedHashMap_LinkedHashMap$_empty(W.Element, t1), P.LinkedHashMap_LinkedHashMap$_empty(P.int, t7), new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, [P.Null]), new P._AsyncBroadcastStreamController(_null, _null, [[Q.HoverCellData, t1]]), [t1]);
      t2.Table$virtual$2$overflowAuto$rowHeight(true, 29, t1);
      t3 = new Y.TotalTimeColumn(_s10_, 145, _null, C.ColumnAlignment_0, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml(_s10_, C.ColumnAlignment_0, _null, 145, false, _null, false, t1);
      t5 = [t1];
      C.JSArray_methods.add$1(t4, H.assertSubtype(t3, "$isColumn", t5, "$asColumn"));
      C.JSArray_methods.add$1(t4, H.assertSubtype(selfTimeColumn, "$isColumn", t5, "$asColumn"));
      C.JSArray_methods.add$1(t4, H.assertSubtype(methodNameColumn, "$isColumn", t5, "$asColumn"));
      t3 = new Y.SourceColumn("Source", _null, _null, C.ColumnAlignment_1, false, _null, false);
      t3.Column$7$alignment$cssClass$fixedWidthPx$hover$percentWidth$usesHtml("Source", C.ColumnAlignment_1, _null, _null, false, _null, false, t1);
      C.JSArray_methods.add$1(t4, H.assertSubtype(t3, "$isColumn", t5, "$asColumn"));
      _this.set$bottomUpTable(t2);
      t2 = _this.bottomUpTable;
      t2.set$sortColumn(selfTimeColumn);
      t2.setRows$1(H.setRuntimeTypeInfo([], [t1]));
      _this.add$1(0, _this.bottomUpTable.element);
    },
    rebuildView$0: function() {
      var t1 = new N.BottomUpProfileProcessor(),
        bottomUpRoots = t1.getRoots$3(this.timelineController.timelineData.cpuProfileData._cpuProfileRoot, null, H.setRuntimeTypeInfo([], [E.CpuStackFrame]));
      C.JSArray_methods.forEach$1(bottomUpRoots, t1.get$cascadeSampleCounts());
      t1.mergeRoots$1(bottomUpRoots);
      this.bottomUpTable.setRows$1(bottomUpRoots);
    },
    set$bottomUpTable: function(bottomUpTable) {
      this.bottomUpTable = H.assertSubtype(bottomUpTable, "$isTreeTable", [E.CpuStackFrame], "$asTreeTable");
    }
  };
  Y.CpuBottomUp__init_closure.prototype = {
    call$1: function(stackFrame) {
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      return this.$this.bottomUpTable.expandNode$1(stackFrame);
    },
    $signature: 27
  };
  Y.CpuBottomUp__init_closure0.prototype = {
    call$1: function(stackFrame) {
      H.interceptedTypeCheck(stackFrame, "$isCpuStackFrame");
      return this.$this.bottomUpTable.collapseNode$1(stackFrame);
    },
    $signature: 27
  };
  Y.SelfTimeColumn.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").get$selfTimeRatio();
    },
    getDisplayValue$1: function(dataObject) {
      var t1, t2, t3;
      H.interceptedTypeCheck(dataObject, "$isCpuStackFrame");
      t1 = dataObject._selfTime;
      if (t1 == null) {
        t1 = dataObject.get$selfTimeRatio();
        t2 = dataObject.profileTime;
        t3 = t2._utils$_end;
        t2 = t2._utils$_start;
        t2 = dataObject._selfTime = P.Duration$(C.JSNumber_methods.round$0(t1 * (t3._duration - t2._duration)), 0, 0, 0);
        t1 = t2;
      }
      return B.msText(t1, 2) + " (" + (C.JSNumber_methods.toStringAsFixed$1(dataObject.get$selfTimeRatio() * 100, 2) + "%") + ")";
    },
    $asColumn: function() {
      return [E.CpuStackFrame];
    }
  };
  Y.TotalTimeColumn.prototype = {
    get$numeric: function() {
      return true;
    },
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").get$totalTimeRatio();
    },
    getDisplayValue$1: function(dataObject) {
      H.interceptedTypeCheck(dataObject, "$isCpuStackFrame");
      return B.msText(dataObject.get$totalTime(), 2) + " (" + (C.JSNumber_methods.toStringAsFixed$1(dataObject.get$totalTimeRatio() * 100, 2) + "%") + ")";
    },
    $asColumn: function() {
      return [E.CpuStackFrame];
    }
  };
  Y.MethodNameColumn.prototype = {
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").name;
    },
    getDisplayValue$1: function(dataObject) {
      var t1 = H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").name;
      if (t1.length > 75)
        return C.JSString_methods.substring$2(t1, 0, 75) + "...";
      return t1;
    },
    get$supportsSorting: function() {
      return true;
    },
    getTooltip$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").name;
    },
    $asColumn: function() {
      return [E.CpuStackFrame];
    },
    $asTreeColumn: function() {
      return [E.CpuStackFrame];
    }
  };
  Y.SourceColumn.prototype = {
    getValue$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").url;
    },
    getDisplayValue$1: function(dataObject) {
      return F.getSimplePackageUrl(H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").url);
    },
    getTooltip$1: function(dataObject) {
      return H.interceptedTypeCheck(dataObject, "$isCpuStackFrame").url;
    },
    get$supportsSorting: function() {
      return true;
    },
    $asColumn: function() {
      return [E.CpuStackFrame];
    }
  };
  Z.CpuProfilerView.prototype = {
    update$0: function(_) {
      if (!H.boolConversionCheck(this.element.hasAttribute("hidden")))
        this.rebuildView$0();
      else
        this.viewNeedsRebuild = true;
    }
  };
  Z.CpuProfilerViewType.prototype = {
    toString$0: function(_) {
      return this._cpu_profiler_view$_name;
    }
  };
  F.EventDetails.prototype = {
    EventDetails$1: function(timelineController) {
      var t1, t2, t3, details, t4, t5, t6, t7, _this = this, _null = null, _s6_ = "layout",
        _s8_ = "vertical",
        _s3_ = "div",
        _s20_ = "cpu-profiler-section",
        _s6_0 = "hidden";
      _this.flex$0(0);
      t1 = _this.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute(_s8_, "");
      t2 = A.CoreElement$(_s3_, _null, "event-details-heading", _null, "[No event selected]");
      _this._title = t2;
      t2 = t2.element.style;
      t3 = Y.colorToCss(_this.titleTextColor);
      t2.color = t3;
      t3 = Y.colorToCss(_this.titleBackgroundColor);
      t2.backgroundColor = t3;
      details = A.CoreElement$(_s3_, _null, "event-details", _null, _null);
      t2 = details.element;
      t2.setAttribute(_s6_, "");
      t2.setAttribute(_s8_, "");
      details.flex$0(0);
      t2 = _this.timelineController;
      t3 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t4 = new F._CpuProfiler(t2, C.CpuProfilerViewType_0, t3);
      t4.CoreElement$5$attributes$classes$html$text(_s3_, _null, _null, _null, _null);
      t3.setAttribute(_s6_, "");
      t3.setAttribute(_s8_, "");
      t4.flex$0(0);
      t3 = new R.CpuFlameChart(t2, C.CpuProfilerViewType_0, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      t3.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s20_, _null, _null);
      t5 = A.CoreElement$(_s3_, _null, "event-details-heading stack-frame-details", _null, _null);
      t6 = t5.element.style;
      t7 = Y.colorToCss(C.ThemedColor_Color_4294375158_Color_4280295716);
      t6.backgroundColor = t7;
      t5.attribute$2(_s6_0, true);
      t3.stackFrameDetails = t5;
      t3.add$1(0, t5);
      t4.flameChart = t3;
      t5 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t6 = new Y.CpuBottomUp(t2, C.CpuProfilerViewType_1, t5);
      t6.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s20_, _null, _null);
      t6.flex$0(0);
      t5.setAttribute(_s6_, "");
      t5.setAttribute(_s8_, "");
      t6._cpu_profile_tables$_init$0();
      t6.attribute$2(_s6_0, true);
      t4.bottomUp = t6;
      t5 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t2 = new Y.CpuCallTree(t2, C.CpuProfilerViewType_2, t5);
      t2.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s20_, _null, _null);
      t2.flex$0(0);
      t5.setAttribute(_s6_, "");
      t5.setAttribute(_s8_, "");
      t2._cpu_profile_tables$_init$0();
      t2.attribute$2(_s6_0, true);
      t4.callTree = t2;
      t2 = H.setRuntimeTypeInfo([t3, t6, t2], [Z.CpuProfilerView]);
      t4.set$views(t2);
      t4.add$1(0, t2);
      t4.attribute$2(_s6_0, true);
      _this.cpuProfiler = t4;
      t2 = A.CoreElement$(_s3_, _null, "message", _null, "CPU profiling is not available for GPU events.");
      t2.attribute$2(_s6_0, true);
      _this.gpuEventDetails = t2;
      t6 = [A.CoreElement];
      details.add$1(0, H.setRuntimeTypeInfo([t4, t2], t6));
      t2 = A.CoreElement$(_s3_, _null, "event-details-section section-border", _null, _null);
      t2.flex$0(0);
      t2.add$1(0, H.setRuntimeTypeInfo([_this._title, details], t6));
      _this.content = t2;
      _this._initTabNav$0();
      _this._event_details$_initListeners$0();
      new ResizeObserver(H.convertDartClosureToJS(P.allowInterop(new F.EventDetails_closure(_this), {func: 1, ret: -1, args: [[P.List, W.ResizeObserverEntry], W.ResizeObserver]}), 2)).observe(t1);
      _this.add$1(0, H.setRuntimeTypeInfo([_this.tabNav, _this.content], t6));
    },
    _initTabNav$0: function() {
      var callTreeTab, bottomUpTab, t1, t2, _null = null, _s3_ = "div",
        _s10_ = "tabnav-tab",
        flameChartTab = new F.CpuProfilerTab(C.CpuProfilerViewType_0, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      flameChartTab.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s10_, _null, "CPU Flame Chart");
      callTreeTab = new F.CpuProfilerTab(C.CpuProfilerViewType_2, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      callTreeTab.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s10_, _null, "Call Tree");
      bottomUpTab = new F.CpuProfilerTab(C.CpuProfilerViewType_1, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      bottomUpTab.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s10_, _null, "Bottom Up");
      t1 = N.PTabNav$(H.setRuntimeTypeInfo([flameChartTab, callTreeTab, bottomUpTab], [F.CpuProfilerTab]));
      t2 = t1.element.style;
      t2.borderBottom = "0";
      this.tabNav = t1;
      this._selectedTab = flameChartTab;
      t1 = t1._selectedTabController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new F.EventDetails__initTabNav_closure(this));
    },
    _event_details$_initListeners$0: function() {
      var _this = this,
        t1 = _this.timelineController,
        t2 = t1._selectedFrameController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new F.EventDetails__initListeners_closure(_this));
      t2 = $.$get$_selectedFrameFlameChartItemController();
      t2.toString;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new F.EventDetails__initListeners_closure0(_this));
      t2 = t1._selectedTimelineEventController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new F.EventDetails__initListeners_closure1(_this));
      t1 = t1._loadOfflineDataController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new F.EventDetails__initListeners_closure2(_this));
    },
    update$1$hide: function(_, hide) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t2, t3, t4, t5, t6, t1, selectedEvent;
      var $async$update$1$hide = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.timelineController.timelineData;
              selectedEvent = t1 == null ? null : t1.selectedEvent;
              t1 = $async$self._title;
              t2 = selectedEvent == null;
              t3 = !t2;
              if (t3) {
                t4 = H.S(C.JSArray_methods.get$first(selectedEvent.traceEvents).event.name) + " - ";
                t5 = selectedEvent.time;
                t6 = t5._utils$_end;
                t5 = t5._utils$_start;
                t5 = t4 + B.msText(new P.Duration(t6._duration - t5._duration), 1);
                t4 = t5;
              } else
                t4 = "[No event selected]";
              t1.element.textContent = t4;
              t4 = $async$self._title.element.style;
              t1 = Y.colorToCss($async$self.titleBackgroundColor);
              t4.backgroundColor = t1;
              t1 = Y.colorToCss($async$self.titleTextColor);
              t4.color = t1;
              $async$self.attribute$2("hidden", hide);
              t1 = $async$self.gpuEventDetails;
              t4 = t2 ? null : selectedEvent.type === C.TimelineEventType_0;
              t1.attribute$2("hidden", t4 !== false);
              t1 = $async$self.cpuProfiler;
              t2 = t2 ? null : selectedEvent.type === C.TimelineEventType_1;
              t1.attribute$2("hidden", t2 !== false);
              $async$goto = t3 && selectedEvent.type === C.TimelineEventType_0 ? 2 : 3;
              break;
            case 2:
              // then
              $async$goto = 4;
              return P._asyncAwait($async$self.cpuProfiler.update$0(0), $async$update$1$hide);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$update$1$hide, $async$completer);
    },
    update$0: function($receiver) {
      return this.update$1$hide($receiver, false);
    },
    reset$1$hide: function(_, hide) {
      this.titleTextColor = C.ThemedColor_Color_4278190080_Color_4293980400;
      this.titleBackgroundColor = C.ThemedColor_Color_4294375158_Color_4281151025;
      this.update$1$hide(0, hide);
    },
    reset$0: function($receiver) {
      return this.reset$1$hide($receiver, false);
    }
  };
  F.EventDetails_closure.prototype = {
    call$2: function(entries, _) {
      H.listTypeCheck(entries);
      H.interceptedTypeCheck(_, "$isResizeObserver");
      this.$this.cpuProfiler.flameChart.updateForContainerResize$0();
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 79
  };
  F.EventDetails__initTabNav_closure.prototype = {
    call$1: function(tab) {
      var t1;
      H.interceptedTypeCheck(tab, "$isPTabNavTab");
      t1 = this.$this;
      if (tab == t1._selectedTab)
        return;
      t1._selectedTab = tab;
      t1.cpuProfiler.showView$1(tab.type);
    },
    $signature: 195
  };
  F.EventDetails__initListeners_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isTimelineFrame");
      return this.$this.reset$0(0);
    },
    $signature: 56
  };
  F.EventDetails__initListeners_closure0.prototype = {
    call$1: function(item) {
      return this.$call$body$EventDetails__initListeners_closure1(H.interceptedTypeCheck(item, "$isFrameFlameChartItem"));
    },
    $call$body$EventDetails__initListeners_closure1: function(item) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t1.titleBackgroundColor = item.backgroundColor;
              t1.titleTextColor = item.defaultTextColor;
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 197
  };
  F.EventDetails__initListeners_closure1.prototype = {
    call$1: function(_) {
      return this.$call$body$EventDetails__initListeners_closure0(H.interceptedTypeCheck(_, "$isTimelineEvent0"));
    },
    $call$body$EventDetails__initListeners_closure0: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.$this.update$0(0), $async$call$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 198
  };
  F.EventDetails__initListeners_closure2.prototype = {
    call$1: function(_) {
      return this.$call$body$EventDetails__initListeners_closure(H.interceptedTypeCheck(_, "$isOfflineTimelineData"));
    },
    $call$body$EventDetails__initListeners_closure: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              $async$goto = t1.timelineController.timelineData.selectedEvent != null ? 2 : 3;
              break;
            case 2:
              // then
              t1.titleTextColor = C.Color_4278190080;
              t1.titleBackgroundColor = C.ThemedColor_Color_4286698746_Color_4288593657;
              $async$goto = 4;
              return P._asyncAwait(t1.update$0(0), $async$call$1);
            case 4:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 199
  };
  F._CpuProfiler.prototype = {
    showView$1: function(showType) {
      var t1, t2, _i, view;
      this._selectedViewType = showType;
      if (this.showingMessage)
        return;
      for (t1 = this.views, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        view = t1[_i];
        if (view.type === showType) {
          view.attribute$2("hidden", false);
          if (view.viewNeedsRebuild) {
            view.viewNeedsRebuild = false;
            J.update$0$x(view);
          }
        } else
          view.attribute$2("hidden", true);
      }
    },
    hideAll$0: function() {
      var t1, t2, _i;
      for (t1 = this.views, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].attribute$2("hidden", true);
    },
    update$0: function(_) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, spinner, offlineModeMessage, e, t1, t2, offlineModeMessage0, t3, exception, $async$exception;
      var $async$update$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.flameChart.reset$0(0);
              $async$self._removeMessage$0();
              spinner = N.Spinner$_(H.setRuntimeTypeInfo(["centered"], [P.String]));
              $async$handler = 4;
              $async$self.add$1(0, spinner);
              $async$goto = !$.offlineMode || $async$self._timelineController.offlineTimelineData == null ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return P._asyncAwait($async$self._timelineController.getCpuProfileForSelectedEvent$0(), $async$update$0);
            case 9:
              // returning from await.
            case 8:
              // join
              if ($.offlineMode) {
                t1 = $async$self._timelineController;
                t2 = t1.timelineData.selectedEvent;
                t1 = t1.offlineTimelineData;
                t1 = t2 != (t1 == null ? null : t1.selectedEvent);
              } else
                t1 = false;
              if (t1) {
                offlineModeMessage0 = A.CoreElement$("div", null, null, null, null);
                offlineModeMessage0.add$1(0, A.CoreElement$("span", null, null, null, "CPU profiling is not yet available for snapshots. You can only view "));
                offlineModeMessage = offlineModeMessage0;
                t1 = $async$self._timelineController.offlineTimelineData;
                if ((t1 == null ? null : t1.cpuProfileData) != null) {
                  t1 = offlineModeMessage;
                  t2 = J.getInterceptor$ax(t1);
                  t2.add$1(t1, A.CoreElement$("span", null, null, null, "the "));
                  t3 = A.CoreElement$("span", null, "message-action", null, "CPU profile");
                  t3.click$1(0, new F._CpuProfiler_update_closure($async$self));
                  t2.add$1(t1, t3);
                  t2.add$1(t1, A.CoreElement$("span", null, null, null, " included in the snapshot."));
                } else
                  J.add$1$ax(offlineModeMessage, A.CoreElement$("span", null, null, null, "a CPU profile if it is included in the imported snapshot file."));
                $async$self._updateDetailsWithMessage$1(offlineModeMessage);
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
              t1 = $async$self._timelineController;
              t2 = t1.timelineData.cpuProfileData.stackFrames;
              if (t2.get$isEmpty(t2)) {
                $async$self._updateDetailsWithMessage$1(A.CoreElement$("div", null, null, null, "CPU profile unavailable for time range [" + t1.timelineData.selectedEvent.time._utils$_start._duration + " - " + t1.timelineData.selectedEvent.time._utils$_end._duration + "]"));
                $async$next = [1];
                // goto finally
                $async$goto = 5;
                break;
              }
              t1 = $async$self.flameChart;
              t1.reset$0(0);
              t1.super$CpuProfilerView$update(0);
              $async$self.callTree.update$0(0);
              $async$self.bottomUp.update$0(0);
              $async$self.showView$1($async$self._selectedViewType);
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              $async$self._updateDetailsWithMessage$1(A.CoreElement$("div", null, null, null, "Error retrieving CPU profile: " + H.S(J.toString$0$(e))));
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              J.remove$0$ax(spinner.element);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$update$0, $async$completer);
    },
    _updateDetailsWithMessage$1: function(message) {
      this.hideAll$0();
      this.showingMessage = true;
      message.element.setAttribute("id", "cpu-profiler-message");
      message.clazz$1("message");
      this.add$1(0, message);
    },
    _removeMessage$0: function() {
      var t1 = J.get$children$x(this.element);
      t1.removeWhere$1(t1, new F._CpuProfiler__removeMessage_closure());
      this.showingMessage = false;
    },
    set$views: function(views) {
      this.views = H.assertSubtype(views, "$isList", [Z.CpuProfilerView], "$asList");
    }
  };
  F._CpuProfiler_update_closure.prototype = {
    call$0: function() {
      return this.$this._timelineController.restoreCpuProfileFromOfflineData$0();
    },
    $signature: 1
  };
  F._CpuProfiler__removeMessage_closure.prototype = {
    call$1: function(e) {
      return H.interceptedTypeCheck(e, "$isElement").id === "cpu-profiler-message";
    },
    $signature: 42
  };
  F.CpuProfilerTab.prototype = {};
  F.FlameChart.prototype = {
    _initRows$0: function() {
      var t1, t2, t3, i, totalWidth, _this = this;
      for (t1 = _this.data, t2 = _this.rows, t3 = [F.FlameChartNode], i = 0; i < t1._cpuProfileRoot.get$depth(); ++i)
        C.JSArray_methods.add$1(t2, new F.FlameChartRow(H.setRuntimeTypeInfo([], t3)));
      t2 = _this.flameChartWidth;
      if (typeof t2 !== "number")
        return t2.$sub();
      totalWidth = t2 - 140;
      new F.FlameChart__initRows_createChartNodes(_this, totalWidth, new F.FlameChart__initRows_calculateLeftForStackFrame(P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.double), totalWidth)).call$2(t1._cpuProfileRoot, 0);
    },
    selectNodeAtOffset$1: function(offset) {
      var t1, _this = this,
        node = _this.getNode$1(offset);
      if (node == null || node === _this.selectedNode)
        return;
      t1 = _this.selectedNode;
      if (t1 != null)
        t1.selected = false;
      node.selected = true;
      _this.selectedNode = node;
      _this._stackFrameSelectedController.add$1(0, node.stackFrame);
    },
    getFlameChartWidth$0: function() {
      var t1 = this.rows;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = t1[0].nodes;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].rect._dart_ui$_value[2] - 70;
    },
    getNode$1: function(offset) {
      var rowIndex = this.getRowIndexForY$1(offset._dy);
      if (rowIndex < 0 || rowIndex >= this.rows.length)
        return;
      return this.getNodeInRow$2(rowIndex, offset._dx);
    },
    getNodeInRow$2: function(rowIndex, x) {
      var nodes,
        t1 = this.rows;
      if (rowIndex < 0 || rowIndex >= t1.length)
        return H.ioore(t1, rowIndex);
      nodes = t1[rowIndex].nodes;
      return nodes.length === 0 ? null : new F.FlameChart_getNodeInRow_binarySearchForNode(nodes, x).call$0();
    },
    getRowIndexForY$1: function(y) {
      if (typeof y !== "number")
        return y.$lt();
      if (y < 27)
        return -1;
      return Math.max(C.JSNumber_methods._tdivFast$1(y - 27, 27), 0);
    }
  };
  F.FlameChart__initRows_calculateLeftForStackFrame.prototype = {
    call$1: function(stackFrame) {
      var left, stackFrameIndex, t1, t2, t3, previous,
        $parent = stackFrame.parent;
      if ($parent == null)
        left = 70;
      else {
        stackFrameIndex = stackFrame.index;
        t1 = this.stackFrameLefts;
        if (stackFrameIndex === 0)
          left = t1.$index(0, $parent.id);
        else {
          t2 = $parent.children;
          t3 = stackFrameIndex - 1;
          if (t3 < 0 || t3 >= t2.length)
            return H.ioore(t2, t3);
          previous = t2[t3];
          t1 = t1.$index(0, previous.id);
          t3 = previous.get$totalTimeRatio();
          if (typeof t1 !== "number")
            return t1.$add();
          left = t1 + this.totalWidth * t3;
        }
      }
      this.stackFrameLefts.$indexSet(0, stackFrame.id, left);
      return left;
    },
    $signature: 200
  };
  F.FlameChart__initRows_createChartNodes.prototype = {
    call$2: function(stackFrame, row) {
      var t2, t3, color, t4, _i, _this = this,
        t1 = stackFrame.get$totalTimeRatio(),
        left = _this.calculateLeftForStackFrame.call$1(stackFrame),
        $top = row * 27 + 27;
      if (typeof left !== "number")
        return left.$add();
      t1 = S.Rect$fromLTRB(left, $top, left + (_this.totalWidth * t1 - 1), $top + 25);
      t2 = _this.$this;
      t3 = t2._colorOffset;
      color = $.uiColorPalette[C.JSInt_methods.$mod(t3, 3)];
      t2._colorOffset = t3 + 1;
      t3 = t1._dart_ui$_value;
      t4 = t3[0];
      t3 = t3[2];
      t2 = t2.rows;
      if (row >= t2.length)
        return H.ioore(t2, row);
      C.JSArray_methods.add$1(t2[row].nodes, new F.FlameChartNode(t4, t3 - t4, color, C.Color_4278190080, C.Color_4278190080, stackFrame, P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.num), t1));
      for (t1 = stackFrame.children, t2 = t1.length, t3 = row + 1, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        _this.call$2(t1[_i], t3);
    },
    $signature: 201
  };
  F.FlameChart_getNodeInRow_binarySearchForNode.prototype = {
    call$0: function() {
      var t2, max0, min, mid, node, t3, t4,
        t1 = this.nodes,
        max = t1.length;
      for (t2 = this.x, max0 = max, min = 0; min < max0;) {
        mid = min + C.JSInt_methods._shrOtherPositive$1(max0 - min, 1);
        if (mid < 0 || mid >= max)
          return H.ioore(t1, mid);
        node = t1[mid];
        t3 = node.rect._dart_ui$_value;
        t4 = t3[0];
        if (typeof t2 !== "number")
          return t2.$ge();
        if (t2 >= t4 && t2 <= t3[2])
          return node;
        if (t2 < t4)
          max0 = mid;
        if (t2 > t3[2])
          min = mid + 1;
      }
      return;
    },
    $signature: 202
  };
  F.FlameChartCanvas.prototype = {
    FlameChartCanvas$3$data$flameChartHeight$flameChartWidth: function(data, flameChartHeight, flameChartWidth) {
      var _this = this,
        t1 = T.ViewportCanvas$("cpu-profiler-section cpu-flame-chart", null, null, null, _this.get$_onTap(), _this.get$_paintCallback()),
        t2 = t1._viewport_canvas$_element.element.style;
      t2.overflow = "hidden";
      _this._viewportCanvas = t1;
      t1.setContentSize$2(flameChartWidth, flameChartHeight);
      t1 = _this._dragScroll;
      t1.enableDragScrolling$1(_this._viewportCanvas._viewport_canvas$_element);
      t1.set$_onVerticalScroll(H.functionTypeCheck(new F.FlameChartCanvas_closure(_this), {func: 1, ret: -1}));
      t1 = J.get$onMouseWheel$x(_this._viewportCanvas._viewport_canvas$_element.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(_this.get$_handleMouseWheel(), {func: 1, ret: -1, args: [t2]}), false, t2);
      _this._initAsciiMeasurements$0();
    },
    _initAsciiMeasurements$0: function() {
      var measurementCanvas = W.CanvasElement_CanvasElement(null, null).getContext("2d");
      measurementCanvas.font = Y.fontStyleToCss(C.TextStyle_w66);
      $._asciiMeasurements = P.List_List$generate(128, new F.FlameChartCanvas__initAsciiMeasurements_closure(measurementCanvas), true, P.num);
    },
    _paintCallback$2: function(canvas, rect) {
      var i, _this = this,
        t1 = rect._dart_ui$_value,
        startRow = Math.max(_this.getRowIndexForY$1(t1[1]), 0),
        endRow = Math.min(_this.getRowIndexForY$1(t1[3]) + 1, _this.rows.length - 1);
      for (i = startRow; i < endRow; ++i)
        _this.paintRow$3(canvas, i, rect);
      _this.timelineGrid.paint$3(canvas, _this._viewportCanvas._viewport, rect);
    },
    paintRow$3: function(canvas, index, visible) {
      var t2, t3, _i, node, t4, t5,
        t1 = this.rows;
      if (index < 0 || index >= t1.length)
        return H.ioore(t1, index);
      for (t1 = t1[index].nodes, t2 = t1.length, t3 = visible._dart_ui$_value, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        node = t1[_i];
        t4 = node.rect._dart_ui$_value;
        t5 = t4[0];
        if (t5 + (t4[2] - t5) < t3[0])
          continue;
        if (t5 > t3[2])
          break;
        node.paint$1(canvas);
      }
    },
    _onTap$1: function(offset) {
      if (!this._dragScroll.wasDragged) {
        this.selectNodeAtOffset$1(offset);
        this._viewportCanvas.rebuild$1$force(true);
      }
    },
    _handleMouseWheel$1: function(e) {
      var t1, t2, t3;
      H.interceptedTypeCheck(e, "$isWheelEvent");
      e.preventDefault();
      t1 = C.WheelEvent_methods.get$deltaY(e);
      if (typeof t1 !== "number")
        return t1.abs$0();
      t2 = C.WheelEvent_methods.get$deltaX(e);
      if (typeof t2 !== "number")
        return t2.abs$0();
      t3 = this._viewportCanvas;
      if (Math.abs(t1) >= Math.abs(t2)) {
        t1 = e.clientX;
        t3 = t3._viewport_canvas$_element.element.getBoundingClientRect().left;
        if (typeof t1 !== "number")
          return t1.$sub();
        this._zoom$2(C.WheelEvent_methods.get$deltaY(e), t1 - t3);
      } else {
        t1 = t3._viewport_canvas$_element.element;
        t2 = C.JSNumber_methods.round$0(t1.scrollLeft);
        t3 = J.round$0$n(C.WheelEvent_methods.get$deltaX(e));
        t1.toString;
        t1.scrollLeft = C.JSInt_methods.round$0(t2 + t3);
      }
    },
    _zoom$2: function(deltaY, mouseX) {
      var t1, newZoomLevel, lastScrollLeft, lastScrollLeft0, fixedX, _this = this;
      deltaY = J.clamp$2$n(deltaY, -20, 20);
      t1 = _this.zoomLevel;
      newZoomLevel = C.JSNumber_methods.clamp$2(t1 + deltaY * (t1 * 0.003), 1, 150);
      t1 = _this.zoomLevel;
      if (newZoomLevel === t1)
        return;
      lastScrollLeft = C.JSNumber_methods.round$0(_this._viewportCanvas._viewport_canvas$_element.element.scrollLeft);
      lastScrollLeft0 = _this.floatingPointScrollLeft;
      if (Math.abs(lastScrollLeft0 - lastScrollLeft) < 0.5)
        lastScrollLeft = lastScrollLeft0;
      fixedX = mouseX + lastScrollLeft - 70;
      if (fixedX >= 0)
        _this.floatingPointScrollLeft = fixedX * newZoomLevel / t1 + 70 - mouseX;
      else
        _this.floatingPointScrollLeft = lastScrollLeft;
      _this.zoomLevel = newZoomLevel;
      _this._updateChartForZoom$0();
    },
    _updateChartForZoom$0: function() {
      var t1, t2, _i, t3, t4, _i0, node, t5, t6, t7, t8, _this = this;
      for (t1 = _this.rows, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        for (t3 = t1[_i].nodes, t4 = t3.length, _i0 = 0; _i0 < t3.length; t3.length === t4 || (0, H.throwConcurrentModificationError)(t3), ++_i0) {
          node = t3[_i0];
          t5 = _this.zoomLevel;
          t6 = node.startingLeft;
          if (typeof t6 !== "number")
            return t6.$sub();
          t7 = node.rect._dart_ui$_value;
          t8 = t7[1];
          node.rect = S.Rect$fromLTWH((t6 - 70) * t5 + 70, t8, node.startingWidth * t5, t7[3] - t8);
        }
      _this.timelineGrid.updateForZoom$2(_this.zoomLevel, _this.getFlameChartWidth$0());
      _this.forceRebuildForSize$2(_this.getFlameChartWidth$0() + 140, _this.flameChartHeight);
      t1 = _this._viewportCanvas._viewport_canvas$_element.element;
      t2 = Math.max(0, C.JSNumber_methods.round$0(_this.floatingPointScrollLeft));
      t1.toString;
      t1.scrollLeft = C.JSInt_methods.round$0(H.intTypeCheck(t2));
    },
    forceRebuildForSize$2: function(width, height) {
      var _this = this;
      _this.flameChartWidth = width;
      _this.flameChartHeight = height;
      _this._viewportCanvas.setContentSize$2(width, height);
      _this._viewportCanvas.rebuild$1$force(true);
    }
  };
  F.FlameChartCanvas_closure.prototype = {
    call$0: function() {
      this.$this._viewportCanvas.rebuild$1$force(true);
    },
    $signature: 0
  };
  F.FlameChartCanvas__initAsciiMeasurements_closure.prototype = {
    call$1: function(i) {
      return this.measurementCanvas.measureText(C.C_AsciiCodec.decode$1(0, H.setRuntimeTypeInfo([i], [P.int]))).width;
    },
    $signature: 82
  };
  F.FlameChartRow.prototype = {};
  F.FlameChartNode.prototype = {
    paint$1: function(canvas) {
      var t1, t2, t3, displayText, textWidth, _this = this;
      canvas.fillStyle = Y.colorToCss(_this.selected ? C.ThemedColor_Color_4292138970_Color_4292138970 : _this.backgroundColor);
      t1 = _this.rect._dart_ui$_value;
      t2 = t1[0];
      t3 = t1[1];
      canvas.fillRect(t2, t3, t1[2] - t2, t1[3] - t3);
      if (_this.selected) {
        canvas.strokeStyle = Y.colorToCss(C.ThemedColor_Color_1511726883_Color_1511726883);
        canvas.lineWidth = 1;
        canvas.stroke();
      }
      t1 = _this.rect._dart_ui$_value;
      if (t1[2] - t1[0] > 20) {
        canvas.fillStyle = Y.colorToCss(_this.selected ? _this.selectedTextColor : _this.textColor);
        canvas.font = Y.fontStyleToCss(C.TextStyle_w66);
        displayText = _this.stackFrame.name;
        t1 = _this.textMeasurements;
        textWidth = t1.$index(0, displayText);
        if (textWidth == null) {
          textWidth = canvas.measureText(displayText).width;
          t1.$indexSet(0, displayText, textWidth);
        }
        t1 = _this.rect._dart_ui$_value;
        t1 = t1[2] - t1[0] - 8;
        if (typeof textWidth !== "number")
          return textWidth.$le();
        if (!(textWidth <= t1))
          displayText = B.longestFittingSubstring(displayText, t1, $._asciiMeasurements, new F.FlameChartNode_paint_closure(canvas));
        t1 = _this.rect._dart_ui$_value;
        t2 = t1[0];
        (canvas && C.CanvasRenderingContext2D_methods).fillText$4(canvas, displayText, t2 + 4, t1[1] + 18, t1[2] - t2 - 8);
      }
    }
  };
  F.FlameChartNode_paint_closure.prototype = {
    call$1: function(value) {
      return this.canvas.measureText(H.Primitives_stringFromCharCode(value)).width;
    },
    $signature: 82
  };
  F.TimelineGrid0.prototype = {
    paint$3: function(canvas, viewport, visible) {
      var t1, t2, t3, t4, left, firstGridNodeText, t5, timestampText, _this = this;
      canvas.fillStyle = Y.colorToCss(C.ThemedColor_Color_4294375158_Color_4280295716);
      t1 = visible._dart_ui$_value;
      t2 = t1[0];
      t3 = viewport._dart_ui$_value;
      canvas.fillRect(t2, t3[1], t1[2] - t2, 25);
      t2 = t1[0];
      t4 = _this.currentInterval;
      left = C.JSNumber_methods.$tdiv(t2 - 70, t4) * t4 + 70;
      firstGridNodeText = B.msText(C.Duration_0, 1);
      canvas.font = Y.fontStyleToCss(C.TextStyle_w66);
      canvas.fillStyle = Y.colorToCss(C.ThemedColor_Color_4280559918_Color_4294638588);
      C.CanvasRenderingContext2D_methods.fillText$3(canvas, firstGridNodeText, _this._getTimestampLeft$4(firstGridNodeText, 0, 70, canvas), t3[1] + 18);
      canvas.strokeStyle = Y.colorToCss(C.ThemedColor_Color_4291611852_Color_4283979864);
      canvas.lineWidth = 0.4;
      canvas.beginPath();
      canvas.moveTo(70, t1[1]);
      canvas.lineTo(70, t1[3]);
      canvas.closePath();
      canvas.stroke();
      for (t2 = _this._flame_chart_canvas$_duration._duration; t4 = t1[2], left < t4;) {
        t5 = left + _this.currentInterval;
        if (t5 < t1[0] || left > t4)
          return;
        t4 = _this._flameChartWidth;
        if (typeof t4 !== "number")
          return H.iae(t4);
        t4 = P.Duration$(C.JSDouble_methods.round$0((t5 - 70) / t4 * t2), 0, 0, 0)._duration;
        t5 = t4 === 0 ? 1 : 3;
        t5 = C.JSDouble_methods.toStringAsFixed$1(t4 / 1000, t5);
        timestampText = t5 + " ms";
        t4 = _this.currentInterval;
        t5 = canvas.measureText(timestampText).width;
        if (typeof t5 !== "number")
          return H.iae(t5);
        canvas.fillText(timestampText, left + t4 - t5 - 6, t3[1] + 18);
        canvas.beginPath();
        canvas.moveTo(left + _this.currentInterval, t3[1]);
        canvas.lineTo(left + _this.currentInterval, t3[3]);
        canvas.closePath();
        canvas.stroke();
        left += _this.currentInterval;
      }
    },
    _getTimestampLeft$4: function(timestampText, left, width, canvas) {
      var t1 = canvas.measureText(timestampText).width;
      if (typeof t1 !== "number")
        return H.iae(t1);
      return left + width - t1 - 6;
    },
    updateForZoom$2: function(newZoomLevel, newFlameChartWidth) {
      var _this = this;
      if (_this._zoomLevel === newZoomLevel)
        return;
      _this._flameChartWidth = newFlameChartWidth;
      _this.currentInterval = 150 / Math.pow(2, C.JSDouble_methods.floor$0(Math.log(newZoomLevel) / Math.log(2))) * newZoomLevel;
      _this._zoomLevel = newZoomLevel;
    }
  };
  K.FrameEventsChart.prototype = {
    _frame_events_chart$_initListeners$0: function() {
      var _this = this,
        t1 = J.get$onMouseWheel$x(_this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(_this.get$_frame_events_chart$_handleMouseWheel(), {func: 1, ret: -1, args: [t2]}), false, t2);
      t2 = $.$get$_selectedFrameFlameChartItemController();
      t2.toString;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(_this.get$_selectItem());
      t2 = _this.timelineController._selectedFrameController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new K.FrameEventsChart__initListeners_closure(_this));
    },
    _frame_events_chart$_render$1: function(frame) {
      var t2, t3, t4, uiSectionHeight, gpuSectionHeight, flameChartHeight, _this = this,
        t1 = _this.element.clientWidth;
      if (typeof t1 !== "number")
        return t1.$sub();
      t2 = frame.time;
      t3 = t2._utils$_end;
      t2 = t2._utils$_start;
      t3 = t3._duration;
      t2 = t2._duration;
      t4 = frame.eventFlows;
      if (0 >= t4.length)
        return H.ioore(t4, 0);
      uiSectionHeight = t4[0].get$depth() * 25 + 15;
      if (1 >= t4.length)
        return H.ioore(t4, 1);
      gpuSectionHeight = t4[1].get$depth() * 25;
      flameChartHeight = 50 + uiSectionHeight + gpuSectionHeight;
      t2 = new K.FrameEventsChart__render_drawSubtree(_this, t2, (t1 - 140) / (t3 - t2));
      t3 = A.CoreElement$("div", null, "flame-chart", null, null);
      t3.flex$0(0);
      t1 = t3.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("vertical", "");
      _this._flameChart = t3;
      t1 = t1.style;
      t3 = "" + flameChartHeight + "px";
      t1.height = t3;
      _this.add$1(0, _this._flameChart);
      new K.FrameEventsChart__render_drawTimelineBackground(_this).call$0();
      new K.FrameEventsChart__render_drawUiEvents(_this, uiSectionHeight, t2, frame).call$0();
      new K.FrameEventsChart__render_drawGpuEvents(_this, gpuSectionHeight, uiSectionHeight, t2, frame).call$0();
      new K.FrameEventsChart__render_drawTimelineGrid(_this, frame, flameChartHeight).call$0();
      _this._setSectionWidths$0();
    },
    _setSectionWidths$0: function() {
      var _this = this,
        width = _this.getFlameChartWidth$0() + 140,
        t1 = _this._flameChart.element.style,
        t2 = H.S(width) + "px";
      t1.width = t2;
      t1 = _this._timelineBackground.element.style;
      t2 = H.S(width) + "px";
      t1.width = t2;
      t1 = _this._uiSection.element.style;
      t2 = H.S(width) + "px";
      t1.width = t2;
      t1 = _this._gpuSection.element.style;
      t2 = H.S(width) + "px";
      t1.width = t2;
    },
    getFlameChartWidth$0: function() {
      var t1, t2, maxRight, _i, item, t3, t4, maxRight0;
      for (t1 = this.chartItems, t2 = t1.length, maxRight = 0, _i = 0; _i < t2; ++_i) {
        item = t1[_i];
        t3 = item.currentLeft;
        t4 = item.currentWidth;
        if (typeof t3 !== "number")
          return t3.$add();
        if (typeof t4 !== "number")
          return H.iae(t4);
        maxRight0 = t3 + t4;
        if (maxRight0 > maxRight)
          maxRight = maxRight0;
      }
      return maxRight - 70;
    },
    _selectItem$1: function(item) {
      var t1;
      H.interceptedTypeCheck(item, "$isFrameFlameChartItem");
      t1 = this.selectedItem;
      if (item == t1)
        return;
      if (t1 != null)
        t1.setSelected$1(false);
      item.setSelected$1(true);
      this.selectedItem = item;
    },
    _frame_events_chart$_handleMouseWheel$1: function(e) {
      var t1, t2, t3;
      H.interceptedTypeCheck(e, "$isWheelEvent");
      e.preventDefault();
      t1 = C.WheelEvent_methods.get$deltaY(e);
      if (typeof t1 !== "number")
        return t1.abs$0();
      t2 = C.WheelEvent_methods.get$deltaX(e);
      if (typeof t2 !== "number")
        return t2.abs$0();
      t3 = this.element;
      if (Math.abs(t1) >= Math.abs(t2)) {
        t1 = e.clientX;
        t3 = t3.getBoundingClientRect().left;
        if (typeof t1 !== "number")
          return t1.$sub();
        this._frame_events_chart$_zoom$2(C.WheelEvent_methods.get$deltaY(e), t1 - t3);
      } else {
        t1 = C.JSNumber_methods.round$0(t3.scrollLeft);
        t2 = J.round$0$n(C.WheelEvent_methods.get$deltaX(e));
        t3.toString;
        t3.scrollLeft = C.JSInt_methods.round$0(t1 + t2);
      }
    },
    _frame_events_chart$_zoom$2: function(deltaY, mouseX) {
      var t1, newZoomLevel, lastScrollLeft, lastScrollLeft0, fixedX, _this = this;
      deltaY = J.clamp$2$n(deltaY, -20, 20);
      t1 = _this.zoomLevel;
      newZoomLevel = C.JSNumber_methods.clamp$2(t1 + deltaY * (t1 * 0.003), 1, 150);
      t1 = _this.zoomLevel;
      if (newZoomLevel === t1)
        return;
      lastScrollLeft = C.JSNumber_methods.round$0(_this.element.scrollLeft);
      lastScrollLeft0 = _this.floatingPointScrollLeft;
      if (Math.abs(lastScrollLeft0 - lastScrollLeft) < 0.5)
        lastScrollLeft = lastScrollLeft0;
      fixedX = mouseX + lastScrollLeft - 70;
      if (fixedX >= 0)
        _this.floatingPointScrollLeft = fixedX * newZoomLevel / t1 + 70 - mouseX;
      else
        _this.floatingPointScrollLeft = lastScrollLeft;
      _this.zoomLevel = newZoomLevel;
      _this._frame_events_chart$_updateChartForZoom$0();
    },
    _frame_events_chart$_updateChartForZoom$0: function() {
      var t1, t2, _i, _this = this;
      for (t1 = _this.chartItems, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].updateHorizontalPosition$1$zoom(_this.zoomLevel);
      _this._setSectionWidths$0();
      _this._timelineGrid.updateForZoom$2(_this.zoomLevel, _this.getFlameChartWidth$0());
      t1 = _this.element;
      t2 = Math.max(0, C.JSNumber_methods.round$0(_this.floatingPointScrollLeft));
      t1.toString;
      t1.scrollLeft = C.JSInt_methods.round$0(H.intTypeCheck(t2));
    }
  };
  K.FrameEventsChart__initListeners_closure.prototype = {
    call$1: function(_) {
      var t1, frame, t2;
      H.interceptedTypeCheck(_, "$isTimelineFrame");
      t1 = this.$this;
      frame = t1.timelineController.timelineData.selectedFrame;
      t2 = t1.element;
      J.get$children$x(t2).clear$0(0);
      t2.scrollLeft = 0;
      t2.scrollTop = 0;
      t1.zoomLevel = 1;
      C.JSArray_methods.set$length(t1.chartItems, 0);
      t1._gpuColorOffset = t1._uiColorOffset = 0;
      if (frame != null) {
        t1.attribute$2("hidden", false);
        t1._frame_events_chart$_render$1(frame);
      }
      return;
    },
    $signature: 56
  };
  K.FrameEventsChart__render_drawSubtree.prototype = {
    call$4$includeDuration: function($event, row, section, includeDuration) {
      var t8, color, item, t9, durationText, title, _i, _this = this,
        t1 = $event.time,
        t2 = _this.frameStartOffset,
        t3 = _this.pxPerMicro,
        startPx = (t1._utils$_start._duration - t2) * t3,
        t4 = t1._utils$_end._duration,
        t5 = _this.$this,
        t6 = row * 25 + 2,
        t7 = $event.type === C.TimelineEventType_0;
      if (t7) {
        t8 = t5._uiColorOffset;
        color = $.uiColorPalette[C.JSInt_methods.$mod(t8, 3)];
        t5._uiColorOffset = t8 + 1;
        t8 = color;
      } else {
        t8 = t5._gpuColorOffset;
        color = $.gpuColorPalette[C.JSInt_methods.$mod(t8, 3)];
        t5._gpuColorOffset = t8 + 1;
        t8 = color;
      }
      t7 = t7 ? new K.ThemedColor(C.Color_4278190080, C.Color_4278190080) : new K.ThemedColor(C.Color_4293980400, C.Color_4293980400);
      item = new K.FrameFlameChartItem($event, includeDuration, t5.timelineController, startPx, (t4 - t2) * t3 - startPx, t6, t8, t7, C.Color_4278190080);
      t3 = document;
      t2 = t3.createElement("div");
      t2.className = "flame-chart-item";
      item.element = t2;
      t3 = t3.createElement("div");
      t3.className = "flame-chart-item-label-wrapper";
      item._labelWrapper = t3;
      t4 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("span", null), "$isElement");
      t4.className = "flame-chart-item-label";
      t9 = t4.style;
      t7 = Y.colorToCss(t7);
      t9.color = t7;
      item.itemLabel = t4;
      t3.appendChild(t4);
      t2.appendChild(t3);
      t2 = t2.style;
      t8 = Y.colorToCss(t8);
      t2.background = t8;
      t3 = "" + t6 + "px";
      t2.top = t3;
      item.updateHorizontalPosition$1$zoom(1);
      t2 = t1._utils$_end;
      t1 = t1._utils$_start;
      durationText = B.msText(new P.Duration(t2._duration - t1._duration), 1);
      title = C.JSArray_methods.get$first($event.traceEvents).event.name;
      item.element.title = H.S(title) + " (" + durationText + ")";
      if (includeDuration)
        title = H.S(title) + " (" + durationText + ")";
      item.itemLabel.textContent = title;
      item.setOnClick$0();
      C.JSArray_methods.add$1(t5.chartItems, item);
      section.element.appendChild(item.element);
      for (t1 = $event.children, t2 = t1.length, t3 = row + 1, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        _this.call$3(t1[_i], t3, section);
    },
    call$3: function($event, row, section) {
      return this.call$4$includeDuration($event, row, section, false);
    },
    $signature: 206
  };
  K.FrameEventsChart__render_drawTimelineBackground.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = A.CoreElement$("div", null, "timeline-background", null, null),
        t3 = t2.element.style;
      t3.height = "25px";
      t1._timelineBackground = t2;
      t1.add$1(0, t2);
    },
    $signature: 1
  };
  K.FrameEventsChart__render_drawUiEvents.prototype = {
    call$0: function() {
      var t3, sectionTitle, _this = this, _null = null,
        t1 = _this.$this,
        t2 = A.CoreElement$("div", _null, "flame-chart-section ui", _null, _null);
      t1._uiSection = t2;
      t1._flameChart.add$1(0, t2);
      t2 = t1._uiSection.element.style;
      t3 = "" + _this.uiSectionHeight + "px";
      t2.height = t3;
      t2.top = "25px";
      sectionTitle = A.CoreElement$("div", _null, "flame-chart-item flame-chart-title", _null, "UI");
      t2 = sectionTitle.element.style;
      t3 = Y.colorToCss(C.ThemedColor_Color_4286698746_Color_4288593657);
      t2.background = t3;
      t2.left = "2px";
      t2.top = "2px";
      t1._uiSection.add$1(0, sectionTitle);
      t2 = _this.frame.eventFlows;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      _this.drawSubtree.call$4$includeDuration(t2[0], 0, t1._uiSection, true);
    },
    $signature: 1
  };
  K.FrameEventsChart__render_drawGpuEvents.prototype = {
    call$0: function() {
      var t3, sectionTitle, _this = this, _null = null,
        t1 = _this.$this,
        t2 = A.CoreElement$("div", _null, "flame-chart-section", _null, _null);
      t1._gpuSection = t2;
      t1._flameChart.add$1(0, t2);
      t2 = t1._gpuSection.element.style;
      t3 = "" + _this.gpuSectionHeight + "px";
      t2.height = t3;
      t3 = "" + (25 + _this.uiSectionHeight) + "px";
      t2.top = t3;
      sectionTitle = A.CoreElement$("div", _null, "flame-chart-item flame-chart-title", _null, "GPU");
      t2 = sectionTitle.element.style;
      t3 = Y.colorToCss(C.ThemedColor_Color_4278356177_Color_4279923688);
      t2.background = t3;
      t2.left = "2px";
      t2.top = "2px";
      t1._gpuSection.add$1(0, sectionTitle);
      t2 = _this.frame.eventFlows;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      _this.drawSubtree.call$4$includeDuration(t2[1], 0, t1._gpuSection, true);
    },
    $signature: 1
  };
  K.FrameEventsChart__render_drawTimelineGrid.prototype = {
    call$0: function() {
      var t4, t5, t6, _null = null,
        t1 = this.$this,
        t2 = this.frame.time,
        t3 = t2._utils$_end;
      t2 = t2._utils$_start;
      t3 = t3._duration;
      t2 = t2._duration;
      t4 = t1.getFlameChartWidth$0();
      t5 = H.setRuntimeTypeInfo([], [K.TimelineGridItem]);
      t6 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement");
      t5 = new K.TimelineGrid(new P.Duration(t3 - t2), t4, t5, t6);
      t5.CoreElement$5$attributes$classes$html$text("div", _null, "flame-chart-grid", _null, _null);
      t5.flex$0(0);
      t6.setAttribute("layout", "");
      t6.setAttribute("horizontal", "");
      t5._initializeGrid$1(150);
      t1._timelineGrid = t5;
      t6 = t6.style;
      t5 = "" + this.flameChartHeight + "px";
      t6.height = t5;
      t1.add$1(0, t1._timelineGrid);
    },
    $signature: 1
  };
  K.FrameFlameChartItem.prototype = {
    setOnClick$0: function() {
      var t1 = W.MouseEvent;
      W._EventStreamSubscription$(this.element, "click", H.functionTypeCheck(new K.FrameFlameChartItem_setOnClick_closure(this), {func: 1, ret: -1, args: [t1]}), false, t1);
    },
    updateHorizontalPosition$1$zoom: function(zoom) {
      var _this = this,
        newLeft = 70 + _this.startingLeft * zoom,
        newWidth = _this.startingWidth * zoom,
        t1 = _this.element.style,
        t2 = H.S(newLeft) + "px";
      t1.left = t2;
      t1 = _this.element.style;
      t2 = H.S(newWidth) + "px";
      t1.width = t2;
      t1 = _this._labelWrapper.style;
      t2 = H.S(Math.max(0, newWidth - 4)) + "px";
      t1.maxWidth = t2;
      _this.currentLeft = newLeft;
      _this.currentWidth = newWidth;
    },
    setSelected$1: function(selected) {
      var _this = this,
        t1 = _this.element.style,
        t2 = Y.colorToCss(selected ? C.ThemedColor_Color_4292138970_Color_4292138970 : _this.backgroundColor);
      t1.backgroundColor = t2;
      t2 = selected ? "1px solid" : "none";
      t1.border = t2;
      t2 = Y.colorToCss(C.ThemedColor_Color_1511726883_Color_1511726883);
      t1.borderColor = t2;
      t1 = _this.itemLabel.style;
      t2 = Y.colorToCss(selected ? _this.selectedTextColor : _this.defaultTextColor);
      t1.color = t2;
    }
  };
  K.FrameFlameChartItem_setOnClick_closure.prototype = {
    call$1: function(e) {
      var t1, t2, t3;
      H.interceptedTypeCheck(e, "$isMouseEvent");
      if (!$.$get$_dragScroll().wasDragged) {
        t1 = this.$this;
        $.$get$_selectedFrameFlameChartItemController().add$1(0, t1);
        t2 = t1._event;
        t1.timelineController.selectTimelineEvent$1(t2);
        t1 = t2.type === C.TimelineEventType_1 ? "flameGPU" : "flameUI";
        t2 = t2.time;
        t3 = t2._utils$_end;
        t2 = t2._utils$_start;
        F.select("timeline", t1, t3._duration - t2._duration);
      }
    },
    $signature: 3
  };
  K.TimelineGrid.prototype = {
    _initializeGrid$1: function(interval) {
      var t1, t2, left, left0, t3, _this = this, _null = null, _s3_ = "div",
        _s21_ = "flame-chart-grid-item",
        gridItem = new K.TimelineGridItem(C.Duration_0, 0, 70, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
      gridItem.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s21_, _null, _null);
      gridItem._initGridItem$0();
      t1 = _this._gridItems;
      C.JSArray_methods.add$1(t1, gridItem);
      _this.add$1(0, gridItem);
      for (t2 = _this._frameDuration._duration, left = 70; left0 = left + interval, t3 = _this._frame_events_chart$_flameChartWidth, left0 < t3 + 140; left = left0) {
        gridItem = new K.TimelineGridItem(P.Duration$(C.JSDouble_methods.round$0((left0 - 70) / t3 * t2), 0, 0, 0), left, interval, H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement"));
        gridItem.CoreElement$5$attributes$classes$html$text(_s3_, _null, _s21_, _null, _null);
        gridItem._initGridItem$0();
        C.JSArray_methods.add$1(t1, gridItem);
        _this.add$1(0, gridItem);
      }
    },
    updateForZoom$2: function(newZoomLevel, newFlameChartWidth) {
      var t1, t2, t3, log2ZoomLevel, log2NewZoomLevel, zoomedGridIntervalPx, i, _this = this;
      if (_this._frame_events_chart$_zoomLevel === newZoomLevel)
        return;
      _this._frame_events_chart$_flameChartWidth = newFlameChartWidth;
      t1 = _this.element;
      t2 = t1.style;
      t3 = H.S(newFlameChartWidth + 140) + "px";
      t2.width = t3;
      log2ZoomLevel = C.JSDouble_methods.floor$0(Math.log(_this._frame_events_chart$_zoomLevel) / Math.log(2));
      log2NewZoomLevel = C.JSDouble_methods.floor$0(Math.log(newZoomLevel) / Math.log(2));
      zoomedGridIntervalPx = 150 / Math.pow(2, log2NewZoomLevel) * newZoomLevel;
      if (log2NewZoomLevel === log2ZoomLevel)
        for (t1 = _this._gridItems, i = 1; i < t1.length; ++i)
          t1[i].setPosition$2(0, 70 + zoomedGridIntervalPx * (i - 1), zoomedGridIntervalPx);
      else {
        J.get$children$x(t1).clear$0(0);
        C.JSArray_methods.set$length(_this._gridItems, 0);
        _this._initializeGrid$1(zoomedGridIntervalPx);
      }
      _this._frame_events_chart$_zoomLevel = newZoomLevel;
    }
  };
  K.TimelineGridItem.prototype = {
    _initGridItem$0: function() {
      var t2, t3, t4, _this = this, _null = null,
        t1 = A.CoreElement$("div", _null, "grid-line", _null, _null);
      _this.gridLine = t1;
      _this.add$1(0, t1);
      t1 = A.CoreElement$("div", _null, "timestamp", _null, _null);
      t2 = t1.element;
      t3 = t2.style;
      t4 = Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4293980400);
      t3.color = t4;
      _this.timestampLabel = t1;
      t1 = _this.timestamp;
      t2.textContent = B.msText(t1, t1._duration === 0 ? 1 : 3);
      _this.add$1(0, _this.timestampLabel);
      _this.setPosition$2(0, _this.currentLeft, _this.currentWidth);
    },
    setPosition$2: function(_, left, width) {
      var t1, t2, _this = this;
      _this.currentLeft = left;
      _this.currentWidth = width;
      t1 = _this.element.style;
      t2 = H.S(left) + "px";
      t1.left = t2;
      t2 = H.S(width) + "px";
      t1.width = t2;
      t1 = _this.gridLine.element.style;
      t2 = H.S(width - 1) + "px";
      t1.left = t2;
      t1 = _this.timestampLabel.element.style;
      t2 = H.S(width - 8) + "px";
      t1.width = t2;
    }
  };
  A.FramesBarChart.prototype = {
    FramesBarChart$1: function(timelineController) {
      var t2, t3, t4, t5, t6, _this = this, _null = null, _s4_ = "100%",
        t1 = _this.element;
      t1.setAttribute("layout", "");
      t1.setAttribute("horizontal", "");
      t1 = t1.style;
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "align-items"), "flex-end", "");
      t1.height = "140px";
      t1.width = _s4_;
      t1.paddingTop = "2px";
      t1 = _this.timelineController;
      t2 = P.int;
      t3 = H.setRuntimeTypeInfo([], [t2]);
      t4 = [P.num];
      t5 = H.setRuntimeTypeInfo([], t4);
      t4 = H.setRuntimeTypeInfo([], t4);
      t6 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag("div", _null), "$isElement");
      t4 = new A.PlotlyDivGraph(t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, Q.TimelineFrame), t3, t5, t4, t6);
      t4.CoreElement$5$attributes$classes$html$text("div", _null, _null, _null, _null);
      t6.id = "graph_frame_timeline";
      t6 = t6.style;
      t6.height = _s4_;
      t6.width = _s4_;
      _this.frameUIgraph = t4;
      _this.add$1(0, t4);
      _this.setState$1(new A.FramesBarChart_closure(_this));
      t1 = t1.frameAddedController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new A.FramesBarChart_closure0(_this));
    }
  };
  A.FramesBarChart_closure.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this;
      if (!t1._createdPlot) {
        t2 = t1.frameUIgraph;
        t2.createPlot$1(t2.element);
        t1._createdPlot = true;
      }
    },
    $signature: 0
  };
  A.FramesBarChart_closure0.prototype = {
    call$1: function(frame) {
      H.interceptedTypeCheck(frame, "$isTimelineFrame");
      this.$this.frameUIgraph.process$1(frame);
    },
    $signature: 207
  };
  A.PlotlyDivGraph.prototype = {
    _plotlyClick$1: function(data) {
      var t1, xPosition, t2, newSelection, t3, t4, t5, timelineFrame, _this = this;
      H.interceptedTypeCheck(data, "$isDataEvent");
      t1 = J.getInterceptor$x(data);
      xPosition = J.get$x$x(J.$index$asx(t1.get$points(data), 0));
      t2 = [Y.SelectTrace];
      newSelection = H.setRuntimeTypeInfo([], t2);
      for (t1 = J.get$iterator$ax(t1.get$points(data)); t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        t4 = J.getInterceptor$x(t3);
        if (!J.$eq$(t4.get$curveNumber(t3), 1) && !J.$eq$(t4.get$curveNumber(t3), 3))
          C.JSArray_methods.add$1(newSelection, new Y.SelectTrace(t4.get$curveNumber(t3), t4.get$pointNumber(t3), t4.get$x(t3), t4.get$y(t3)));
      }
      t1 = _this.currentSelection;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo([], t2);
        t1 = _this.currentSelection = new Y.Selection("graph_frame_timeline", H.assertSubtype(_this.element.data, "$isList", [O.Data], "$asList"), t1);
      }
      t3 = newSelection.length;
      if (t3 === 2) {
        H.assertSubtype(newSelection, "$isList", t2, "$asList");
        t2 = t1.selectInfo;
        t4 = t2.length;
        if (t4 === 2) {
          if (0 >= t4)
            return H.ioore(t2, 0);
          t5 = t2[0];
          if (0 >= t3)
            return H.ioore(newSelection, 0);
          if (t5.xValue == newSelection[0].xValue) {
            if (1 >= t4)
              return H.ioore(t2, 1);
            t2 = t2[1];
            if (1 >= t3)
              return H.ioore(newSelection, 1);
            t2 = t2.xValue == newSelection[1].xValue;
          } else
            t2 = false;
        } else
          t2 = false;
        t2 = !t2;
      } else
        t2 = false;
      if (t2) {
        t1.select$1(0, newSelection);
        t1 = _this._frames;
        if (t1.containsKey$1(0, xPosition)) {
          timelineFrame = t1.$index(0, xPosition);
          _this.timelineController.selectFrame$1(timelineFrame);
          t1 = timelineFrame.get$gpuDuration();
          t2 = timelineFrame.get$uiDuration();
          t2 = {event_category: "select", event_label: "frame", user_app: $._userAppType, user_build: $._userBuildType, user_platform: $._userPlatformType, devtools_platform: $._devtoolsPlatformType, devtools_chrome: $._devtoolsChrome, devtools_version: "0.1.2", ide_launched: $._ideLaunched, gpu_duration: t1, ui_duration: t2};
          if (H.boolConversionCheck(self.gaCollectionAllowed()))
            self.gtag("event", "timeline", t2);
        }
      }
    },
    _plotlyHover$1: function(data) {
      var hoverDisplay, t1, t2, t3, ptNumber;
      H.interceptedTypeCheck(data, "$isDataEvent");
      hoverDisplay = H.setRuntimeTypeInfo([], [O.HoverFX]);
      for (t1 = J.get$iterator$ax(J.get$points$x(data)); t1.moveNext$0();) {
        t2 = t1.get$current(t1);
        t3 = J.getInterceptor$x(t2);
        ptNumber = t3.get$pointNumber(t2);
        if (H.intTypeCheck(J.$index$asx(J.get$x$x(t3.get$data(t2)), ptNumber)) !== -1)
          C.JSArray_methods.add$1(hoverDisplay, {curveNumber: t3.get$curveNumber(t2), pointNumber: t3.get$pointNumber(t2)});
      }
      self.Plotly.Fx.hover("graph_frame_timeline", hoverDisplay);
    },
    createPlot$1: function(element) {
      var allTraces, t5, t6, _this = this,
        t1 = {text: "Milliseconds"},
        t2 = H.setRuntimeTypeInfo([0, 2], [P.num]),
        t3 = {color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)},
        t4 = [P.int];
      t3 = {tickformat: ".0f", title: t1, type: "log", range: t2, showgrid: false, tickfont: {color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}, nticks: 10, tickmode: "array", tickvals: H.setRuntimeTypeInfo([1, 10, 100], t4), ticktext: H.setRuntimeTypeInfo([1, 10, 100], t4), hoverformat: ".3f", titlefont: t3};
      t2 = {text: "Milliseconds"};
      t1 = {color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)};
      t1 = {title: t2, fixedrange: true, tickfont: {color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}, titlefont: t1};
      _this.plotlyChart = new Y.FramesBarPlotly("graph_frame_timeline", element, false, false, t3, t1);
      allTraces = H.setRuntimeTypeInfo([], [O.Data]);
      t3 = {font: {color: Y.colorToCss(C.Color_4278190080)}};
      C.JSArray_methods.insert$2(allTraces, 0, {x: [-1], y: [0], type: "bar", marker: {color: Y.colorToCss(C.ThemedColor_Color_4278356177_Color_4279923688)}, name: "GPU", hoverinfo: "y+name", hoverlabel: t3, width: H.setRuntimeTypeInfo([0], t4)});
      t3 = Y.colorToCss(C.ThemedColor_Color_4290098613_Color_4291414473);
      t2 = {color: Y.colorToCss(C.Color_4278190080)};
      t2 = {bgcolor: t3, bordercolor: Y.colorToCss(C.ThemedColor_Color_4290098613_Color_4291414473), font: t2};
      C.JSArray_methods.insert$2(allTraces, 1, {x: [-1], y: [0], type: "bar", marker: {color: Y.colorToCss(C.ThemedColor_Color_4290098613_Color_4291414473)}, hoverinfo: "y+name", hoverlabel: t2, showlegend: false});
      t2 = {font: {color: Y.colorToCss(C.Color_4278190080)}};
      C.JSArray_methods.insert$2(allTraces, 2, {x: [-1], y: [0], type: "bar", marker: {color: Y.colorToCss(C.ThemedColor_Color_4286698746_Color_4288593657)}, name: "UI", hoverinfo: "y+name", hoverlabel: t2, width: H.setRuntimeTypeInfo([0], t4)});
      t4 = Y.colorToCss(C.ThemedColor_Color_4292138970_Color_4294967295);
      t2 = {color: Y.colorToCss(C.Color_4278190080)};
      t2 = {bgcolor: t4, bordercolor: Y.colorToCss(C.ThemedColor_Color_4292138970_Color_4294967295), font: t2};
      C.JSArray_methods.insert$2(allTraces, 3, {x: [-1], y: [0], type: "bar", marker: {color: Y.colorToCss(C.ThemedColor_Color_4292138970_Color_4294967295)}, hoverinfo: "y+name", hoverlabel: t2, showlegend: false});
      t2 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
      t4 = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025);
      t3 = {font: {color: Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371)}};
      t5 = {autorange: true, rangemode: "nonnegative", rangeslider: null, tickfont: {color: Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025), size: 1}};
      t6 = H.setRuntimeTypeInfo([{type: "line", xref: "paper", layer: "below", x0: 0, y0: 16.666666666666668, x1: 1, y1: 16.666666666666668, line: {color: Y.colorToCss(C.Color_4292138970), dash: "dot", width: 1}}], [O.Shape]);
      t4 = {xaxis: t5, yaxis: t1, autosize: true, margin: {l: 60, r: 0, b: 8, t: 5, pad: 8}, hovermode: "x", barmode: "stack", dragmode: "pan", shapes: t6, legend: t3, plot_bgcolor: t2, paper_bgcolor: t4};
      t2 = {displayModeBar: false, responsive: true, displaylogo: false};
      self.Plotly.newPlot("graph_frame_timeline", allTraces, t4, t2);
      _this.plotlyChart.toString;
      t2 = P.Function;
      t4 = P.allowInterop(_this.get$_plotlyClick(), t2);
      self.hookupPlotlyClick("graph_frame_timeline", t4);
      _this.plotlyChart.toString;
      t2 = P.allowInterop(_this.get$_plotlyHover(), t2);
      self.hookupPlotlyHover("graph_frame_timeline", t2);
      P.Timer_Timer$periodic(C.Duration_166000, new A.PlotlyDivGraph_createPlot_closure(_this));
    },
    process$1: function(frame) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t1;
      var $async$process$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = frame.get$uiDurationMs();
              if (typeof t1 !== "number") {
                $async$returnValue = t1.$gt();
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1 > 0) {
                t1 = frame.get$gpuDurationMs();
                if (typeof t1 !== "number") {
                  $async$returnValue = t1.$gt();
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = t1 > 0;
              } else
                t1 = false;
              if (t1) {
                C.JSArray_methods.add$1($async$self.dataIndexes, $async$self._frameIndex);
                C.JSArray_methods.add$1($async$self.uiDurations, frame.get$uiDurationMs());
                C.JSArray_methods.add$1($async$self.gpuDurations, frame.get$gpuDurationMs());
                $async$self._frames.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal([$async$self._frameIndex, frame], P.int, Q.TimelineFrame));
                ++$async$self._frameIndex;
              } else
                P.print("WARNING: Ignored onFrameAdded - bad data.\n [uiDuration: " + H.S(frame.get$uiDuration()) + ", gpuDuration: " + H.S(frame.get$gpuDuration()));
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$process$1, $async$completer);
    }
  };
  A.PlotlyDivGraph_createPlot_closure.prototype = {
    call$1: function(t) {
      var t1, t2, t3, dataLength, t4;
      H.interceptedTypeCheck(t, "$isTimer");
      t1 = this.$this;
      t2 = t1._lastPlottedFrameIndex;
      t3 = t1._frameIndex;
      if (t2 === t3)
        return;
      t1._lastPlottedFrameIndex = t3;
      t2 = t1.dataIndexes;
      dataLength = t2.length;
      if (dataLength > 0) {
        t3 = t1.uiDurations;
        t4 = t1.gpuDurations;
        t1.plotlyChart.plotFPSDataList$4(t2, t3, t4, t1.timelineController._timeline_controller$_paused);
        C.JSArray_methods.removeRange$2(t2, 0, dataLength);
        C.JSArray_methods.removeRange$2(t3, 0, dataLength);
        C.JSArray_methods.removeRange$2(t4, 0, dataLength);
      }
    },
    $signature: 50
  };
  A._FramesBarChart_CoreElement_SetStateMixin.prototype = {};
  Y.FramesBarPlotly.prototype = {
    plotFPSDataList$4: function(dataIndexes, uiDurations, gpuDurations, paused) {
      var t2, uiGoodX, uiGoodTrace, gpuGoodX, gpuGoodTrace, totalIndexes, t3, t4, dataIndex, uiDuration, gpuDuration, t5, t6, nextShape, t7, t8, jsShape, data, traces,
        t1 = [P.int];
      H.assertSubtype(dataIndexes, "$isList", t1, "$asList");
      t2 = [P.num];
      H.assertSubtype(uiDurations, "$isList", t2, "$asList");
      H.assertSubtype(gpuDurations, "$isList", t2, "$asList");
      uiGoodX = H.setRuntimeTypeInfo([], t1);
      uiGoodTrace = H.setRuntimeTypeInfo([], t2);
      gpuGoodX = H.setRuntimeTypeInfo([], t1);
      gpuGoodTrace = H.setRuntimeTypeInfo([], t2);
      totalIndexes = dataIndexes.length;
      for (t3 = this._frames_bar_plotly$_chart, t4 = this._frames_bar_plotly$_domName, dataIndex = 0; dataIndex < totalIndexes; ++dataIndex) {
        if (dataIndex >= uiDurations.length)
          return H.ioore(uiDurations, dataIndex);
        uiDuration = uiDurations[dataIndex];
        if (dataIndex >= gpuDurations.length)
          return H.ioore(gpuDurations, dataIndex);
        gpuDuration = gpuDurations[dataIndex];
        if (dataIndex >= dataIndexes.length)
          return H.ioore(dataIndexes, dataIndex);
        C.JSArray_methods.add$1(uiGoodX, dataIndexes[dataIndex]);
        C.JSArray_methods.add$1(uiGoodTrace, uiDuration);
        if (dataIndex >= dataIndexes.length)
          return H.ioore(dataIndexes, dataIndex);
        C.JSArray_methods.add$1(gpuGoodX, dataIndexes[dataIndex]);
        C.JSArray_methods.add$1(gpuGoodTrace, gpuDuration);
        if (typeof uiDuration !== "number")
          return uiDuration.$add();
        if (typeof gpuDuration !== "number")
          return H.iae(gpuDuration);
        t5 = uiDuration + gpuDuration;
        if (t5 > 16.666666666666668) {
          if (dataIndex >= dataIndexes.length)
            return H.ioore(dataIndexes, dataIndex);
          t6 = dataIndexes[dataIndex];
          nextShape = J.get$length$asx(J.get$shapes$x(H.interceptedTypeCheck(t3.layout, "$isLayout")));
          t7 = Y.colorToCss(C.ThemedColor_Color_1727987712_Color_1727175833);
          t8 = Y.colorToCss(C.ThemedColor_Color_2164195328_Color_2580420892);
          jsShape = self.createGlowShape(nextShape, t6, t5, t7, t8);
          self.Plotly.relayout(t4, jsShape);
        }
      }
      t3 = [[P.List,,]];
      data = {x: H.setRuntimeTypeInfo([], t3), y: H.setRuntimeTypeInfo([], t3)};
      traces = H.setRuntimeTypeInfo([], t1);
      if (uiGoodX.length !== 0) {
        t1 = J.getInterceptor$x(data);
        J.add$1$ax(t1.get$x(data), uiGoodX);
        J.add$1$ax(t1.get$y(data), uiGoodTrace);
        C.JSArray_methods.add$1(traces, 2);
      }
      if (gpuGoodX.length !== 0) {
        t1 = J.getInterceptor$x(data);
        J.add$1$ax(t1.get$x(data), gpuGoodX);
        J.add$1$ax(t1.get$y(data), gpuGoodTrace);
        C.JSArray_methods.add$1(traces, 0);
      }
      self.extendTraces2(t4, uiGoodX, gpuGoodX, uiGoodTrace, gpuGoodTrace, [2, 0]);
      if (!paused) {
        t1 = C.JSArray_methods.get$last(dataIndexes) + 1;
        t3 = H.setRuntimeTypeInfo([{}], [O.Data]);
        t5 = {color: Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4281151025)};
        t2 = H.setRuntimeTypeInfo([t1 - 90, t1], t2);
        t1 = {xaxis: {rangemode: "nonnegative", range: t2, rangeslider: null, tickfont: t5}};
        self.Plotly.update(t4, t3, t1);
      }
    }
  };
  Y.SelectTrace.prototype = {};
  Y.Selection.prototype = {
    select$1: function(_, newSelection) {
      var oldSelectInfo, t1, t2, oldPtNum0, oldPtNum1, t3, t4, newPtNum0, t5, newPtNum1, _i, selectTrace, gpuSelectionHoverName, uiSelectionHoverName, _this = this;
      H.assertSubtype(newSelection, "$isList", [Y.SelectTrace], "$asList");
      oldSelectInfo = _this.unselect$0();
      t1 = oldSelectInfo.length;
      if (t1 !== 0) {
        if (0 >= t1)
          return H.ioore(oldSelectInfo, 0);
        t2 = oldSelectInfo[0];
        oldPtNum0 = t2.ptNumber;
        if (1 >= t1)
          return H.ioore(oldSelectInfo, 1);
        t1 = oldSelectInfo[1];
        oldPtNum1 = t1.ptNumber;
        t3 = newSelection.length;
        if (0 >= t3)
          return H.ioore(newSelection, 0);
        t4 = newSelection[0];
        newPtNum0 = t4.ptNumber;
        if (1 >= t3)
          return H.ioore(newSelection, 1);
        t5 = newSelection[1];
        newPtNum1 = t5.ptNumber;
        if (t2.traceIndex == t4.traceIndex) {
          if (typeof newPtNum0 !== "number")
            return newPtNum0.$ge();
          if (typeof oldPtNum0 !== "number")
            return H.iae(oldPtNum0);
          t2 = newPtNum0 >= oldPtNum0;
        } else
          t2 = false;
        if (t2) {
          if (typeof newPtNum0 !== "number")
            return newPtNum0.$add();
          t4.ptNumber = newPtNum0 + 1;
        }
        if (t1.traceIndex == t5.traceIndex) {
          if (typeof newPtNum1 !== "number")
            return newPtNum1.$ge();
          if (typeof oldPtNum1 !== "number")
            return H.iae(oldPtNum1);
          t1 = newPtNum1 >= oldPtNum1;
        } else
          t1 = false;
        if (t1) {
          if (1 >= t3)
            return H.ioore(newSelection, 1);
          t1 = t5.ptNumber;
          if (typeof t1 !== "number")
            return t1.$add();
          t5.ptNumber = t1 + 1;
        }
      }
      _this.set$selectInfo(newSelection);
      for (t1 = _this.selectInfo, t2 = t1.length, t3 = _this._frames_bar_plotly$_data, t4 = J.getInterceptor$asx(t3), _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        selectTrace = t1[_i];
        t5 = selectTrace.traceIndex;
        J.removeAt$1$ax(J.get$x$x(t4.$index(t3, t5)), selectTrace.ptNumber);
        J.removeAt$1$ax(J.get$y$x(t4.$index(t3, t5)), selectTrace.ptNumber);
      }
      t1 = _this._frames_bar_plotly$_domName;
      t2 = _this.selectInfo;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      t4 = t2[0];
      if (1 >= t3)
        return H.ioore(t2, 1);
      t2 = t2[1];
      self.extendTraces2(t1, [t4.xValue], [t2.xValue], [t4.yValue], [t2.yValue], [1, 3]);
      t2 = _this.selectInfo;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      gpuSelectionHoverName = t2[0].traceIndex === 0 ? "GPU" : "GPU Jank";
      if (1 >= t3)
        return H.ioore(t2, 1);
      uiSelectionHoverName = t2[1].traceIndex === 2 ? "UI" : "UI Jank";
      t2 = [P.int];
      t3 = H.setRuntimeTypeInfo([1], t2);
      self.Plotly.restyle(t1, "name", [gpuSelectionHoverName], t3);
      t2 = H.setRuntimeTypeInfo([3], t2);
      self.Plotly.restyle(t1, "name", [uiSelectionHoverName], t2);
    },
    unselect$0: function() {
      var t3, t4, _i, selectTrace, trace, ptNumber, oldSelectInfo, _this = this,
        t1 = _this.selectInfo,
        t2 = t1.length;
      if (t2 !== 0) {
        for (t3 = _this._frames_bar_plotly$_data, t4 = J.getInterceptor$asx(t3), _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          selectTrace = t1[_i];
          trace = selectTrace.traceIndex;
          ptNumber = selectTrace.ptNumber;
          J.insert$2$ax(J.get$x$x(t4.$index(t3, trace)), ptNumber, selectTrace.xValue);
          J.insert$2$ax(J.get$y$x(t4.$index(t3, trace)), ptNumber, selectTrace.yValue);
        }
        J.removeAt$1$ax(J.get$x$x(t4.$index(t3, 1)), 1);
        J.removeAt$1$ax(J.get$y$x(t4.$index(t3, 1)), 1);
        J.removeAt$1$ax(J.get$x$x(t4.$index(t3, 3)), 1);
        J.removeAt$1$ax(J.get$y$x(t4.$index(t3, 3)), 1);
        t1 = [Y.SelectTrace];
        oldSelectInfo = H.setRuntimeTypeInfo([], t1);
        t2 = _this.selectInfo;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        C.JSArray_methods.add$1(oldSelectInfo, t2[0]);
        t2 = _this.selectInfo;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        C.JSArray_methods.add$1(oldSelectInfo, t2[1]);
        _this.set$selectInfo(H.setRuntimeTypeInfo([], t1));
        return oldSelectInfo;
      }
      return H.setRuntimeTypeInfo([], [Y.SelectTrace]);
    },
    set$selectInfo: function(selectInfo) {
      this.selectInfo = H.assertSubtype(selectInfo, "$isList", [Y.SelectTrace], "$asList");
    }
  };
  Y.TimelineController.prototype = {
    selectFrame$1: function(frame) {
      var t1;
      if (frame != null) {
        t1 = this.timelineData;
        t1 = t1.selectedFrame === frame || t1 == null;
      } else
        t1 = true;
      if (t1)
        return;
      t1 = this.timelineData;
      t1.selectedFrame = frame;
      t1.cpuProfileData = t1.selectedEvent = null;
      this._selectedFrameController.add$1(0, frame);
    },
    selectTimelineEvent$1: function($event) {
      var t1 = this.timelineData;
      if (t1.selectedEvent === $event)
        return;
      t1.selectedEvent = $event;
      this._selectedTimelineEventController.add$1(0, $event);
    },
    getCpuProfileForSelectedEvent$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$returnValue, $async$self = this, t1;
      var $async$getCpuProfileForSelectedEvent$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.timelineData;
              if (t1.selectedEvent.type !== C.TimelineEventType_0) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(t1.selectedFrame.cpuProfileReady.future, $async$getCpuProfileForSelectedEvent$0);
            case 3:
              // returning from await.
              t1 = $async$self.timelineData;
              t1.cpuProfileData = E.CpuProfileData_subProfile(t1.selectedFrame.cpuProfileData, t1.selectedEvent.time);
              $async$self.cpuProfileProtocol.processData$1($async$self.timelineData.cpuProfileData);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getCpuProfileForSelectedEvent$0, $async$completer);
    },
    restoreCpuProfileFromOfflineData$0: function() {
      var _this = this,
        t1 = _this.offlineTimelineData;
      if (t1 == null)
        return;
      _this.timelineData = t1.copy$0();
      _this._loadOfflineDataController.add$1(0, _this.offlineTimelineData);
    },
    recordTraceForTimelineEvent$1: function($event) {
      var t1, t2;
      H.interceptedTypeCheck($event, "$isTimelineEvent0");
      t1 = [P.String, null];
      t2 = H.assertSubtype(C.JSArray_methods.get$first($event.traceEvents).event.json, "$isMap", t1, "$asMap");
      J.add$1$ax(this.timelineData.traceEvents, t2);
      C.JSArray_methods.forEach$1($event.children, this.get$recordTraceForTimelineEvent());
      if ($event.get$endTraceEventJson() != null) {
        t1 = H.assertSubtype($event.get$endTraceEventJson(), "$isMap", t1, "$asMap");
        J.add$1$ax(this.timelineData.traceEvents, t1);
      }
    },
    loadOfflineData$1: function(offlineData) {
      var t1, traceEvents, t2, _i, $event, _this = this;
      _this.timelineData = offlineData.copy$0();
      _this.offlineTimelineData = offlineData.copy$0();
      t1 = Q.TraceEvent;
      traceEvents = J.map$1$1$ax(offlineData.traceEvents, new Y.TimelineController_loadOfflineData_closure(), t1).toList$0(0);
      t2 = [Q.TimelineEvent0];
      _this.timelineProtocol = new O.TimelineProtocol(C.JSArray_methods.get$first(traceEvents).threadId, C.JSArray_methods.get$last(traceEvents).threadId, _this, P.LinkedHashMap_LinkedHashMap$_empty(P.String, Q.TimelineFrame), H.setRuntimeTypeInfo([], t2), H.setRuntimeTypeInfo([null, null], t2), H.setRuntimeTypeInfo([null, null], [t1]), P.List_List$generate(2, new O.TimelineProtocol_closure(), true, [Y.HeapPriorityQueue, Q.TraceEventWrapper]));
      for (t1 = traceEvents.length, _i = 0; _i < traceEvents.length; traceEvents.length === t1 || (0, H.throwConcurrentModificationError)(traceEvents), ++_i) {
        $event = traceEvents[_i];
        _this.timelineProtocol.processTraceEvent$2$immediate($event, true);
      }
      _this.timelineProtocol.maybeAddPendingEvents$0();
      t1 = _this.timelineData.cpuProfileData;
      if (t1 != null)
        _this.cpuProfileProtocol.processData$1(t1);
      _this._loadOfflineDataController.add$1(0, offlineData);
    }
  };
  Y.TimelineController_loadOfflineData_closure.prototype = {
    call$1: function(trace) {
      return Q.TraceEvent$(H.assertSubtype(trace, "$isMap", [P.String, null], "$asMap"));
    },
    $signature: 84
  };
  Q.TimelineData.prototype = {
    get$json: function(_) {
      var t2,
        t1 = this.cpuProfileData;
      t1 = t1 == null ? null : t1.get$json(t1);
      if (t1 == null)
        t1 = P.LinkedHashMap__makeEmpty();
      t2 = this.selectedEvent;
      t2 = t2 == null ? null : t2.get$json(t2);
      if (t2 == null)
        t2 = P.LinkedHashMap__makeEmpty();
      return P.LinkedHashMap_LinkedHashMap$_literal(["traceEvents", this.traceEvents, "cpuProfile", t1, "selectedEvent", t2, "dartDevToolsScreen", "timeline"], P.String, null);
    },
    clear$0: function(_) {
      var _this = this;
      J.clear$0$ax(_this.traceEvents);
      C.JSArray_methods.set$length(_this.frames, 0);
      _this.cpuProfileData = _this.selectedEvent = _this.selectedFrame = null;
    }
  };
  Q.OfflineTimelineData.prototype = {
    copy$0: function() {
      var _this = this,
        t1 = _this.selectedFrame,
        t2 = _this.selectedEvent;
      return Q.OfflineTimelineData$_(_this.cpuProfileData, _this.frames, t2, t1, _this.traceEvents);
    }
  };
  Q.OfflineTimelineEvent.prototype = {};
  Q.TimelineFrame.prototype = {
    get$uiDuration: function() {
      var t2,
        t1 = this.eventFlows;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = t1[0];
      if (t1 != null) {
        t1 = t1.time;
        t2 = t1._utils$_end;
        t1 = t1._utils$_start;
        t1 = t2._duration - t1._duration;
      } else
        t1 = null;
      return t1;
    },
    get$uiDurationMs: function() {
      if (this.get$uiDuration() != null) {
        var t1 = this.get$uiDuration();
        if (typeof t1 !== "number")
          return t1.$div();
        t1 /= 1000;
      } else
        t1 = null;
      return t1;
    },
    get$gpuDuration: function() {
      var t2,
        t1 = this.eventFlows;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t1 = t1[1];
      if (t1 != null) {
        t1 = t1.time;
        t2 = t1._utils$_end;
        t1 = t1._utils$_start;
        t1 = t2._duration - t1._duration;
      } else
        t1 = null;
      return t1;
    },
    get$gpuDurationMs: function() {
      if (this.get$gpuDuration() != null) {
        var t1 = this.get$gpuDuration();
        if (typeof t1 !== "number")
          return t1.$div();
        t1 /= 1000;
      } else
        t1 = null;
      return t1;
    },
    toString$0: function(_) {
      var t1 = "Frame " + this.id + " - " + this.time.toString$0(0) + ", ui: ",
        t2 = this.eventFlows;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1 = t1 + t2[0].time.toString$0(0) + ", gpu: ";
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      return t1 + t2[1].time.toString$0(0);
    },
    get$id: function(receiver) {
      return this.id;
    }
  };
  Q.TimelineFrame_closure.prototype = {
    call$1: function(_) {
      return;
    },
    $signature: 63
  };
  Q.TimelineEventType.prototype = {
    toString$0: function(_) {
      return this._timeline_model$_name;
    }
  };
  Q.TimelineEvent0.prototype = {
    get$name: function(_) {
      return C.JSArray_methods.get$first(this.traceEvents).event.name;
    },
    get$endTraceEventJson: function() {
      var t1 = this.traceEvents;
      return t1.length > 1 ? C.JSArray_methods.get$last(t1).event.json : null;
    },
    get$isUiEventFlow: function() {
      return this.containsChildWithCondition$1(new Q.TimelineEvent_isUiEventFlow_closure());
    },
    get$isGpuEventFlow: function() {
      return this.containsChildWithCondition$1(new Q.TimelineEvent_isGpuEventFlow_closure());
    },
    maybeRemoveDuplicate$0: function() {
      var t2, _this = this,
        t1 = new Q.TimelineEvent_maybeRemoveDuplicate__maybeRemoveDuplicate(_this);
      if (_this.children.length !== 0)
        t1.call$1$parent(_this);
      t2 = _this.parent;
      if (t2 != null)
        t1.call$1$parent(t2);
    },
    removeChild$1: function(childToRemove) {
      C.JSArray_methods.forEach$1(P.List_List$from(childToRemove.children, true, Q.TimelineEvent0), this.get$_addChild());
      C.JSArray_methods.remove$1(this.children, childToRemove);
    },
    addChild$1: function(child) {
      new Q.TimelineEvent_addChild__putChildInTree(child).call$1(this);
    },
    _addChild$1: function(child) {
      H.interceptedTypeCheck(child, "$isTimelineEvent0");
      C.JSArray_methods.add$1(this.children, child);
      child.set$parent(0, this);
    },
    couldBeParentOf$1: function(e) {
      var endTime, eStartTime, eEndTime,
        t1 = this.time,
        startTime = t1._utils$_start._duration;
      t1 = t1._utils$_end;
      endTime = t1 == null ? null : t1._duration;
      t1 = e.time;
      eStartTime = t1._utils$_start._duration;
      t1 = t1._utils$_end;
      eEndTime = t1 == null ? null : t1._duration;
      t1 = endTime != null;
      if (t1 && eEndTime != null) {
        if (startTime === eStartTime && endTime === eEndTime)
          return C.JSArray_methods.get$first(this.traceEvents).id < C.JSArray_methods.get$first(e.traceEvents).id;
        if (startTime <= eStartTime) {
          if (typeof endTime !== "number")
            return endTime.$ge();
          t1 = endTime >= eEndTime;
        } else
          t1 = false;
        return t1;
      } else if (t1)
        return startTime <= eStartTime && endTime > eStartTime;
      else if (startTime === eStartTime)
        return C.JSArray_methods.get$first(this.traceEvents).id < C.JSArray_methods.get$first(e.traceEvents).id;
      else
        return startTime < eStartTime;
    },
    format$2: function(buf, indent) {
      var t1, t2, _i;
      buf._contents += indent + H.S(C.JSArray_methods.get$first(this.traceEvents).event.name) + " " + this.time.toString$0(0) + "\n";
      for (t1 = this.children, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
        t1[_i].format$2(buf, "  " + indent);
    },
    get$json: function(_) {
      var t1 = C.JSArray_methods.get$first(this.traceEvents),
        t2 = J.toString$0$(this.type),
        t3 = this.time,
        t4 = t3._utils$_start._duration;
      return P.LinkedHashMap_LinkedHashMap$_literal(["name", t1.event.name, "type", t2, "startMicros", t4, "durationMicros", t3._utils$_end._duration - t4], P.String, null);
    },
    toString$0: function(_) {
      var t1,
        buf = new P.StringBuffer("");
      this.format$2(buf, "  ");
      t1 = buf._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $asTreeNode0: function() {
      return [Q.TimelineEvent0];
    }
  };
  Q.TimelineEvent_isUiEventFlow_closure.prototype = {
    call$1: function($event) {
      return J.contains$1$asx(C.JSArray_methods.get$first(H.interceptedTypeCheck($event, "$isTimelineEvent0").traceEvents).event.name, "Engine::BeginFrame");
    },
    $signature: 57
  };
  Q.TimelineEvent_isGpuEventFlow_closure.prototype = {
    call$1: function($event) {
      return J.contains$1$asx(C.JSArray_methods.get$first(H.interceptedTypeCheck($event, "$isTimelineEvent0").traceEvents).event.name, "PipelineConsume");
    },
    $signature: 57
  };
  Q.TimelineEvent_maybeRemoveDuplicate__maybeRemoveDuplicate.prototype = {
    call$1$parent: function($parent) {
      var t1 = $parent.children;
      if (t1.length === 1 && C.C_DeepCollectionEquality.equals$2(C.JSArray_methods.get$first($parent.traceEvents).event.json, C.JSArray_methods.get$first(C.JSArray_methods.get$first(t1).traceEvents).event.json) && C.C_DeepCollectionEquality.equals$2($parent.get$endTraceEventJson(), C.JSArray_methods.get$first(t1).get$endTraceEventJson()))
        $parent.removeChild$1(C.JSArray_methods.get$first(this.$this.children));
    },
    call$0: function() {
      return this.call$1$parent(null);
    },
    $signature: 211
  };
  Q.TimelineEvent_addChild__putChildInTree.prototype = {
    call$1: function(root) {
      var t2, _children, childrenToReorder, t3, _i, otherChild, t4, t5,
        t1 = root.children;
      if (t1.length === 0) {
        t2 = this.child;
        C.JSArray_methods.add$1(t1, t2);
        t2.set$parent(0, root);
        return;
      }
      _children = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
      childrenToReorder = [];
      for (t2 = _children.length, t3 = this.child, _i = 0; _i < _children.length; _children.length === t2 || (0, H.throwConcurrentModificationError)(_children), ++_i) {
        otherChild = _children[_i];
        if (t3.couldBeParentOf$1(otherChild))
          childrenToReorder.push(otherChild);
      }
      if (childrenToReorder.length !== 0) {
        C.JSArray_methods.add$1(t1, t3);
        t3.set$parent(0, root);
        for (t2 = childrenToReorder.length, t4 = t3.children, _i = 0; _i < childrenToReorder.length; childrenToReorder.length === t2 || (0, H.throwConcurrentModificationError)(childrenToReorder), ++_i) {
          t5 = childrenToReorder[_i];
          C.JSArray_methods.add$1(t4, t5);
          t5.set$parent(0, t3);
          C.JSArray_methods.remove$1(t1, t5);
        }
        return;
      }
      for (t2 = H.getTypeArgumentByIndex(_children, 0), t4 = new H.ReversedListIterable(_children, [t2]), t2 = new H.ListIterator(t4, t4.get$length(t4), [t2]); t2.moveNext$0();) {
        t4 = t2.__internal$_current;
        if (t4.couldBeParentOf$1(t3)) {
          this.call$1(t4);
          return;
        }
      }
      C.JSArray_methods.add$1(t1, t3);
      t3.set$parent(0, root);
    },
    $signature: 46
  };
  Q.TraceEvent.prototype = {
    get$id: function(_) {
      return J.$index$asx(this.json, "id");
    },
    get$type: function(_) {
      var t2, _this = this,
        t1 = _this._type;
      if (t1 == null) {
        t1 = _this.args;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(t2.$index(t1, "type"), "ui")) {
          _this._type = C.TimelineEventType_0;
          t1 = C.TimelineEventType_0;
        } else if (J.$eq$(t2.$index(t1, "type"), "gpu")) {
          _this._type = C.TimelineEventType_1;
          t1 = C.TimelineEventType_1;
        } else {
          _this._type = C.TimelineEventType_2;
          t1 = C.TimelineEventType_2;
        }
      }
      return t1;
    },
    toString$0: function(_) {
      var _this = this;
      return H.S(_this.get$type(_this)) + " event [id: " + H.S(J.$index$asx(_this.json, "id")) + "] [ph: " + H.S(_this.phase) + "] " + H.S(_this.name) + " - [ts: " + H.S(_this.timestampMicros) + "] [dur: " + H.S(_this.duration) + "]";
    },
    get$json: function(receiver) {
      return this.json;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  Q.TraceEventWrapper.prototype = {
    get$json: function(_) {
      return this.event.json;
    },
    compareTo$1: function(_, other) {
      var compare;
      H.interceptedTypeCheck(other, "$isTraceEventWrapper");
      compare = J.compareTo$1$ns(this.event.timestampMicros, other.event.timestampMicros);
      return compare !== 0 ? compare : C.JSInt_methods.compareTo$1(this.id, other.id);
    },
    $isComparable: 1,
    $asComparable: function() {
      return [Q.TraceEventWrapper];
    },
    get$id: function(receiver) {
      return this.id;
    }
  };
  O.TimelineProtocol.prototype = {
    processTraceEvent$2$immediate: function($event, immediate) {
      var t1, t2, phaseWhitelist, heap, t3, t4, newCapacity, newQueue, _this = this,
        _s12_ = "PipelineItem";
      $event._type = _this._inferEventType$1($event);
      t1 = P.String;
      t2 = H.setRuntimeTypeInfo(["s", "f", "B", "E", "X"], [t1]);
      phaseWhitelist = P.LinkedHashSet_LinkedHashSet(t1);
      phaseWhitelist.addAll$1(0, t2);
      t1 = $event.phase;
      if (phaseWhitelist.contains$1(0, t1))
        if ($event.category !== "GC")
          if ($event.name !== "MessageLoop::RunExpiredTasks")
            t2 = $event.get$type($event) === C.TimelineEventType_1 || $event.get$type($event) === C.TimelineEventType_0;
          else
            t2 = false;
        else
          t2 = false;
      else
        t2 = false;
      if (!t2)
        return;
      switch (t1) {
        case "s":
          if (J.contains$1$asx($event.name, _s12_))
            _this._handleFrameStartEvent$1($event);
          break;
        case "f":
          if (J.contains$1$asx($event.name, _s12_))
            _this._handleFrameEndEvent$1($event);
          break;
        default:
          if (immediate)
            _this._processDurationEvent$1(Q.TraceEventWrapper$($event, Date.now()));
          else {
            t1 = _this.heaps;
            t2 = $event.get$type($event).index;
            if (t2 >= t1.length)
              return H.ioore(t1, t2);
            heap = t1[t2];
            t2 = Q.TraceEventWrapper$($event, Date.now());
            heap.toString;
            t1 = H.getTypeArgumentByIndex(heap, 0);
            H.assertSubtypeOfRuntimeType(t2, t1);
            t3 = heap._priority_queue$_length;
            t4 = heap._priority_queue$_queue.length;
            if (t3 === t4) {
              newCapacity = t4 * 2 + 1;
              if (newCapacity < 7)
                newCapacity = 7;
              t3 = new Array(newCapacity);
              t3.fixed$length = Array;
              newQueue = H.setRuntimeTypeInfo(t3, [t1]);
              C.JSArray_methods.setRange$3(newQueue, 0, heap._priority_queue$_length, heap._priority_queue$_queue);
              heap.set$_priority_queue$_queue(newQueue);
            }
            heap._bubbleUp$2(t2, heap._priority_queue$_length++);
            B.executeWithDelay(P.Duration$(0, 1000, 0, 0), new O.TimelineProtocol_processTraceEvent_closure(_this, heap), _this.shouldProcessTopEvent$1(heap));
          }
      }
    },
    processTraceEvent$1: function($event) {
      return this.processTraceEvent$2$immediate($event, false);
    },
    shouldProcessTopEvent$1: function(heap) {
      var t1, t2;
      H.assertSubtype(heap, "$isHeapPriorityQueue", [Q.TraceEventWrapper], "$asHeapPriorityQueue");
      if (heap._priority_queue$_length !== 0) {
        t1 = Date.now();
        if (heap._priority_queue$_length === 0)
          H.throwExpression(P.StateError$("No such element"));
        t2 = heap._priority_queue$_queue;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = t1 - t2[0].timeReceived >= 1000;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    _processDurationEvents$1: function(heap) {
      var t1, t2, t3, result, newLength, last,
        _s15_ = "No such element";
      H.assertSubtype(heap, "$isHeapPriorityQueue", [Q.TraceEventWrapper], "$asHeapPriorityQueue");
      while (true) {
        t1 = heap._priority_queue$_length;
        t2 = t1 !== 0;
        if (t2)
          if (t2) {
            t1 = Date.now();
            t2 = heap._priority_queue$_length;
            if (t2 === 0)
              H.throwExpression(P.StateError$(_s15_));
            t3 = heap._priority_queue$_queue;
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            t3 = t1 - t3[0].timeReceived >= 1000;
            t1 = t3;
          } else {
            t2 = t1;
            t1 = false;
          }
        else {
          t2 = t1;
          t1 = false;
        }
        if (!t1)
          break;
        if (t2 === 0)
          H.throwExpression(P.StateError$(_s15_));
        t1 = heap._priority_queue$_queue;
        t3 = t1.length;
        if (0 >= t3)
          return H.ioore(t1, 0);
        result = t1[0];
        newLength = t2 - 1;
        if (newLength < 0 || newLength >= t3)
          return H.ioore(t1, newLength);
        last = t1[newLength];
        C.JSArray_methods.$indexSet(t1, newLength, null);
        heap._priority_queue$_length = newLength;
        if (newLength > 0)
          heap._bubbleDown$2(last, 0);
        this._processDurationEvent$1(result);
      }
    },
    _processDurationEvent$1: function(eventWrapper) {
      var t3, _this = this,
        $event = eventWrapper.event,
        t1 = _this.currentEventNodes,
        t2 = $event.get$type($event).index;
      if (t2 >= 2)
        return H.ioore(t1, t2);
      if (t1[t2] != null) {
        t2 = $event.timestampMicros;
        t3 = $event.get$type($event).index;
        if (t3 >= 2)
          return H.ioore(t1, t3);
        t3 = t1[t3];
        t3 = t3.get$root(t3).time._utils$_start._duration;
        if (typeof t2 !== "number")
          return t2.$lt();
        t3 = t2 < t3;
        t1 = t3;
      } else
        t1 = false;
      if (t1)
        return;
      switch ($event.phase) {
        case "B":
          _this._handleDurationBeginEvent$1(eventWrapper);
          break;
        case "E":
          _this._handleDurationEndEvent$1(eventWrapper);
          break;
        case "X":
          _this._handleDurationCompleteEvent$1(eventWrapper);
          break;
      }
    },
    _handleFrameStartEvent$1: function($event) {
      var id, pendingFrame, t3,
        t1 = $event.json,
        t2 = J.getInterceptor$asx(t1);
      if (t2.$index(t1, "id") != null) {
        id = H.S($event.name) + "-" + H.S(t2.$index(t1, "id"));
        pendingFrame = this.pendingFrames.putIfAbsent$2(0, id, new O.TimelineProtocol__handleFrameStartEvent_closure(id));
        t1 = pendingFrame.pipelineItemTime;
        t2 = t1._utils$_start;
        t2 = t2 == null ? null : t2._duration;
        t3 = $event.timestampMicros;
        t2 = P.Duration$(B.nullSafeMin(t2, t3, P.int), 0, 0, 0);
        t1._utils$_start = t2;
        if (t2._duration === t3)
          pendingFrame.pipelineItemStartTrace = $event;
        this.maybeAddPendingEvents$0();
      }
    },
    _handleFrameEndEvent$1: function($event) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, id, pendingFrame, t3, t1, t2;
      var $async$_handleFrameEndEvent$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $event.json;
              t2 = J.getInterceptor$asx(t1);
              if (t2.$index(t1, "id") != null) {
                id = H.S($event.name) + "-" + H.S(t2.$index(t1, "id"));
                pendingFrame = $async$self.pendingFrames.putIfAbsent$2(0, id, new O.TimelineProtocol__handleFrameEndEvent_closure(id));
                t1 = pendingFrame.pipelineItemTime;
                t2 = t1._utils$_end;
                t2 = t2 == null ? null : t2._duration;
                t3 = $event.timestampMicros;
                t2 = P.Duration$(B.nullSafeMax(t2, t3, P.int), 0, 0, 0);
                t1._utils$_end = t2;
                if (t2._duration === t3)
                  pendingFrame.pipelineItemEndTrace = $event;
                $async$self.maybeAddPendingEvents$0();
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_handleFrameEndEvent$1, $async$completer);
    },
    _handleDurationBeginEvent$1: function(eventWrapper) {
      var current, t3, timelineEvent,
        $event = eventWrapper.event,
        t1 = this.currentEventNodes,
        t2 = $event.get$type($event).index;
      if (t2 >= 2)
        return H.ioore(t1, t2);
      current = t1[t2];
      t2 = current == null;
      if (t2) {
        t3 = $event.name;
        t3 = !(J.getInterceptor$asx(t3).contains$1(t3, "VSYNC") || C.JSString_methods.contains$1(t3, "GPURasterizer::Draw"));
      } else
        t3 = false;
      if (t3)
        return;
      timelineEvent = Q.TimelineEvent$(eventWrapper);
      if (!t2)
        current.addChild$1(timelineEvent);
      C.JSArray_methods.$indexSet(t1, $event.get$type($event).index, timelineEvent);
    },
    _handleDurationEndEvent$1: function(eventWrapper) {
      var current, t3, t4, t5, t6, current0, _this = this, _null = null,
        $event = eventWrapper.event,
        t1 = _this.currentEventNodes,
        t2 = $event.get$type($event).index;
      if (t2 >= 2)
        return H.ioore(t1, t2);
      current = t1[t2];
      if (current == null)
        return;
      t2 = $event.name;
      t3 = current.traceEvents;
      if (t2 != C.JSArray_methods.get$first(t3).event.name) {
        t4 = _this.previousDurationEndEvents;
        t5 = $event.get$type($event).index;
        if (t5 >= 2)
          return H.ioore(t4, t5);
        t5 = t4[t5];
        t5 = t5 == null ? _null : t5.json;
        if (C.C_DeepCollectionEquality.equals$2($event.json, t5))
          return;
        else {
          t5 = C.JSArray_methods.get$first(t3);
          t6 = $event.get$type($event).index;
          if (t6 >= 2)
            return H.ioore(t4, t6);
          t6 = t4[t6];
          t4 = t6 == null ? _null : t6.name;
          if (t5.event.name == t4) {
            t4 = current.parent;
            if ((t4 == null ? _null : C.JSArray_methods.get$first(t4.traceEvents).event.name) == t2) {
              t2 = current.children;
              t2 = t2.length === 1 && C.C_DeepCollectionEquality.equals$2(C.JSArray_methods.get$first(t3).event.json, C.JSArray_methods.get$first(C.JSArray_methods.get$first(t2).traceEvents).event.json);
            } else
              t2 = false;
          } else
            t2 = false;
          if (t2) {
            current.parent.removeChild$1(current);
            current = current.parent;
            C.JSArray_methods.$indexSet(t1, $event.get$type($event).index, current);
          } else {
            C.JSArray_methods.$indexSet(t1, $event.get$type($event).index, _null);
            return;
          }
        }
      }
      C.JSArray_methods.$indexSet(_this.previousDurationEndEvents, $event.get$type($event).index, $event);
      t2 = current.time;
      t3 = P.Duration$($event.timestampMicros, 0, 0, 0);
      t2._utils$_end = t3;
      C.JSArray_methods.add$1(current.traceEvents, eventWrapper);
      current.maybeRemoveDuplicate$0();
      while (true) {
        current0 = current.parent;
        if (current0 != null) {
          t2 = current0.time._utils$_end;
          t2 = (t2 == null ? _null : t2._duration) != null;
        } else
          t2 = false;
        if (!t2)
          break;
        current = current0;
      }
      C.JSArray_methods.$indexSet(t1, $event.get$type($event).index, current.parent);
      if (current.parent == null)
        _this._maybeAddEvent$1(current);
    },
    _handleDurationCompleteEvent$1: function(eventWrapper) {
      var current,
        $event = eventWrapper.event,
        timelineEvent = Q.TimelineEvent$(eventWrapper),
        t1 = $event.timestampMicros,
        t2 = $event.duration;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t2 = P.Duration$(t1 + t2, 0, 0, 0);
      timelineEvent.time._utils$_end = t2;
      t1 = this.currentEventNodes;
      t2 = $event.get$type($event).index;
      if (t2 >= 2)
        return H.ioore(t1, t2);
      current = t1[t2];
      if (current != null) {
        if (current.containsChildWithCondition$1(new O.TimelineProtocol__handleDurationCompleteEvent_closure(timelineEvent)))
          return;
        current.addChild$1(timelineEvent);
      } else
        this._maybeAddEvent$1(timelineEvent);
    },
    maybeAddPendingEvents$0: function() {
      var t2, $frames, t3, _i, frame, eventsToRemove, t4, _i0, $event, _this = this,
        t1 = _this.pendingEvents;
      if (t1.length !== 0) {
        t2 = _this.pendingFrames;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = true;
      if (t2)
        return;
      C.JSArray_methods.sort$1(t1, new O.TimelineProtocol_maybeAddPendingEvents_closure());
      $frames = _this._getAndSortWellFormedFrames$0();
      for (t2 = $frames.length, t3 = [Q.TimelineEvent0], _i = 0; _i < $frames.length; $frames.length === t2 || (0, H.throwConcurrentModificationError)($frames), ++_i) {
        frame = $frames[_i];
        eventsToRemove = H.setRuntimeTypeInfo([], t3);
        for (t4 = t1.length, _i0 = 0; _i0 < t1.length; t1.length === t4 || (0, H.throwConcurrentModificationError)(t1), ++_i0) {
          $event = t1[_i0];
          if (_this._maybeAddEventToFrame$2($event, frame)) {
            C.JSArray_methods.add$1(eventsToRemove, $event);
            break;
          }
        }
        t4 = eventsToRemove.length;
        if (t4 !== 0)
          for (_i0 = 0; _i0 < eventsToRemove.length; eventsToRemove.length === t4 || (0, H.throwConcurrentModificationError)(eventsToRemove), ++_i0)
            C.JSArray_methods.remove$1(t1, eventsToRemove[_i0]);
      }
    },
    _maybeAddEvent$1: function($event) {
      var $frames, t1, eventAdded, _i, _this = this;
      if (!$event.get$isUiEventFlow() && !$event.get$isGpuEventFlow())
        return;
      $frames = _this._getAndSortWellFormedFrames$0();
      for (t1 = $frames.length, eventAdded = false, _i = 0; _i < $frames.length; $frames.length === t1 || (0, H.throwConcurrentModificationError)($frames), ++_i) {
        eventAdded = _this._maybeAddEventToFrame$2($event, $frames[_i]);
        if (eventAdded) {
          _this.maybeAddPendingEvents$0();
          break;
        }
      }
      if (!eventAdded)
        C.JSArray_methods.add$1(_this.pendingEvents, $event);
    },
    _maybeAddEventToFrame$2: function($event, frame) {
      var type, t3, _null = null,
        t1 = frame.eventFlows,
        t2 = $event.type.index;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      if (t1[t2] != null || !this.eventOccursWithinFrameBounds$2($event, frame))
        return false;
      type = $event == null ? _null : $event.type;
      if (type === C.TimelineEventType_0) {
        t2 = frame.time;
        t3 = $event == null ? _null : $event.time;
        t3 = t3 == null ? _null : t3._utils$_start;
        t2._utils$_start = t3;
      }
      if (type === C.TimelineEventType_1) {
        t2 = frame.time;
        t3 = $event == null ? _null : $event.time;
        t3 = t3 == null ? _null : t3._utils$_end;
        t2._utils$_end = t3;
      }
      C.JSArray_methods.$indexSet(t1, type.index, $event);
      if ($event != null)
        $event._timeline_model$_frameId = frame.id;
      this._maybeAddCompletedFrame$1(frame);
      return true;
    },
    _maybeAddCompletedFrame$1: function(frame) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$returnValue, $async$self = this, t3, t4, t1, t2, $async$temp1, $async$temp2;
      var $async$_maybeAddCompletedFrame$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = frame.eventFlows;
              t2 = t1.length;
              if (0 >= t2) {
                $async$returnValue = H.ioore(t1, 0);
                // goto return
                $async$goto = 1;
                break;
              }
              if (t1[0] != null) {
                if (1 >= t2) {
                  $async$returnValue = H.ioore(t1, 1);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (t1[1] != null) {
                  t2 = frame.pipelineItemTime;
                  t3 = t2._utils$_start;
                  if ((t3 == null ? null : t3._duration) != null) {
                    t2 = t2._utils$_end;
                    t2 = (t2 == null ? null : t2._duration) != null;
                  } else
                    t2 = false;
                } else
                  t2 = false;
              } else
                t2 = false;
              $async$goto = t2 && frame._addedToTimeline == null ? 3 : 4;
              break;
            case 3:
              // then
              t2 = $async$self.timelineController;
              t3 = [P.String, null];
              t4 = H.assertSubtype(frame.pipelineItemStartTrace.json, "$isMap", t3, "$asMap");
              J.add$1$ax(t2.timelineData.traceEvents, t4);
              if (0 >= t1.length) {
                $async$returnValue = H.ioore(t1, 0);
                // goto return
                $async$goto = 1;
                break;
              }
              t2.recordTraceForTimelineEvent$1(t1[0]);
              if (1 >= t1.length) {
                $async$returnValue = H.ioore(t1, 1);
                // goto return
                $async$goto = 1;
                break;
              }
              t2.recordTraceForTimelineEvent$1(t1[1]);
              t3 = H.assertSubtype(frame.pipelineItemEndTrace.json, "$isMap", t3, "$asMap");
              J.add$1$ax(t2.timelineData.traceEvents, t3);
              C.JSArray_methods.add$1(t2.timelineData.frames, frame);
              t2.frameAddedController.add$1(0, frame);
              $async$self.pendingFrames.remove$1(0, frame.id);
              frame._addedToTimeline = true;
              t2 = t2.timelineService;
              if (0 >= t1.length) {
                $async$returnValue = H.ioore(t1, 0);
                // goto return
                $async$goto = 1;
                break;
              }
              t1 = t1[0].time;
              t3 = t1._utils$_start._duration;
              $async$temp1 = frame;
              $async$temp2 = H;
              $async$goto = 5;
              return P._asyncAwait(t2.getCpuProfile$2$extentMicros$startMicros(t1._utils$_end._duration - t3, t3), $async$_maybeAddCompletedFrame$1);
            case 5:
              // returning from await.
              $async$temp1.cpuProfileData = $async$temp2.interceptedTypeCheck($async$result, "$isCpuProfileData");
              frame.cpuProfileReady.complete$0(0);
            case 4:
              // join
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_maybeAddCompletedFrame$1, $async$completer);
    },
    eventOccursWithinFrameBounds$2: function(e, f) {
      var t3, epsilon, t4, t5,
        t1 = e.time,
        t2 = t1._utils$_end;
      t1 = t1._utils$_start;
      t3 = t2._duration;
      t1 = t1._duration;
      epsilon = Math.min(C.JSInt_methods._tdivFast$1(t3 - t1, 2), 1000);
      t4 = f.pipelineItemTime;
      t5 = t4._utils$_start._duration;
      t4 = t4._utils$_end._duration;
      t2 = t2 == null ? null : t3;
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t5 - t1 - epsilon <= 0 && t4 - t2 + epsilon >= 0 && H.boolConversionCheck(new O.TimelineProtocol_eventOccursWithinFrameBounds_satisfiesUiGpuOrder(e, f).call$0());
    },
    _getAndSortWellFormedFrames$0: function() {
      var t2, $frames,
        t1 = this.pendingFrames;
      t1 = t1.get$values(t1);
      t2 = H.getRuntimeTypeArgument(t1, "Iterable", 0);
      $frames = P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new O.TimelineProtocol__getAndSortWellFormedFrames_closure(), {func: 1, ret: P.bool, args: [t2]}), [t2]), true, t2);
      C.JSArray_methods.sort$1($frames, new O.TimelineProtocol__getAndSortWellFormedFrames_closure0());
      return $frames;
    },
    _inferEventType$1: function($event) {
      var t1 = $event.threadId;
      if (t1 == this.uiThreadId)
        return C.TimelineEventType_0;
      else if (t1 == this.gpuThreadId)
        return C.TimelineEventType_1;
      else
        return C.TimelineEventType_2;
    }
  };
  O.TimelineProtocol_closure.prototype = {
    call$1: function(_) {
      var t3,
        t1 = Q.TraceEventWrapper,
        t2 = new Array(7);
      t2.fixed$length = Array;
      t2 = H.setRuntimeTypeInfo(t2, [t1]);
      t3 = B.defaultCompare(t1);
      return new Y.HeapPriorityQueue(t3, t2, [t1]);
    },
    $signature: 212
  };
  O.TimelineProtocol_processTraceEvent_closure.prototype = {
    call$0: function() {
      return this.$this._processDurationEvents$1(this.heap);
    },
    $signature: 1
  };
  O.TimelineProtocol__handleFrameStartEvent_closure.prototype = {
    call$0: function() {
      return new Q.TimelineFrame(this.id, P.List_List$generate(2, new Q.TimelineFrame_closure(), true, Q.TimelineEvent0), new B.TimeRange(true), new P._AsyncCompleter(new P._Future($.Zone__current, [null]), [null]), new B.TimeRange(false));
    },
    $signature: 86
  };
  O.TimelineProtocol__handleFrameEndEvent_closure.prototype = {
    call$0: function() {
      return new Q.TimelineFrame(this.id, P.List_List$generate(2, new Q.TimelineFrame_closure(), true, Q.TimelineEvent0), new B.TimeRange(true), new P._AsyncCompleter(new P._Future($.Zone__current, [null]), [null]), new B.TimeRange(false));
    },
    $signature: 86
  };
  O.TimelineProtocol__handleDurationCompleteEvent_closure.prototype = {
    call$1: function($event) {
      return C.C_DeepCollectionEquality.equals$2(C.JSArray_methods.get$first(H.interceptedTypeCheck($event, "$isTimelineEvent0").traceEvents).event.json, C.JSArray_methods.get$first(this.timelineEvent.traceEvents).event.json);
    },
    $signature: 57
  };
  O.TimelineProtocol_maybeAddPendingEvents_closure.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isTimelineEvent0");
      H.interceptedTypeCheck(b, "$isTimelineEvent0");
      return C.JSInt_methods.compareTo$1(a.time._utils$_start._duration, b.time._utils$_start._duration);
    },
    $signature: 214
  };
  O.TimelineProtocol_eventOccursWithinFrameBounds_satisfiesUiGpuOrder.prototype = {
    call$0: function() {
      var t2, _this = this,
        t1 = _this.e;
      if (t1.get$isUiEventFlow()) {
        t2 = _this.f.eventFlows;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        t2 = t2[1] != null;
      } else
        t2 = false;
      if (t2) {
        t1 = t1.time._utils$_start._duration;
        t2 = _this.f.eventFlows;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        return t1 < t2[1].time._utils$_start._duration;
      } else {
        if (t1.get$isGpuEventFlow()) {
          t2 = _this.f.eventFlows;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = t2[0] != null;
        } else
          t2 = false;
        if (t2) {
          t1 = t1.time._utils$_start._duration;
          t2 = _this.f.eventFlows;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          return t1 > t2[0].time._utils$_start._duration;
        }
      }
      return true;
    },
    $signature: 71
  };
  O.TimelineProtocol__getAndSortWellFormedFrames_closure.prototype = {
    call$1: function(frame) {
      var t1 = H.interceptedTypeCheck(frame, "$isTimelineFrame").pipelineItemTime,
        t2 = t1._utils$_start;
      if ((t2 == null ? null : t2._duration) != null) {
        t1 = t1._utils$_end;
        t1 = (t1 == null ? null : t1._duration) != null;
      } else
        t1 = false;
      return t1;
    },
    $signature: 215
  };
  O.TimelineProtocol__getAndSortWellFormedFrames_closure0.prototype = {
    call$2: function(a, b) {
      H.interceptedTypeCheck(a, "$isTimelineFrame");
      H.interceptedTypeCheck(b, "$isTimelineFrame");
      return C.JSInt_methods.compareTo$1(a.pipelineItemTime._utils$_start._duration, b.pipelineItemTime._utils$_start._duration);
    },
    $signature: 216
  };
  X.TimelineScreen.prototype = {
    createContent$1: function(framework) {
      var screenDiv, t1, t2, t3, t4, t5, t6, t7, _this = this, _null = null, _s3_ = "div", _s6_ = "layout",
        _s8_ = "vertical",
        _s6_0 = "btn-sm",
        _s11_ = "margin-left",
        _s5_ = "title", _s6_1 = "hidden",
        _s9_ = "btn-group";
      E.setupDimensions();
      screenDiv = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t1 = screenDiv.element;
      t1.setAttribute(_s6_, "");
      t1.setAttribute(_s8_, "");
      t1 = N.PButton$icon("Pause recording", C.UrlIcon_46y, _null);
      t1.clazz$1(_s6_0);
      t1.clazz$1("btn-primary");
      t1.click$1(0, _this.get$_pauseRecording());
      _this.pauseButton = t1;
      t1 = N.PButton$icon("Resume recording", C.UrlIcon_y9i, _null);
      t1.clazz$1(_s6_0);
      t1.clazz$1(_s11_);
      t1.attribute$2("disabled", true);
      t1.click$1(0, _this.get$_resumeRecording());
      _this.resumeButton = t1;
      t1 = N.PButton$icon("", C.MaterialIcon_JaK, _null);
      t1.clazz$1(_s6_0);
      t1.clazz$1(_s11_);
      t1.element.setAttribute(_s5_, "Export timeline");
      t1.click$1(0, _this.get$_exportTimeline());
      _this.exportButton = t1;
      t1 = N.PButton$icon("Clear", C.MaterialIcon_ref, _null);
      t1.clazz$1(_s6_0);
      t1.clazz$1(_s11_);
      t1.element.setAttribute(_s5_, "Clear timeline");
      t1.click$1(0, _this.get$clearTimeline());
      _this.clearButton = t1;
      t1 = N.PButton$icon("Exit offline mode", C.MaterialIcon_ifn, _null);
      t1.clazz$1(_s6_0);
      t2 = t1.element;
      t2.setAttribute(_s5_, "Exit offline mode to connect to a VM Service.");
      t2.setAttribute(_s6_1, "true");
      t1.click$1(0, _this.get$_exitOfflineMode());
      _this.exitOfflineModeButton = t1;
      t1 = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t2 = t1.element;
      t2.setAttribute(_s6_, "");
      t2.setAttribute("horizontal", "");
      t2 = A.CoreElement$(_s3_, _null, _s9_, _null, _null);
      t2.add$1(0, H.setRuntimeTypeInfo([_this.pauseButton, _this.resumeButton], [N.PButton]));
      t3 = _this.clearButton;
      t4 = _this.exitOfflineModeButton;
      t5 = A.CoreElement$(_s3_, _null, _null, _null, _null);
      t5.flex$0(0);
      t6 = A.CoreElement$(_s3_, _null, _s9_, _null, _null);
      _this.debugButtonSection = t6;
      t7 = [A.CoreElement];
      t1.add$1(0, H.setRuntimeTypeInfo([t2, t3, t4, t5, t6, _this.exportButton], t7));
      _this.upperButtonSection = t1;
      _this._maybeAddDebugButtons$0();
      t1 = _this.upperButtonSection;
      t6 = A.CoreElement$(_s3_, _null, "section section-border", _null, _null);
      t5 = _this.timelineController;
      t4 = A.FramesBarChart$(t5);
      _this.framesBarChart = t4;
      t6.add$1(0, t4);
      t4 = A.CoreElement$(_s3_, _null, "section", _null, _null);
      t3 = t4.element;
      t3.setAttribute(_s6_, "");
      t3.setAttribute(_s8_, "");
      t4.flex$0(0);
      t3 = H.setRuntimeTypeInfo([], [K.FrameFlameChartItem]);
      t2 = H.interceptedTypeCheck(W._ElementFactoryProvider_createElement_tag(_s3_, _null), "$isElement");
      t3 = new K.FrameEventsChart(t5, t3, t2);
      t3.CoreElement$5$attributes$classes$html$text(_s3_, _null, "section-border flame-chart-container", _null, _null);
      t3.flex$0(0);
      t2.setAttribute(_s6_, "");
      t2.setAttribute(_s8_, "");
      $.$get$_dragScroll().enableDragScrolling$1(t3);
      t3._frame_events_chart$_initListeners$0();
      t3.attribute$2(_s6_1, true);
      _this.frameEventsChart = t3;
      t5 = F.EventDetails$(t5);
      t5.attribute$2(_s6_1, true);
      _this.eventDetails = t5;
      t4.add$1(0, H.setRuntimeTypeInfo([t3, t5], t7));
      screenDiv.add$1(0, H.setRuntimeTypeInfo([t1, t6, t4], t7));
      _this._timeline_screen$_initListeners$0();
      Y.maybeAddDebugMessage(framework, "timeline");
      return screenDiv;
    },
    _timeline_screen$_initListeners$0: function() {
      var t1 = this.timelineController,
        t2 = t1._selectedFrameController;
      new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new X.TimelineScreen__initListeners_closure(this));
      t1 = t1._loadOfflineDataController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(new X.TimelineScreen__initListeners_closure0(this));
    },
    _destroySplitter$0: function() {
      if (this.splitterConfigured) {
        J.destroy$0$x(this.splitter);
        this.splitterConfigured = false;
      }
    },
    entering$0: function() {
      this._timeline_screen$_updateListeningState$0();
      this._updateButtonStates$0();
    },
    exiting$0: function() {
      this._timeline_screen$_updateListeningState$0();
      this._updateButtonStates$0();
    },
    _exitOfflineMode$0: function() {
      var t1, _this = this;
      _this.clearTimeline$0();
      _this.eventDetails.reset$1$hide(0, true);
      t1 = _this.timelineController;
      t1.timelineData.clear$0(0);
      t1.offlineTimelineData = null;
      _this.framework.exitOfflineMode$0();
      _this._updateButtonStates$0();
      _this._destroySplitter$0();
    },
    _pauseRecording$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$_pauseRecording$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._manuallyPaused = true;
              $async$self.timelineController._timeline_controller$_paused = true;
              F.select("timeline", "pause", 0);
              $async$self._updateButtonStates$0();
              $async$goto = 2;
              return P._asyncAwait($async$self._timeline_screen$_updateListeningState$0(), $async$_pauseRecording$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_pauseRecording$0, $async$completer);
    },
    _resumeRecording$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$_resumeRecording$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._manuallyPaused = false;
              $async$self.timelineController._timeline_controller$_paused = false;
              F.select("timeline", "resume", 0);
              $async$self._updateButtonStates$0();
              $async$goto = 2;
              return P._asyncAwait($async$self._timeline_screen$_updateListeningState$0(), $async$_resumeRecording$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_resumeRecording$0, $async$completer);
    },
    _updateButtonStates$0: function() {
      var _this = this,
        _s8_ = "disabled",
        _s6_ = "hidden",
        t1 = _this.pauseButton;
      t1.attribute$2(_s8_, _this._manuallyPaused);
      t1.attribute$2(_s6_, $.offlineMode);
      t1 = _this.resumeButton;
      t1.attribute$2(_s8_, !_this._manuallyPaused);
      t1.attribute$2(_s6_, $.offlineMode);
      _this.clearButton.attribute$2(_s6_, $.offlineMode);
      _this.exportButton.attribute$2(_s6_, $.offlineMode);
      _this.exitOfflineModeButton.attribute$2(_s6_, !$.offlineMode);
    },
    _timeline_screen$_updateListeningState$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, shouldBeRunning, t1, t2;
      var $async$_timeline_screen$_updateListeningState$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              shouldBeRunning = !$async$self._manuallyPaused && !$.offlineMode && $async$self.get$isCurrentScreen();
              t1 = $async$self.timelineController;
              t2 = t1._timeline_controller$_paused;
              $async$goto = 2;
              return P._asyncAwait(t1.timelineService.updateListeningState$2$isRunning$shouldBeRunning(!t2, shouldBeRunning), $async$_timeline_screen$_updateListeningState$0);
            case 2:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_timeline_screen$_updateListeningState$0, $async$completer);
    },
    clearTimeline$0: function() {
      var t1, _this = this;
      C.JSArray_methods.set$length($.debugHandledTraceEvents, 0);
      $.$get$debugFrameTracking()._contents = "";
      t1 = _this.timelineController.timelineData;
      if (t1 != null)
        t1.clear$0(0);
      t1 = _this.framesBarChart.frameUIgraph;
      C.JSArray_methods.set$length(t1.dataIndexes, 0);
      C.JSArray_methods.set$length(t1.uiDurations, 0);
      C.JSArray_methods.set$length(t1.gpuDurations, 0);
      t1._frames.clear$0(0);
      t1._frameIndex = 0;
      t1._lastPlottedFrameIndex = -1;
      t1.currentSelection = null;
      t1.createPlot$1(t1.element);
      _this.frameEventsChart.attribute$2("hidden", true);
      _this.eventDetails.reset$1$hide(0, true);
      _this._destroySplitter$0();
    },
    _exportTimeline$0: function() {
      var now,
        t1 = this.timelineController.timelineData,
        encodedTimelineData = C.C_JsonCodec.encode$2$toEncodable(t1.get$json(t1), null);
      t1 = Date.now();
      now = new P.DateTime(t1, false);
      Y.downloadFile(encodedTimelineData, "timeline_" + ("" + H.Primitives_getYear(now) + "_" + H.Primitives_getMonth(now) + "_" + H.Primitives_getDay(now) + "-" + 1000 * t1) + ".json");
    },
    _maybeAddDebugButtons$0: function() {
    }
  };
  X.TimelineScreen__initListeners_closure.prototype = {
    call$1: function(_) {
      var t1, t2, t3, t4, t5;
      H.interceptedTypeCheck(_, "$isTimelineFrame");
      t1 = this.$this;
      if (!t1.splitterConfigured) {
        t2 = t1.frameEventsChart.element;
        t3 = t1.eventDetails.element;
        t4 = [P.num];
        t5 = H.setRuntimeTypeInfo([75, 25], t4);
        t1.splitter = A.flexSplit([t2, t3], 10, false, H.setRuntimeTypeInfo([50, 160], t4), t5);
        t1.splitterConfigured = true;
      }
      return;
    },
    $signature: 56
  };
  X.TimelineScreen__initListeners_closure0.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isOfflineTimelineData");
      t1 = this.$this.frameEventsChart;
      t1.attribute$2("hidden", true);
      return t1;
    },
    $signature: 217
  };
  N.TimelineService.prototype = {
    _initListeners$0: function() {
      var t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionAvailableController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(this.get$_timeline_service$_handleConnectionStart());
      if (H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service != null)
        this._timeline_service$_handleConnectionStart$1(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service);
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._connectionClosedController;
      new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$1(this.get$_timeline_service$_handleConnectionStop());
    },
    _timeline_service$_handleConnectionStart$1: function(service) {
      var t1, t2, t3;
      H.interceptedTypeCheck(service, "$isVmServiceWrapper");
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service;
      t2 = t1._vmService;
      t2.toString;
      t3 = S.Success;
      t1._trackFuture$1$2("setFlag", t2._call$1$2(0, "setFlag", P.LinkedHashMap__makeLiteral(["name", "profile_period", "value", "50"]), t3), t3);
      t3 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service._vmService._getEventController$1("Timeline");
      new P._BroadcastStream(t3, [H.getTypeArgumentByIndex(t3, 0)]).listen$1(new N.TimelineService__handleConnectionStart_closure(this));
    },
    _timeline_service$_handleConnectionStop$1: function($event) {
    },
    startTimeline$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this, t2, traceEvents, t3, t4, events, uiThreadId, gpuThreadId, _i, $event, t5, t6, t1, $async$temp1, $async$temp2, $async$temp3;
      var $async$startTimeline$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.timelineController;
              t1.timelineData = Q.TimelineData$(null, null, null, null, null);
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").serviceAvailable.future, $async$startTimeline$0);
            case 2:
              // returning from await.
              t2 = P.String;
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.setVMTimelineFlags$1(H.setRuntimeTypeInfo(["GC", "Dart", "Embedder"], [t2])), $async$startTimeline$0);
            case 3:
              // returning from await.
              $async$goto = 4;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.clearVMTimeline$0(), $async$startTimeline$0);
            case 4:
              // returning from await.
              $async$temp1 = J;
              $async$temp2 = H;
              $async$temp3 = J;
              $async$goto = 5;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.getVMTimeline$0(), $async$startTimeline$0);
            case 5:
              // returning from await.
              traceEvents = $async$temp1.cast$1$0$ax($async$temp2.listTypeCheck($async$temp3.$index$asx($async$result.json, "traceEvents")), [P.Map, P.String,,]);
              t3 = Q.TraceEvent;
              t4 = H.getRuntimeTypeArgument(traceEvents, "ListMixin", 0);
              t4 = new H.MappedListIterable(traceEvents, H.functionTypeCheck(new N.TimelineService_startTimeline_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).super$Iterable$where(0, H.functionTypeCheck(new N.TimelineService_startTimeline_closure0(), {func: 1, ret: P.bool, args: [t3]}));
              events = P.List_List$from(t4, true, H.getTypeArgumentByIndex(t4, 0));
              for (t4 = events.length, uiThreadId = null, gpuThreadId = null, _i = 0; _i < events.length; events.length === t4 || (0, H.throwConcurrentModificationError)(events), ++_i) {
                $event = events[_i];
                t5 = $event.args;
                t6 = J.getInterceptor$asx(t5);
                if (H.boolConversionCheck(H.boolTypeCheck(J.contains$1$asx(t6.$index(t5, "name"), "1.ui"))))
                  uiThreadId = $event.threadId;
                if (H.boolConversionCheck(H.boolTypeCheck(J.contains$1$asx(t6.$index(t5, "name"), "1.gpu"))))
                  gpuThreadId = $event.threadId;
              }
              t4 = [Q.TimelineEvent0];
              t1.timelineProtocol = new O.TimelineProtocol(uiThreadId, gpuThreadId, t1, P.LinkedHashMap_LinkedHashMap$_empty(t2, Q.TimelineFrame), H.setRuntimeTypeInfo([], t4), H.setRuntimeTypeInfo([null, null], t4), H.setRuntimeTypeInfo([null, null], [t3]), P.List_List$generate(2, new O.TimelineProtocol_closure(), true, [Y.HeapPriorityQueue, Q.TraceEventWrapper]));
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$startTimeline$0, $async$completer);
    },
    updateListeningState$2$isRunning$shouldBeRunning: function(isRunning, shouldBeRunning) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(-1),
        $async$self = this;
      var $async$updateListeningState$2$isRunning$shouldBeRunning = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").serviceAvailable.future, $async$updateListeningState$2$isRunning$shouldBeRunning);
            case 2:
              // returning from await.
              $async$goto = shouldBeRunning && isRunning && $async$self.timelineController.timelineData == null ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait($async$self.startTimeline$0(), $async$updateListeningState$2$isRunning$shouldBeRunning);
            case 6:
              // returning from await.
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = shouldBeRunning && !isRunning ? 7 : 9;
              break;
            case 7:
              // then
              $async$self.timelineController._timeline_controller$_paused = false;
              $async$goto = 10;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.setVMTimelineFlags$1(H.setRuntimeTypeInfo(["GC", "Dart", "Embedder"], [P.String])), $async$updateListeningState$2$isRunning$shouldBeRunning);
            case 10:
              // returning from await.
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = !shouldBeRunning && isRunning ? 11 : 12;
              break;
            case 11:
              // then
              $async$self.timelineController._timeline_controller$_paused = true;
              $async$goto = 13;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.setVMTimelineFlags$1(H.setRuntimeTypeInfo([], [P.String])), $async$updateListeningState$2$isRunning$shouldBeRunning);
            case 13:
              // returning from await.
            case 12:
              // join
            case 8:
              // join
            case 4:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$updateListeningState$2$isRunning$shouldBeRunning, $async$completer);
    },
    getCpuProfile$2$extentMicros$startMicros: function(extentMicros, startMicros) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(E.CpuProfileData),
        $async$returnValue, $async$temp1;
      var $async$getCpuProfile$2$extentMicros$startMicros = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = E;
              $async$goto = 3;
              return P._asyncAwait(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager").service.getCpuProfileTimeline$3(H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._isolateManager._selectedIsolate.id, startMicros, extentMicros), $async$getCpuProfile$2$extentMicros$startMicros);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.CpuProfileData_parse($async$result.json);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getCpuProfile$2$extentMicros$startMicros, $async$completer);
    }
  };
  N.TimelineService__handleConnectionStart_closure.prototype = {
    call$1: function($event) {
      var t1, t2, e, t3,
        events = J.cast$1$0$ax(H.listTypeCheck(J.$index$asx(H.interceptedTypeCheck($event, "$isEvent0").json, "timelineEvents")), [P.Map, P.String,,]);
      if (!$.offlineMode)
        t1 = !this.$this.timelineController._timeline_controller$_paused;
      else
        t1 = false;
      if (t1)
        for (t1 = new H.ListIterator(events, events.get$length(events), [H.getRuntimeTypeArgument(events, "ListMixin", 0)]), t2 = this.$this.timelineController; t1.moveNext$0();) {
          e = Q.TraceEvent$(t1.__internal$_current);
          t3 = t2.timelineProtocol;
          if (t3 != null)
            t3.processTraceEvent$1(e);
        }
    },
    $signature: 34
  };
  N.TimelineService_startTimeline_closure.prototype = {
    call$1: function($event) {
      return Q.TraceEvent$(H.assertSubtype($event, "$isMap", [P.String, null], "$asMap"));
    },
    $signature: 84
  };
  N.TimelineService_startTimeline_closure0.prototype = {
    call$1: function($event) {
      return H.interceptedTypeCheck($event, "$isTraceEvent").name === "thread_name";
    },
    $signature: 218
  };
  X.TreeNode0.prototype = {
    get$depth: function() {
      var t2, t3, _i, _this = this,
        t1 = _this._depth;
      if (t1 !== 0)
        return t1;
      for (t2 = _this.children, t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
        t1 = H.intTypeCheck(Math.max(t1, t2[_i].get$depth()));
        _this._depth = t1;
      }
      return _this._depth = t1 + 1;
    },
    get$root: function(_) {
      var root, root0, _this = this,
        t1 = _this._trees$_root;
      if (t1 != null)
        return t1;
      H.assertSubtypeOfRuntimeType(_this, H.getRuntimeTypeArgument(_this, "TreeNode0", 0));
      for (root = _this; root0 = root.parent, root0 != null; root = root0)
        ;
      _this.set$_trees$_root(root);
      return root;
    },
    get$level: function(_) {
      var current, level, _this = this,
        t1 = _this._level;
      if (t1 != null)
        return t1;
      H.assertSubtypeOfRuntimeType(_this, H.getRuntimeTypeArgument(_this, "TreeNode0", 0));
      for (current = _this, level = 0; current = current.parent, current != null;)
        ++level;
      return _this._level = level;
    },
    addChild$1: function(child) {
      var t2,
        t1 = H.getRuntimeTypeArgument(this, "TreeNode0", 0);
      H.assertSubtypeOfRuntimeType(child, t1);
      t2 = this.children;
      C.JSArray_methods.add$1(t2, child);
      J.set$parent$x(child, H.assertSubtypeOfRuntimeType(this, t1));
      child.index = t2.length - 1;
    },
    containsChildWithCondition$2$root: function(condition, root) {
      var t1 = H.getRuntimeTypeArgument(this, "TreeNode0", 0);
      H.functionTypeCheck(condition, {func: 1, ret: P.bool, args: [t1]});
      H.assertSubtypeOfRuntimeType(root, t1);
      if (root == null)
        root = H.assertSubtypeOfRuntimeType(this, t1);
      if (H.boolConversionCheck(condition.call$1(root)))
        return true;
      t1 = C.JSArray_methods.get$iterator(root.children);
      if (t1.moveNext$0())
        return this.containsChildWithCondition$2$root(condition, t1.get$current(t1));
      return false;
    },
    containsChildWithCondition$1: function(condition) {
      return this.containsChildWithCondition$2$root(condition, null);
    },
    set$parent: function(_, $parent) {
      this.parent = H.assertSubtypeOfRuntimeType($parent, H.getRuntimeTypeArgument(this, "TreeNode0", 0));
    },
    set$_trees$_root: function(_root) {
      this._trees$_root = H.assertSubtypeOfRuntimeType(_root, H.getRuntimeTypeArgument(this, "TreeNode0", 0));
    }
  };
  F.GtagEventDevTools.prototype = {};
  F.GtagExceptionDevTools.prototype = {};
  E.waitForDimensionsComputed_closure.prototype = {
    call$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.Null),
        $async$self = this, t1;
      var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($._analyticsComputed)
                F.screen($async$self.screenName);
              else {
                t1 = $._stillWaiting;
                $._stillWaiting = t1 + 1;
                if (t1 < 50)
                  E.waitForDimensionsComputed($async$self.screenName);
                else
                  P.print("Cancel waiting for dimensions.");
              }
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$call$0, $async$completer);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 17
  };
  N.ProgressElement.prototype = {
    get$value: function(_) {
      return 0;
    }
  };
  N.Spinner.prototype = {
    remove$0: function(_) {
      return J.remove$0$ax(this.element);
    }
  };
  N.SelectableList.prototype = {
    selectedItem$0: function() {
      var childrenElements, i, t1;
      if (this._selectedElement != null) {
        childrenElements = J.get$children$x(this.element);
        i = 0;
        while (true) {
          t1 = childrenElements.get$length(childrenElements);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.get$classes$x(childrenElements.$index(0, i)).contains$1(0, "selected"))
            return J.$index$asx(this.items, i);
          ++i;
        }
      }
      return;
    },
    setItems$3$scrollSelectionIntoView$selection: function(items, scrollSelectionIntoView, selection) {
      var t1, t2, renderer, _this = this;
      H.assertSubtype(items, "$isList", _this.$ti, "$asList");
      t1 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtypeOfRuntimeType(selection, t1);
      _this.set$items(0, items);
      t2 = _this._selectedElement;
      _this._selectedElement = null;
      if (selection == null)
        _this._hadClicked = false;
      renderer = _this.renderer;
      if (renderer == null)
        renderer = H.instantiate1(N.custom___defaultRenderer$closure(), t1);
      J.get$children$x(_this.element).clear$0(0);
      _this.add$1(0, J.map$1$1$ax(items, new N.SelectableList_setItems_closure(_this, renderer, selection, scrollSelectionIntoView), A.CoreElement).toList$0(0));
      if (t2 != null) {
        t1 = _this._selectedElement;
        if (t1 == null)
          _this._selectionController.add$1(0, null);
        else
          _this._custom$_select$2(t1, selection);
      }
      _this._itemsChangedController.add$1(0, null);
    },
    setItems$1: function(items) {
      return this.setItems$3$scrollSelectionIntoView$selection(items, false, null);
    },
    setItems$2$selection: function(items, selection) {
      return this.setItems$3$scrollSelectionIntoView$selection(items, false, selection);
    },
    setReplace$2: function(index, item) {
      var t2, renderer, element, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtypeOfRuntimeType(item, t1);
      t2 = _this._selectedElement;
      if (t2 != null)
        J.get$classes$x(t2.element).toggle$2(0, "selected", false);
      _this._selectedElement = null;
      renderer = _this.renderer;
      element = _this._hookup$3(renderer == null ? H.instantiate1(N.custom___defaultRenderer$closure(), t1) : renderer, item, item);
      _this.replace$2(0, index, element);
      _this._custom$_select$2(element, item);
      return element;
    },
    _hookup$3: function(renderer, item, selection) {
      var element, _this = this,
        t1 = H.getTypeArgumentByIndex(_this, 0);
      H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [t1]});
      H.assertSubtypeOfRuntimeType(item, t1);
      H.assertSubtypeOfRuntimeType(selection, t1);
      element = renderer.call$1(item);
      element.click$1(0, new N.SelectableList__hookup_closure(_this, element, item));
      element.dblclick$1(new N.SelectableList__hookup_closure0(_this, item));
      if (J.$eq$(selection, item))
        _this._custom$_select$2(element, item);
      return element;
    },
    _custom$_select$4$clear$clicked: function(element, item, clear, clicked) {
      var t1, _this = this,
        _s8_ = "selected";
      H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._selectedElement;
      if (t1 != null)
        J.get$classes$x(t1.element).toggle$2(0, _s8_, false);
      if (clear) {
        element = null;
        item = null;
      }
      _this._selectedElement = element;
      t1 = element == null;
      if (!t1)
        J.get$classes$x(element.element).toggle$2(0, _s8_, true);
      if (!t1)
        element.scrollIntoView$0(0);
      _this._selectionController.add$1(0, item);
      _this._hadClicked = clicked;
    },
    _custom$_select$2: function(element, item) {
      return this._custom$_select$4$clear$clicked(element, item, false, false);
    },
    set$items: function(_, items) {
      this.items = H.assertSubtype(items, "$isList", this.$ti, "$asList");
    },
    set$renderer: function(renderer) {
      this.renderer = H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]});
    }
  };
  N.SelectableList_setItems_closure.prototype = {
    call$1: function(item) {
      var t2, element, _this = this,
        t1 = _this.$this;
      H.assertSubtypeOfRuntimeType(item, H.getTypeArgumentByIndex(t1, 0));
      t2 = _this.selection;
      element = t1._hookup$3(_this.renderer, item, t2);
      if (_this.scrollSelectionIntoView && J.$eq$(t2, item))
        t1._selectedElement = element;
      return element;
    },
    $signature: function() {
      return {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this.$this, 0)]};
    }
  };
  N.SelectableList__hookup_closure.prototype = {
    call$0: function() {
      this.$this._custom$_select$4$clear$clicked(this.element, this.item, false, true);
    },
    $signature: 0
  };
  N.SelectableList__hookup_closure0.prototype = {
    call$0: function() {
      this.$this._doubleClickController.add$1(0, this.item);
    },
    $signature: 0
  };
  N.ChildProvider.prototype = {};
  N.SelectableTreeNodeItem.prototype = {};
  N.SelectableTree.prototype = {
    setItems$1: function(items) {
      var t1, _this = this;
      H.assertSubtype(items, "$isList", _this.$ti, "$asList");
      _this.set$items(0, items);
      t1 = _this._selectedItem;
      _this.set$_selectedItem(null);
      J.get$children$x(_this.element).clear$0(0);
      _this.set$treeNodes(_this._buildTree$3(items, _this, null));
      if (t1 != null && _this._selectedItem == null)
        _this._selectionController.add$1(0, null);
    },
    _addItemToTree$2: function(container, item) {
      var renderer, t3, obj, element, toggle, childContainer, _this = this, _null = null, t1 = {},
        t2 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtypeOfRuntimeType(item, t2);
      renderer = _this.renderer;
      t3 = (renderer == null ? H.instantiate1(N.custom___defaultRenderer$closure(), t2) : renderer).call$1(item);
      t2 = [N.SelectableTreeNodeItem, t2];
      obj = new X.TreeNode(new N.SelectableTreeNodeItem(t3, item, _this.$ti), H.setRuntimeTypeInfo([], [[X.TreeNode, t2]]), [t2]);
      t3.click$1(0, new N.SelectableTree__addItemToTree_closure(_this, obj));
      element = A.CoreElement$("div", _null, _null, _null, _null);
      element.add$1(0, t3);
      t2 = _this.childProvider.hasChildren$1(item);
      t3 = t3.element;
      if (t2) {
        toggle = N.TreeToggle$(false, false);
        J.get$children$x(t3).insert$2(0, 0, toggle.element);
        t1.hasPopulated = false;
        childContainer = A.ul("tree-list");
        element.add$1(0, childContainer);
        childContainer.attribute$2("hidden", true);
        obj.set$expand(0, new N.SelectableTree__addItemToTree_closure0(toggle));
        obj.set$collapse(0, new N.SelectableTree__addItemToTree_closure1(toggle));
        t2 = toggle._openController;
        new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]).listen$1(new N.SelectableTree__addItemToTree_closure2(t1, _this, obj, childContainer, item));
      } else
        J.get$children$x(t3).insert$2(0, 0, N.TreeToggle$(true, false).element);
      container.add$1(0, element);
      return obj;
    },
    _buildTree$3: function(results, container, $parent) {
      var t1, children, _this = this;
      H.assertSubtype(results, "$isList", _this.$ti, "$asList");
      t1 = H.getTypeArgumentByIndex(_this, 0);
      H.assertSubtype($parent, "$isTreeNode", [[N.SelectableTreeNodeItem, t1]], "$asTreeNode");
      children = J.map$1$1$ax(results, new N.SelectableTree__buildTree_closure(_this, container), [X.TreeNode, [N.SelectableTreeNodeItem, t1]]).toList$0(0);
      _this.connectNodes$3($parent, children, new N.SelectableTree__buildTree_closure0(_this));
      return children;
    },
    select$2$clear: function(_, node, clear) {
      var t1, _this = this, _null = null,
        _s8_ = "selected";
      H.assertSubtype(node, "$isTreeNode", [[N.SelectableTreeNodeItem, H.getTypeArgumentByIndex(_this, 0)]], "$asTreeNode");
      t1 = _this._selectedItem;
      t1 = t1 == null ? _null : t1.data;
      t1 = t1 == null ? _null : t1.element;
      if (t1 != null)
        J.get$classes$x(t1.element).toggle$2(0, _s8_, false);
      if (clear)
        node = _null;
      _this.set$_selectedItem(node);
      t1 = _this._selectedItem;
      t1 = t1 == null ? _null : t1.data;
      t1 = t1 == null ? _null : t1.element;
      if (t1 != null)
        J.get$classes$x(t1.element).toggle$2(0, _s8_, true);
      t1 = _this._selectedItem;
      t1 = t1 == null ? _null : t1.data;
      t1 = t1 == null ? _null : t1.element;
      if (t1 != null)
        t1.scrollIntoView$0(0);
      t1 = node == null ? _null : node.data;
      t1 = t1 == null ? _null : t1.item;
      _this._selectionController.add$1(0, t1);
    },
    select$1: function($receiver, node) {
      return this.select$2$clear($receiver, node, false);
    },
    set$items: function(_, items) {
      this.items = H.assertSubtype(items, "$isList", this.$ti, "$asList");
    },
    set$treeNodes: function(treeNodes) {
      this.treeNodes = H.assertSubtype(treeNodes, "$isList", [[X.TreeNode, [N.SelectableTreeNodeItem, H.getTypeArgumentByIndex(this, 0)]]], "$asList");
    },
    set$renderer: function(renderer) {
      this.renderer = H.functionTypeCheck(renderer, {func: 1, ret: A.CoreElement, args: [H.getTypeArgumentByIndex(this, 0)]});
    },
    set$childProvider: function(childProvider) {
      this.childProvider = H.assertSubtype(childProvider, "$isChildProvider", this.$ti, "$asChildProvider");
    },
    set$_selectedItem: function(_selectedItem) {
      this._selectedItem = H.assertSubtype(_selectedItem, "$isTreeNode", [[N.SelectableTreeNodeItem, H.getTypeArgumentByIndex(this, 0)]], "$asTreeNode");
    },
    $asTreeNavigator: function($T) {
      return [[N.SelectableTreeNodeItem, $T]];
    },
    $asTree: function($T) {
      return [[N.SelectableTreeNodeItem, $T]];
    }
  };
  N.SelectableTree__addItemToTree_closure.prototype = {
    call$0: function() {
      var t1 = this.obj;
      this.$this.select$2$clear(0, t1, J.get$classes$x(t1.data.element.element).contains$1(0, "selected"));
    },
    $signature: 0
  };
  N.SelectableTree__addItemToTree_closure0.prototype = {
    call$0: function() {
      return this.toggle.toggle$1$onlyExpand(0, true);
    },
    $signature: 1
  };
  N.SelectableTree__addItemToTree_closure1.prototype = {
    call$0: function() {
      return this.toggle.toggle$1$onlyCollapse(0, true);
    },
    $signature: 1
  };
  N.SelectableTree__addItemToTree_closure2.prototype = {
    call$1: function($open) {
      var t1, t2, t3, _this = this;
      H.boolTypeCheck($open);
      t1 = _this.obj;
      t1.isExpanded = $open;
      t2 = _this.childContainer;
      t2.attribute$2("hidden", !H.boolConversionCheck($open));
      t3 = _this._box_0;
      if (!t3.hasPopulated) {
        t3.hasPopulated = true;
        t3 = _this.$this;
        t3.childProvider.getChildren$1(_this.item).then$1$1(new N.SelectableTree__addItemToTree__closure(t3, t2, t1), null).catchError$1(new N.SelectableTree__addItemToTree__closure0());
      }
    },
    $signature: 9
  };
  N.SelectableTree__addItemToTree__closure.prototype = {
    call$1: function(results) {
      var t1 = this.$this;
      t1._buildTree$3(H.assertSubtype(results, "$isList", [H.getTypeArgumentByIndex(t1, 0)], "$asList"), this.childContainer, this.obj);
    },
    $signature: function() {
      return {func: 1, ret: P.Null, args: [[P.List, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  N.SelectableTree__addItemToTree__closure0.prototype = {
    call$1: function(e) {
    },
    $signature: 2
  };
  N.SelectableTree__buildTree_closure.prototype = {
    call$1: function(result) {
      var t1 = this.$this;
      return t1._addItemToTree$2(this.container, H.assertSubtypeOfRuntimeType(result, H.getTypeArgumentByIndex(t1, 0)));
    },
    $signature: function() {
      var t1 = H.getTypeArgumentByIndex(this.$this, 0);
      return {func: 1, ret: [X.TreeNode, [N.SelectableTreeNodeItem, t1]], args: [t1]};
    }
  };
  N.SelectableTree__buildTree_closure0.prototype = {
    call$1: function(node) {
      var t1 = this.$this;
      H.assertSubtype(node, "$isSelectableTreeNodeItem", [H.getTypeArgumentByIndex(t1, 0)], "$asSelectableTreeNodeItem");
      return t1.childProvider.hasChildren$1(node.item);
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [[N.SelectableTreeNodeItem, H.getTypeArgumentByIndex(this.$this, 0)]]};
    }
  };
  N.TreeToggle.prototype = {
    toggle$2$onlyCollapse$onlyExpand: function(_, onlyCollapse, onlyExpand) {
      var t1, t2, t3, _this = this;
      if (!(onlyExpand && _this._isOpen))
        t1 = onlyCollapse && !_this._isOpen;
      else
        t1 = true;
      if (t1)
        return;
      t1 = !_this._isOpen;
      _this._isOpen = t1;
      _this._openController.add$1(0, t1);
      t1 = _this._isOpen;
      t2 = _this.element;
      t3 = J.getInterceptor$x(t2);
      t3.get$classes(t2).toggle$2(0, "octicon-triangle-right", !t1);
      t1 = _this._isOpen;
      t3.get$classes(t2).toggle$2(0, "octicon-triangle-down", t1);
    },
    toggle$0: function($receiver) {
      return this.toggle$2$onlyCollapse$onlyExpand($receiver, false, false);
    },
    toggle$1$onlyCollapse: function($receiver, onlyCollapse) {
      return this.toggle$2$onlyCollapse$onlyExpand($receiver, onlyCollapse, false);
    },
    toggle$1$onlyExpand: function($receiver, onlyExpand) {
      return this.toggle$2$onlyCollapse$onlyExpand($receiver, false, onlyExpand);
    }
  };
  N.ActionButton.prototype = {
    get$element: function() {
      return this._custom$_element;
    },
    $isCoreElementView: 1,
    get$id: function(receiver) {
      return this.id;
    }
  };
  N._SelectableTree_CoreElement_Tree.prototype = {};
  N._SelectableTree_CoreElement_Tree_TreeNavigator.prototype = {};
  N._SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator.prototype = {};
  F.DragScroll.prototype = {
    enableDragScrolling$1: function(element) {
      var t2, t3, t1 = {},
        dragged = element.element;
      t1.lastY = t1.lastX = null;
      t1.clicked = false;
      t2 = J.get$onMouseDown$x(dragged);
      t3 = H.getTypeArgumentByIndex(t2, 0);
      W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new F.DragScroll_enableDragScrolling_closure(t1, this), {func: 1, ret: -1, args: [t3]}), false, t3);
      t3 = W.MouseEvent;
      t2 = {func: 1, ret: -1, args: [t3]};
      W._EventStreamSubscription$(window, "mouseup", H.functionTypeCheck(new F.DragScroll_enableDragScrolling_closure0(t1), t2), false, t3);
      W._EventStreamSubscription$(window, "mousemove", H.functionTypeCheck(new F.DragScroll_enableDragScrolling_closure1(t1, this, dragged), t2), false, t3);
    },
    set$_onVerticalScroll: function(_onVerticalScroll) {
      this._onVerticalScroll = H.functionTypeCheck(_onVerticalScroll, {func: 1, ret: -1});
    }
  };
  F.DragScroll_enableDragScrolling_closure.prototype = {
    call$1: function($event) {
      var t1, t2;
      H.interceptedTypeCheck($event, "$isMouseEvent");
      t1 = this._box_0;
      t1.clicked = true;
      this.$this.wasDragged = false;
      t2 = $event.clientX;
      $event.clientY;
      t1.lastX = t2;
      t1.lastY = $event.clientY;
      $event.preventDefault();
    },
    $signature: 3
  };
  F.DragScroll_enableDragScrolling_closure0.prototype = {
    call$1: function($event) {
      H.interceptedTypeCheck($event, "$isMouseEvent");
      return this._box_0.clicked = false;
    },
    $signature: 41
  };
  F.DragScroll_enableDragScrolling_closure1.prototype = {
    call$1: function($event) {
      var t1, t2, t3, t4, t5, t6;
      H.interceptedTypeCheck($event, "$isMouseEvent");
      t1 = this._box_0;
      if (t1.clicked) {
        t2 = $event.clientX;
        t3 = $event.clientY;
        t4 = t1.lastX;
        if (typeof t4 !== "number")
          return t4.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t5 = t1.lastY;
        if (typeof t5 !== "number")
          return t5.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t6 = this.dragged;
        t6.scrollLeft = C.JSInt_methods.round$0(C.JSNumber_methods.round$0(t6.scrollLeft) + C.JSNumber_methods.round$0(t4 - t2));
        t4 = C.JSNumber_methods.round$0(t6.scrollTop);
        t5 = C.JSNumber_methods.round$0(t5 - t3);
        t6.scrollTop = C.JSInt_methods.round$0(t4 + t5);
        t4 = this.$this;
        t6 = t4._onVerticalScroll;
        if (t6 != null && t5 !== 0)
          t6.call$0();
        t1.lastX = t2;
        t1.lastY = t3;
        t4.wasDragged = true;
      }
    },
    $signature: 3
  };
  A.CoreElement.prototype = {
    CoreElement$5$attributes$classes$html$text: function(tag, attributes, classes, html, text) {
      var _this = this;
      if (text != null)
        _this.element.textContent = text;
      if (html != null)
        J.set$innerHtml$x(_this.element, html);
      if (classes != null)
        J.get$classes$x(_this.element).addAll$1(0, H.setRuntimeTypeInfo(classes.split(" "), [P.String]));
      if (attributes != null)
        C.JSArray_methods.forEach$1(H.setRuntimeTypeInfo(attributes.split(" "), [P.String]), _this.get$attribute());
    },
    get$id: function(_) {
      return this.element.getAttribute("id");
    },
    attribute$2: function($name, value) {
      var t1;
      H.stringTypeCheck($name);
      if (value == null)
        value = !H.boolConversionCheck(this.element.hasAttribute($name));
      t1 = this.element;
      if (value)
        t1.setAttribute($name, "");
      else {
        t1.toString;
        if (typeof $name === "string")
          t1.removeAttribute($name);
      }
    },
    attribute$1: function($name) {
      return this.attribute$2($name, null);
    },
    clazz$2$removeOthers: function(_class, removeOthers) {
      H.stringTypeCheck(_class);
      if (J.contains$1$asx(_class, " "))
        throw H.wrapException(P.ArgumentError$("spaces not allowed in class names"));
      if (removeOthers)
        J.get$classes$x(this.element).clear$0(0);
      J.get$classes$x(this.element).add$1(0, _class);
    },
    clazz$1: function(_class) {
      return this.clazz$2$removeOthers(_class, false);
    },
    add$1: function(_, child) {
      var _this = this,
        t1 = J.getInterceptor$(child);
      if (!!t1.$isIterable)
        return t1.map$1$1(child, new A.CoreElement_add_closure(_this), null).toList$0(0);
      else if (!!t1.$isCoreElement)
        J.get$children$x(_this.element).add$1(0, child.element);
      else if (!!t1.$isCoreElementView)
        J.get$children$x(_this.element).add$1(0, child.get$element().element);
      else if (!!t1.$isElement)
        J.get$children$x(_this.element).add$1(0, child);
      else
        throw H.wrapException(P.ArgumentError$("argument type " + t1.get$runtimeType(child).toString$0(0) + " not supported"));
      return child;
    },
    replace$2: function(_, childIndex, child) {
      var _this = this, t1 = {},
        t2 = J.getInterceptor$(child);
      if (!!t2.$isIterable) {
        t1.nextIndex = childIndex;
        t2.map$1$1(child, new A.CoreElement_replace_closure(t1, _this), null);
      } else if (!!t2.$isCoreElement)
        J.get$children$x(_this.element).$indexSet(0, childIndex, child.element);
      else if (!!t2.$isCoreElementView)
        J.get$children$x(_this.element).$indexSet(0, childIndex, child.get$element().element);
      else if (!!t2.$isElement)
        J.get$children$x(_this.element).$indexSet(0, childIndex, child);
      else
        throw H.wrapException(P.ArgumentError$("argument type " + t2.get$runtimeType(child).toString$0(0) + " not supported"));
    },
    flex$0: function(_) {
      this.attribute$2("flex", true);
    },
    get$onClick: function(_) {
      var t1 = J.get$onClick$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new A.CoreElement_onClick_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    get$onFocus: function(_) {
      var t1 = J.get$onFocus$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new A.CoreElement_onFocus_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    get$onBlur: function(_) {
      var t1 = J.get$onBlur$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new A.CoreElement_onBlur_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    get$onMouseOver: function(_) {
      var t1 = J.get$onMouseOver$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new A.CoreElement_onMouseOver_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    get$onMouseLeave: function(_) {
      var t1 = J.get$onMouseLeave$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new A.CoreElement_onMouseLeave_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    click$1: function(_, handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onClick(this).listen$1(new A.CoreElement_click_closure(null, handle));
    },
    dblclick$1: function(handle) {
      var t1, t2;
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      t1 = J.get$onDoubleClick$x(this.element);
      t2 = H.getTypeArgumentByIndex(t1, 0);
      return W._EventStreamSubscription$(t1._html$_target, t1._eventType, H.functionTypeCheck(new A.CoreElement_dblclick_closure(handle), {func: 1, ret: -1, args: [t2]}), false, t2);
    },
    focus$1: function(_, handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onFocus(this).listen$1(new A.CoreElement_focus_closure(handle));
    },
    blur$1: function(_, handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onBlur(this).listen$1(new A.CoreElement_blur_closure(handle));
    },
    over$1: function(handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onMouseOver(this).listen$1(new A.CoreElement_over_closure(handle));
    },
    leave$1: function(handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onMouseLeave(this).listen$1(new A.CoreElement_leave_closure(handle));
    },
    scrollIntoView$2$bottom$top: function(_, bottom, $top) {
      var t1 = this.element;
      if ($top)
        J.scrollIntoView$1$x(t1, C.ScrollAlignment_TOP);
      else
        J.scrollIntoView$0$x(t1);
    },
    scrollIntoView$0: function($receiver) {
      return this.scrollIntoView$2$bottom$top($receiver, false, false);
    },
    dispose$0: function() {
      var exception,
        t1 = this.element,
        t2 = t1.parentElement;
      if (t2 == null)
        return;
      if (J.get$children$x(t2).contains$1(0, t1))
        try {
          J.get$children$x(t1.parentElement).remove$1(0, t1);
        } catch (exception) {
          H.unwrapException(exception);
        }
    },
    toString$0: function(_) {
      return J.toString$0$(this.element);
    }
  };
  A.CoreElement_add_closure.prototype = {
    call$1: function(c) {
      return this.$this.add$1(0, c);
    },
    $signature: 4
  };
  A.CoreElement_replace_closure.prototype = {
    call$1: function(c) {
      var t1 = this._box_0,
        t2 = t1.nextIndex;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.nextIndex = t2 + 1;
      this.$this.replace$2(0, t2, c);
    },
    $signature: 2
  };
  A.CoreElement_onClick_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isMouseEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 41
  };
  A.CoreElement_onFocus_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 58
  };
  A.CoreElement_onBlur_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 58
  };
  A.CoreElement_onMouseOver_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isMouseEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 41
  };
  A.CoreElement_onMouseLeave_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isMouseEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 41
  };
  A.CoreElement_click_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isMouseEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 3
  };
  A.CoreElement_dblclick_closure.prototype = {
    call$1: function($event) {
      $event.stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  A.CoreElement_focus_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  A.CoreElement_blur_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  A.CoreElement_over_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  A.CoreElement_leave_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  A.TrustedHtmlTreeSanitizer.prototype = {
    sanitizeTree$1: function(node) {
    },
    $isNodeTreeSanitizer: 1
  };
  S.Color.prototype = {
    get$alpha: function(_) {
      return (4278190080 & this.value) >>> 24;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, H.getRuntimeType(this)))
        return false;
      H.interceptedTypeCheck(other, "$isColor");
      return this.value === other.get$value(other);
    },
    get$hashCode: function(_) {
      return C.JSInt_methods.get$hashCode(this.value);
    },
    toString$0: function(_) {
      return H.throwExpression("Warning: do not add colors directly to HTML");
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  S.MaterialColor.prototype = {
    get$shade400: function() {
      return this._swatch.$index(0, H.assertSubtypeOfRuntimeType(400, H.getRuntimeTypeArgument(this, "ColorSwatch", 0)));
    },
    get$shade500: function() {
      return this._swatch.$index(0, H.assertSubtypeOfRuntimeType(500, H.getRuntimeTypeArgument(this, "ColorSwatch", 0)));
    },
    $asColorSwatch: function() {
      return [P.int];
    }
  };
  S.MaterialAccentColor.prototype = {
    $asColorSwatch: function() {
      return [P.int];
    }
  };
  S.ColorSwatch.prototype = {
    $index: function(_, index) {
      return this._swatch.$index(0, H.assertSubtypeOfRuntimeType(index, H.getRuntimeTypeArgument(this, "ColorSwatch", 0)));
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, H.getRuntimeType(_this)))
        return false;
      H.assertSubtype(other, "$isColorSwatch", [H.getRuntimeTypeArgument(_this, "ColorSwatch", 0)], "$asColorSwatch");
      return _this.super$Color$$eq(0, other) && _this._swatch === other._swatch;
    },
    get$hashCode: function(_) {
      return S.hashValues(H.getRuntimeType(this), this.value, this._swatch, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      return H.getRuntimeType(this).toString$0(0) + "(primary value: " + H.S(this.super$Color$toString(0)) + ")";
    }
  };
  S.OffsetBase.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof S.OffsetBase))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t1 = H.getRuntimeType(this).toString$0(0) + "(",
        t2 = this._dx;
      t1 = t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  S.Offset.prototype = {
    get$dx: function(_) {
      return this._dx;
    },
    get$dy: function(_) {
      return this._dy;
    },
    $sub: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new S.Offset(t1 - t2, t3 - t4);
    },
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new S.Offset(t1 + t2, t3 + t4);
    },
    $div: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$div();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$div();
      return new S.Offset(t1 / operand, t2 / operand);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof S.Offset))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Offset(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  S.Size.prototype = {
    $add: function(_, other) {
      var t1, t2, t3, t4;
      H.interceptedTypeCheck(other, "$isOffset");
      t1 = this._dx;
      t2 = other._dx;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = this._dy;
      t4 = other._dy;
      if (typeof t3 !== "number")
        return t3.$add();
      if (typeof t4 !== "number")
        return H.iae(t4);
      return new S.Size(t1 + t2, t3 + t4);
    },
    $div: function(_, operand) {
      var t2,
        t1 = this._dx;
      if (typeof t1 !== "number")
        return t1.$div();
      t2 = this._dy;
      if (typeof t2 !== "number")
        return t2.$div();
      return new S.Size(t1 / operand, t2 / operand);
    },
    contains$1: function(_, offset) {
      H.interceptedTypeCheck(offset, "$isOffset");
      return offset.get$dx(offset).$ge(0, 0) && offset.get$dx(offset).$lt(0, this._dx) && offset.get$dy(offset).$ge(0, 0) && offset.get$dy(offset).$lt(0, this._dy);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof S.Size))
        return false;
      return this._dx == other._dx && this._dy == other._dy;
    },
    get$hashCode: function(_) {
      return S.hashValues(this._dx, this._dy, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd, C.C__HashEnd);
    },
    toString$0: function(_) {
      var t2,
        t1 = this._dx;
      t1 = "Size(" + H.S(t1 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t1, 1)) + ", ";
      t2 = this._dy;
      return t1 + H.S(t2 == null ? null : C.JSNumber_methods.toStringAsFixed$1(t2, 1)) + ")";
    }
  };
  S.Rect.prototype = {
    inflate$1: function(delta) {
      var t1 = this._dart_ui$_value;
      return S.Rect$fromLTRB(t1[0] - delta, t1[1] - delta, t1[2] + delta, t1[3] + delta);
    },
    overlaps$1: function(other) {
      var t1 = this._dart_ui$_value,
        t2 = t1[2],
        t3 = other._dart_ui$_value;
      if (t2 <= t3[0] || t3[2] <= t1[0])
        return false;
      if (t1[3] <= t3[1] || t3[3] <= t1[1])
        return false;
      return true;
    },
    contains$1: function(_, offset) {
      var t1, t2, t3;
      H.interceptedTypeCheck(offset, "$isOffset");
      t1 = offset._dx;
      t2 = this._dart_ui$_value;
      t3 = t2[0];
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 >= t3)
        if (t1 < t2[2]) {
          t1 = offset._dy;
          t3 = t2[1];
          if (typeof t1 !== "number")
            return t1.$ge();
          t1 = t1 >= t3 && t1 < t2[3];
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    $eq: function(_, other) {
      var t1, t2, i;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!H.getRuntimeType(this).$eq(0, J.get$runtimeType$(other)))
        return false;
      for (t1 = this._dart_ui$_value, t2 = H.interceptedTypeCheck(other, "$isRect")._dart_ui$_value, i = 0; i < 4; ++i)
        if (t1[i] !== t2[i])
          return false;
      return true;
    },
    get$hashCode: function(_) {
      return S.hashList(this._dart_ui$_value);
    },
    toString$0: function(_) {
      var t1 = this._dart_ui$_value;
      return "Rect.fromLTRB(" + C.JSNumber_methods.toStringAsFixed$1(t1[0], 1) + ", " + C.JSNumber_methods.toStringAsFixed$1(t1[1], 1) + ", " + C.JSNumber_methods.toStringAsFixed$1(t1[2], 1) + ", " + C.JSNumber_methods.toStringAsFixed$1(t1[3], 1) + ")";
    }
  };
  S._HashEnd.prototype = {};
  S.FontStyle.prototype = {
    toString$0: function(_) {
      return this._dart_ui$_name;
    }
  };
  S.FontWeight.prototype = {
    toString$0: function(_) {
      return C.Map_yXAeS.$index(0, this.index);
    }
  };
  U.DiagnosticLevel.prototype = {
    toString$0: function(_) {
      return this._fake_flutter$_name;
    }
  };
  U.DiagnosticsTreeStyle.prototype = {
    toString$0: function(_) {
      return this._fake_flutter$_name;
    }
  };
  U.TextTreeConfiguration.prototype = {};
  U._PrefixedStringBuilder.prototype = {
    get$_currentLineLength: function() {
      var _this = this;
      return (_this._hasMultipleLines ? _this.prefixOtherLines : _this.prefixLineOne).length + _this._lineIndex;
    },
    write$1: function(_, s) {
      var t2, t3, lineTerminated, parts, i, _this = this,
        t1 = s.length;
      if (t1 === 0)
        return;
      if (s === "\n") {
        t1 = _this._fake_flutter$_buffer;
        t2 = t1._contents;
        if (t2.length === 0)
          t2 = t1._contents += C.JSString_methods.trimRight$0(_this.prefixLineOne);
        else if (_this._lineIndex === 0) {
          t2 = t1._contents += J.trimRight$0$s(_this.prefixOtherLines);
          _this._hasMultipleLines = true;
        }
        t1._contents = t2 + "\n";
        _this._lineIndex = 0;
        return;
      }
      t2 = _this._fake_flutter$_buffer;
      t3 = t2._contents;
      if (t3.length === 0)
        t2._contents = t3 + _this.prefixLineOne;
      else if (_this._lineIndex === 0) {
        t2._contents += H.S(_this.prefixOtherLines);
        _this._hasMultipleLines = true;
      }
      if (J.getInterceptor$s(s).endsWith$1(s, "\n")) {
        s = C.JSString_methods.substring$2(s, 0, t1 - 1);
        lineTerminated = true;
      } else
        lineTerminated = false;
      parts = s.split("\n");
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      t1 = t2._contents += H.S(parts[0]);
      for (i = 1; i < parts.length; ++i) {
        t2._contents = t1 + "\n";
        t2._contents += H.S(_this.prefixOtherLines);
        if (i >= parts.length)
          return H.ioore(parts, i);
        t1 = t2._contents += H.S(parts[i]);
      }
      if (lineTerminated)
        t2._contents = t1 + "\n";
      if (lineTerminated)
        _this._lineIndex = 0;
      else
        _this._lineIndex = _this._lineIndex + J.get$length$asx(C.JSArray_methods.get$last(parts));
    },
    writeRaw$1: function(text) {
      var lastLineBreakIndex,
        t1 = text.length;
      if (t1 === 0)
        return;
      this._fake_flutter$_buffer._contents += text;
      lastLineBreakIndex = C.JSString_methods.lastIndexOf$1(text, "\n");
      if (lastLineBreakIndex !== -1)
        this._lineIndex = t1 - lastLineBreakIndex - 1;
      else
        this._lineIndex += t1;
    },
    writeRawLine$1: function(line) {
      var t1, t2;
      if (line.length === 0)
        return;
      t1 = this._fake_flutter$_buffer;
      t2 = t1._contents += line;
      if (!C.JSString_methods.endsWith$1(line, "\n"))
        t1._contents = t2 + "\n";
      this._lineIndex = 0;
    },
    writeStretched$2: function(text, lineLength) {
      var targetLength, t1, t2, lastChar, _this = this;
      _this.write$1(0, text);
      targetLength = lineLength - _this.get$_currentLineLength();
      if (targetLength > 0) {
        t1 = text.length;
        t2 = t1 - 1;
        if (t2 < 0)
          return H.ioore(text, t2);
        lastChar = text[t2];
        if (_this.get$_currentLineLength() < targetLength)
          _this.writeRaw$1(C.JSString_methods.$mul(lastChar, targetLength));
      }
    },
    toString$0: function(_) {
      var t1 = this._fake_flutter$_buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  U._NoDefaultValue.prototype = {};
  U.TextRenderer_renderToString_visitor.prototype = {
    call$1: function(node) {
      var t1, t2, t3, t4, t5, t6, _i, child, t7, _this = this;
      for (t1 = node.getChildren$0(), t2 = t1.length, t3 = _this._box_0, t4 = _this.maxLines, t5 = _this.descendants, t6 = _this.maxDepth, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        t7 = t3.lines;
        if (t7 < t4) {
          ++t3.depth;
          C.JSArray_methods.add$1(t5, H.S(t3.prefixOtherLines) + C.JSString_methods.$mul("  ", t3.depth) + child.toString$0(0));
          if (t3.depth < t6)
            _this.call$1(child);
          --t3.depth;
        } else if (t7 === t4)
          C.JSArray_methods.add$1(t5, H.S(t3.prefixOtherLines) + "  ...(descendants list truncated after " + t3.lines + " lines)");
        ++t3.lines;
      }
    },
    $signature: 225
  };
  U.TextRenderer_renderToString_closure.prototype = {
    call$1: function(n) {
      H.interceptedTypeCheck(n, "$isDiagnosticsNode");
      return n.get$level(n).index >= this.minLevel.index;
    },
    $signature: 226
  };
  U.DiagnosticsNode.prototype = {
    get$level: function(_) {
      return C.DiagnosticLevel_3;
    },
    get$emptyBodyDescription: function() {
      return;
    },
    get$allowWrap: function() {
      return true;
    },
    toString$2$minLevel$parentConfiguration: function(_, minLevel, parentConfiguration) {
      var description, t1, _this = this;
      if (_this.get$style(_this) === C.DiagnosticsTreeStyle_7)
        return _this.toStringDeep$2$minLevel$parentConfiguration(minLevel, parentConfiguration);
      description = _this.toDescription$1$parentConfiguration(parentConfiguration);
      t1 = _this.name;
      if (t1 == null || t1.length === 0 || false)
        return description;
      if (J.contains$1$asx(description, "\n")) {
        t1 = H.S(t1);
        t1 = t1 + ":\n" + description;
      } else {
        t1 = H.S(t1);
        t1 = t1 + ": " + description;
      }
      return t1;
    },
    toString$0: function($receiver) {
      return this.toString$2$minLevel$parentConfiguration($receiver, C.DiagnosticLevel_3, null);
    },
    toString$1$minLevel: function($receiver, minLevel) {
      return this.toString$2$minLevel$parentConfiguration($receiver, minLevel, null);
    },
    get$textTreeConfiguration: function() {
      switch (this.get$style(this)) {
        case C.DiagnosticsTreeStyle_2:
          return $.$get$denseTextConfiguration();
        case C.DiagnosticsTreeStyle_0:
          return $.$get$sparseTextConfiguration();
        case C.DiagnosticsTreeStyle_1:
          return $.$get$dashedTextConfiguration();
        case C.DiagnosticsTreeStyle_5:
          return $.$get$whitespaceTextConfiguration();
        case C.DiagnosticsTreeStyle_3:
          return $.$get$transitionTextConfiguration();
        case C.DiagnosticsTreeStyle_7:
          return $.$get$singleLineTextConfiguration();
        case C.DiagnosticsTreeStyle_8:
          return $.$get$headerLineTextConfiguration();
        case C.DiagnosticsTreeStyle_9:
          return $.$get$singleLineTextConfigurationIndented();
        case C.DiagnosticsTreeStyle_10:
          return $.$get$shallowTextConfiguration();
        case C.DiagnosticsTreeStyle_4:
          return $.$get$errorTextConfiguration();
        case C.DiagnosticsTreeStyle_11:
          return $.$get$whitespaceTextConfiguration();
        case C.DiagnosticsTreeStyle_6:
          return $.$get$flatTextConfiguration();
      }
      return;
    },
    toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines: function(minLevel, parentConfiguration, prefixLineOne, prefixOtherLines) {
      return U.TextRenderer_renderToString(this, minLevel, parentConfiguration, prefixLineOne, prefixOtherLines, 100, 65);
    },
    toStringDeep$2$minLevel$parentConfiguration: function(minLevel, parentConfiguration) {
      return this.toStringDeep$4$minLevel$parentConfiguration$prefixLineOne$prefixOtherLines(minLevel, parentConfiguration, "", null);
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$style: function(receiver) {
      return this.style;
    }
  };
  U.DiagnosticsProperty.prototype = {
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      var t1, t2, v, result, _this = this;
      _this._maybeCacheValue$0();
      if (_this._fake_flutter$_exception != null) {
        _this._maybeCacheValue$0();
        return "EXCEPTION (" + J.get$runtimeType$(_this._fake_flutter$_exception).toString$0(0) + ")";
      }
      t1 = _this.ifNull;
      if (t1 != null) {
        _this._maybeCacheValue$0();
        t2 = _this._fake_flutter$_value == null;
      } else
        t2 = false;
      if (t2)
        return _this._addTooltip$1(t1);
      _this._maybeCacheValue$0();
      v = _this._fake_flutter$_value;
      t1 = J.getInterceptor$(v);
      result = !!t1.$isDiagnosticableTree ? H.stringTypeCheck(J.$index$asx(v.json, "description")) : t1.toString$0(v);
      if (result == null)
        result = "";
      return _this._addTooltip$1(result);
    },
    _addTooltip$1: function(text) {
      return text;
    },
    get$value: function(_) {
      this._maybeCacheValue$0();
      return this._fake_flutter$_value;
    },
    _maybeCacheValue$0: function() {
      return;
    },
    get$level: function(_) {
      this._maybeCacheValue$0();
      if (this._fake_flutter$_exception != null)
        return C.DiagnosticLevel_9;
      this._maybeCacheValue$0();
      return C.DiagnosticLevel_3;
    },
    getProperties$0: function(_) {
      return C.List_empty2;
    },
    getChildren$0: function() {
      return C.List_empty2;
    },
    get$allowWrap: function() {
      return true;
    }
  };
  U.DiagnosticableNode.prototype = {
    get$_builder: function() {
      var t1, _this = this;
      if (_this._cachedBuilder == null) {
        t1 = new U.DiagnosticPropertiesBuilder(H.setRuntimeTypeInfo([], [U.DiagnosticsNode]));
        _this._cachedBuilder = t1;
        _this.value.debugFillProperties$1(t1);
      }
      return _this._cachedBuilder;
    },
    get$style: function(_) {
      var t1 = this.style;
      if (t1 == null) {
        this.get$_builder().toString;
        t1 = C.DiagnosticsTreeStyle_0;
      }
      return t1;
    },
    get$emptyBodyDescription: function() {
      this.get$_builder().toString;
      return;
    },
    getProperties$0: function(_) {
      return this.get$_builder().properties;
    },
    getChildren$0: function() {
      return C.List_empty2;
    },
    toDescription$1$parentConfiguration: function(parentConfiguration) {
      return H.stringTypeCheck(J.$index$asx(this.value.json, "description"));
    },
    get$level: function(_) {
      return C.DiagnosticLevel_3;
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  U._DiagnosticableTreeNode.prototype = {
    getChildren$0: function() {
      var t1 = this.value.debugDescribeChildren$0();
      return t1;
    },
    $asDiagnosticableNode: function() {
      return [U.DiagnosticableTree];
    }
  };
  U.DiagnosticPropertiesBuilder.prototype = {};
  U.Diagnosticable.prototype = {
    toString$0: function(_) {
      return this.toDiagnosticsNode$1$style(C.DiagnosticsTreeStyle_7).toString$1$minLevel(0, C.DiagnosticLevel_2);
    },
    debugFillProperties$1: function(properties) {
    }
  };
  U.DiagnosticableTree.prototype = {
    toDiagnosticsNode$2$name$style: function($name, style) {
      return new U._DiagnosticableTreeNode(this, $name, true, true, null, style);
    }
  };
  U._WordWrapParseMode.prototype = {
    toString$0: function(_) {
      return this._fake_flutter$_name;
    }
  };
  U.TextStyle.prototype = {
    merge$1: function(other) {
      var t1, t2, t3, t4, t5, t6, _this = this;
      if (other == null)
        return _this;
      t1 = other.color;
      t2 = other.fontFamily;
      t3 = other.fontSize;
      t4 = other.fontWeight;
      t5 = other.fontStyle;
      t6 = other.decoration;
      if (t1 == null)
        t1 = _this.color;
      if (t2 == null)
        t2 = _this.fontFamily;
      if (t3 == null)
        t3 = _this.fontSize;
      if (t4 == null)
        t4 = _this.fontWeight;
      if (t5 == null)
        t5 = _this.fontStyle;
      if (t6 == null)
        t6 = _this.decoration;
      return U.TextStyle$(t1, null, t6, _this.decorationColor, _this.decorationStyle, t2, t3, t5, t4, _this.height, true, _this.letterSpacing, _this.textBaseline, _this.wordSpacing);
    },
    $eq: function(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!J.get$runtimeType$(other).$eq(0, H.getRuntimeType(_this)))
        return false;
      H.interceptedTypeCheck(other, "$isTextStyle");
      if (_this.color == other.color)
        if (_this.fontFamily == other.fontFamily)
          if (_this.fontSize == other.fontSize)
            if (_this.fontWeight == other.fontWeight)
              if (_this.fontStyle == other.fontStyle)
                if (J.$eq$(_this.decoration, other.decoration))
                  t1 = true;
                else
                  t1 = false;
              else
                t1 = false;
            else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var _this = this;
      return S.hashValues(true, _this.color, _this.fontFamily, _this.fontSize, _this.fontWeight, _this.fontStyle, _this.letterSpacing, _this.wordSpacing, _this.textBaseline, _this.height, _this.decoration, _this.decorationColor, _this.decorationStyle);
    }
  };
  F.GtagEvent.prototype = {};
  F.GtagException.prototype = {};
  Y.HtmlIconRenderer.prototype = {
    createElement$0: function(_) {
      var canvasSource = this.createCanvasSource$0(),
        t1 = canvasSource.style,
        t2 = this.icon,
        t3 = "" + t2.get$iconWidth() + "px";
      t1.width = t3;
      t2 = "" + t2.get$iconHeight() + "px";
      t1.height = t2;
      canvasSource.classList.add("flutter-icon");
      return canvasSource;
    },
    get$iconWidth: function() {
      return this.icon.get$iconWidth();
    },
    get$iconHeight: function() {
      return this.icon.get$iconHeight();
    }
  };
  Y._UrlIconRenderer.prototype = {
    get$image: function(_) {
      return this._image;
    },
    createCanvasSource$0: function() {
      var e = document.createElement("img");
      e.src = this.src;
      return e;
    },
    createElement$0: function(_) {
      var t1, t2,
        element = document.createElement("div");
      element.classList.add("flutter-icon");
      t1 = element.style;
      t1.width = "18px";
      t1.height = "18px";
      t2 = "url(" + this.src + ")";
      t1.backgroundImage = t2;
      if (this.icon.invertDark && $._isDarkTheme) {
        t1 = element.style;
        C.CssStyleDeclaration_methods._setPropertyHelper$3(t1, (t1 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t1, "filter"), "invert(1)", "");
      }
      return element;
    },
    loadImage$0: function() {
      var t2, imageElement, t3, _this = this,
        t1 = _this._imageFuture;
      if (t1 != null)
        return t1;
      t1 = W.CanvasImageSource;
      t2 = new P._Future($.Zone__current, [t1]);
      imageElement = W.ImageElement_ImageElement(_this.src);
      t3 = W.Event;
      W._EventStreamSubscription$(imageElement, "load", H.functionTypeCheck(new Y._UrlIconRenderer_loadImage_closure(_this, imageElement, new P._AsyncCompleter(t2, [t1])), {func: 1, ret: -1, args: [t3]}), false, t3);
      document.head.appendChild(imageElement);
      _this.set$_imageFuture(t2);
      return _this._imageFuture;
    },
    set$_imageFuture: function(_imageFuture) {
      this._imageFuture = H.assertSubtype(_imageFuture, "$isFuture", [W.CanvasImageSource], "$asFuture");
    },
    $asHtmlIconRenderer: function() {
      return [S.UrlIcon];
    }
  };
  Y._UrlIconRenderer_loadImage_closure.prototype = {
    call$1: function(e) {
      var t1 = this.imageElement;
      this.$this._image = t1;
      this.completer.complete$1(0, t1);
    },
    $signature: 6
  };
  Y._ColorIconRenderer.prototype = {
    createCanvasSource$0: function() {
      var canvas = Y.createHighDpiCanvas(18, 18),
        context = canvas.getContext("2d");
      context.clearRect(0, 0, 18, 18);
      context.fillStyle = Y.colorToCss(C.ThemedColor_Color_4294967295_Color_4278190080);
      context.fillRect(1, 1, 16, 16);
      context.fillStyle = Y.colorToCss(C.ThemedColor_Color_4286611584_Color_4286611584);
      context.fillRect(1, 1, 8, 8);
      context.fillRect(9, 9, 8, 8);
      context.fillStyle = Y.colorToCss(this.icon.color);
      context.fillRect(1, 1, 16, 16);
      context.strokeStyle = Y.colorToCss(C.ThemedColor_Color_4278190080_Color_4290493371);
      context.rect(1, 1, 16, 16);
      context.stroke();
      return canvas;
    },
    get$image: function(_) {
      var t1 = this._image;
      if (t1 != null)
        return t1;
      return this._image = this.createCanvasSource$0();
    },
    loadImage$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(W.CanvasImageSource),
        $async$returnValue, $async$self = this;
      var $async$loadImage$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.get$image($async$self);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadImage$0, $async$completer);
    },
    get$iconWidth: function() {
      return 18;
    },
    get$iconHeight: function() {
      return 18;
    },
    $asHtmlIconRenderer: function() {
      return [S.ColorIcon];
    }
  };
  Y._CustomIconRenderer.prototype = {
    createCanvasSource$0: function() {
      var canvas, _this = this,
        t1 = _this.baseIconRenderer,
        baseImage = t1.get$image(t1);
      if (baseImage == null)
        return _this._buildImageAsync$0();
      t1 = _this.icon;
      canvas = Y.createHighDpiCanvas(t1.get$iconWidth(), t1.get$iconHeight());
      _this._drawIcon$2(canvas, baseImage);
      return canvas;
    },
    get$image: function(_) {
      var _this = this,
        t1 = _this._image;
      if (t1 != null)
        return t1;
      t1 = _this.baseIconRenderer;
      if (t1.get$image(t1) == null)
        return;
      return _this._image = _this.createCanvasSource$0();
    },
    loadImage$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(W.CanvasImageSource),
        $async$returnValue, $async$self = this, source, t1, canvas;
      var $async$loadImage$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return P._asyncAwait($async$self.baseIconRenderer.loadImage$0(), $async$loadImage$0);
            case 3:
              // returning from await.
              source = $async$result;
              t1 = $async$self.icon;
              canvas = Y.createHighDpiCanvas(t1.get$iconWidth(), t1.get$iconHeight());
              $async$self._drawIcon$2(canvas, source);
              $async$returnValue = canvas;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$loadImage$0, $async$completer);
    },
    _buildImageAsync$0: function() {
      var t1 = this.icon,
        canvas = Y.createHighDpiCanvas(t1.get$iconWidth(), t1.get$iconHeight());
      this.baseIconRenderer.loadImage$0().then$1$1(new Y._CustomIconRenderer__buildImageAsync_closure(this, canvas), null);
      return canvas;
    },
    _drawIcon$2: function(canvas, source) {
      var t1 = canvas.getContext("2d"),
        t2 = this.icon;
      t1.drawImage(source, 0, 0, t2.get$iconWidth(), t2.get$iconHeight());
      t1.strokeStyle = "#231F20";
      t1.font = "arial 8px";
      t1.textBaseline = "middle";
      t1.textAlign = "center";
      C.CanvasRenderingContext2D_methods.fillText$4(t1, t2.text, t2.get$iconWidth() / 2, t2.get$iconHeight() / 2, t2.get$iconWidth());
    },
    $asHtmlIconRenderer: function() {
      return [S.CustomIcon];
    }
  };
  Y._CustomIconRenderer__buildImageAsync_closure.prototype = {
    call$1: function(source) {
      this.$this._drawIcon$2(this.canvas, H.interceptedTypeCheck(source, "$isCanvasImageSource"));
    },
    $signature: 47
  };
  Y._MaterialIconRenderer.prototype = {
    get$image: function(_) {
      var t1 = this._image;
      if (t1 != null)
        return t1;
      if (!$._MaterialIconRenderer__fontLoaded)
        return;
      return this._image = this.createCanvasSource$0();
    },
    loadImage$0: function() {
      var t1, t2, t3;
      if ($._MaterialIconRenderer__fontLoaded) {
        t1 = this.get$image(this);
        t2 = new P._Future($.Zone__current, [W.CanvasImageSource]);
        t2._asyncComplete$1(t1);
        return t2;
      }
      t1 = W.CanvasElement;
      t2 = new P._Future($.Zone__current, [t1]);
      if ($._MaterialIconRenderer__iconsFont == null) {
        t3 = W.FontFace_FontFace("Material Icons", "url(packages/devtools/src/ui/MaterialIcons-Regular.woff2)");
        $._MaterialIconRenderer__iconsFont = t3;
        document.fonts.add(t3);
        t3 = W.promiseToFuture($._MaterialIconRenderer__iconsFont.load(), W.FontFace);
        $._MaterialIconRenderer__iconsFontFuture = t3;
        t3.then$1$1(new Y._MaterialIconRenderer_loadImage_closure(), null);
      }
      $._MaterialIconRenderer__iconsFontFuture.then$1$1(new Y._MaterialIconRenderer_loadImage_closure0(this, new P._AsyncCompleter(t2, [t1])), null);
      return t2;
    },
    createCanvasSource$0: function() {
      var t1 = this.icon,
        canvas = Y.createHighDpiCanvas(t1.get$iconWidth(), t1.get$iconHeight()),
        context2D = canvas.getContext("2d");
      context2D.translate(t1.get$iconWidth() / 2, t1.get$iconHeight() / 2);
      t1 = t1.angle;
      if (t1 !== 0)
        context2D.rotate(t1);
      t1 = new Y._MaterialIconRenderer_createCanvasSource__drawIcon(this, context2D);
      if ($._MaterialIconRenderer__fontLoaded)
        t1.call$0();
      else
        this.loadImage$0().then$1$1(new Y._MaterialIconRenderer_createCanvasSource_closure(t1), null);
      return canvas;
    },
    $asHtmlIconRenderer: function() {
      return [K.MaterialIcon];
    }
  };
  Y._MaterialIconRenderer_loadImage_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isFontFace");
      $._MaterialIconRenderer__fontLoaded = true;
    },
    $signature: 90
  };
  Y._MaterialIconRenderer_loadImage_closure0.prototype = {
    call$1: function(_) {
      var t1, t2;
      H.interceptedTypeCheck(_, "$isFontFace");
      t1 = this.$this;
      t2 = t1.createCanvasSource$0();
      t1._image = t2;
      this.imageCompleter.complete$1(0, t2);
    },
    $signature: 90
  };
  Y._MaterialIconRenderer_createCanvasSource__drawIcon.prototype = {
    call$0: function() {
      var t1 = this.context2D,
        t2 = this.$this.icon;
      t1.font = "" + t2.fontSize + "px Material Icons";
      t1.fillStyle = Y.colorToCss(t2.color);
      t1.textBaseline = "middle";
      t1.textAlign = "center";
      C.CanvasRenderingContext2D_methods.fillText$4(t1, t2.text, 0, 0, t2.get$iconWidth() + 10);
    },
    $signature: 1
  };
  Y._MaterialIconRenderer_createCanvasSource_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isCanvasImageSource");
      this._drawIcon.call$0();
    },
    $signature: 47
  };
  S.Icon.prototype = {
    get$iconWidth: function() {
      return 18;
    },
    get$iconHeight: function() {
      return 18;
    }
  };
  S.UrlIcon.prototype = {};
  S.CustomIcon.prototype = {
    get$iconWidth: function() {
      this.kind.icon;
      return 18;
    },
    get$iconHeight: function() {
      this.kind.icon;
      return 18;
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.CustomIconMaker.prototype = {
    getCustomIcon$2$kind: function(fromText, kind) {
      var t2, text, t1 = {};
      t1.kind = kind;
      t2 = fromText.length;
      if (t2 === 0)
        return;
      if (0 >= t2)
        return H.ioore(fromText, 0);
      text = fromText[0].toUpperCase();
      return this.iconCache.putIfAbsent$2(0, text + "_" + kind.name + "_false", new S.CustomIconMaker_getCustomIcon_closure(t1, text, false));
    },
    fromWidgetName$1: function($name) {
      var isPrivate, t1, t2;
      if ($name == null)
        return;
      isPrivate = C.JSString_methods.startsWith$1($name, "_");
      while (true) {
        t1 = $name.length === 0;
        if (!t1) {
          t2 = C.JSString_methods._codeUnitAt$1($name, 0);
          t2 = !((t2 < 48 || t2 > 57) && t2 !== 95 && t2 !== 36);
        } else
          t2 = false;
        if (!t2)
          break;
        $name = C.JSString_methods.substring$1($name, 1);
      }
      if (t1)
        return;
      return this.getCustomIcon$2$kind($name, isPrivate ? C.IconKind_jzj : C.IconKind_Q7f);
    },
    fromInfo$1: function($name) {
      if ($name.length === 0)
        return;
      return this.getCustomIcon$2$kind($name, C.IconKind_0KV);
    }
  };
  S.CustomIconMaker_getCustomIcon_closure.prototype = {
    call$0: function() {
      return new S.CustomIcon(this._box_0.kind, this.text, this.isAbstract);
    },
    $signature: 228
  };
  S.IconKind.prototype = {
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.ColorIcon.prototype = {};
  S.ColorIconMaker.prototype = {
    getCustomIcon$1: function(color) {
      return this.iconCache.putIfAbsent$2(0, color, new S.ColorIconMaker_getCustomIcon_closure(color));
    }
  };
  S.ColorIconMaker_getCustomIcon_closure.prototype = {
    call$0: function() {
      return new S.ColorIcon(this.color);
    },
    $signature: 229
  };
  K.MaterialIcon.prototype = {
    get$iconWidth: function() {
      return this.iconWidth;
    }
  };
  K.FlutterMaterialIcons_getIconForCodePoint_closure.prototype = {
    call$0: function() {
      return new K.MaterialIcon(this.code, C.ThemedColor_Color_4278190080_Color_4290493371, 18, 0, 18);
    },
    $signature: 230
  };
  O.Plotly.prototype = {};
  O.TraceData.prototype = {};
  O.Data.prototype = {};
  O.Marker.prototype = {};
  O.Line.prototype = {};
  O.Transform0.prototype = {};
  O.Title.prototype = {};
  O.Layout.prototype = {};
  O.Shape.prototype = {};
  O.Legend.prototype = {};
  O.HoverLabel.prototype = {};
  O.Font.prototype = {};
  O.AxisLayout.prototype = {};
  O.RangeSelector.prototype = {};
  O.Button.prototype = {};
  O.Margin.prototype = {};
  O.RangeSlider.prototype = {};
  O.Configuration.prototype = {};
  O.DataEvent.prototype = {};
  O.LegendDataEvent.prototype = {};
  O.Point1.prototype = {};
  O.HoverFX.prototype = {};
  N.PSelect.prototype = {
    get$value: function(_) {
      return H.interceptedTypeCheck(this.element, "$isSelectElement").value;
    },
    get$onChange: function(_) {
      var t1 = J.get$onChange$x(this.element),
        t2 = H.getTypeArgumentByIndex(t1, 0);
      return new P._WhereStream(H.functionTypeCheck(new N.PSelect_onChange_closure(this), {func: 1, ret: P.bool, args: [t2]}), t1, [t2]);
    },
    change$1: function(handle) {
      H.functionTypeCheck(handle, {func: 1, ret: -1});
      return this.get$onChange(this).listen$1(new N.PSelect_change_closure(handle));
    }
  };
  N.PSelect_onChange_closure.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isEvent");
      return !H.boolConversionCheck(this.$this.element.hasAttribute("disabled"));
    },
    $signature: 58
  };
  N.PSelect_change_closure.prototype = {
    call$1: function(e) {
      H.interceptedTypeCheck(e, "$isEvent").stopImmediatePropagation();
      this.handle.call$0();
    },
    $signature: 6
  };
  N.PButton.prototype = {};
  N.PFlash.prototype = {};
  N.PTabNav.prototype = {
    PTabNav$1: function(tabs) {
      var t1, _i, tab;
      H.interceptedTypeCheck(this.add$1(0, A.CoreElement$("nav", null, "tabnav-tabs", null, null)), "$isCoreElement").add$1(0, tabs);
      if (tabs.length !== 0)
        this.selectTab$1(C.JSArray_methods.get$first(tabs));
      for (t1 = tabs.length, _i = 0; _i < tabs.length; tabs.length === t1 || (0, H.throwConcurrentModificationError)(tabs), ++_i) {
        tab = tabs[_i];
        J.click$1$x(tab, new N.PTabNav_closure(this, tab));
      }
    },
    selectTab$1: function(tab) {
      var _this = this,
        _s8_ = "selected",
        t1 = _this.selectedTab;
      if (t1 != null)
        J.get$classes$x(t1.element).toggle$2(0, _s8_, false);
      _this.selectedTab = tab;
      if (tab != null)
        J.get$classes$x(tab.element).toggle$2(0, _s8_, true);
      _this._selectedTabController.add$1(0, _this.selectedTab);
    }
  };
  N.PTabNav_closure.prototype = {
    call$0: function() {
      this.$this.selectTab$1(this.tab);
    },
    $signature: 0
  };
  N.PTabNavTab.prototype = {};
  N.PNavMenu.prototype = {
    PNavMenu$2$supportsSelection: function(items, supportsSelection) {
      this.add$1(0, items);
    }
  };
  N.PNavMenuItem.prototype = {};
  K.ThemedColor.prototype = {
    get$alpha: function(_) {
      return (4278190080 & ($._isDarkTheme ? this._dark : this._light).value) >>> 24;
    },
    get$value: function(_) {
      return ($._isDarkTheme ? this._dark : this._light).value;
    },
    $isColor: 1
  };
  X.TreeNavigator.prototype = {
    moveRight$0: function() {
      var t1 = this._selectedItem;
      if (!H.boolConversionCheck(t1.hasChildren))
        return;
      if (!H.boolConversionCheck(t1.isExpanded))
        t1.expand.call$0();
      else {
        t1 = t1.children;
        this.select$1(0, C.JSArray_methods.get$first(t1));
      }
    },
    _getNextVisibleElementBelow$2$includeChildren: function(node, includeChildren) {
      var t1;
      H.assertSubtype(node, "$isTreeNode", [H.getRuntimeTypeArgument(this, "TreeNavigator", 0)], "$asTreeNode");
      if (includeChildren)
        if (H.boolConversionCheck(node.isExpanded)) {
          t1 = node.children;
          t1 = t1.length !== 0;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return C.JSArray_methods.get$first(H.boolConversionCheck(node.isExpanded) ? node.children : H.setRuntimeTypeInfo([], [[X.TreeNode, H.getTypeArgumentByIndex(node, 0)]]));
      t1 = node.nextSibling;
      if (t1 == null) {
        t1 = node.parent;
        t1 = t1 != null ? this._getNextVisibleElementBelow$2$includeChildren(t1, false) : null;
      }
      return t1;
    },
    _getNextVisibleElementBelow$1: function(node) {
      return this._getNextVisibleElementBelow$2$includeChildren(node, true);
    },
    _getLastVisibleDescendant$1: function(node) {
      var t1, t2;
      H.assertSubtype(node, "$isTreeNode", [H.getRuntimeTypeArgument(this, "TreeNavigator", 0)], "$asTreeNode");
      while (true) {
        t1 = H.boolConversionCheck(node.isExpanded);
        if (t1) {
          t2 = node.children;
          t2 = t2.length !== 0;
        } else
          t2 = false;
        if (!t2)
          break;
        node = C.JSArray_methods.get$last(t1 ? node.children : H.setRuntimeTypeInfo([], [[X.TreeNode, H.getTypeArgumentByIndex(node, 0)]]));
      }
      return node;
    }
  };
  X.Tree.prototype = {
    connectNodes$3: function($parent, children, hasChildren) {
      var previousNode, _i, node, t2,
        t1 = H.getRuntimeTypeArgument(this, "Tree", 0);
      H.assertSubtype($parent, "$isTreeNode", [t1], "$asTreeNode");
      H.assertSubtype(children, "$isList", [[X.TreeNode, t1]], "$asList");
      H.functionTypeCheck(hasChildren, {func: 1, ret: P.bool, args: [t1]});
      for (t1 = children.length, previousNode = null, _i = 0; _i < children.length; children.length === t1 || (0, H.throwConcurrentModificationError)(children), ++_i, previousNode = node) {
        node = children[_i];
        t2 = J.getInterceptor$x(node);
        t2.set$parent(node, $parent);
        node.hasChildren = H.boolTypeCheck(hasChildren.call$1(node.data));
        if (previousNode != null) {
          t2.set$previousSibling(node, previousNode);
          if (previousNode.nextSibling == null)
            previousNode.set$nextSibling(0, node);
        }
      }
      t1 = $parent == null ? null : $parent.children;
      if (t1 != null)
        C.JSArray_methods.addAll$1(t1, children);
    }
  };
  X.TreeNode.prototype = {
    set$expand: function(_, expand) {
      this.expand = H.functionTypeCheck(expand, {func: 1});
    },
    set$collapse: function(_, collapse) {
      this.collapse = H.functionTypeCheck(collapse, {func: 1});
    },
    set$parent: function(_, $parent) {
      this.parent = H.assertSubtype($parent, "$isTreeNode", this.$ti, "$asTreeNode");
    },
    set$previousSibling: function(_, previousSibling) {
      this.previousSibling = H.assertSubtype(previousSibling, "$isTreeNode", this.$ti, "$asTreeNode");
    },
    set$nextSibling: function(_, nextSibling) {
      this.nextSibling = H.assertSubtype(nextSibling, "$isTreeNode", this.$ti, "$asTreeNode");
    }
  };
  R.HtmlTreeNavigator.prototype = {
    handleKeyPress$1: function(e) {
      var t1, nextElm, t2, prevElm, _this = this;
      H.interceptedTypeCheck(e, "$isKeyboardEvent");
      t1 = e.keyCode;
      if (t1 === 40) {
        t1 = _this._selectedItem;
        if (t1 != null) {
          nextElm = _this._getNextVisibleElementBelow$1(t1);
          if (nextElm != null)
            _this.select$1(0, nextElm);
        } else {
          t1 = _this.treeNodes;
          if (t1.length !== 0)
            _this.select$1(0, C.JSArray_methods.get$first(t1));
        }
      } else if (t1 === 38) {
        t1 = _this._selectedItem;
        if (t1 != null) {
          H.assertSubtype(t1, "$isTreeNode", [H.getRuntimeTypeArgument(_this, "TreeNavigator", 0)], "$asTreeNode");
          t2 = t1.previousSibling;
          if (t2 != null) {
            t2 = _this._getLastVisibleDescendant$1(t2);
            if (t2 == null)
              t2 = t1.previousSibling;
            prevElm = t2 == null ? t1.parent : t2;
          } else
            prevElm = t1.parent;
          if (prevElm != null)
            _this.select$1(0, prevElm);
        } else {
          t1 = _this.treeNodes;
          if (t1.length !== 0) {
            t1 = _this._getLastVisibleDescendant$1(C.JSArray_methods.get$last(t1));
            _this.select$1(0, t1 == null ? C.JSArray_methods.get$last(_this.treeNodes) : t1);
          }
        }
      } else if (t1 === 39)
        _this.moveRight$0();
      else if (t1 === 37) {
        t1 = _this._selectedItem;
        if (H.boolConversionCheck(t1.isExpanded))
          t1.collapse.call$0();
        else {
          t1 = t1.parent;
          if (t1 != null)
            _this.select$1(0, t1);
        }
      } else
        return;
      e.preventDefault();
    }
  };
  Y.ServiceExtensionButton.prototype = {
    ServiceExtensionButton$1: function(extensionDescription) {
      var extensionName, streamController, _this = this,
        t1 = _this.extensionDescription,
        t2 = N.PButton$icon(t1.description, t1.icon, t1.disabledTooltip);
      t2.clazz$1("btn-sm");
      _this.button = t2;
      extensionName = t1.extension;
      t2.attribute$2("disabled", !H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._serviceExtensionManager.isServiceExtensionAvailable$1(extensionName));
      t2 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._serviceExtensionManager;
      t1 = H.functionTypeCheck(new Y.ServiceExtensionButton_closure(_this), {func: 1, ret: -1, args: [P.bool]});
      if (t2._serviceExtensions.contains$1(0, extensionName) && true)
        t1.call$1(true);
      streamController = t2._getServiceExtensionController$1(extensionName);
      streamController.get$stream(streamController).listen$1(t1);
      _this.button.click$1(0, new Y.ServiceExtensionButton_closure0(_this));
      _this._updateState$0();
    },
    _updateState$0: function() {
      var streamController,
        t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._serviceExtensionManager,
        t2 = this.extensionDescription.extension,
        t3 = H.functionTypeCheck(new Y.ServiceExtensionButton__updateState_closure(this), {func: 1, ret: -1, args: [R.ServiceExtensionState]}),
        t4 = t1._enabledServiceExtensions;
      if (t4.containsKey$1(0, t2) && true)
        t3.call$1(t4.$index(0, t2));
      streamController = t1._getServiceExtensionStateController$1(t2);
      streamController.get$stream(streamController).listen$1(t3);
    }
  };
  Y.ServiceExtensionButton_closure.prototype = {
    call$1: function(available) {
      var t1, t2;
      H.boolTypeCheck(available);
      t1 = this.$this.button;
      t2 = !H.boolConversionCheck(available);
      t1.attribute$2("disabled", t2);
      return t2;
    },
    $signature: 232
  };
  Y.ServiceExtensionButton_closure0.prototype = {
    call$0: function() {
      var wasSelected, t3,
        t1 = this.$this,
        t2 = t1.extensionDescription;
      F.select(t2.gaScreenName, t2.gaItem, 0);
      wasSelected = J.get$classes$x(t1.button.element).contains$1(0, "selected");
      t1 = H.interceptedTypeCheck($.globals.$index(0, C.Type_ServiceConnectionManager_qdG), "$isServiceConnectionManager")._serviceExtensionManager;
      t3 = wasSelected ? t2.disabledValue : t2.enabledValue;
      t1.setServiceExtensionState$3(t2.extension, !wasSelected, t3);
      return;
    },
    $signature: 1
  };
  Y.ServiceExtensionButton__updateState_closure.prototype = {
    call$1: function(state) {
      var t1 = this.$this,
        t2 = t1.extensionDescription,
        extensionEnabled = H.interceptedTypeCheck(state, "$isServiceExtensionState").value === t2.enabledValue;
      J.get$classes$x(t1.button.element).toggle$2(0, "selected", extensionEnabled);
      t1 = t1.button;
      t2 = extensionEnabled ? t2.enabledTooltip : t2.disabledTooltip;
      t1.element.title = t2;
    },
    $signature: 233
  };
  T._CanvasChunk.prototype = {
    set$position: function(_, p) {
      var t1, t2, _this = this;
      if (J.$eq$(_this._viewport_canvas$_position, p))
        return;
      _this._viewport_canvas$_position = p;
      t1 = S.Rect$fromLTWH(p.x * 512, p.y * 512, 512, 512);
      _this.rect = t1;
      t2 = _this.canvas.style;
      t1 = "translate(" + H.S(t1._dart_ui$_value[0]) + "px, " + H.S(_this.rect._dart_ui$_value[1]) + "px)";
      C.CssStyleDeclaration_methods._setPropertyHelper$3(t2, (t2 && C.CssStyleDeclaration_methods)._browserPropertyName$1(t2, "transform"), t1, "");
      t1 = _this._context;
      t1.restore();
      t1.save();
      t2 = _this.rect._dart_ui$_value;
      t1.translate(-t2[0], -t2[1]);
      _this._debugPaint$0();
      _this._dirty = true;
    },
    clear$0: function(_) {
      var t1, t2, _this = this;
      if (_this._empty)
        return;
      t1 = _this._context;
      t2 = _this.rect._dart_ui$_value;
      t1.clearRect(t2[0], t2[1], 512, 512);
      _this._debugPaint$0();
      _this._empty = true;
    },
    _debugPaint$0: function() {
    }
  };
  T._ChunkPosition.prototype = {
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!(other instanceof T._ChunkPosition))
        return false;
      return this.y === other.y && this.x === other.x;
    },
    get$hashCode: function(_) {
      return this.y * 37 + this.x;
    }
  };
  T.ViewportCanvas.prototype = {
    ViewportCanvas$7$addBuffer$classes$onMouseLeave$onMouseMove$onSizeChange$onTap$paintCallback: function(addBuffer, classes, onMouseLeave, onMouseMove, onSizeChange, onTap, paintCallback) {
      var t4, t5, _this = this,
        t1 = _this._viewport_canvas$_element,
        t2 = t1.element,
        t3 = t2.style;
      t3.overflow = "scroll";
      t3 = _this._content;
      t4 = t3.element;
      t5 = t4.style;
      t5.position = "relative";
      t5.width = "0";
      t5.height = "0";
      t5.overflow = "hidden";
      t1.add$1(0, t3);
      t1 = new ResizeObserver(H.convertDartClosureToJS(P.allowInterop(new T.ViewportCanvas_closure(_this), {func: 1, ret: -1, args: [[P.List, W.ResizeObserverEntry], W.ResizeObserver]}), 2));
      _this._resizeObserver = t1;
      t1.observe(t2);
      t2 = J.get$onScroll$x(t2);
      t1 = H.getTypeArgumentByIndex(t2, 0);
      W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new T.ViewportCanvas_closure0(_this), {func: 1, ret: -1, args: [t1]}), false, t1);
      t3.get$onClick(t3).listen$1(new T.ViewportCanvas_closure1(_this));
      t1 = J.getInterceptor$x(t4);
      t2 = t1.get$onMouseLeave(t4);
      t3 = H.getTypeArgumentByIndex(t2, 0);
      W._EventStreamSubscription$(t2._html$_target, t2._eventType, H.functionTypeCheck(new T.ViewportCanvas_closure2(_this), {func: 1, ret: -1, args: [t3]}), false, t3);
      t4 = t1.get$onMouseMove(t4);
      t1 = H.getTypeArgumentByIndex(t4, 0);
      W._EventStreamSubscription$(t4._html$_target, t4._eventType, H.functionTypeCheck(new T.ViewportCanvas_closure3(_this), {func: 1, ret: -1, args: [t1]}), false, t1);
    },
    _dispatchMouseMoveEvent$0: function() {
      var t1 = this._onMouseMove;
      if (t1 != null)
        t1.call$1(this._clientToGlobal$1(this._currentMouseHover));
    },
    _clientToGlobal$1: function(client) {
      var elementRect, t1, t2, t3, t4;
      H.assertSubtype(client, "$isPoint", [P.num], "$asPoint");
      elementRect = this._content.element.getBoundingClientRect();
      t1 = client.x;
      t2 = elementRect.left;
      if (typeof t1 !== "number")
        return t1.$sub();
      t3 = client.y;
      t4 = elementRect.top;
      if (typeof t3 !== "number")
        return t3.$sub();
      return new S.Offset(t1 - t2, t3 - t4);
    },
    _viewport_canvas$_scheduleRebuild$0: function() {
      var _this = this;
      if (!_this._viewport_canvas$_hasPendingRebuild) {
        _this._viewport_canvas$_hasPendingRebuild = true;
        _this.setState$1(new T.ViewportCanvas__scheduleRebuild_closure(_this));
      }
    },
    rebuild$1$force: function(force) {
      var t2, t3, t4, t5, _this = this,
        lastViewport = _this._viewport,
        rawElement = _this._viewport_canvas$_element.element,
        t1 = S.Rect$fromLTWH(C.JSNumber_methods.round$0(rawElement.scrollLeft), C.JSNumber_methods.round$0(rawElement.scrollTop), C.JSNumber_methods.round$0(rawElement.offsetWidth), C.JSNumber_methods.round$0(rawElement.offsetHeight));
      _this._viewport = t1;
      t1 = t1._dart_ui$_value;
      t2 = t1[2];
      t3 = t1[0];
      t4 = t1[3];
      t1 = t1[1];
      t5 = lastViewport._dart_ui$_value;
      if (!new S.Size(t2 - t3, t4 - t1).$eq(0, new S.Size(t5[2] - t5[0], t5[3] - t5[1])) && _this._onSizeChange != null) {
        t1 = _this._viewport._dart_ui$_value;
        _this._onSizeChange.call$1(new S.Size(t1[2] - t1[0], t1[3] - t1[1]));
      }
      t1 = _this._viewport.inflate$1(512)._dart_ui$_value;
      t2 = S.Rect$fromLTWH(0, 0, _this._contentWidth, _this._contentHeight)._dart_ui$_value;
      _this._renderedViewport = S.Rect$fromLTRB(Math.max(t1[0], t2[0]), Math.max(t1[1], t2[1]), Math.min(t1[2], t2[2]), Math.min(t1[3], t2[3]));
      _this._contentSizeChanged = false;
      _this._render$1(force);
    },
    setContentSize$2: function(width, height) {
      var t1, t2, _this = this;
      if (width == _this._contentWidth && height === _this._contentHeight)
        return;
      _this._contentWidth = width;
      _this._contentHeight = height;
      t1 = _this._content.element.style;
      t2 = H.S(width) + "px";
      t1.width = t2;
      t2 = H.S(height) + "px";
      t1.height = t2;
      if (!_this._contentSizeChanged) {
        _this._contentSizeChanged = true;
        _this._viewport_canvas$_scheduleRebuild$0();
      }
    },
    _getChunkPosition$1: function(offset) {
      var t2,
        t1 = offset._dx;
      if (typeof t1 !== "number")
        return t1.$tdiv();
      t1 = C.JSNumber_methods._tdivFast$1(t1, 512);
      t2 = offset._dy;
      if (typeof t2 !== "number")
        return t2.$tdiv();
      return new T._ChunkPosition(t1, C.JSNumber_methods._tdivFast$1(t2, 512));
    },
    _getChunk$1: function(position) {
      var t2, t3, chunk,
        t1 = this._chunks,
        existing = t1.$index(0, position);
      if (existing != null) {
        if (H.boolConversionCheck(existing._dirty))
          existing.clear$0(0);
        return existing;
      }
      for (t2 = t1.get$values(t1), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        t3 = t2.get$current(t2);
        if (!t3.rect.overlaps$1(this._renderedViewport)) {
          t1.remove$1(0, t3._viewport_canvas$_position);
          t3.set$position(0, position);
          t1.$indexSet(0, position, t3);
          if (H.boolConversionCheck(t3._dirty))
            t3.clear$0(0);
          return t3;
        }
      }
      t2 = Y.createHighDpiCanvas(512, 512);
      chunk = new T._CanvasChunk(t2);
      t3 = t2.style;
      t3.position = "absolute";
      t2 = t2.getContext("2d");
      t2.save();
      chunk._context = t2;
      chunk.set$position(0, position);
      chunk._dirty = true;
      t1.$indexSet(0, position, chunk);
      return chunk;
    },
    _render$1: function(force) {
      var chunk, e, st, t1, t2, start, end, y, x, t3, x0, exception, t4, attach, t5, _this = this;
      if (force)
        for (t1 = _this._chunks, t1 = t1.get$values(t1), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          t2 = t1.get$current(t1);
          t2._dirty = true;
          t2.clear$0(0);
        }
      ++_this._frameId;
      t1 = _this._renderedViewport._dart_ui$_value;
      start = _this._getChunkPosition$1(new S.Offset(t1[0], t1[1]));
      t1 = _this._renderedViewport._dart_ui$_value;
      end = _this._getChunkPosition$1(new S.Offset(t1[2], t1[3]));
      for (y = start.y, t1 = end.y, x = start.x, t2 = end.x, t3 = _this._viewport_canvas$_paintCallback; y <= t1; ++y)
        for (x0 = x; x0 <= t2; ++x0) {
          chunk = _this._getChunk$1(new T._ChunkPosition(x0, y));
          if (H.boolConversionCheck(chunk._dirty)) {
            try {
              t3.call$2(chunk.canvas.getContext("2d"), chunk.rect);
            } catch (exception) {
              e = H.unwrapException(exception);
              st = H.getTraceFromException(exception);
              window;
              if (typeof console != "undefined")
                window.console.error(e);
              if (typeof console != "undefined")
                window.console.error(st);
            }
            t4 = chunk;
            t4._empty = t4._dirty = false;
          }
          chunk._lastFrameRendered = _this._frameId;
        }
      for (t1 = _this._chunks, t1 = t1.get$values(t1), t1 = t1.get$iterator(t1), t2 = _this._content.element; t1.moveNext$0();) {
        t3 = t1.get$current(t1);
        attach = t3._lastFrameRendered === _this._frameId;
        if (attach !== t3.attached) {
          if (attach)
            t2.appendChild(t3.canvas);
          else {
            t4 = t3.canvas;
            t5 = t4.parentNode;
            if (t5 != null)
              t5.removeChild(t4);
          }
          t3.attached = attach;
        }
      }
    },
    scrollToRect$1: function(target) {
      this.setState$1(new T.ViewportCanvas_scrollToRect_closure(this, target));
    },
    set$_currentMouseHover: function(_currentMouseHover) {
      this._currentMouseHover = H.assertSubtype(_currentMouseHover, "$isPoint", [P.num], "$asPoint");
    }
  };
  T.ViewportCanvas_closure.prototype = {
    call$2: function(entries, _) {
      H.listTypeCheck(entries);
      H.interceptedTypeCheck(_, "$isResizeObserver");
      this.$this._viewport_canvas$_scheduleRebuild$0();
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 79
  };
  T.ViewportCanvas_closure0.prototype = {
    call$1: function(_) {
      var t1 = this.$this;
      if (t1._currentMouseHover != null)
        t1._dispatchMouseMoveEvent$0();
      t1.rebuild$1$force(false);
    },
    $signature: 6
  };
  T.ViewportCanvas_closure1.prototype = {
    call$1: function(e) {
      var t1;
      H.interceptedTypeCheck(e, "$isMouseEvent");
      t1 = this.$this;
      t1._viewport_canvas$_onTap.call$1(t1._clientToGlobal$1(new P.Point(e.clientX, e.clientY, [P.num])));
    },
    $signature: 3
  };
  T.ViewportCanvas_closure2.prototype = {
    call$1: function(_) {
      var t1;
      H.interceptedTypeCheck(_, "$isMouseEvent");
      t1 = this.$this;
      t1.set$_currentMouseHover(null);
      t1 = t1._onMouseLeave;
      if (t1 != null)
        t1.call$0();
    },
    $signature: 3
  };
  T.ViewportCanvas_closure3.prototype = {
    call$1: function(e) {
      var t1;
      H.interceptedTypeCheck(e, "$isMouseEvent");
      t1 = this.$this;
      t1.set$_currentMouseHover(new P.Point(e.clientX, e.clientY, [P.num]));
      t1._dispatchMouseMoveEvent$0();
    },
    $signature: 3
  };
  T.ViewportCanvas__scheduleRebuild_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1._viewport_canvas$_hasPendingRebuild = false;
      t1.rebuild$1$force(false);
    },
    $signature: 0
  };
  T.ViewportCanvas_scrollToRect_closure.prototype = {
    call$0: function() {
      var t2, t3, overlaps, x, y, y0, t4, t5,
        t1 = this.$this;
      t1.rebuild$1$force(false);
      t2 = this.target;
      t3 = t2._dart_ui$_value;
      if (t1._viewport.contains$1(0, new S.Offset(t3[0], t3[1])) && t1._viewport.contains$1(0, new S.Offset(t3[0], t3[3])))
        return;
      overlaps = t1._viewport.overlaps$1(t2);
      t2 = t1._viewport._dart_ui$_value;
      x = t2[0];
      y = t2[1];
      y0 = t3[1];
      if (y > y0)
        y = C.JSNumber_methods.toInt$0(y0);
      else {
        t2 = t2[3];
        t4 = t3[3];
        if (t2 < t4)
          y = overlaps ? t4 - (t2 - y) : y0;
      }
      t2 = t1._viewport._dart_ui$_value;
      t4 = t2[0];
      t5 = t3[0];
      if (t4 > t5)
        x = C.JSNumber_methods.toInt$0(t5);
      else {
        t2 = t2[2];
        t3 = t3[2];
        if (t2 < t3)
          x = C.JSNumber_methods.toInt$0(t3 - (t2 - t4));
      }
      J.scrollTo$2$x(t1._viewport_canvas$_element.element, x, y);
    },
    $signature: 0
  };
  T._ViewportCanvas_Object_SetStateMixin.prototype = {};
  B.executeWithDelay_closure.prototype = {
    call$0: function() {
      this.callback.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  B.Property.prototype = {
    get$value: function(_) {
      return this._utils$_value;
    },
    set$value: function(_, newValue) {
      var _this = this;
      H.assertSubtypeOfRuntimeType(newValue, H.getTypeArgumentByIndex(_this, 0));
      if (newValue !== _this._utils$_value) {
        _this.set$_utils$_value(newValue);
        _this._changeController.add$1(0, newValue);
      }
    },
    set$_utils$_value: function(_value) {
      this._utils$_value = H.assertSubtypeOfRuntimeType(_value, H.getTypeArgumentByIndex(this, 0));
    }
  };
  B.DelayedTimer.prototype = {
    _fire$0: function() {
      var _this = this,
        t1 = _this._minTimer;
      if (t1 != null)
        t1.cancel$0(0);
      _this._minTimer = null;
      t1 = _this._maxTimer;
      if (t1 != null)
        t1.cancel$0(0);
      _this._maxTimer = null;
      _this._closure.call$0();
      _this.set$_closure(null);
    },
    set$_closure: function(_closure) {
      this._closure = H.functionTypeCheck(_closure, {func: 1, ret: -1});
    }
  };
  B.RateLimiter.prototype = {
    scheduleRequest$0: function() {
      var t1, t2, _this = this;
      if (_this.requestScheduledButNotStarted)
        return;
      t1 = _this._pendingRequest;
      if (t1 != null && t1.future._state === 0) {
        _this.requestScheduledButNotStarted = true;
        t1.future.whenComplete$1(new B.RateLimiter_scheduleRequest_closure(_this));
        return;
      }
      t1 = Date.now();
      t2 = _this._lastRequestTime;
      if (t2 == null || t2 + _this.delayBetweenRequests <= t1) {
        _this._performRequest$0();
        return;
      }
      _this.requestScheduledButNotStarted = true;
      if (typeof t2 !== "number")
        return H.iae(t2);
      P.Timer_Timer(P.Duration$(0, t1 - t2 + _this.delayBetweenRequests, 0, 0), new B.RateLimiter_scheduleRequest_closure0(_this));
    },
    _performRequest$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, t1;
      var $async$_performRequest$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 2;
              $async$self._lastRequestTime = Date.now();
              t1 = -1;
              $async$self.set$_pendingRequest(new P._AsyncCompleter(new P._Future($.Zone__current, [t1]), [t1]));
              $async$goto = 5;
              return P._asyncAwait($async$self.callback.call$0(), $async$_performRequest$0);
            case 5:
              // returning from await.
              $async$next.push(4);
              // goto finally
              $async$goto = 3;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 3:
              // finally
              $async$handler = 1;
              $async$self._pendingRequest.complete$1(0, null);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 4:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_performRequest$0, $async$completer);
    },
    set$_pendingRequest: function(_pendingRequest) {
      this._pendingRequest = H.assertSubtype(_pendingRequest, "$isCompleter", [-1], "$asCompleter");
    }
  };
  B.RateLimiter_scheduleRequest_closure.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.set$_pendingRequest(null);
      t1.requestScheduledButNotStarted = false;
      t1.scheduleRequest$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  B.RateLimiter_scheduleRequest_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this;
      t1.requestScheduledButNotStarted = false;
      t1._performRequest$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  B.TimeUnit.prototype = {
    toString$0: function(_) {
      return this._utils$_name;
    }
  };
  B.TimeRange.prototype = {
    contains$1: function(_, target) {
      var t1 = H.interceptedTypeCheck(target, "$isDuration")._duration;
      return t1 >= this._utils$_start._duration && t1 <= this._utils$_end._duration;
    },
    toString$0: function(_) {
      var t1, t2, _this = this, _null = null;
      switch (C.TimeUnit_0) {
        case C.TimeUnit_0:
          t1 = _this._utils$_start;
          t1 = "[" + H.S(t1 == null ? _null : t1._duration) + " \u03bcs - ";
          t2 = _this._utils$_end;
          return t1 + H.S(t2 == null ? _null : t2._duration) + " \u03bcs]";
        case C.TimeUnit_1:
        default:
          t1 = _this._utils$_start;
          t1 = "[" + H.S(t1 == null ? _null : C.JSInt_methods._tdivFast$1(t1._duration, 1000)) + " ms - ";
          t2 = _this._utils$_end;
          return t1 + H.S(t2 == null ? _null : C.JSInt_methods._tdivFast$1(t2._duration, 1000)) + " ms]";
      }
    }
  };
  U.VmServiceWrapper.prototype = {
    addBreakpoint$4$column: function(isolateId, scriptId, line, column) {
      var m, t2,
        _s13_ = "addBreakpoint",
        t1 = this._vmService;
      t1.toString;
      m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "scriptId", scriptId, "line", line]);
      t2 = S.Breakpoint;
      return this._trackFuture$1$2(_s13_, t1._call$1$2(0, _s13_, m, t2), t2);
    },
    addBreakpoint$3: function(isolateId, scriptId, line) {
      return this.addBreakpoint$4$column(isolateId, scriptId, line, null);
    },
    callMethod$3$args$isolateId: function(method, args, isolateId) {
      H.interceptedTypeCheck(args, "$isMap");
      return this._trackFuture$1$2("callMethod " + H.S(method), this._vmService.callServiceExtension$3$args$isolateId(method, args, isolateId), S.Response);
    },
    callMethod$1: function(method) {
      return this.callMethod$3$args$isolateId(method, null, null);
    },
    callMethod$2$args: function(method, args) {
      return this.callMethod$3$args$isolateId(method, args, null);
    },
    callServiceExtension$3$args$isolateId: function(method, args, isolateId) {
      return this._trackFuture$1$2("callServiceExtension " + H.S(method), this._vmService.callServiceExtension$3$args$isolateId(method, args, isolateId), S.Response);
    },
    callServiceExtension$2$isolateId: function(method, isolateId) {
      return this.callServiceExtension$3$args$isolateId(method, null, isolateId);
    },
    clearVMTimeline$0: function() {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Success),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$clearVMTimeline$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.isProtocolVersionLessThan$2$major$minor(3, 19), $async$clearVMTimeline$0);
            case 5:
              // returning from await.
              $async$goto = $async$temp1.boolConversionCheck($async$result) ? 3 : 4;
              break;
            case 3:
              // then
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self._trackFuture$1$2("clearVMTimeline", $async$self.callMethod$1("_clearVMTimeline"), S.Response), $async$clearVMTimeline$0);
            case 6:
              // returning from await.
              $async$returnValue = $async$temp1.interceptedTypeCast($async$result, "$isSuccess");
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              t1 = S.Success;
              $async$returnValue = $async$self._trackFuture$1$2("clearVMTimeline", $async$self._vmService._call$1$1(0, "clearVMTimeline", t1), t1);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$clearVMTimeline$0, $async$completer);
    },
    evaluate$5$disableBreakpoints$scope: function(_, isolateId, targetId, expression, disableBreakpoints, scope) {
      var t2, m,
        t1 = P.String;
      H.assertSubtype(scope, "$isMap", [t1, t1], "$asMap");
      t1 = "evaluate " + expression;
      t2 = this._vmService;
      t2.toString;
      m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "targetId", targetId, "expression", expression]);
      if (scope != null)
        m.$indexSet(0, "scope", scope);
      return this._trackFuture$1$2(t1, t2._call$1$2(0, "evaluate", m, null), null);
    },
    evaluate$4$scope: function($receiver, isolateId, targetId, expression, scope) {
      return this.evaluate$5$disableBreakpoints$scope($receiver, isolateId, targetId, expression, null, scope);
    },
    evaluate$3: function($receiver, isolateId, targetId, expression) {
      return this.evaluate$5$disableBreakpoints$scope($receiver, isolateId, targetId, expression, null, null);
    },
    getAllocationProfile$3$gc$reset: function(isolateId, gc, reset) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.AllocationProfile),
        $async$returnValue, $async$self = this, args, t1, m, t2, $async$temp1;
      var $async$getAllocationProfile$3$gc$reset = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.isProtocolVersionLessThan$2$major$minor(3, 18), $async$getAllocationProfile$3$gc$reset);
            case 5:
              // returning from await.
              $async$goto = $async$temp1.boolConversionCheck($async$result) ? 3 : 4;
              break;
            case 3:
              // then
              args = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
              if (gc === true)
                args.$indexSet(0, "gc", "full");
              if (reset === true)
                args.$indexSet(0, "reset", reset);
              $async$goto = 6;
              return P._asyncAwait($async$self._trackFuture$1$2("getAllocationProfile", $async$self.callMethod$3$args$isolateId("_getAllocationProfile", args, isolateId), S.Response), $async$getAllocationProfile$3$gc$reset);
            case 6:
              // returning from await.
              t1 = $async$result.json;
              $async$returnValue = t1 == null ? null : S.AllocationProfile$_fromJson(t1);
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              t1 = $async$self._vmService;
              t1.toString;
              m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId]);
              if (reset === true)
                m.$indexSet(0, "reset", reset);
              if (gc === true)
                m.$indexSet(0, "gc", gc);
              t2 = S.AllocationProfile;
              $async$returnValue = $async$self._trackFuture$1$2("getAllocationProfile", t1._call$1$2(0, "getAllocationProfile", m, t2), t2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getAllocationProfile$3$gc$reset, $async$completer);
    },
    getAllocationProfile$2$gc: function(isolateId, gc) {
      return this.getAllocationProfile$3$gc$reset(isolateId, gc, null);
    },
    getAllocationProfile$2$reset: function(isolateId, reset) {
      return this.getAllocationProfile$3$gc$reset(isolateId, null, reset);
    },
    getCpuProfileTimeline$3: function(isolateId, origin, extent) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Response),
        $async$returnValue, $async$self = this;
      var $async$getCpuProfileTimeline$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self._trackFuture$1$2("getCpuProfileTimeline", $async$self.callMethod$3$args$isolateId("_getCpuProfileTimeline", P.LinkedHashMap__makeLiteral(["tags", "None", "timeOriginMicros", origin, "timeExtentMicros", extent]), isolateId), S.Response);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getCpuProfileTimeline$3, $async$completer);
    },
    getInstances$4$classId: function(isolateId, objectId, limit, classId) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.InstanceSet),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1;
      var $async$getInstances$4$classId = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.isProtocolVersionLessThan$2$major$minor(3, 20), $async$getInstances$4$classId);
            case 5:
              // returning from await.
              $async$goto = $async$temp1.boolConversionCheck($async$result) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait($async$self._trackFuture$1$2("getInstances", $async$self.callMethod$2$args("_getInstances", P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "classId", classId, "limit", limit])), S.Response), $async$getInstances$4$classId);
            case 6:
              // returning from await.
              t1 = $async$result.json;
              $async$returnValue = t1 == null ? null : S.InstanceSet$_fromJson(t1);
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              t1 = $async$self._vmService;
              t1.toString;
              t2 = S.InstanceSet;
              $async$returnValue = $async$self._trackFuture$1$2("getInstances", t1._call$1$2(0, "getInstances", P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "objectId", objectId, "limit", limit]), t2), t2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getInstances$4$classId, $async$completer);
    },
    getVMTimeline$2$timeExtentMicros$timeOriginMicros: function(timeExtentMicros, timeOriginMicros) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Timeline),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1;
      var $async$getVMTimeline$2$timeExtentMicros$timeOriginMicros = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.isProtocolVersionLessThan$2$major$minor(3, 19), $async$getVMTimeline$2$timeExtentMicros$timeOriginMicros);
            case 5:
              // returning from await.
              $async$goto = $async$temp1.boolConversionCheck($async$result) ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait($async$self._trackFuture$1$2("getVMTimeline", $async$self.callMethod$1("_getVMTimeline"), S.Response), $async$getVMTimeline$2$timeExtentMicros$timeOriginMicros);
            case 6:
              // returning from await.
              t1 = $async$result.json;
              $async$returnValue = t1 == null ? null : S.Timeline$_fromJson(t1);
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              t1 = $async$self._vmService;
              t2 = S.Timeline;
              $async$returnValue = $async$self._trackFuture$1$2("getVMTimeline", t1._call$1$2(0, "getVMTimeline", P.LinkedHashMap__makeEmpty(), t2), t2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$getVMTimeline$2$timeExtentMicros$timeOriginMicros, $async$completer);
    },
    getVMTimeline$0: function() {
      return this.getVMTimeline$2$timeExtentMicros$timeOriginMicros(null, null);
    },
    invoke$5$disableBreakpoints: function(isolateId, targetId, selector, argumentIds, disableBreakpoints) {
      var t1, t2, m;
      H.assertSubtype(argumentIds, "$isList", [P.String], "$asList");
      t1 = "invoke " + selector;
      t2 = this._vmService;
      t2.toString;
      m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "targetId", targetId, "selector", selector, "argumentIds", argumentIds]);
      m.$indexSet(0, "disableBreakpoints", true);
      return this._trackFuture$1$2(t1, t2._call$1$2(0, "invoke", m, null), null);
    },
    get$onDebugEvent: function() {
      var t1 = this._vmService._getEventController$1("Debug");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$onExtensionEvent: function() {
      var t1 = this._vmService._getEventController$1("Extension");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$onStderrEvent: function() {
      var t1 = this._vmService._getEventController$1("Stderr");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$onStdoutEvent: function() {
      var t1 = this._vmService._getEventController$1("Stdout");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    resume$3$frameIndex$step: function(_, isolateId, frameIndex, step) {
      var m, t2,
        t1 = this._vmService;
      t1.toString;
      m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId]);
      if (step != null)
        m.$indexSet(0, "step", step);
      t2 = S.Success;
      return this._trackFuture$1$2("resume", t1._call$1$2(0, "resume", m, t2), t2);
    },
    resume$2$step: function($receiver, isolateId, step) {
      return this.resume$3$frameIndex$step($receiver, isolateId, null, step);
    },
    resume$1: function($receiver, isolateId) {
      return this.resume$3$frameIndex$step($receiver, isolateId, null, null);
    },
    setVMTimelineFlags$1: function(recordedStreams) {
      return this.setVMTimelineFlags$body$VmServiceWrapper(H.assertSubtype(recordedStreams, "$isList", [P.String], "$asList"));
    },
    setVMTimelineFlags$body$VmServiceWrapper: function(recordedStreams) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(S.Success),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1;
      var $async$setVMTimelineFlags$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self.isProtocolVersionLessThan$2$major$minor(3, 19), $async$setVMTimelineFlags$1);
            case 5:
              // returning from await.
              $async$goto = $async$temp1.boolConversionCheck($async$result) ? 3 : 4;
              break;
            case 3:
              // then
              $async$temp1 = H;
              $async$goto = 6;
              return P._asyncAwait($async$self._trackFuture$1$2("setVMTimelineFlags", $async$self.callMethod$2$args("_setVMTimelineFlags", P.LinkedHashMap__makeLiteral(["recordedStreams", recordedStreams])), S.Response), $async$setVMTimelineFlags$1);
            case 6:
              // returning from await.
              $async$returnValue = $async$temp1.interceptedTypeCast($async$result, "$isSuccess");
              // goto return
              $async$goto = 1;
              break;
            case 4:
              // join
              t1 = $async$self._vmService;
              t1.toString;
              t2 = S.Success;
              $async$returnValue = $async$self._trackFuture$1$2("setVMTimelineFlags", t1._call$1$2(0, "setVMTimelineFlags", P.LinkedHashMap__makeLiteral(["recordedStreams", H.assertSubtype(recordedStreams, "$isList", [P.String], "$asList")]), t2), t2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$setVMTimelineFlags$1, $async$completer);
    },
    streamListen$1: function(streamId) {
      var t2, t3, future,
        _s12_ = "streamListen",
        t1 = this._activeStreams;
      if (!t1.containsKey$1(0, streamId)) {
        t2 = this._vmService;
        t2.toString;
        t3 = S.Success;
        future = this._trackFuture$1$2(_s12_, t2._call$1$2(0, _s12_, P.LinkedHashMap__makeLiteral(["streamId", streamId]), t3), t3);
        t1.$indexSet(0, streamId, future);
        return future;
      } else
        return t1.$index(0, streamId);
    },
    isProtocolVersionLessThan$2$major$minor: function(major, minor) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(P.bool),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$isProtocolVersionLessThan$2$major$minor = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = $async$self._protocolVersion == null ? 3 : 4;
              break;
            case 3:
              // then
              t1 = S.Version;
              $async$temp1 = H;
              $async$goto = 5;
              return P._asyncAwait($async$self._trackFuture$1$2("getVersion", $async$self._vmService._call$1$1(0, "getVersion", t1), t1), $async$isProtocolVersionLessThan$2$major$minor);
            case 5:
              // returning from await.
              $async$self._protocolVersion = $async$temp1.interceptedTypeCheck($async$result, "$isVersion");
            case 4:
              // join
              $async$returnValue = $async$self.protocolVersionLessThan$2$major$minor(major, minor);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$isProtocolVersionLessThan$2$major$minor, $async$completer);
    },
    protocolVersionLessThan$2$major$minor: function(major, minor) {
      var t1 = this._protocolVersion,
        t2 = t1.major;
      if (typeof t2 !== "number")
        return t2.$lt();
      if (t2 >= major)
        if (t2 === major) {
          t1 = t1.minor;
          if (typeof t1 !== "number")
            return t1.$lt();
          t1 = t1 < minor;
        } else
          t1 = false;
      else
        t1 = true;
      return t1;
    },
    _trackFuture$1$2: function($name, future, $T) {
      H.assertSubtype(future, "$isFuture", [$T], "$asFuture");
      return future;
    },
    $isVmService: 1
  };
  U.TrackedFuture.prototype = {};
  G.get_closure.prototype = {
    call$1: function(client) {
      return client._sendUnstreamed$3("GET", this.url, this.headers);
    },
    $signature: 234
  };
  E.BaseClient.prototype = {
    _sendUnstreamed$3: function(method, url, headers) {
      return this._sendUnstreamed$body$BaseClient(method, url, headers);
    },
    _sendUnstreamed$body$BaseClient: function(method, url, headers) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(U.Response0),
        $async$returnValue, $async$self = this, t1, t2, $async$temp1;
      var $async$_sendUnstreamed$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              url = P.Uri_parse(url, 0, null);
              t1 = new Uint8Array(0);
              t2 = P.String;
              t2 = P.LinkedHashMap_LinkedHashMap(new G.BaseRequest_closure(), new G.BaseRequest_closure0(), t2, t2);
              $async$temp1 = U;
              $async$goto = 3;
              return P._asyncAwait($async$self.send$1(0, new O.Request(C.C_Utf8Codec, t1, method, url, t2)), $async$_sendUnstreamed$3);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.Response_fromStream($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_sendUnstreamed$3, $async$completer);
    },
    $isClient: 1
  };
  G.BaseRequest.prototype = {
    finalize$0: function() {
      if (this._finalized)
        throw H.wrapException(P.StateError$("Can't finalize a finalized Request."));
      this._finalized = true;
      return;
    },
    toString$0: function(_) {
      return this.method + " " + H.S(this.url);
    }
  };
  G.BaseRequest_closure.prototype = {
    call$2: function(key1, key2) {
      H.stringTypeCheck(key1);
      H.stringTypeCheck(key2);
      return key1.toLowerCase() === key2.toLowerCase();
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 235
  };
  G.BaseRequest_closure0.prototype = {
    call$1: function(key) {
      return C.JSString_methods.get$hashCode(H.stringTypeCheck(key).toLowerCase());
    },
    $signature: 236
  };
  T.BaseResponse.prototype = {
    BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request: function(statusCode, contentLength, headers, isRedirect, persistentConnection, reasonPhrase, request) {
      var t1 = this.statusCode;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 100)
        throw H.wrapException(P.ArgumentError$("Invalid status code " + t1 + "."));
    }
  };
  O.BrowserClient.prototype = {
    send$1: function(_, request) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(X.StreamedResponse),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, xhr, completer, t1, bytes, t2, t3, t4;
      var $async$send$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              request.super$BaseRequest$finalize();
              t1 = [P.List, P.int];
              $async$goto = 3;
              return P._asyncAwait(new Z.ByteStream(P.Stream_Stream$fromIterable(H.setRuntimeTypeInfo([request._bodyBytes], [t1]), t1)).toBytes$0(), $async$send$1);
            case 3:
              // returning from await.
              bytes = $async$result;
              xhr = new XMLHttpRequest();
              t1 = $async$self._xhrs;
              t1.add$1(0, xhr);
              t2 = J.toString$0$(request.url);
              t3 = H.interceptedTypeCheck(xhr, "$isHttpRequest");
              (t3 && C.HttpRequest_methods).open$5$async$password$user(t3, request.method, t2, true, null, null);
              xhr.responseType = "blob";
              xhr.withCredentials = false;
              request.headers.forEach$1(0, J.get$setRequestHeader$x(xhr));
              t2 = X.StreamedResponse;
              completer = new P._AsyncCompleter(new P._Future($.Zone__current, [t2]), [t2]);
              t2 = [W.ProgressEvent];
              t3 = new W._EventStream(H.interceptedTypeCheck(xhr, "$isEventTarget"), "load", false, t2);
              t4 = -1;
              t3.get$first(t3).then$1$1(new O.BrowserClient_send_closure(xhr, completer, request), t4);
              t2 = new W._EventStream(H.interceptedTypeCheck(xhr, "$isEventTarget"), "error", false, t2);
              t2.get$first(t2).then$1$1(new O.BrowserClient_send_closure0(completer, request), t4);
              J.send$1$x(xhr, bytes);
              $async$handler = 4;
              $async$goto = 7;
              return P._asyncAwait(completer.future, $async$send$1);
            case 7:
              // returning from await.
              t2 = $async$result;
              $async$returnValue = t2;
              $async$next = [1];
              // goto finally
              $async$goto = 5;
              break;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              t1.remove$1(0, xhr);
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$send$1, $async$completer);
    },
    close$0: function(_) {
      var t1;
      for (t1 = this._xhrs, t1 = P._LinkedHashSetIterator$(t1, t1._collection$_modifications, H.getTypeArgumentByIndex(t1, 0)); t1.moveNext$0();)
        t1._collection$_current.abort();
    }
  };
  O.BrowserClient_send_closure.prototype = {
    call$1: function(_) {
      var t1, blob, reader, t2, t3, t4, t5;
      H.interceptedTypeCheck(_, "$isProgressEvent");
      t1 = this.xhr;
      blob = W._convertNativeToDart_XHR_Response(t1.response) == null ? W.Blob_Blob([]) : W._convertNativeToDart_XHR_Response(t1.response);
      reader = new FileReader();
      t2 = [W.ProgressEvent];
      t3 = new W._EventStream(reader, "load", false, t2);
      t4 = this.completer;
      t5 = this.request;
      t3.get$first(t3).then$1$1(new O.BrowserClient_send__closure(reader, t4, t1, t5), null);
      t2 = new W._EventStream(reader, "error", false, t2);
      t2.get$first(t2).then$1$1(new O.BrowserClient_send__closure0(t4, t5), null);
      reader.readAsArrayBuffer(H.interceptedTypeCheck(blob, "$isBlob"));
    },
    $signature: 22
  };
  O.BrowserClient_send__closure.prototype = {
    call$1: function(_) {
      var body, t1, t2, t3, t4, t5, t6, _this = this;
      H.interceptedTypeCheck(_, "$isProgressEvent");
      body = H.interceptedTypeCast(C.FileReader_methods.get$result(_this.reader), "$isUint8List");
      t1 = [P.List, P.int];
      t1 = P.Stream_Stream$fromIterable(H.setRuntimeTypeInfo([body], [t1]), t1);
      t2 = _this.xhr;
      t3 = t2.status;
      t4 = body.length;
      t5 = _this.request;
      t6 = C.HttpRequest_methods.get$responseHeaders(t2);
      t2 = t2.statusText;
      t1 = new X.StreamedResponse(B.toByteStream(new Z.ByteStream(t1)), t5, t3, t2, t4, t6, false, true);
      t1.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(t3, t4, t6, false, true, t2, t5);
      _this.completer.complete$1(0, t1);
    },
    $signature: 22
  };
  O.BrowserClient_send__closure0.prototype = {
    call$1: function(error) {
      this.completer.completeError$2(new E.ClientException(J.toString$0$(H.interceptedTypeCheck(error, "$isProgressEvent"))), P.StackTrace_current());
    },
    $signature: 22
  };
  O.BrowserClient_send_closure0.prototype = {
    call$1: function(_) {
      H.interceptedTypeCheck(_, "$isProgressEvent");
      this.completer.completeError$2(new E.ClientException("XMLHttpRequest error."), P.StackTrace_current());
    },
    $signature: 22
  };
  Z.ByteStream.prototype = {
    toBytes$0: function() {
      var t1 = P.Uint8List,
        t2 = new P._Future($.Zone__current, [t1]),
        completer = new P._AsyncCompleter(t2, [t1]),
        sink = new P._ByteCallbackSink(new Z.ByteStream_toBytes_closure(completer), new Uint8Array(1024));
      this.listen$4$cancelOnError$onDone$onError(sink.get$add(sink), true, sink.get$close(sink), completer.get$completeError());
      return t2;
    },
    $asStream: function() {
      return [[P.List, P.int]];
    },
    $asStreamView: function() {
      return [[P.List, P.int]];
    }
  };
  Z.ByteStream_toBytes_closure.prototype = {
    call$1: function(bytes) {
      return this.completer.complete$1(0, new Uint8Array(H._ensureNativeList(H.assertSubtype(bytes, "$isList", [P.int], "$asList"))));
    },
    $signature: 237
  };
  U.Client.prototype = {};
  E.ClientException.prototype = {
    toString$0: function(_) {
      return this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  O.Request.prototype = {};
  U.Response0.prototype = {};
  U.Response_fromStream_closure.prototype = {
    call$1: function(body) {
      var t1, t2, t3, t4, t5, t6;
      H.interceptedTypeCheck(body, "$isUint8List");
      t1 = this.response;
      t2 = t1.statusCode;
      t3 = t1.request;
      t4 = t1.headers;
      t1 = t1.reasonPhrase;
      t5 = B.toUint8List(body);
      t6 = body.length;
      t5 = new U.Response0(t5, t3, t2, t1, t6, t4, false, true);
      t5.BaseResponse$7$contentLength$headers$isRedirect$persistentConnection$reasonPhrase$request(t2, t6, t4, false, true, t1, t3);
      return t5;
    },
    $signature: 238
  };
  X.StreamedResponse.prototype = {};
  Z.CaseInsensitiveMap.prototype = {
    $asMap: function($V) {
      return [P.String, $V];
    },
    $asCanonicalizedMap: function($V) {
      return [P.String, P.String, $V];
    }
  };
  Z.CaseInsensitiveMap$from_closure.prototype = {
    call$1: function(key) {
      return H.stringTypeCheck(key).toLowerCase();
    },
    $signature: 5
  };
  Z.CaseInsensitiveMap$from_closure0.prototype = {
    call$1: function(key) {
      return key != null;
    },
    $signature: 30
  };
  R.MediaType.prototype = {
    toString$0: function(_) {
      var buffer = new P.StringBuffer(""),
        t1 = this.type;
      buffer._contents = t1;
      t1 += "/";
      buffer._contents = t1;
      buffer._contents = t1 + this.subtype;
      t1 = this.parameters;
      J.forEach$1$ax(t1._collection$_map, H.functionTypeCheck(new R.MediaType_toString_closure(buffer), {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]}));
      t1 = buffer._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    }
  };
  R.MediaType_MediaType$parse_closure.prototype = {
    call$0: function() {
      var t3, type, subtype, t4, parameters, t5, success, attribute, value,
        t1 = this.mediaType,
        scanner = new X.StringScanner(null, t1),
        t2 = $.$get$whitespace();
      scanner.scan$1(t2);
      t3 = $.$get$token();
      scanner.expect$1(t3);
      type = scanner.get$lastMatch().$index(0, 0);
      scanner.expect$1("/");
      scanner.expect$1(t3);
      subtype = scanner.get$lastMatch().$index(0, 0);
      scanner.scan$1(t2);
      t4 = P.String;
      parameters = P.LinkedHashMap_LinkedHashMap$_empty(t4, t4);
      while (true) {
        t4 = scanner._lastMatch = C.JSString_methods.matchAsPrefix$2(";", t1, scanner._string_scanner$_position);
        t5 = scanner._lastMatchPosition = scanner._string_scanner$_position;
        success = t4 != null;
        t4 = success ? scanner._lastMatchPosition = scanner._string_scanner$_position = t4.get$end(t4) : t5;
        if (!success)
          break;
        t4 = scanner._lastMatch = t2.matchAsPrefix$2(0, t1, t4);
        scanner._lastMatchPosition = scanner._string_scanner$_position;
        if (t4 != null)
          scanner._lastMatchPosition = scanner._string_scanner$_position = t4.get$end(t4);
        scanner.expect$1(t3);
        if (scanner._string_scanner$_position !== scanner._lastMatchPosition)
          scanner._lastMatch = null;
        attribute = scanner._lastMatch.$index(0, 0);
        scanner.expect$1("=");
        t4 = scanner._lastMatch = t3.matchAsPrefix$2(0, t1, scanner._string_scanner$_position);
        t5 = scanner._lastMatchPosition = scanner._string_scanner$_position;
        success = t4 != null;
        if (success) {
          t4 = scanner._lastMatchPosition = scanner._string_scanner$_position = t4.get$end(t4);
          t5 = t4;
        } else
          t4 = t5;
        if (success) {
          if (t4 !== t5)
            scanner._lastMatch = null;
          value = scanner._lastMatch.$index(0, 0);
        } else
          value = N.expectQuotedString(scanner);
        t4 = scanner._lastMatch = t2.matchAsPrefix$2(0, t1, scanner._string_scanner$_position);
        scanner._lastMatchPosition = scanner._string_scanner$_position;
        if (t4 != null)
          scanner._lastMatchPosition = scanner._string_scanner$_position = t4.get$end(t4);
        parameters.$indexSet(0, attribute, value);
      }
      scanner.expectDone$0();
      return R.MediaType$(type, subtype, parameters);
    },
    $signature: 239
  };
  R.MediaType_toString_closure.prototype = {
    call$2: function(attribute, value) {
      var t1, t2;
      H.stringTypeCheck(attribute);
      H.stringTypeCheck(value);
      t1 = this.buffer;
      t1._contents += "; " + H.S(attribute) + "=";
      t2 = $.$get$nonToken()._nativeRegExp;
      if (typeof value !== "string")
        H.throwExpression(H.argumentErrorValue(value));
      if (t2.test(value)) {
        t1._contents += '"';
        t2 = $.$get$_escapedChar();
        value.toString;
        t2 = t1._contents += J.splitMapJoin$2$onMatch$s(value, t2, H.functionTypeCheck(new R.MediaType_toString__closure(), {func: 1, ret: P.String, args: [P.Match]}));
        t1._contents = t2 + '"';
      } else
        t1._contents += H.S(value);
    },
    $signature: 240
  };
  R.MediaType_toString__closure.prototype = {
    call$1: function(match) {
      return C.JSString_methods.$add("\\", match.$index(0, 0));
    },
    $signature: 91
  };
  N.expectQuotedString_closure.prototype = {
    call$1: function(match) {
      return match.$index(0, 1);
    },
    $signature: 91
  };
  B.DateSymbols.prototype = {
    toString$0: function(_) {
      return this.NAME;
    }
  };
  T.DateFormat.prototype = {
    format$1: function(date) {
      var t1, _this = this,
        result = new P.StringBuffer("");
      if (_this._formatFieldsPrivate == null) {
        if (_this._intl$_pattern == null) {
          _this.addPattern$1("yMMMMd");
          _this.addPattern$1("jms");
        }
        _this.set$_formatFieldsPrivate(_this.parsePattern$1(_this._intl$_pattern));
      }
      t1 = _this._formatFieldsPrivate;
      (t1 && C.JSArray_methods).forEach$1(t1, new T.DateFormat_format_closure(result, date));
      t1 = result._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _appendPattern$2: function(inputPattern, separator) {
      var t1 = this._intl$_pattern;
      this._intl$_pattern = t1 == null ? inputPattern : t1 + separator + H.S(inputPattern);
    },
    addPattern$1: function(inputPattern) {
      var t1, t2, _this = this;
      _this.set$_formatFieldsPrivate(null);
      t1 = $.$get$dateTimePatterns();
      t2 = _this._locale;
      t1.toString;
      if (!H.boolConversionCheck(H.interceptedTypeCheck(t2 === "en_US" ? t1.fallbackData : t1._throwException$0(), "$isMap").containsKey$1(0, inputPattern)))
        _this._appendPattern$2(inputPattern, " ");
      else {
        t1 = $.$get$dateTimePatterns();
        t2 = _this._locale;
        t1.toString;
        _this._appendPattern$2(H.stringTypeCheck(H.interceptedTypeCheck(t2 === "en_US" ? t1.fallbackData : t1._throwException$0(), "$isMap").$index(0, inputPattern)), " ");
      }
      return _this;
    },
    get$dateSymbols: function() {
      var t2,
        t1 = this._locale;
      if (t1 != $.lastDateSymbolLocale) {
        $.lastDateSymbolLocale = t1;
        t2 = $.$get$_dateTimeSymbols();
        t2.toString;
        $.cachedDateSymbols = H.interceptedTypeCheck(t1 === "en_US" ? t2.fallbackData : t2._throwException$0(), "$isDateSymbols");
      }
      return $.cachedDateSymbols;
    },
    get$useNativeDigits: function() {
      var t1 = this._useNativeDigits;
      if (t1 == null) {
        $.DateFormat__useNativeDigitsByDefault.$index(0, this._locale);
        t1 = this._useNativeDigits = true;
      }
      return t1;
    },
    _localizeDigits$1: function(numberString) {
      var t1, t2, newDigits, i, t3, t4, _this = this;
      if (!(H.boolConversionCheck(_this.get$useNativeDigits()) && _this._localeZeroCodeUnit != $.$get$DateFormat__asciiZeroCodeUnit()))
        return numberString;
      t1 = numberString.length;
      t2 = new Array(t1);
      t2.fixed$length = Array;
      newDigits = H.setRuntimeTypeInfo(t2, [P.int]);
      for (i = 0; i < t1; ++i) {
        t2 = C.JSString_methods._codeUnitAt$1(numberString, i);
        t3 = _this._localeZeroCodeUnit;
        if (t3 == null) {
          t3 = _this._localeZero;
          if (t3 == null) {
            t3 = _this._useNativeDigits;
            if (t3 == null) {
              $.DateFormat__useNativeDigitsByDefault.$index(0, _this._locale);
              t3 = _this._useNativeDigits = true;
            }
            if (t3) {
              t3 = _this._locale;
              if (t3 != $.lastDateSymbolLocale) {
                $.lastDateSymbolLocale = t3;
                t4 = $.$get$_dateTimeSymbols();
                t4.toString;
                $.cachedDateSymbols = H.interceptedTypeCheck(t3 === "en_US" ? t4.fallbackData : t4._throwException$0(), "$isDateSymbols");
              }
              $.cachedDateSymbols.toString;
            }
            t3 = _this._localeZero = "0";
          }
          t3 = _this._localeZeroCodeUnit = C.JSString_methods._codeUnitAt$1(t3, 0);
        }
        t4 = $.$get$DateFormat__asciiZeroCodeUnit();
        if (typeof t4 !== "number")
          return H.iae(t4);
        C.JSArray_methods.$indexSet(newDigits, i, t2 + t3 - t4);
      }
      return P.String_String$fromCharCodes(newDigits, 0, null);
    },
    parsePattern$1: function(pattern) {
      var t1;
      if (pattern == null)
        return;
      t1 = this._parsePatternHelper$1(pattern);
      return new H.ReversedListIterable(t1, [H.getTypeArgumentByIndex(t1, 0)]).toList$0(0);
    },
    _parsePatternHelper$1: function(pattern) {
      var matched, parsed;
      if (pattern.length === 0)
        return H.setRuntimeTypeInfo([], [T._DateFormatField]);
      matched = this._intl$_match$1(pattern);
      if (matched == null)
        return H.setRuntimeTypeInfo([], [T._DateFormatField]);
      parsed = this._parsePatternHelper$1(C.JSString_methods.substring$1(pattern, matched.fullPattern$0().length));
      C.JSArray_methods.add$1(parsed, matched);
      return parsed;
    },
    _intl$_match$1: function(pattern) {
      var i, t1, match, t2;
      for (i = 0; t1 = $.$get$DateFormat__matchers(), i < 3; ++i) {
        match = t1[i].firstMatch$1(pattern);
        if (match != null) {
          t1 = T.DateFormat__fieldConstructors()[i];
          t2 = match._match;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          return H.interceptedTypeCheck(t1.call$2(t2[0], this), "$is_DateFormatField");
        }
      }
      return;
    },
    set$_formatFieldsPrivate: function(_formatFieldsPrivate) {
      this._formatFieldsPrivate = H.assertSubtype(_formatFieldsPrivate, "$isList", [T._DateFormatField], "$asList");
    }
  };
  T.DateFormat_format_closure.prototype = {
    call$1: function(field) {
      this.result._contents += H.S(H.interceptedTypeCheck(field, "$is_DateFormatField").format$1(this.date));
      return;
    },
    $signature: 242
  };
  T.DateFormat__fieldConstructors_closure.prototype = {
    call$2: function(pattern, $parent) {
      var t1 = T._DateFormatQuotedField__patchQuotes(pattern),
        t2 = new T._DateFormatQuotedField(t1, $parent);
      C.JSString_methods.trim$0(t1);
      t2._fullPattern = pattern;
      return t2;
    },
    $signature: 243
  };
  T.DateFormat__fieldConstructors_closure0.prototype = {
    call$2: function(pattern, $parent) {
      J.trim$0$s(pattern);
      return new T._DateFormatPatternField(pattern, $parent);
    },
    $signature: 366
  };
  T.DateFormat__fieldConstructors_closure1.prototype = {
    call$2: function(pattern, $parent) {
      J.trim$0$s(pattern);
      return new T._DateFormatLiteralField(pattern, $parent);
    },
    $signature: 245
  };
  T._DateFormatField.prototype = {
    fullPattern$0: function() {
      return this.pattern;
    },
    toString$0: function(_) {
      return this.pattern;
    },
    format$1: function(date) {
      return this.pattern;
    }
  };
  T._DateFormatLiteralField.prototype = {};
  T._DateFormatQuotedField.prototype = {
    fullPattern$0: function() {
      return this._fullPattern;
    }
  };
  T._DateFormatPatternField.prototype = {
    format$1: function(date) {
      return this.formatField$1(date);
    },
    formatField$1: function(date) {
      var hours, index, era, year, _this = this, _s1_ = "0",
        t1 = _this.pattern,
        t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      switch (t1[0]) {
        case "a":
          hours = H.Primitives_getHours(date);
          index = hours >= 12 && hours < 24 ? 1 : 0;
          return _this.parent.get$dateSymbols().AMPMS[index];
        case "c":
          return _this.formatStandaloneDay$1(date);
        case "d":
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getDay(date), t2, _s1_));
        case "D":
          t1 = H.Primitives_valueFromDecomposedDate(H.Primitives_getYear(date), 2, 29, 0, 0, 0, 0, false);
          if (typeof t1 !== "number" || Math.floor(t1) !== t1)
            H.throwExpression(H.argumentErrorValue(t1));
          t1 = T._dayOfYear(H.Primitives_getMonth(date), H.Primitives_getDay(date), H.Primitives_getMonth(new P.DateTime(t1, false)) === 2);
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + t1, t2, _s1_));
        case "E":
          t1 = _this.parent;
          t1 = t2 >= 4 ? t1.get$dateSymbols().WEEKDAYS : t1.get$dateSymbols().SHORTWEEKDAYS;
          return t1[C.JSInt_methods.$mod(H.Primitives_getWeekday(date), 7)];
        case "G":
          era = H.Primitives_getYear(date) > 0 ? 1 : 0;
          t1 = _this.parent;
          return t2 >= 4 ? t1.get$dateSymbols().ERANAMES[era] : t1.get$dateSymbols().ERAS[era];
        case "h":
          hours = H.Primitives_getHours(date);
          if (H.Primitives_getHours(date) > 12)
            hours -= 12;
          if (hours === 0)
            hours = 12;
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + hours, t2, _s1_));
        case "H":
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getHours(date), t2, _s1_));
        case "K":
          t1 = C.JSInt_methods.$mod(H.Primitives_getHours(date), 12);
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + t1, t2, _s1_));
        case "k":
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getHours(date), t2, _s1_));
        case "L":
          return _this.formatStandaloneMonth$1(date);
        case "M":
          return _this.formatMonth$1(date);
        case "m":
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getMinutes(date), t2, _s1_));
        case "Q":
          return _this.formatQuarter$1(date);
        case "S":
          return _this.formatFractionalSeconds$1(date);
        case "s":
          return _this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getSeconds(date), t2, _s1_));
        case "v":
          return _this.formatTimeZoneId$1(date);
        case "y":
          year = H.Primitives_getYear(date);
          if (year < 0)
            year = -year;
          t1 = _this.parent;
          return t2 === 2 ? t1._localizeDigits$1(C.JSString_methods.padLeft$2("" + C.JSInt_methods.$mod(year, 100), 2, _s1_)) : t1._localizeDigits$1(C.JSString_methods.padLeft$2("" + year, t2, _s1_));
        case "z":
          return _this.formatTimeZone$1(date);
        case "Z":
          return _this.formatTimeZoneRFC$1(date);
        default:
          return "";
      }
    },
    formatMonth$1: function(date) {
      var t1 = this.pattern.length,
        t2 = this.parent;
      switch (t1) {
        case 5:
          t1 = t2.get$dateSymbols().NARROWMONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        case 4:
          t1 = t2.get$dateSymbols().MONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        case 3:
          t1 = t2.get$dateSymbols().SHORTMONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        default:
          return t2._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getMonth(date), t1, "0"));
      }
    },
    formatFractionalSeconds$1: function(date) {
      var basic = this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getMilliseconds(date), 3, "0")),
        t1 = this.pattern.length - 3;
      if (t1 > 0)
        return basic + this.parent._localizeDigits$1(C.JSString_methods.padLeft$2("0", t1, "0"));
      else
        return basic;
    },
    formatStandaloneDay$1: function(date) {
      var t1 = this.pattern.length,
        t2 = this.parent;
      switch (t1) {
        case 5:
          return t2.get$dateSymbols().STANDALONENARROWWEEKDAYS[C.JSInt_methods.$mod(H.Primitives_getWeekday(date), 7)];
        case 4:
          return t2.get$dateSymbols().STANDALONEWEEKDAYS[C.JSInt_methods.$mod(H.Primitives_getWeekday(date), 7)];
        case 3:
          return t2.get$dateSymbols().STANDALONESHORTWEEKDAYS[C.JSInt_methods.$mod(H.Primitives_getWeekday(date), 7)];
        default:
          return t2._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getDay(date), 1, "0"));
      }
    },
    formatStandaloneMonth$1: function(date) {
      var t1 = this.pattern.length,
        t2 = this.parent;
      switch (t1) {
        case 5:
          t1 = t2.get$dateSymbols().STANDALONENARROWMONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        case 4:
          t1 = t2.get$dateSymbols().STANDALONEMONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        case 3:
          t1 = t2.get$dateSymbols().STANDALONESHORTMONTHS;
          t2 = H.Primitives_getMonth(date) - 1;
          if (t2 < 0 || t2 >= 12)
            return H.ioore(t1, t2);
          return t1[t2];
        default:
          return t2._localizeDigits$1(C.JSString_methods.padLeft$2("" + H.Primitives_getMonth(date), t1, "0"));
      }
    },
    formatQuarter$1: function(date) {
      var quarter = C.JSDouble_methods.toInt$0((H.Primitives_getMonth(date) - 1) / 3),
        t1 = this.pattern.length,
        t2 = this.parent;
      switch (t1) {
        case 4:
          t1 = t2.get$dateSymbols().QUARTERS;
          if (quarter < 0 || quarter >= 4)
            return H.ioore(t1, quarter);
          return t1[quarter];
        case 3:
          t1 = t2.get$dateSymbols().SHORTQUARTERS;
          if (quarter < 0 || quarter >= 4)
            return H.ioore(t1, quarter);
          return t1[quarter];
        default:
          return t2._localizeDigits$1(C.JSString_methods.padLeft$2("" + (quarter + 1), t1, "0"));
      }
    },
    formatTimeZoneId$1: function(date) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    formatTimeZone$1: function(date) {
      throw H.wrapException(P.UnimplementedError$(null));
    },
    formatTimeZoneRFC$1: function(date) {
      throw H.wrapException(P.UnimplementedError$(null));
    }
  };
  T.NumberFormat.prototype = {
    set$_multiplier: function(x) {
      var t1, t2;
      this._internalMultiplier = x;
      t1 = Math.log(x);
      t2 = $.$get$NumberFormat__ln10();
      if (typeof t2 !== "number")
        return H.iae(t2);
      this._multiplierDigits = C.JSDouble_methods.round$0(t1 / t2);
    },
    format$1: function(number) {
      var t2, _this = this,
        t1 = typeof number === "number";
      if (t1 && isNaN(number))
        return _this._symbols.NAN;
      if (t1)
        t1 = number == 1 / 0 || number == -1 / 0;
      else
        t1 = false;
      if (t1) {
        t1 = J.get$isNegative$n(number) ? _this._negativePrefix : _this._positivePrefix;
        return t1 + _this._symbols.INFINITY;
      }
      t1 = J.getInterceptor$n(number).get$isNegative(number) ? _this._negativePrefix : _this._positivePrefix;
      t2 = _this._buffer;
      t2._contents += t1;
      t1 = Math.abs(number);
      if (_this._useExponentialNotation)
        _this._formatExponential$1(t1);
      else
        _this._formatFixed$1(t1);
      t1 = t2._contents += C.JSNumber_methods.get$isNegative(number) ? _this._negativeSuffix : _this._positiveSuffix;
      t2._contents = "";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _formatExponential$1: function(number) {
      var t1, t2, exponent, mantissa, _this = this;
      if (number === 0) {
        _this._formatFixed$1(number);
        _this._formatExponent$1(0);
        return;
      }
      t1 = Math.log(number);
      t2 = $.$get$NumberFormat__ln10();
      if (typeof t2 !== "number")
        return H.iae(t2);
      exponent = C.JSDouble_methods.floor$0(t1 / t2);
      mantissa = number / Math.pow(10, exponent);
      t1 = _this.maximumIntegerDigits;
      if (t1 > 1 && t1 > _this.minimumIntegerDigits)
        for (; C.JSInt_methods.$mod(exponent, t1) !== 0;) {
          mantissa *= 10;
          --exponent;
        }
      else {
        t1 = _this.minimumIntegerDigits;
        if (t1 < 1) {
          ++exponent;
          mantissa /= 10;
        } else {
          --t1;
          exponent -= t1;
          mantissa *= Math.pow(10, t1);
        }
      }
      _this._formatFixed$1(mantissa);
      _this._formatExponent$1(exponent);
    },
    _formatExponent$1: function(exponent) {
      var _this = this,
        t1 = _this._symbols,
        t2 = _this._buffer,
        t3 = t2._contents += t1.EXP_SYMBOL;
      if (exponent < 0) {
        exponent = -exponent;
        t2._contents = t3 + t1.MINUS_SIGN;
      } else if (_this._useSignForPositiveExponent)
        t2._contents = t3 + t1.PLUS_SIGN;
      t1 = _this.minimumExponentDigits;
      t3 = C.JSInt_methods.toString$0(exponent);
      if (_this._zeroOffset === 0)
        t2._contents += C.JSString_methods.padLeft$2(t3, t1, "0");
      else
        _this._slowPad$2(t1, t3);
    },
    _floor$1: function(number) {
      var t1;
      if (C.JSNumber_methods.get$isNegative(number) && !C.JSNumber_methods.get$isNegative(Math.abs(number)))
        throw H.wrapException(P.ArgumentError$("Internal error: expected positive number, got " + H.S(number)));
      t1 = C.JSNumber_methods.floor$0(number);
      return t1;
    },
    _round$1: function(number) {
      if (number == 1 / 0 || number == -1 / 0)
        return $.$get$NumberFormat__maxInt();
      else
        return C.JSNumber_methods.round$0(number);
    },
    _formatFixed$1: function(number) {
      var integerPart, fractionPart, extraIntegerDigits, power, fraction, digitMultiplier, remainingDigits, t2, howManyDigitsTooBig, divisor, paddingDigits, extra, intDigits, integerDigits, digitLength, fractionPresent, i, _this = this,
        fractionDigits = _this.maximumFractionDigits,
        t1 = number == 1 / 0 || number == -1 / 0;
      if (t1) {
        integerPart = C.JSNumber_methods.toInt$0(number);
        fractionPart = 0;
        extraIntegerDigits = 0;
        power = 0;
      } else {
        integerPart = _this._floor$1(number);
        fraction = number - integerPart;
        if (C.JSNumber_methods.toInt$0(fraction) !== 0) {
          integerPart = number;
          fraction = 0;
        }
        H.checkNum(fractionDigits);
        power = H.intTypeCheck(Math.pow(10, fractionDigits));
        digitMultiplier = power * _this._internalMultiplier;
        remainingDigits = C.JSNumber_methods.toInt$0(_this._round$1(fraction * digitMultiplier));
        if (remainingDigits >= digitMultiplier) {
          ++integerPart;
          remainingDigits -= digitMultiplier;
        }
        extraIntegerDigits = C.JSInt_methods.$tdiv(remainingDigits, power);
        fractionPart = C.JSInt_methods.$mod(remainingDigits, power);
      }
      t1 = $.$get$NumberFormat__maxInt();
      if (integerPart > t1) {
        t1 = Math.log(integerPart);
        t2 = $.$get$NumberFormat__ln10();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = C.JSDouble_methods.ceil$0(t1 / t2);
        t1 = $.$get$NumberFormat__maxDigits();
        if (typeof t1 !== "number")
          return H.iae(t1);
        howManyDigitsTooBig = t2 - t1;
        divisor = C.JSNumber_methods.round$0(Math.pow(10, howManyDigitsTooBig));
        if (divisor === 0)
          divisor = Math.pow(10, howManyDigitsTooBig);
        paddingDigits = C.JSString_methods.$mul("0", C.JSInt_methods.toInt$0(howManyDigitsTooBig));
        integerPart = C.JSDouble_methods.toInt$0(integerPart / divisor);
      } else
        paddingDigits = "";
      extra = extraIntegerDigits === 0 ? "" : C.JSInt_methods.toString$0(extraIntegerDigits);
      intDigits = _this._mainIntegerDigits$1(integerPart);
      integerDigits = intDigits + (intDigits.length === 0 ? extra : C.JSString_methods.padLeft$2(extra, _this._multiplierDigits, "0")) + paddingDigits;
      digitLength = integerDigits.length;
      if (typeof fractionDigits !== "number")
        return fractionDigits.$gt();
      if (fractionDigits > 0) {
        t1 = _this.minimumFractionDigits;
        if (typeof t1 !== "number")
          return t1.$gt();
        fractionPresent = t1 > 0 || fractionPart > 0;
      } else
        fractionPresent = false;
      if (digitLength !== 0 || _this.minimumIntegerDigits > 0) {
        integerDigits = C.JSString_methods.$mul("0", _this.minimumIntegerDigits - digitLength) + integerDigits;
        digitLength = integerDigits.length;
        for (t1 = _this._buffer, i = 0; i < digitLength; ++i) {
          t1._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(integerDigits, i) + _this._zeroOffset);
          _this._group$2(digitLength, i);
        }
      } else if (!fractionPresent)
        _this._buffer._contents += _this._symbols.ZERO_DIGIT;
      if (_this._decimalSeparatorAlwaysShown || fractionPresent)
        _this._buffer._contents += _this._symbols.DECIMAL_SEP;
      _this._formatFractionPart$1(C.JSInt_methods.toString$0(fractionPart + power));
    },
    _mainIntegerDigits$1: function(integer) {
      var digits;
      if (integer === 0)
        return "";
      digits = C.JSNumber_methods.toString$0(integer);
      return C.JSString_methods.startsWith$1(digits, "-") ? C.JSString_methods.substring$1(digits, 1) : digits;
    },
    _formatFractionPart$1: function(fractionPart) {
      var fractionLength0, t2, i,
        fractionLength = fractionPart.length,
        t1 = this.minimumFractionDigits;
      while (true) {
        fractionLength0 = fractionLength - 1;
        if (C.JSString_methods.codeUnitAt$1(fractionPart, fractionLength0) === 48) {
          if (typeof t1 !== "number")
            return t1.$add();
          t2 = fractionLength > t1 + 1;
        } else
          t2 = false;
        if (!t2)
          break;
        fractionLength = fractionLength0;
      }
      for (t1 = this._buffer, i = 1; i < fractionLength; ++i)
        t1._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(fractionPart, i) + this._zeroOffset);
    },
    _slowPad$2: function(numberOfDigits, basic) {
      var t1, t2, t3, i;
      for (t1 = basic.length, t2 = numberOfDigits - t1, t3 = this._buffer, i = 0; i < t2; ++i)
        t3._contents += this._symbols.ZERO_DIGIT;
      for (i = 0; i < t1; ++i)
        t3._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1(basic, i) + this._zeroOffset);
    },
    _group$2: function(totalLength, position) {
      var t1, _this = this,
        distanceFromEnd = totalLength - position;
      if (distanceFromEnd <= 1 || _this._groupingSize <= 0)
        return;
      t1 = _this._finalGroupingSize;
      if (distanceFromEnd === t1 + 1)
        _this._buffer._contents += _this._symbols.GROUP_SEP;
      else if (distanceFromEnd > t1 && C.JSInt_methods.$mod(distanceFromEnd - t1, _this._groupingSize) === 1)
        _this._buffer._contents += _this._symbols.GROUP_SEP;
    },
    _setPattern$1: function(newPattern) {
      var t1, t2, _this = this;
      if (newPattern == null)
        return;
      _this._intl$_pattern = H.stringReplaceAllUnchecked(newPattern, " ", "\xa0");
      t1 = _this._currencySymbol;
      if (t1 == null)
        t1 = _this.currencyName;
      t2 = new T._StringIterator(newPattern);
      t2.moveNext$0();
      new T._NumberFormatParser(_this, t2, t1).parse$0(0);
      t1 = _this._decimalDigits;
      t2 = t1 == null;
      if (!t2 || false) {
        if (t2) {
          t1 = $.currencyFractionDigits.$index(0, _this.currencyName.toUpperCase());
          t1 = _this._decimalDigits = t1 == null ? $.currencyFractionDigits.$index(0, "DEFAULT") : t1;
        }
        _this.maximumFractionDigits = _this.minimumFractionDigits = t1;
      }
    },
    toString$0: function(_) {
      return "NumberFormat(" + H.S(this._locale) + ", " + H.S(this._intl$_pattern) + ")";
    }
  };
  T.NumberFormat$decimalPattern_closure.prototype = {
    call$1: function(x) {
      return x.DECIMAL_PATTERN;
    },
    $signature: 246
  };
  T._NumberFormatParser.prototype = {
    parse$0: function(_) {
      var trunk, t2, t3, each, t4, _this = this,
        t1 = _this.format;
      t1._positivePrefix = _this._parseAffix$0();
      trunk = _this._parseTrunk$0();
      t2 = _this._parseAffix$0();
      t1._positiveSuffix = t2;
      t3 = _this.pattern;
      if (t3._intl$_current === ";") {
        t3.moveNext$0();
        t1._negativePrefix = _this._parseAffix$0();
        t2 = new T._StringIterator(trunk);
        for (; t2.moveNext$0();) {
          each = t2._intl$_current;
          t4 = t3._intl$_current;
          if (t4 != each && t4 != null)
            throw H.wrapException(P.FormatException$("Positive and negative trunks must be the same", null, null));
          t3.moveNext$0();
        }
        t1._negativeSuffix = _this._parseAffix$0();
      } else {
        t1._negativePrefix = t1._negativePrefix + t1._positivePrefix;
        t1._negativeSuffix = t2 + t1._negativeSuffix;
      }
    },
    _parseAffix$0: function() {
      var affix = new P.StringBuffer(""),
        t1 = this.inQuote = false,
        t2 = this.pattern;
      while (true)
        if (!(this.parseCharacterAffix$1(affix) ? t2.moveNext$0() : t1))
          break;
      t1 = affix._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    parseCharacterAffix$1: function(affix) {
      var t2, t3, _this = this, _null = null,
        _s24_ = "Too many percent/permill",
        t1 = _this.pattern,
        ch = t1._intl$_current;
      if (ch == null)
        return false;
      if (ch === "'") {
        t2 = t1.nextIndex;
        t3 = t1.input;
        if ((t2 >= t3.length ? _null : t3[t2]) === "'") {
          t1.moveNext$0();
          affix._contents += "'";
        } else
          _this.inQuote = !_this.inQuote;
        return true;
      }
      if (_this.inQuote)
        affix._contents += ch;
      else
        switch (ch) {
          case "#":
          case "0":
          case ",":
          case ".":
          case ";":
            return false;
          case "\xa4":
            affix._contents += _this.currencySymbol;
            break;
          case "%":
            t1 = _this.format;
            t2 = t1._internalMultiplier;
            if (t2 !== 1 && t2 !== 100)
              throw H.wrapException(P.FormatException$(_s24_, _null, _null));
            t1.set$_multiplier(100);
            affix._contents += t1._symbols.PERCENT;
            break;
          case "\u2030":
            t1 = _this.format;
            t2 = t1._internalMultiplier;
            if (t2 !== 1 && t2 !== 1000)
              throw H.wrapException(P.FormatException$(_s24_, _null, _null));
            t1.set$_multiplier(1000);
            affix._contents += t1._symbols.PERMILL;
            break;
          default:
            affix._contents += ch;
        }
      return true;
    },
    _parseTrunk$0: function() {
      var t2, n, effectiveDecimalPos, t3, totalDigits, t4, t5, _this = this,
        trunk = new P.StringBuffer(""),
        t1 = _this.pattern,
        loop = true;
      while (true) {
        if (!(t1._intl$_current != null && loop))
          break;
        loop = _this.parseTrunkCharacter$1(trunk);
      }
      t2 = _this.zeroDigitCount;
      if (t2 === 0 && _this.digitLeftCount > 0 && _this.decimalPos >= 0) {
        n = _this.decimalPos;
        if (n === 0)
          n = 1;
        _this.digitRightCount = _this.digitLeftCount - n;
        _this.digitLeftCount = n - 1;
        t2 = _this.zeroDigitCount = 1;
      }
      effectiveDecimalPos = _this.decimalPos;
      if (!(effectiveDecimalPos < 0 && _this.digitRightCount > 0)) {
        if (effectiveDecimalPos >= 0) {
          t3 = _this.digitLeftCount;
          t3 = effectiveDecimalPos < t3 || effectiveDecimalPos > t3 + t2;
        } else
          t3 = false;
        t3 = t3 || _this.groupingCount === 0;
      } else
        t3 = true;
      if (t3)
        throw H.wrapException(P.FormatException$('Malformed pattern "' + t1.input + '"', null, null));
      t1 = _this.digitLeftCount;
      t2 = t1 + t2;
      totalDigits = t2 + _this.digitRightCount;
      t3 = _this.format;
      t4 = effectiveDecimalPos >= 0;
      t5 = t4 ? totalDigits - effectiveDecimalPos : 0;
      t3.maximumFractionDigits = t5;
      if (t4) {
        t2 -= effectiveDecimalPos;
        t3.minimumFractionDigits = t2;
        if (t2 < 0)
          t3.minimumFractionDigits = 0;
      }
      t2 = t3.minimumIntegerDigits = (t4 ? effectiveDecimalPos : totalDigits) - t1;
      if (t3._useExponentialNotation) {
        t3.maximumIntegerDigits = t1 + t2;
        if (t5 === 0 && t2 === 0)
          t3.minimumIntegerDigits = 1;
      }
      t1 = H.intTypeCheck(Math.max(0, _this.groupingCount));
      t3._finalGroupingSize = t1;
      if (!t3._groupingSizeSetExplicitly)
        t3._groupingSize = t1;
      t3._decimalSeparatorAlwaysShown = effectiveDecimalPos === 0 || effectiveDecimalPos === totalDigits;
      t1 = trunk._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    parseTrunkCharacter$1: function(trunk) {
      var t2, t3, nextChar, _this = this, _null = null,
        t1 = _this.pattern,
        ch = t1._intl$_current;
      switch (ch) {
        case "#":
          if (_this.zeroDigitCount > 0)
            ++_this.digitRightCount;
          else
            ++_this.digitLeftCount;
          t2 = _this.groupingCount;
          if (t2 >= 0 && _this.decimalPos < 0)
            _this.groupingCount = t2 + 1;
          break;
        case "0":
          if (_this.digitRightCount > 0)
            throw H.wrapException(P.FormatException$('Unexpected "0" in pattern "' + t1.input + '"', _null, _null));
          ++_this.zeroDigitCount;
          t2 = _this.groupingCount;
          if (t2 >= 0 && _this.decimalPos < 0)
            _this.groupingCount = t2 + 1;
          break;
        case ",":
          t2 = _this.groupingCount;
          if (t2 > 0) {
            t3 = _this.format;
            t3._groupingSizeSetExplicitly = true;
            t3._groupingSize = t2;
          }
          _this.groupingCount = 0;
          break;
        case ".":
          if (_this.decimalPos >= 0)
            throw H.wrapException(P.FormatException$('Multiple decimal separators in pattern "' + t1.toString$0(0) + '"', _null, _null));
          _this.decimalPos = _this.digitLeftCount + _this.zeroDigitCount + _this.digitRightCount;
          break;
        case "E":
          trunk._contents += H.S(ch);
          t2 = _this.format;
          if (t2._useExponentialNotation)
            throw H.wrapException(P.FormatException$('Multiple exponential symbols in pattern "' + t1.toString$0(0) + '"', _null, _null));
          t2._useExponentialNotation = true;
          t2.minimumExponentDigits = 0;
          t1.moveNext$0();
          nextChar = t1._intl$_current;
          if (nextChar === "+") {
            trunk._contents += H.S(nextChar);
            t1.moveNext$0();
            t2._useSignForPositiveExponent = true;
          }
          for (; t3 = t1._intl$_current, t3 === "0";) {
            trunk._contents += H.S(t3);
            t1.moveNext$0();
            ++t2.minimumExponentDigits;
          }
          if (_this.digitLeftCount + _this.zeroDigitCount < 1 || t2.minimumExponentDigits < 1)
            throw H.wrapException(P.FormatException$('Malformed exponential pattern "' + t1.toString$0(0) + '"', _null, _null));
          return false;
        default:
          return false;
      }
      trunk._contents += H.S(ch);
      t1.moveNext$0();
      return true;
    }
  };
  T._StringIterable.prototype = {
    $asIterable: function() {
      return [P.String];
    },
    get$iterator: function(receiver) {
      return this.iterator;
    }
  };
  T._StringIterator.prototype = {
    get$current: function(_) {
      return this._intl$_current;
    },
    moveNext$0: function() {
      var _this = this,
        t1 = _this.nextIndex,
        t2 = _this.input;
      if (t1 >= t2.length) {
        _this._intl$_current = null;
        return false;
      }
      _this.nextIndex = t1 + 1;
      _this._intl$_current = t2[t1];
      return true;
    },
    get$iterator: function(_) {
      return this;
    },
    $isIterator: 1,
    $asIterator: function() {
      return [P.String];
    }
  };
  B.NumberSymbols.prototype = {
    toString$0: function(_) {
      return this.NAME;
    }
  };
  X.UninitializedLocaleData.prototype = {
    $index: function(_, key) {
      return H.stringTypeCheck(key) === "en_US" ? this.fallbackData : this._throwException$0();
    },
    containsKey$1: function(_, key) {
      return key === "en_US" ? true : this._throwException$0();
    },
    _throwException$0: function() {
      throw H.wrapException(new X.LocaleDataException("Locale data has not been initialized, call " + this.message + "."));
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  X.LocaleDataException.prototype = {
    toString$0: function(_) {
      return "LocaleDataException: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  M.Context0.prototype = {
    absolute$1: function(_, part1) {
      var t1, _null = null;
      M._validateArgList("absolute", H.setRuntimeTypeInfo([part1, null, null, null, null, null, null], [P.String]));
      t1 = this.style;
      t1 = t1.rootLength$1(part1) > 0 && !t1.isRootRelative$1(part1);
      if (t1)
        return part1;
      t1 = D.current();
      return this.join$8(0, t1, part1, _null, _null, _null, _null, _null, _null);
    },
    extension$1: function(path) {
      return X.ParsedPath_ParsedPath$parse(H.stringTypeCheck(path), this.style)._splitExtension$0()[1];
    },
    join$8: function(_, part1, part2, part3, part4, part5, part6, part7, part8) {
      var t1,
        parts = H.setRuntimeTypeInfo([part1, part2, part3, part4, part5, part6, part7, part8], [P.String]);
      M._validateArgList("join", parts);
      t1 = H.getTypeArgumentByIndex(parts, 0);
      return this.joinAll$1(new H.WhereIterable(parts, H.functionTypeCheck(new M.Context_join_closure(), {func: 1, ret: P.bool, args: [t1]}), [t1]));
    },
    joinAll$1: function(parts) {
      var t1, t2, t3, needsSeparator, isAbsoluteAndNotRootRelative, t4, t5, parsed, path;
      H.assertSubtype(parts, "$isIterable", [P.String], "$asIterable");
      for (t1 = H.getTypeArgumentByIndex(parts, 0), t2 = H.functionTypeCheck(new M.Context_joinAll_closure(), {func: 1, ret: P.bool, args: [t1]}), t3 = parts.get$iterator(parts), t1 = new H.WhereIterator(t3, t2, [t1]), t2 = this.style, needsSeparator = false, isAbsoluteAndNotRootRelative = false, t4 = ""; t1.moveNext$0();) {
        t5 = t3.get$current(t3);
        if (t2.isRootRelative$1(t5) && isAbsoluteAndNotRootRelative) {
          parsed = X.ParsedPath_ParsedPath$parse(t5, t2);
          path = t4.charCodeAt(0) == 0 ? t4 : t4;
          t4 = C.JSString_methods.substring$2(path, 0, t2.rootLength$2$withDrive(path, true));
          parsed.root = t4;
          if (t2.needsSeparator$1(t4))
            C.JSArray_methods.$indexSet(parsed.separators, 0, t2.get$separator());
          t4 = parsed.toString$0(0);
        } else if (t2.rootLength$1(t5) > 0) {
          isAbsoluteAndNotRootRelative = !t2.isRootRelative$1(t5);
          t4 = H.S(t5);
        } else {
          if (!(t5.length > 0 && t2.containsSeparator$1(t5[0])))
            if (needsSeparator)
              t4 += t2.get$separator();
          t4 += H.S(t5);
        }
        needsSeparator = t2.needsSeparator$1(t5);
      }
      return t4.charCodeAt(0) == 0 ? t4 : t4;
    },
    split$1: function(_, path) {
      var parsed = X.ParsedPath_ParsedPath$parse(path, this.style),
        t1 = parsed.parts,
        t2 = H.getTypeArgumentByIndex(t1, 0);
      parsed.set$parts(P.List_List$from(new H.WhereIterable(t1, H.functionTypeCheck(new M.Context_split_closure(), {func: 1, ret: P.bool, args: [t2]}), [t2]), true, t2));
      t1 = parsed.root;
      if (t1 != null)
        C.JSArray_methods.insert$2(parsed.parts, 0, t1);
      return parsed.parts;
    },
    normalize$1: function(_, path) {
      var parsed;
      if (!this._needsNormalization$1(path))
        return path;
      parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
      parsed.normalize$0(0);
      return parsed.toString$0(0);
    },
    _needsNormalization$1: function(path) {
      var i, start, previous, t2, t3, previousPrevious, codeUnit, t4,
        t1 = this.style,
        root = t1.rootLength$1(path);
      if (root !== 0) {
        if (t1 === $.$get$Style_windows())
          for (i = 0; i < root; ++i)
            if (C.JSString_methods._codeUnitAt$1(path, i) === 47)
              return true;
        start = root;
        previous = 47;
      } else {
        start = 0;
        previous = null;
      }
      for (t2 = new H.CodeUnits(path).__internal$_string, t3 = t2.length, i = start, previousPrevious = null; i < t3; ++i, previousPrevious = previous, previous = codeUnit) {
        codeUnit = C.JSString_methods.codeUnitAt$1(t2, i);
        if (t1.isSeparator$1(codeUnit)) {
          if (t1 === $.$get$Style_windows() && codeUnit === 47)
            return true;
          if (previous != null && t1.isSeparator$1(previous))
            return true;
          if (previous === 46)
            t4 = previousPrevious == null || previousPrevious === 46 || t1.isSeparator$1(previousPrevious);
          else
            t4 = false;
          if (t4)
            return true;
        }
      }
      if (previous == null)
        return true;
      if (t1.isSeparator$1(previous))
        return true;
      if (previous === 46)
        t1 = previousPrevious == null || t1.isSeparator$1(previousPrevious) || previousPrevious === 46;
      else
        t1 = false;
      if (t1)
        return true;
      return false;
    },
    relative$1: function(path) {
      var from, fromParsed, pathParsed, t3, _this = this,
        _s26_ = 'Unable to find a path to "',
        t1 = _this.style,
        t2 = t1.rootLength$1(path);
      if (t2 <= 0)
        return _this.normalize$1(0, path);
      from = D.current();
      if (t1.rootLength$1(from) <= 0 && t1.rootLength$1(path) > 0)
        return _this.normalize$1(0, path);
      if (t1.rootLength$1(path) <= 0 || t1.isRootRelative$1(path))
        path = _this.absolute$1(0, path);
      if (t1.rootLength$1(path) <= 0 && t1.rootLength$1(from) > 0)
        throw H.wrapException(X.PathException$(_s26_ + path + '" from "' + H.S(from) + '".'));
      fromParsed = X.ParsedPath_ParsedPath$parse(from, t1);
      fromParsed.normalize$0(0);
      pathParsed = X.ParsedPath_ParsedPath$parse(path, t1);
      pathParsed.normalize$0(0);
      t2 = fromParsed.parts;
      if (t2.length > 0 && J.$eq$(t2[0], "."))
        return pathParsed.toString$0(0);
      t2 = fromParsed.root;
      t3 = pathParsed.root;
      if (t2 != t3)
        t2 = t2 == null || t3 == null || !t1.pathsEqual$2(t2, t3);
      else
        t2 = false;
      if (t2)
        return pathParsed.toString$0(0);
      while (true) {
        t2 = fromParsed.parts;
        if (t2.length > 0) {
          t3 = pathParsed.parts;
          t2 = t3.length > 0 && t1.pathsEqual$2(t2[0], t3[0]);
        } else
          t2 = false;
        if (!t2)
          break;
        C.JSArray_methods.removeAt$1(fromParsed.parts, 0);
        C.JSArray_methods.removeAt$1(fromParsed.separators, 1);
        C.JSArray_methods.removeAt$1(pathParsed.parts, 0);
        C.JSArray_methods.removeAt$1(pathParsed.separators, 1);
      }
      t2 = fromParsed.parts;
      if (t2.length > 0 && J.$eq$(t2[0], ".."))
        throw H.wrapException(X.PathException$(_s26_ + path + '" from "' + H.S(from) + '".'));
      t2 = P.String;
      C.JSArray_methods.insertAll$2(pathParsed.parts, 0, P.List_List$filled(fromParsed.parts.length, "..", t2));
      C.JSArray_methods.$indexSet(pathParsed.separators, 0, "");
      C.JSArray_methods.insertAll$2(pathParsed.separators, 1, P.List_List$filled(fromParsed.parts.length, t1.get$separator(), t2));
      t1 = pathParsed.parts;
      t2 = t1.length;
      if (t2 === 0)
        return ".";
      if (t2 > 1 && J.$eq$(C.JSArray_methods.get$last(t1), ".")) {
        C.JSArray_methods.removeLast$0(pathParsed.parts);
        t1 = pathParsed.separators;
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.add$1(t1, "");
      }
      pathParsed.root = "";
      pathParsed.removeTrailingSeparators$0();
      return pathParsed.toString$0(0);
    },
    prettyUri$1: function(uri) {
      var path, rel, _this = this,
        typedUri = M._parseUri(uri);
      if (typedUri.get$scheme() === "file" && _this.style == $.$get$Style_url())
        return typedUri.toString$0(0);
      else if (typedUri.get$scheme() !== "file" && typedUri.get$scheme() !== "" && _this.style != $.$get$Style_url())
        return typedUri.toString$0(0);
      path = _this.normalize$1(0, _this.style.pathFromUri$1(M._parseUri(typedUri)));
      rel = _this.relative$1(path);
      return _this.split$1(0, rel).length > _this.split$1(0, path).length ? path : rel;
    }
  };
  M.Context_join_closure.prototype = {
    call$1: function(part) {
      return H.stringTypeCheck(part) != null;
    },
    $signature: 20
  };
  M.Context_joinAll_closure.prototype = {
    call$1: function(part) {
      return H.stringTypeCheck(part) !== "";
    },
    $signature: 20
  };
  M.Context_split_closure.prototype = {
    call$1: function(part) {
      return H.stringTypeCheck(part).length !== 0;
    },
    $signature: 20
  };
  M._validateArgList_closure.prototype = {
    call$1: function(arg) {
      H.stringTypeCheck(arg);
      return arg == null ? "null" : '"' + arg + '"';
    },
    $signature: 5
  };
  B.InternalStyle.prototype = {
    getRoot$1: function(path) {
      var t1,
        $length = this.rootLength$1(path);
      if ($length > 0)
        return J.substring$2$s(path, 0, $length);
      if (this.isRootRelative$1(path)) {
        if (0 >= path.length)
          return H.ioore(path, 0);
        t1 = path[0];
      } else
        t1 = null;
      return t1;
    },
    pathsEqual$2: function(path1, path2) {
      return path1 == path2;
    }
  };
  X.ParsedPath.prototype = {
    get$extension: function() {
      return this._splitExtension$0()[1];
    },
    removeTrailingSeparators$0: function() {
      var t1, t2, _this = this;
      while (true) {
        t1 = _this.parts;
        if (!(t1.length !== 0 && J.$eq$(C.JSArray_methods.get$last(t1), "")))
          break;
        C.JSArray_methods.removeLast$0(_this.parts);
        C.JSArray_methods.removeLast$0(_this.separators);
      }
      t1 = _this.separators;
      t2 = t1.length;
      if (t2 > 0)
        C.JSArray_methods.$indexSet(t1, t2 - 1, "");
    },
    normalize$0: function(_) {
      var t2, t3, leadingDoubles, _i, part, t4, newSeparators, _this = this,
        t1 = P.String,
        newParts = H.setRuntimeTypeInfo([], [t1]);
      for (t2 = _this.parts, t3 = t2.length, leadingDoubles = 0, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
        part = t2[_i];
        t4 = J.getInterceptor$(part);
        if (!(t4.$eq(part, ".") || t4.$eq(part, "")))
          if (t4.$eq(part, ".."))
            if (newParts.length > 0)
              newParts.pop();
            else
              ++leadingDoubles;
          else
            C.JSArray_methods.add$1(newParts, part);
      }
      if (_this.root == null)
        C.JSArray_methods.insertAll$2(newParts, 0, P.List_List$filled(leadingDoubles, "..", t1));
      if (newParts.length === 0 && _this.root == null)
        C.JSArray_methods.add$1(newParts, ".");
      newSeparators = P.List_List$generate(newParts.length, new X.ParsedPath_normalize_closure(_this), true, t1);
      t1 = _this.root;
      C.JSArray_methods.insert$2(newSeparators, 0, t1 != null && newParts.length > 0 && _this.style.needsSeparator$1(t1) ? _this.style.get$separator() : "");
      _this.set$parts(newParts);
      _this.set$separators(newSeparators);
      t1 = _this.root;
      if (t1 != null && _this.style === $.$get$Style_windows()) {
        t1.toString;
        _this.root = H.stringReplaceAllUnchecked(t1, "/", "\\");
      }
      _this.removeTrailingSeparators$0();
    },
    toString$0: function(_) {
      var i, t2, _this = this,
        t1 = _this.root;
      t1 = t1 != null ? t1 : "";
      for (i = 0; i < _this.parts.length; ++i) {
        t2 = _this.separators;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = t1 + H.S(t2[i]);
        t1 = _this.parts;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = t2 + H.S(t1[i]);
      }
      t1 += H.S(C.JSArray_methods.get$last(_this.separators));
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _splitExtension$0: function() {
      var lastDot,
        file = C.JSArray_methods.lastWhere$2$orElse(this.parts, new X.ParsedPath__splitExtension_closure(), new X.ParsedPath__splitExtension_closure0());
      if (file == null)
        return H.setRuntimeTypeInfo(["", ""], [P.String]);
      if (file === "..")
        return H.setRuntimeTypeInfo(["..", ""], [P.String]);
      lastDot = C.JSString_methods.lastIndexOf$1(file, ".");
      if (lastDot <= 0)
        return H.setRuntimeTypeInfo([file, ""], [P.String]);
      return H.setRuntimeTypeInfo([C.JSString_methods.substring$2(file, 0, lastDot), C.JSString_methods.substring$1(file, lastDot)], [P.String]);
    },
    set$parts: function(parts) {
      this.parts = H.assertSubtype(parts, "$isList", [P.String], "$asList");
    },
    set$separators: function(separators) {
      this.separators = H.assertSubtype(separators, "$isList", [P.String], "$asList");
    }
  };
  X.ParsedPath_normalize_closure.prototype = {
    call$1: function(_) {
      return this.$this.style.get$separator();
    },
    $signature: 33
  };
  X.ParsedPath__splitExtension_closure.prototype = {
    call$1: function(p) {
      return H.stringTypeCheck(p) !== "";
    },
    $signature: 20
  };
  X.ParsedPath__splitExtension_closure0.prototype = {
    call$0: function() {
      return;
    },
    $signature: 0
  };
  X.PathException.prototype = {
    toString$0: function(_) {
      return "PathException: " + this.message;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  O.Style.prototype = {
    toString$0: function(_) {
      return this.get$name(this);
    }
  };
  E.PosixStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      return t1 !== 0 && J.codeUnitAt$1$s(path, t1 - 1) !== 47;
    },
    rootLength$2$withDrive: function(path, withDrive) {
      if (path.length !== 0 && J._codeUnitAt$1$s(path, 0) === 47)
        return 1;
      return 0;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return false;
    },
    pathFromUri$1: function(uri) {
      var t1;
      if (uri.get$scheme() === "" || uri.get$scheme() === "file") {
        t1 = uri.get$path(uri);
        return P._Uri__uriDecode(t1, 0, t1.length, C.C_Utf8Codec, false);
      }
      throw H.wrapException(P.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'."));
    },
    get$name: function() {
      return "posix";
    },
    get$separator: function() {
      return "/";
    }
  };
  F.UrlStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      if (t1 === 0)
        return false;
      if (J.getInterceptor$s(path).codeUnitAt$1(path, t1 - 1) !== 47)
        return true;
      return C.JSString_methods.endsWith$1(path, "://") && this.rootLength$1(path) === t1;
    },
    rootLength$2$withDrive: function(path, withDrive) {
      var i, codeUnit, index, t2,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      if (J.getInterceptor$s(path)._codeUnitAt$1(path, 0) === 47)
        return 1;
      for (i = 0; i < t1; ++i) {
        codeUnit = C.JSString_methods._codeUnitAt$1(path, i);
        if (codeUnit === 47)
          return 0;
        if (codeUnit === 58) {
          if (i === 0)
            return 0;
          index = C.JSString_methods.indexOf$2(path, "/", C.JSString_methods.startsWith$2(path, "//", i + 1) ? i + 3 : i);
          if (index <= 0)
            return t1;
          if (!withDrive || t1 < index + 3)
            return index;
          if (!C.JSString_methods.startsWith$1(path, "file://"))
            return index;
          if (!B.isDriveLetter(path, index + 1))
            return index;
          t2 = index + 3;
          return t1 === t2 ? t2 : index + 4;
        }
      }
      return 0;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return path.length !== 0 && J._codeUnitAt$1$s(path, 0) === 47;
    },
    pathFromUri$1: function(uri) {
      return J.toString$0$(uri);
    },
    get$name: function() {
      return "url";
    },
    get$separator: function() {
      return "/";
    }
  };
  L.WindowsStyle.prototype = {
    containsSeparator$1: function(path) {
      return C.JSString_methods.contains$1(path, "/");
    },
    isSeparator$1: function(codeUnit) {
      return codeUnit === 47 || codeUnit === 92;
    },
    needsSeparator$1: function(path) {
      var t1 = path.length;
      if (t1 === 0)
        return false;
      t1 = J.codeUnitAt$1$s(path, t1 - 1);
      return !(t1 === 47 || t1 === 92);
    },
    rootLength$2$withDrive: function(path, withDrive) {
      var t2, index,
        t1 = path.length;
      if (t1 === 0)
        return 0;
      t2 = J.getInterceptor$s(path)._codeUnitAt$1(path, 0);
      if (t2 === 47)
        return 1;
      if (t2 === 92) {
        if (t1 < 2 || C.JSString_methods._codeUnitAt$1(path, 1) !== 92)
          return 1;
        index = C.JSString_methods.indexOf$2(path, "\\", 2);
        if (index > 0) {
          index = C.JSString_methods.indexOf$2(path, "\\", index + 1);
          if (index > 0)
            return index;
        }
        return t1;
      }
      if (t1 < 3)
        return 0;
      if (!B.isAlphabetic(t2))
        return 0;
      if (C.JSString_methods._codeUnitAt$1(path, 1) !== 58)
        return 0;
      t1 = C.JSString_methods._codeUnitAt$1(path, 2);
      if (!(t1 === 47 || t1 === 92))
        return 0;
      return 3;
    },
    rootLength$1: function(path) {
      return this.rootLength$2$withDrive(path, false);
    },
    isRootRelative$1: function(path) {
      return this.rootLength$1(path) === 1;
    },
    pathFromUri$1: function(uri) {
      var path, t1;
      if (uri.get$scheme() !== "" && uri.get$scheme() !== "file")
        throw H.wrapException(P.ArgumentError$("Uri " + uri.toString$0(0) + " must have scheme 'file:'."));
      path = uri.get$path(uri);
      if (uri.get$host(uri) === "") {
        if (path.length >= 3 && C.JSString_methods.startsWith$1(path, "/") && B.isDriveLetter(path, 1))
          path = C.JSString_methods.replaceFirst$2(path, "/", "");
      } else
        path = "\\\\" + H.S(uri.get$host(uri)) + path;
      t1 = H.stringReplaceAllUnchecked(path, "/", "\\");
      return P._Uri__uriDecode(t1, 0, t1.length, C.C_Utf8Codec, false);
    },
    codeUnitsEqual$2: function(codeUnit1, codeUnit2) {
      var upperCase1;
      if (codeUnit1 === codeUnit2)
        return true;
      if (codeUnit1 === 47)
        return codeUnit2 === 92;
      if (codeUnit1 === 92)
        return codeUnit2 === 47;
      if ((codeUnit1 ^ codeUnit2) !== 32)
        return false;
      upperCase1 = codeUnit1 | 32;
      return upperCase1 >= 97 && upperCase1 <= 122;
    },
    pathsEqual$2: function(path1, path2) {
      var t1, t2, i;
      if (path1 == path2)
        return true;
      t1 = path1.length;
      if (t1 !== path2.length)
        return false;
      for (t2 = J.getInterceptor$s(path2), i = 0; i < t1; ++i)
        if (!this.codeUnitsEqual$2(C.JSString_methods._codeUnitAt$1(path1, i), t2._codeUnitAt$1(path2, i)))
          return false;
      return true;
    },
    get$name: function() {
      return "windows";
    },
    get$separator: function() {
      return "\\";
    }
  };
  L.Browser.prototype = {
    get$name: function(receiver) {
      return this.name;
    }
  };
  L.Browser_getCurrentBrowser_closure.prototype = {
    call$1: function(browser) {
      var t1;
      H.interceptedTypeCheck(browser, "$isBrowser");
      t1 = $.Browser_navigator;
      return H.boolTypeCheck(browser._matchesNavigator.call$1(t1));
    },
    $signature: 247
  };
  L.Browser_getCurrentBrowser_closure0.prototype = {
    call$0: function() {
      return $.$get$Browser_UnknownBrowser();
    },
    $signature: 248
  };
  L._Chrome.prototype = {};
  L._Firefox.prototype = {};
  L._Safari.prototype = {};
  L._WKWebView.prototype = {};
  L._InternetExplorer.prototype = {};
  G._HtmlNavigator.prototype = {$isNavigatorProvider: 1};
  G.NavigatorProvider.prototype = {};
  K.AsObservableFuture.prototype = {};
  B.WrappedFuture.prototype = {
    then$1$2$onError: function(onValue, onError, $S) {
      return this.wrapped.then$1$2$onError(H.functionTypeCheck(onValue, {func: 1, ret: {futureOr: 1, type: $S}, args: [H.getTypeArgumentByIndex(this, 0)]}), onError, $S);
    },
    then$1$1: function(onValue, $S) {
      return this.then$1$2$onError(onValue, null, $S);
    },
    whenComplete$1: function(action) {
      return this.wrapped.whenComplete$1(H.functionTypeCheck(action, {func: 1, ret: -1}));
    },
    $isFuture: 1
  };
  X.Observable.prototype = {
    cast$1$0: function(_, $R) {
      return new X.Observable(this._observable$_stream.cast$1$0(0, $R), [$R]);
    },
    contains$1: function(_, needle) {
      return new K.AsObservableFuture(this._observable$_stream.contains$1(0, needle), [P.bool]);
    },
    get$isBroadcast: function() {
      var t1 = this._observable$_stream.get$isBroadcast();
      return t1;
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._observable$_stream.listen$4$cancelOnError$onDone$onError(H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]}), cancelOnError, H.functionTypeCheck(onDone, {func: 1, ret: -1}), onError);
    },
    listen$1: function(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    },
    get$length: function(_) {
      var t1 = this._observable$_stream;
      return new K.AsObservableFuture(t1.get$length(t1), [P.int]);
    },
    map$1$1: function(_, convert, $S) {
      return new X.Observable(this._observable$_stream.map$1$1(0, H.functionTypeCheck(convert, {func: 1, ret: $S, args: [H.getTypeArgumentByIndex(this, 0)]}), $S), [$S]);
    },
    map$1: function($receiver, convert) {
      return this.map$1$1($receiver, convert, null);
    },
    toList$0: function(_) {
      return new K.AsObservableFuture(this._observable$_stream.toList$0(0), [[P.List, H.getTypeArgumentByIndex(this, 0)]]);
    }
  };
  R.ConcatStream.prototype = {
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1;
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      t1 = this.controller;
      t1.toString;
      return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  R.ConcatStream__buildController_closure.prototype = {
    call$1: function(stream) {
      return H.assertSubtype(stream, "$isStream", [this.T], "$asStream") == null;
    },
    $signature: function() {
      return {func: 1, ret: P.bool, args: [[P.Stream, this.T]]};
    }
  };
  R.ConcatStream__buildController_closure1.prototype = {
    call$0: function() {
      var t1 = {};
      t1.index = 0;
      new R.ConcatStream__buildController_closure_moveNext(t1, this._box_1, this.streams, 2).call$0();
    },
    $signature: 0
  };
  R.ConcatStream__buildController_closure_moveNext.prototype = {
    call$0: function() {
      var stream, _this = this,
        t1 = _this.streams,
        t2 = _this._box_0,
        t3 = t2.index;
      if (t3 >= 2)
        return H.ioore(t1, t3);
      stream = t1[t3];
      t3 = _this._box_1;
      t1 = t3.subscription;
      if (t1 != null)
        t1.cancel$0(0);
      t1 = t3.controller;
      t3.subscription = stream.listen$3$onDone$onError(t1.get$add(t1), new R.ConcatStream__buildController__moveNext_closure(t2, t3, _this.len, _this), t1.get$addError());
    },
    $signature: 1
  };
  R.ConcatStream__buildController__moveNext_closure.prototype = {
    call$0: function() {
      var _this = this;
      if (++_this._box_0.index === _this.len)
        _this._box_1.controller.close$0(0);
      else
        _this.moveNext.call$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  R.ConcatStream__buildController_closure2.prototype = {
    call$1: function(resumeSignal) {
      var t1 = this._box_1.subscription;
      return t1 == null ? null : t1.pause$1(0, resumeSignal);
    },
    call$0: function() {
      return this.call$1(null);
    },
    $signature: 92
  };
  R.ConcatStream__buildController_closure3.prototype = {
    call$0: function() {
      var t1 = this._box_1.subscription;
      return t1 == null ? null : t1.resume$0(0);
    },
    $signature: 1
  };
  R.ConcatStream__buildController_closure0.prototype = {
    call$0: function() {
      return this._box_1.subscription.cancel$0(0);
    },
    $signature: 10
  };
  D.DeferStream.prototype = {
    get$isBroadcast: function() {
      return true;
    },
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      H.functionTypeCheck(onData, {func: 1, ret: -1, args: [H.getTypeArgumentByIndex(this, 0)]});
      H.functionTypeCheck(onDone, {func: 1, ret: -1});
      this._defer$_isUsed = true;
      return this._streamFactory.call$0().listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    listen$3$cancelOnError$onDone: function(onData, cancelOnError, onDone) {
      return this.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, null);
    }
  };
  U.BehaviorSubject.prototype = {
    get$stream: function(_) {
      return this;
    },
    get$value: function(_) {
      return this._wrapper.latestValue;
    }
  };
  U.BehaviorSubject_BehaviorSubject_closure.prototype = {
    call$0: function() {
      var t2, t3, t4, _this = this,
        t1 = _this.wrapper;
      if (t1.latestIsError)
        P.scheduleMicrotask(new U.BehaviorSubject_BehaviorSubject__closure(_this.controller, t1));
      else if (t1.latestIsValue) {
        t2 = _this.controller;
        t3 = _this.T;
        t4 = [t3];
        return new X.Observable(new X.Observable(new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]), t4).super$Stream$transform(0, H.assertSubtype(new G.StartWithStreamTransformer(G.StartWithStreamTransformer__buildTransformer(H.assertSubtypeOfRuntimeType(t1.latestValue, t3), t3), [t3]), "$isStreamTransformer", [t3, t3], "$asStreamTransformer"), t3), t4);
      }
      t1 = _this.controller;
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    $signature: function() {
      return {func: 1, ret: [P.Stream, this.T]};
    }
  };
  U.BehaviorSubject_BehaviorSubject__closure.prototype = {
    call$0: function() {
      var t1 = this.wrapper;
      return this.controller.addError$2(t1.latestError, t1.latestStackTrace);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  U.BehaviorSubject_BehaviorSubject$seeded_closure.prototype = {
    call$0: function() {
      var t2, t3, t4, _this = this,
        t1 = _this.wrapper;
      if (t1.latestIsError)
        P.scheduleMicrotask(new U.BehaviorSubject_BehaviorSubject$seeded__closure(_this.controller, t1));
      t2 = _this.controller;
      t3 = _this.T;
      t4 = [t3];
      return new X.Observable(new X.Observable(new P._BroadcastStream(t2, [H.getTypeArgumentByIndex(t2, 0)]), t4).super$Stream$transform(0, H.assertSubtype(new G.StartWithStreamTransformer(G.StartWithStreamTransformer__buildTransformer(H.assertSubtypeOfRuntimeType(t1.latestValue, t3), t3), [t3]), "$isStreamTransformer", [t3, t3], "$asStreamTransformer"), t3), t4);
    },
    $signature: function() {
      return {func: 1, ret: [X.Observable, this.T]};
    }
  };
  U.BehaviorSubject_BehaviorSubject$seeded__closure.prototype = {
    call$0: function() {
      var t1 = this.wrapper;
      return this.controller.addError$2(t1.latestError, t1.latestStackTrace);
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 1
  };
  U._Wrapper.prototype = {
    set$latestValue: function(latestValue) {
      this.latestValue = H.assertSubtypeOfRuntimeType(latestValue, H.getTypeArgumentByIndex(this, 0));
    }
  };
  F.Subject.prototype = {
    get$stream: function(_) {
      return this;
    },
    add$1: function(_, $event) {
      var t1, _this = this;
      H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(_this, 0));
      t1 = _this._wrapper;
      $event = H.assertSubtypeOfRuntimeType(H.assertSubtypeOfRuntimeType($event, H.getTypeArgumentByIndex(_this, 0)), H.getTypeArgumentByIndex(t1, 0));
      t1.latestIsValue = true;
      t1.latestIsError = false;
      t1.set$latestValue($event);
      t1.latestStackTrace = t1.latestError = null;
      _this.controller.add$1(0, $event);
    },
    $isStreamController: 1
  };
  G.StartWithStreamTransformer.prototype = {
    $asStreamTransformer: function($T) {
      return [$T, $T];
    }
  };
  G.StartWithStreamTransformer__buildTransformer_closure.prototype = {
    call$2: function(input, cancelOnError) {
      var controller, t1 = {},
        t2 = this.T;
      H.assertSubtype(input, "$isStream", [t2], "$asStream");
      H.boolTypeCheck(cancelOnError);
      t1.subscription = t1.controller = null;
      controller = t1.controller = P.StreamController_StreamController(new G.StartWithStreamTransformer__buildTransformer__closure(t1), new G.StartWithStreamTransformer__buildTransformer__closure0(t1, this.startValue, input, cancelOnError), new G.StartWithStreamTransformer__buildTransformer__closure1(t1), new G.StartWithStreamTransformer__buildTransformer__closure2(t1), true, t2);
      return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]).listen$1(null);
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: function() {
      var t1 = this.T;
      return {func: 1, ret: [P.StreamSubscription, t1], args: [[P.Stream, t1], P.bool]};
    }
  };
  G.StartWithStreamTransformer__buildTransformer__closure0.prototype = {
    call$0: function() {
      var e, s, exception, t1, t2, t3, t4, _this = this;
      try {
        _this._box_0.controller.add$1(0, _this.startValue);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        _this._box_0.controller.addError$2(e, s);
      }
      t1 = _this._box_0;
      t2 = t1.controller;
      t3 = t2.get$add(t2);
      t4 = t2.get$addError();
      t1.subscription = _this.input.listen$4$cancelOnError$onDone$onError(t3, _this.cancelOnError, t2.get$close(t2), t4);
    },
    $signature: 0
  };
  G.StartWithStreamTransformer__buildTransformer__closure1.prototype = {
    call$1: function(resumeSignal) {
      return this._box_0.subscription.pause$1(0, resumeSignal);
    },
    call$0: function() {
      return this.call$1(null);
    },
    $signature: 92
  };
  G.StartWithStreamTransformer__buildTransformer__closure2.prototype = {
    call$0: function() {
      return this._box_0.subscription.resume$0(0);
    },
    $signature: 1
  };
  G.StartWithStreamTransformer__buildTransformer__closure.prototype = {
    call$0: function() {
      return this._box_0.subscription.cancel$0(0);
    },
    $signature: 10
  };
  Y.SourceFile.prototype = {
    get$length: function(_) {
      return this._decodedChars.length;
    },
    get$lines: function(_) {
      return this._lineStarts.length;
    },
    SourceFile$decoded$2$url: function(decodedChars, url) {
      var t1, t2, t3, i, c, j, t4;
      for (t1 = this._decodedChars, t2 = t1.length, t3 = this._lineStarts, i = 0; i < t2; ++i) {
        c = t1[i];
        if (c === 13) {
          j = i + 1;
          if (j < t2) {
            if (j >= t2)
              return H.ioore(t1, j);
            t4 = t1[j] !== 10;
          } else
            t4 = true;
          if (t4)
            c = 10;
        }
        if (c === 10)
          C.JSArray_methods.add$1(t3, i + 1);
      }
    },
    getLine$1: function(offset) {
      var t1, _this = this;
      if (offset < 0)
        throw H.wrapException(P.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > _this._decodedChars.length)
        throw H.wrapException(P.RangeError$("Offset " + offset + " must not be greater than the number of characters in the file, " + _this.get$length(_this) + "."));
      t1 = _this._lineStarts;
      if (offset < C.JSArray_methods.get$first(t1))
        return -1;
      if (offset >= C.JSArray_methods.get$last(t1))
        return t1.length - 1;
      if (_this._isNearCachedLine$1(offset))
        return _this._cachedLine;
      return _this._cachedLine = _this._binarySearch$1(offset) - 1;
    },
    _isNearCachedLine$1: function(offset) {
      var t2, t3, t4, _this = this,
        t1 = _this._cachedLine;
      if (t1 == null)
        return false;
      t2 = _this._lineStarts;
      if (t1 >>> 0 !== t1 || t1 >= t2.length)
        return H.ioore(t2, t1);
      if (offset < t2[t1])
        return false;
      t1 = _this._cachedLine;
      t3 = t2.length;
      if (typeof t1 !== "number")
        return t1.$ge();
      if (t1 < t3 - 1) {
        t4 = t1 + 1;
        if (t4 < 0 || t4 >= t3)
          return H.ioore(t2, t4);
        t4 = offset < t2[t4];
      } else
        t4 = true;
      if (t4)
        return true;
      if (t1 < t3 - 2) {
        t4 = t1 + 2;
        if (t4 < 0 || t4 >= t3)
          return H.ioore(t2, t4);
        t4 = offset < t2[t4];
        t2 = t4;
      } else
        t2 = true;
      if (t2) {
        _this._cachedLine = t1 + 1;
        return true;
      }
      return false;
    },
    _binarySearch$1: function(offset) {
      var min, half,
        t1 = this._lineStarts,
        t2 = t1.length,
        max = t2 - 1;
      for (min = 0; min < max;) {
        half = min + C.JSInt_methods._tdivFast$1(max - min, 2);
        if (half < 0 || half >= t2)
          return H.ioore(t1, half);
        if (t1[half] > offset)
          max = half;
        else
          min = half + 1;
      }
      return max;
    },
    getColumn$1: function(offset) {
      var line, lineStart, _this = this;
      if (offset < 0)
        throw H.wrapException(P.RangeError$("Offset may not be negative, was " + offset + "."));
      else if (offset > _this._decodedChars.length)
        throw H.wrapException(P.RangeError$("Offset " + offset + " must be not be greater than the number of characters in the file, " + _this.get$length(_this) + "."));
      line = _this.getLine$1(offset);
      lineStart = C.JSArray_methods.$index(_this._lineStarts, line);
      if (lineStart > offset)
        throw H.wrapException(P.RangeError$("Line " + H.S(line) + " comes after offset " + offset + "."));
      return offset - lineStart;
    },
    getOffset$1: function(line) {
      var t1, t2, result, t3, _this = this;
      if (typeof line !== "number")
        return line.$lt();
      if (line < 0)
        throw H.wrapException(P.RangeError$("Line may not be negative, was " + line + "."));
      else {
        t1 = _this._lineStarts;
        t2 = t1.length;
        if (line >= t2)
          throw H.wrapException(P.RangeError$("Line " + line + " must be less than the number of lines in the file, " + _this.get$lines(_this) + "."));
      }
      result = t1[line];
      if (result <= _this._decodedChars.length) {
        t3 = line + 1;
        t1 = t3 < t2 && result >= t1[t3];
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$("Line " + line + " doesn't have 0 columns."));
      return result;
    }
  };
  Y.FileLocation.prototype = {
    get$sourceUrl: function() {
      return this.file.url;
    },
    get$line: function(_) {
      return this.file.getLine$1(this.offset);
    },
    get$column: function() {
      return this.file.getColumn$1(this.offset);
    },
    get$offset: function(receiver) {
      return this.offset;
    }
  };
  Y._FileSpan.prototype = {
    get$sourceUrl: function() {
      return this.file.url;
    },
    get$length: function(_) {
      return this._file$_end - this._file$_start;
    },
    get$start: function(_) {
      return Y.FileLocation$_(this.file, this._file$_start);
    },
    get$end: function(_) {
      return Y.FileLocation$_(this.file, this._file$_end);
    },
    get$text: function(_) {
      return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this.file._decodedChars, this._file$_start, this._file$_end), 0, null);
    },
    get$context: function(_) {
      var t2, _this = this,
        t1 = _this.file,
        endOffset = _this._file$_end,
        endLine = t1.getLine$1(endOffset);
      if (t1.getColumn$1(endOffset) === 0 && endLine !== 0) {
        if (endOffset - _this._file$_start === 0) {
          if (endLine === t1._lineStarts.length - 1)
            t1 = "";
          else {
            t2 = t1.getOffset$1(endLine);
            if (typeof endLine !== "number")
              return endLine.$add();
            t1 = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1._decodedChars, t2, t1.getOffset$1(endLine + 1)), 0, null);
          }
          return t1;
        }
      } else if (endLine === t1._lineStarts.length - 1)
        endOffset = t1._decodedChars.length;
      else {
        if (typeof endLine !== "number")
          return endLine.$add();
        endOffset = t1.getOffset$1(endLine + 1);
      }
      return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1._decodedChars, t1.getOffset$1(t1.getLine$1(_this._file$_start)), endOffset), 0, null);
    },
    compareTo$1: function(_, other) {
      var result;
      H.interceptedTypeCheck(other, "$isSourceSpan");
      if (!(other instanceof Y._FileSpan))
        return this.super$SourceSpanMixin$compareTo(0, other);
      result = C.JSInt_methods.compareTo$1(this._file$_start, other._file$_start);
      return result === 0 ? C.JSInt_methods.compareTo$1(this._file$_end, other._file$_end) : result;
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (!J.getInterceptor$(other).$isFileSpan)
        return _this.super$SourceSpanMixin$$eq(0, other);
      return _this._file$_start === other._file$_start && _this._file$_end === other._file$_end && J.$eq$(_this.file.url, other.file.url);
    },
    get$hashCode: function(_) {
      return Y.SourceSpanMixin.prototype.get$hashCode.call(this, this);
    },
    $isFileSpan: 1,
    $isSourceSpanWithContext: 1
  };
  U.Highlighter.prototype = {
    highlight$0: function(_) {
      var t1, t2, lineStart, context, lines, t3, t4, lineNumber, _i, line, lastLineIndex, _this = this;
      _this._writeSidebar$1$end("\u2577");
      t1 = _this._highlighter$_buffer;
      t1._contents += "\n";
      t2 = _this._highlighter$_span;
      lineStart = B.findLineStart(t2.get$context(t2), t2.get$text(t2), t2.get$start(t2).get$column());
      context = t2.get$context(t2);
      if (typeof lineStart !== "number")
        return lineStart.$gt();
      if (lineStart > 0) {
        lines = C.JSString_methods.substring$2(context, 0, lineStart - 1).split("\n");
        t3 = t2.get$start(t2);
        t3 = t3.get$line(t3);
        t4 = lines.length;
        if (typeof t3 !== "number")
          return t3.$sub();
        lineNumber = t3 - t4;
        for (t3 = _this._multiline, _i = 0; _i < t4; ++_i) {
          line = lines[_i];
          _this._writeSidebar$1$line(lineNumber);
          t1._contents += C.JSString_methods.$mul(" ", t3 ? 3 : 1);
          _this._writeText$1(line);
          t1._contents += "\n";
          ++lineNumber;
        }
        context = C.JSString_methods.substring$1(context, lineStart);
      }
      lines = H.setRuntimeTypeInfo(context.split("\n"), [P.String]);
      t3 = t2.get$end(t2);
      t3 = t3.get$line(t3);
      t2 = t2.get$start(t2);
      t2 = t2.get$line(t2);
      if (typeof t3 !== "number")
        return t3.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      lastLineIndex = t3 - t2;
      if (J.get$length$asx(C.JSArray_methods.get$last(lines)) === 0 && lines.length > lastLineIndex + 1) {
        if (0 >= lines.length)
          return H.ioore(lines, -1);
        lines.pop();
      }
      _this._writeFirstLine$1(C.JSArray_methods.get$first(lines));
      if (_this._multiline) {
        _this._writeIntermediateLines$1(H.SubListIterable$(lines, 1, null, H.getTypeArgumentByIndex(lines, 0)).take$1(0, lastLineIndex - 1));
        if (lastLineIndex < 0 || lastLineIndex >= lines.length)
          return H.ioore(lines, lastLineIndex);
        _this._writeLastLine$1(lines[lastLineIndex]);
      }
      _this._writeTrailingLines$1(H.SubListIterable$(lines, lastLineIndex + 1, null, H.getTypeArgumentByIndex(lines, 0)));
      _this._writeSidebar$1$end("\u2575");
      t1 = t1._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _writeFirstLine$1: function(line) {
      var t4, startColumn, endColumn, textBefore, textInside, tabsBefore, tabsInside, _this = this, t1 = {},
        t2 = _this._highlighter$_span,
        t3 = t2.get$start(t2);
      _this._writeSidebar$1$line(t3.get$line(t3));
      t3 = t2.get$start(t2).get$column();
      t4 = line.length;
      startColumn = t1.startColumn = Math.min(t3, t4);
      t3 = t2.get$end(t2);
      t3 = t3.get$offset(t3);
      t2 = t2.get$start(t2);
      endColumn = t1.endColumn = Math.min(startColumn + t3 - t2.get$offset(t2), t4);
      textBefore = J.substring$2$s(line, 0, startColumn);
      t2 = _this._multiline;
      if (t2 && _this._isOnlyWhitespace$1(textBefore)) {
        t1 = _this._highlighter$_buffer;
        t1._contents += " ";
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure(_this, line));
        t1._contents += "\n";
        return;
      }
      t3 = _this._highlighter$_buffer;
      t3._contents += C.JSString_methods.$mul(" ", t2 ? 3 : 1);
      _this._writeText$1(textBefore);
      textInside = C.JSString_methods.substring$2(line, startColumn, endColumn);
      _this._colorize$1(new U.Highlighter__writeFirstLine_closure0(_this, textInside));
      _this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
      t3._contents += "\n";
      tabsBefore = _this._countTabs$1(textBefore);
      tabsInside = _this._countTabs$1(textInside);
      startColumn += tabsBefore * 3;
      t1.startColumn = startColumn;
      t1.endColumn = endColumn + (tabsBefore + tabsInside) * 3;
      _this._writeSidebar$0();
      if (t2) {
        t3._contents += " ";
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure1(t1, _this));
      } else {
        t3._contents += C.JSString_methods.$mul(" ", startColumn + 1);
        _this._colorize$1(new U.Highlighter__writeFirstLine_closure2(t1, _this));
      }
      t3._contents += "\n";
    },
    _writeIntermediateLines$1: function(lines) {
      var t1, lineNumber, t2, t3, _this = this;
      H.assertSubtype(lines, "$isIterable", [P.String], "$asIterable");
      t1 = _this._highlighter$_span;
      t1 = t1.get$start(t1);
      t1 = t1.get$line(t1);
      if (typeof t1 !== "number")
        return t1.$add();
      lineNumber = t1 + 1;
      for (t1 = new H.ListIterator(lines, lines.get$length(lines), [H.getTypeArgumentByIndex(lines, 0)]), t2 = _this._highlighter$_buffer; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        _this._writeSidebar$1$line(lineNumber);
        t2._contents += " ";
        _this._colorize$1(new U.Highlighter__writeIntermediateLines_closure(_this, t3));
        t2._contents += "\n";
        ++lineNumber;
      }
    },
    _writeLastLine$1: function(line) {
      var endColumn, textInside, _this = this, t1 = {},
        t2 = _this._highlighter$_span,
        t3 = t2.get$end(t2);
      _this._writeSidebar$1$line(t3.get$line(t3));
      t2 = t2.get$end(t2).get$column();
      t3 = line.length;
      endColumn = t1.endColumn = Math.min(t2, t3);
      if (_this._multiline && endColumn === t3) {
        t1 = _this._highlighter$_buffer;
        t1._contents += " ";
        _this._colorize$1(new U.Highlighter__writeLastLine_closure(_this, line));
        t1._contents += "\n";
        return;
      }
      t2 = _this._highlighter$_buffer;
      t2._contents += " ";
      textInside = J.substring$2$s(line, 0, endColumn);
      _this._colorize$1(new U.Highlighter__writeLastLine_closure0(_this, textInside));
      _this._writeText$1(C.JSString_methods.substring$1(line, endColumn));
      t2._contents += "\n";
      t1.endColumn = endColumn + _this._countTabs$1(textInside) * 3;
      _this._writeSidebar$0();
      t2._contents += " ";
      _this._colorize$1(new U.Highlighter__writeLastLine_closure1(t1, _this));
      t2._contents += "\n";
    },
    _writeTrailingLines$1: function(lines) {
      var t1, lineNumber, t2, t3, t4, _this = this;
      H.assertSubtype(lines, "$isIterable", [P.String], "$asIterable");
      t1 = _this._highlighter$_span;
      t1 = t1.get$end(t1);
      t1 = t1.get$line(t1);
      if (typeof t1 !== "number")
        return t1.$add();
      lineNumber = t1 + 1;
      for (t1 = new H.ListIterator(lines, lines.get$length(lines), [H.getTypeArgumentByIndex(lines, 0)]), t2 = _this._highlighter$_buffer, t3 = _this._multiline; t1.moveNext$0();) {
        t4 = t1.__internal$_current;
        _this._writeSidebar$1$line(lineNumber);
        t2._contents += C.JSString_methods.$mul(" ", t3 ? 3 : 1);
        _this._writeText$1(t4);
        t2._contents += "\n";
        ++lineNumber;
      }
    },
    _writeText$1: function(text) {
      var t1, t2, t3;
      for (text.toString, t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1), [P.int]), t2 = this._highlighter$_buffer; t1.moveNext$0();) {
        t3 = t1.__internal$_current;
        if (t3 === 9)
          t2._contents += C.JSString_methods.$mul(" ", 4);
        else
          t2._contents += H.Primitives_stringFromCharCode(t3);
      }
    },
    _writeSidebar$2$end$line: function(end, line) {
      this._colorize$2$color(new U.Highlighter__writeSidebar_closure(this, line, end), "\x1b[34m");
    },
    _writeSidebar$1$end: function(end) {
      return this._writeSidebar$2$end$line(end, null);
    },
    _writeSidebar$1$line: function(line) {
      return this._writeSidebar$2$end$line(null, line);
    },
    _writeSidebar$0: function() {
      return this._writeSidebar$2$end$line(null, null);
    },
    _countTabs$1: function(text) {
      var t1, count;
      for (t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1), [P.int]), count = 0; t1.moveNext$0();)
        if (t1.__internal$_current === 9)
          ++count;
      return count;
    },
    _isOnlyWhitespace$1: function(text) {
      var t1, t2;
      for (t1 = new H.CodeUnits(text), t1 = new H.ListIterator(t1, t1.get$length(t1), [P.int]); t1.moveNext$0();) {
        t2 = t1.__internal$_current;
        if (t2 !== 32 && t2 !== 9)
          return false;
      }
      return true;
    },
    _colorize$2$color: function(callback, color) {
      var t1, t2;
      H.functionTypeCheck(callback, {func: 1, ret: -1});
      t1 = this._color;
      t2 = t1 != null;
      if (t2) {
        t1 = color == null ? t1 : color;
        this._highlighter$_buffer._contents += t1;
      }
      callback.call$0();
      if (t2)
        this._highlighter$_buffer._contents += "\x1b[0m";
    },
    _colorize$1: function(callback) {
      return this._colorize$2$color(callback, null);
    }
  };
  U.Highlighter__writeFirstLine_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += "\u250c";
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    },
    $signature: 0
  };
  U.Highlighter__writeFirstLine_closure0.prototype = {
    call$0: function() {
      return this.$this._writeText$1(this.textInside);
    },
    $signature: 1
  };
  U.Highlighter__writeFirstLine_closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this._highlighter$_buffer;
      t1._contents += "\u250c";
      t2 = t1._contents += C.JSString_methods.$mul("\u2500", this._box_0.startColumn + 1);
      t1._contents = t2 + "^";
    },
    $signature: 0
  };
  U.Highlighter__writeFirstLine_closure2.prototype = {
    call$0: function() {
      var t1 = this._box_0;
      this.$this._highlighter$_buffer._contents += C.JSString_methods.$mul("^", Math.max(t1.endColumn - t1.startColumn, 1));
      return;
    },
    $signature: 1
  };
  U.Highlighter__writeIntermediateLines_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += "\u2502";
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    },
    $signature: 0
  };
  U.Highlighter__writeLastLine_closure.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += "\u2514";
      t2._contents = t3 + " ";
      t1._writeText$1(this.line);
    },
    $signature: 0
  };
  U.Highlighter__writeLastLine_closure0.prototype = {
    call$0: function() {
      var t1 = this.$this,
        t2 = t1._highlighter$_buffer,
        t3 = t2._contents += "\u2502";
      t2._contents = t3 + " ";
      t1._writeText$1(this.textInside);
    },
    $signature: 0
  };
  U.Highlighter__writeLastLine_closure1.prototype = {
    call$0: function() {
      var t2,
        t1 = this.$this._highlighter$_buffer;
      t1._contents += "\u2514";
      t2 = t1._contents += C.JSString_methods.$mul("\u2500", this._box_0.endColumn);
      t1._contents = t2 + "^";
    },
    $signature: 0
  };
  U.Highlighter__writeSidebar_closure.prototype = {
    call$0: function() {
      var t1 = this.line,
        t2 = this.$this,
        t3 = t2._highlighter$_buffer;
      t2 = t2._paddingBeforeSidebar;
      if (t1 != null)
        t3._contents += C.JSString_methods.padRight$1(C.JSInt_methods.toString$0(t1 + 1), t2);
      else
        t3._contents += C.JSString_methods.$mul(" ", t2);
      t1 = this.end;
      t3._contents += t1 == null ? "\u2502" : t1;
    },
    $signature: 0
  };
  V.SourceLocation0.prototype = {
    distance$1: function(other) {
      var t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return Math.abs(this.offset - other.get$offset(other));
    },
    compareTo$1: function(_, other) {
      var t1;
      H.interceptedTypeCheck(other, "$isSourceLocation0");
      t1 = this.sourceUrl;
      if (!J.$eq$(t1, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return this.offset - other.get$offset(other);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceLocation0 && J.$eq$(this.sourceUrl, other.get$sourceUrl()) && this.offset === other.get$offset(other);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.sourceUrl) + this.offset;
    },
    toString$0: function(_) {
      var _this = this,
        t1 = "<" + H.getRuntimeType(_this).toString$0(0) + ": " + _this.offset + " ",
        source = _this.sourceUrl;
      return t1 + (H.S(source == null ? "unknown source" : source) + ":" + (_this.line + 1) + ":" + (_this.column + 1)) + ">";
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceLocation0];
    },
    get$sourceUrl: function() {
      return this.sourceUrl;
    },
    get$offset: function(receiver) {
      return this.offset;
    },
    get$line: function(receiver) {
      return this.line;
    },
    get$column: function() {
      return this.column;
    }
  };
  D.SourceLocationMixin.prototype = {
    distance$1: function(other) {
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return Math.abs(this.offset - other.get$offset(other));
    },
    compareTo$1: function(_, other) {
      H.interceptedTypeCheck(other, "$isSourceLocation0");
      if (!J.$eq$(this.file.url, other.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
      return this.offset - other.get$offset(other);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceLocation0 && J.$eq$(this.file.url, other.get$sourceUrl()) && this.offset === other.get$offset(other);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.file.url) + this.offset;
    },
    toString$0: function(_) {
      var t1 = this.offset,
        t2 = "<" + H.getRuntimeType(this).toString$0(0) + ": " + t1 + " ",
        t3 = this.file,
        source = t3.url,
        t4 = H.S(source == null ? "unknown source" : source) + ":",
        t5 = t3.getLine$1(t1);
      if (typeof t5 !== "number")
        return t5.$add();
      return t2 + (t4 + (t5 + 1) + ":" + (t3.getColumn$1(t1) + 1)) + ">";
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceLocation0];
    },
    $isSourceLocation0: 1
  };
  V.SourceSpan.prototype = {$isComparable: 1,
    $asComparable: function() {
      return [V.SourceSpan];
    }
  };
  V.SourceSpanBase.prototype = {
    SourceSpanBase$3: function(start, end, text) {
      var t3,
        t1 = this.end,
        t2 = this.start;
      if (!J.$eq$(t1.get$sourceUrl(), t2.get$sourceUrl()))
        throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t2.get$sourceUrl()) + '" and  "' + H.S(t1.get$sourceUrl()) + "\" don't match."));
      else if (t1.get$offset(t1) < t2.get$offset(t2))
        throw H.wrapException(P.ArgumentError$("End " + t1.toString$0(0) + " must come after start " + t2.toString$0(0) + "."));
      else {
        t3 = this.text;
        if (t3.length !== t2.distance$1(t1))
          throw H.wrapException(P.ArgumentError$('Text "' + t3 + '" must be ' + t2.distance$1(t1) + " characters long."));
      }
    },
    get$start: function(receiver) {
      return this.start;
    },
    get$end: function(receiver) {
      return this.end;
    },
    get$text: function(receiver) {
      return this.text;
    }
  };
  G.SourceSpanException.prototype = {
    get$message: function(_) {
      return this._span_exception$_message;
    },
    toString$0: function(_) {
      return "Error on " + this._span.message$2$color(0, this._span_exception$_message, null);
    }
  };
  G.SourceSpanFormatException.prototype = {
    get$source: function(_) {
      return this._span_exception$_source;
    },
    get$offset: function(_) {
      var t1 = this._span;
      t1 = Y.FileLocation$_(t1.file, t1._file$_start);
      return t1.offset;
    },
    $isFormatException: 1
  };
  Y.SourceSpanMixin.prototype = {
    get$sourceUrl: function() {
      return this.get$start(this).get$sourceUrl();
    },
    get$length: function(_) {
      var t2, _this = this,
        t1 = _this.get$end(_this);
      t1 = t1.get$offset(t1);
      t2 = _this.get$start(_this);
      return t1 - t2.get$offset(t2);
    },
    compareTo$1: function(_, other) {
      var result, _this = this;
      H.interceptedTypeCheck(other, "$isSourceSpan");
      result = _this.get$start(_this).compareTo$1(0, other.get$start(other));
      return result === 0 ? _this.get$end(_this).compareTo$1(0, other.get$end(other)) : result;
    },
    message$2$color: function(_, message, color) {
      var t2, highlight, _this = this,
        t1 = _this.get$start(_this);
      t1 = t1.get$line(t1);
      if (typeof t1 !== "number")
        return t1.$add();
      t1 = "line " + (t1 + 1) + ", column " + (_this.get$start(_this).get$column() + 1);
      if (_this.get$sourceUrl() != null) {
        t2 = _this.get$sourceUrl();
        t2 = t1 + (" of " + $.$get$context0().prettyUri$1(t2));
        t1 = t2;
      }
      t1 += ": " + message;
      highlight = _this.highlight$1$color(0, color);
      if (highlight.length !== 0)
        t1 = t1 + "\n" + highlight;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    message$1: function($receiver, message) {
      return this.message$2$color($receiver, message, null);
    },
    highlight$1$color: function(_, color) {
      var t2, t3, t4, newSpan, _this = this,
        t1 = !!_this.$isSourceSpanWithContext;
      if (!t1 && _this.get$length(_this) === 0)
        return "";
      if (t1 && B.findLineStart(_this.get$context(_this), _this.get$text(_this), _this.get$start(_this).get$column()) != null)
        t1 = _this;
      else {
        t1 = _this.get$start(_this);
        t1 = V.SourceLocation$(t1.get$offset(t1), 0, 0, _this.get$sourceUrl());
        t2 = _this.get$end(_this);
        t2 = t2.get$offset(t2);
        t3 = _this.get$sourceUrl();
        t4 = B.countCodeUnits(_this.get$text(_this), 10);
        t3 = X.SourceSpanWithContext$(t1, V.SourceLocation$(t2, U.Highlighter__lastLineLength(_this.get$text(_this)), t4, t3), _this.get$text(_this), _this.get$text(_this));
        t1 = t3;
      }
      newSpan = U.Highlighter__normalizeEndOfLine(U.Highlighter__normalizeTrailingNewline(U.Highlighter__normalizeNewlines(t1)));
      t1 = newSpan.get$start(newSpan);
      t1 = t1.get$line(t1);
      t2 = newSpan.get$end(newSpan);
      t2 = t2.get$line(t2);
      t3 = newSpan.get$end(newSpan);
      return new U.Highlighter(newSpan, color, t1 != t2, J.toString$0$(t3.get$line(t3)).length + 1, new P.StringBuffer("")).highlight$0(0);
    },
    $eq: function(_, other) {
      var _this = this;
      if (other == null)
        return false;
      return !!J.getInterceptor$(other).$isSourceSpan && _this.get$start(_this).$eq(0, other.get$start(other)) && _this.get$end(_this).$eq(0, other.get$end(other));
    },
    get$hashCode: function(_) {
      var t2, _this = this,
        t1 = _this.get$start(_this);
      t1 = t1.get$hashCode(t1);
      t2 = _this.get$end(_this);
      return t1 + 31 * t2.get$hashCode(t2);
    },
    toString$0: function(_) {
      var _this = this;
      return "<" + H.getRuntimeType(_this).toString$0(0) + ": from " + _this.get$start(_this).toString$0(0) + " to " + _this.get$end(_this).toString$0(0) + ' "' + _this.get$text(_this) + '">';
    },
    $isComparable: 1,
    $asComparable: function() {
      return [V.SourceSpan];
    },
    $isSourceSpan: 1
  };
  X.SourceSpanWithContext.prototype = {
    get$context: function(_) {
      return this._span_with_context$_context;
    }
  };
  A._SplitOptions.prototype = {};
  A.Splitter.prototype = {};
  A.flexSplit_closure.prototype = {
    call$4: function(dimension, size, gutterSize, index) {
      var t1;
      H.numTypeCheck(gutterSize);
      H.intTypeCheck(index);
      t1 = P.String;
      return P.jsify(P.LinkedHashMap_LinkedHashMap$_literal(["flex-basis", "calc(" + H.S(size) + "% - " + H.S(gutterSize) + "px)"], t1, t1));
    },
    "call*": "call$4",
    $requiredArgCount: 4,
    $signature: 251
  };
  A.flexSplit_closure0.prototype = {
    call$3: function(dimension, gutterSize, index) {
      var t1;
      H.numTypeCheck(gutterSize);
      H.intTypeCheck(index);
      t1 = P.String;
      return P.jsify(P.LinkedHashMap_LinkedHashMap$_literal(["flex-basis", H.S(gutterSize) + "px"], t1, t1));
    },
    "call*": "call$3",
    $requiredArgCount: 3,
    $signature: 252
  };
  A.flexSplitBidirectional_createSplitter.prototype = {
    call$0: function() {
      var _this = this,
        horizontal = _this.mediaQueryList.matches,
        t1 = H.boolConversionCheck(horizontal) ? _this.horizontalSizes : _this.verticalSizes;
      _this._box_0.splitter = A.flexSplit(_this.parts, _this.gutterSize, horizontal, _this.minSize, t1);
    },
    $signature: 1
  };
  A.flexSplitBidirectional_closure.prototype = {
    call$1: function(e) {
      J.destroy$2$x(this._box_0.splitter, true, false);
      this.createSplitter.call$0();
    },
    $signature: 6
  };
  E.StringScannerException.prototype = {
    get$source: function(_) {
      return G.SourceSpanFormatException.prototype.get$source.call(this, this);
    }
  };
  X.StringScanner.prototype = {
    get$lastMatch: function() {
      var _this = this;
      if (_this._string_scanner$_position !== _this._lastMatchPosition)
        _this._lastMatch = null;
      return _this._lastMatch;
    },
    scan$1: function(pattern) {
      var success, _this = this,
        t1 = _this._lastMatch = J.matchAsPrefix$2$s(pattern, _this.string, _this._string_scanner$_position);
      _this._lastMatchPosition = _this._string_scanner$_position;
      success = t1 != null;
      if (success)
        _this._lastMatchPosition = _this._string_scanner$_position = t1.get$end(t1);
      return success;
    },
    expect$2$name: function(pattern, $name) {
      var t1, source;
      if (this.scan$1(pattern))
        return;
      if ($name == null) {
        t1 = J.getInterceptor$(pattern);
        if (!!t1.$isRegExp) {
          source = pattern.pattern;
          if (!H.boolConversionCheck($.$get$_slashAutoEscape()))
            source = H.stringReplaceAllUnchecked(source, "/", "\\/");
          $name = "/" + source + "/";
        } else {
          t1 = t1.toString$0(pattern);
          t1 = H.stringReplaceAllUnchecked(t1, "\\", "\\\\");
          $name = '"' + H.stringReplaceAllUnchecked(t1, '"', '\\"') + '"';
        }
      }
      this.error$3$length$position(0, "expected " + $name + ".", 0, this._string_scanner$_position);
    },
    expect$1: function(pattern) {
      return this.expect$2$name(pattern, null);
    },
    expectDone$0: function() {
      var t1 = this._string_scanner$_position;
      if (t1 === this.string.length)
        return;
      this.error$3$length$position(0, "expected no more input.", 0, t1);
    },
    error$3$length$position: function(_, message, $length, position) {
      var t2, t3, t4, t5, sourceFile, end,
        t1 = this.string;
      if (position < 0)
        H.throwExpression(P.RangeError$("position must be greater than or equal to 0."));
      else if (position > t1.length)
        H.throwExpression(P.RangeError$("position must be less than or equal to the string length."));
      t2 = position + $length > t1.length;
      if (t2)
        H.throwExpression(P.RangeError$("position plus length must not go beyond the end of the string."));
      t2 = this.sourceUrl;
      t3 = new H.CodeUnits(t1);
      t4 = H.setRuntimeTypeInfo([0], [P.int]);
      t5 = new Uint32Array(H._ensureNativeList(t3.toList$0(t3)));
      sourceFile = new Y.SourceFile(t2, t4, t5);
      sourceFile.SourceFile$decoded$2$url(t3, t2);
      end = position + $length;
      if (end > t5.length)
        H.throwExpression(P.RangeError$("End " + end + " must not be greater than the number of characters in the file, " + sourceFile.get$length(sourceFile) + "."));
      else if (position < 0)
        H.throwExpression(P.RangeError$("Start may not be negative, was " + position + "."));
      throw H.wrapException(new E.StringScannerException(t1, message, new Y._FileSpan(sourceFile, position, end)));
    }
  };
  S.createServiceObject_closure.prototype = {
    call$1: function(e) {
      return S.createServiceObject(e);
    },
    $signature: 93
  };
  S._createSpecificObject_closure.prototype = {
    call$1: function(e) {
      return this.creator.call$1(H.assertSubtype(e, "$isMap", [P.String, null], "$asMap"));
    },
    $signature: 4
  };
  S.VmService.prototype = {
    _getEventController$1: function(eventName) {
      var t1 = this._eventControllers,
        controller = t1.$index(0, eventName);
      if (controller == null) {
        controller = new P._AsyncBroadcastStreamController(null, null, [S.Event0]);
        t1.$indexSet(0, eventName, controller);
      }
      return controller;
    },
    get$onStdoutEvent: function() {
      var t1 = this._getEventController$1("Stdout");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    get$onStderrEvent: function() {
      var t1 = this._getEventController$1("Stderr");
      return new P._BroadcastStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
    },
    getObject$2: function(_, isolateId, objectId) {
      var m = P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "objectId", objectId]);
      return this._call$1$2(0, "getObject", m, null);
    },
    setExceptionPauseMode$2: function(isolateId, mode) {
      return this._call$1$2(0, "setExceptionPauseMode", P.LinkedHashMap__makeLiteral(["isolateId", isolateId, "mode", mode]), S.Success);
    },
    callServiceExtension$3$args$isolateId: function(method, args, isolateId) {
      var t1;
      H.interceptedTypeCheck(args, "$isMap");
      t1 = args == null;
      if (t1 && isolateId == null)
        return this._call$1$1(0, method, S.Response);
      else if (t1)
        return this._call$1$2(0, method, P.LinkedHashMap__makeLiteral(["isolateId", isolateId]), S.Response);
      else {
        args = P.LinkedHashMap_LinkedHashMap$from(args, null, null);
        if (isolateId != null)
          args.$indexSet(0, "isolateId", isolateId);
        return this._call$1$2(0, method, args, S.Response);
      }
    },
    dispose$0: function() {
      this._streamSub.cancel$0(0);
      var t1 = this._completers;
      t1.get$values(t1).forEach$1(0, new S.VmService_dispose_closure());
    },
    _call$1$2: function(_, method, args, $T) {
      var m, message, _this = this,
        id = "" + ++_this._id,
        t1 = new P._Future($.Zone__current, [$T]);
      _this._completers.$indexSet(0, id, new P._AsyncCompleter(t1, [$T]));
      _this._methodCalls.$indexSet(0, id, method);
      m = P.LinkedHashMap__makeLiteral(["id", id, "method", method]);
      if (args != null)
        m.$indexSet(0, "params", args);
      message = C.C_JsonCodec.encode$2$toEncodable(m, null);
      _this._onSend.add$1(0, message);
      _this._writeMessage.call$1(message);
      return t1;
    },
    _call$1$1: function($receiver, method, $T) {
      return this._call$1$2($receiver, method, null, $T);
    },
    _processMessage$1: function(message) {
      var t1, t2, _this = this;
      if (typeof message === "string")
        _this._processMessageStr$1(message);
      else if (H.checkSubtype(message, "$isList", [P.int], "$asList")) {
        t1 = new Uint8Array(H._ensureNativeList(message)).buffer;
        t1.toString;
        _this._processMessageByteData$1(H.NativeByteData_NativeByteData$view(t1, 0, null));
      } else {
        t1 = J.getInterceptor$(message);
        if (!!t1.$isByteData)
          _this._processMessageByteData$1(message);
        else {
          t2 = _this._log;
          t1.get$runtimeType(message).toString$0(0);
          t2.toString;
        }
      }
    },
    _processMessageByteData$1: function(bytes) {
      var meta, offset, t3, data, map, streamId, $event,
        metaSize = bytes.getUint32(4, false),
        t1 = bytes.buffer,
        t2 = bytes.byteOffset;
      if (typeof t2 !== "number")
        return t2.$add();
      t1.toString;
      meta = C.C_Utf8Codec.decode$1(0, H.NativeUint8List_NativeUint8List$view(t1, t2 + 8, metaSize));
      offset = 8 + metaSize;
      t2 = bytes.buffer;
      t1 = bytes.byteOffset;
      if (typeof t1 !== "number")
        return t1.$add();
      t3 = bytes.byteLength;
      if (typeof t3 !== "number")
        return t3.$sub();
      t2.toString;
      data = H.NativeByteData_NativeByteData$view(t2, t1 + offset, t3 - offset);
      map = C.C_JsonCodec.decode$2$reviver(0, meta, null);
      if (map != null && J.$eq$(J.$index$asx(map, "method"), "streamNotify")) {
        t1 = J.getInterceptor$asx(map);
        streamId = H.stringTypeCheck(J.$index$asx(t1.$index(map, "params"), "streamId"));
        $event = H.interceptedTypeCheck(J.$index$asx(t1.$index(map, "params"), "event"), "$isMap");
        J.$indexSet$ax($event, "_data", data);
        this._getEventController$1(streamId).add$1(0, H.interceptedTypeCheck(S.createServiceObject($event), "$isEvent0"));
      }
    },
    _processMessageStr$1: function(message) {
      var e, s, exception, t1, t2, t3, completer, methodName, result, type, _this = this, _s2_ = "id", _s5_ = "error", json = null;
      try {
        _this._onReceive.add$1(0, message);
        json = C.C_JsonCodec.decode$2$reviver(0, message, null);
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = _this._log;
        H.S(e);
        H.S(s);
        t1.toString;
        return;
      }
      if (H.boolConversionCheck(J.containsKey$1$x(json, "method"))) {
        t1 = [P.String, null];
        if (H.boolConversionCheck(J.containsKey$1$x(json, _s2_)))
          _this._processRequest$1(H.assertSubtype(json, "$isMap", t1, "$asMap"));
        else
          _this._processNotification$1(H.assertSubtype(json, "$isMap", t1, "$asMap"));
      } else {
        if (H.boolConversionCheck(J.containsKey$1$x(json, _s2_)))
          t1 = H.boolConversionCheck(J.containsKey$1$x(json, "result")) || H.boolConversionCheck(J.containsKey$1$x(json, _s5_));
        else
          t1 = false;
        if (t1) {
          t1 = [P.String, null];
          t2 = H.assertSubtype(json, "$isMap", t1, "$asMap");
          t3 = J.getInterceptor$asx(t2);
          completer = _this._completers.remove$1(0, t3.$index(t2, _s2_));
          methodName = _this._methodCalls.remove$1(0, t3.$index(t2, _s2_));
          if (completer == null) {
            t1 = _this._log;
            C.C_JsonCodec.encode$2$toEncodable(t2, null);
            t1.toString;
          } else if (t3.$index(t2, _s5_) != null) {
            t1 = t3.$index(t2, _s5_);
            t2 = J.getInterceptor$asx(t1);
            completer.completeError$1(new S.RPCError(methodName, H.intTypeCheck(t2.$index(t1, "code")), H.stringTypeCheck(t2.$index(t1, "message")), H.interceptedTypeCheck(t2.$index(t1, "data"), "$isMap")));
          } else {
            result = H.subtypeCast(t3.$index(t2, "result"), "$isMap", t1, "$asMap");
            type = H.stringTypeCheck(J.$index$asx(result, "type"));
            if ($._typeFactories.$index(0, type) == null) {
              t1 = S.Response$_fromJson(result);
              completer.complete$1(0, t1);
            } else
              completer.complete$1(0, S.createServiceObject(result));
          }
        } else
          _this._log.toString;
      }
    },
    _processRequest$1: function(json) {
      return this._processRequest$body$VmService(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
    },
    _processRequest$body$VmService: function(json) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, message, t1, m, t2;
      var $async$_processRequest$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$asx(json);
              $async$goto = 2;
              return P._asyncAwait($async$self._routeRequest$2(H.stringTypeCheck(t1.$index(json, "method")), H.interceptedTypeCheck(t1.$index(json, "params"), "$isMap")), $async$_processRequest$1);
            case 2:
              // returning from await.
              m = $async$result;
              t2 = J.getInterceptor$ax(m);
              t2.$indexSet(m, "id", t1.$index(json, "id"));
              t2.$indexSet(m, "jsonrpc", "2.0");
              message = C.C_JsonCodec.encode$2$toEncodable(m, null);
              $async$self._onSend.add$1(0, message);
              $async$self._writeMessage.call$1(message);
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_processRequest$1, $async$completer);
    },
    _processNotification$1: function(json) {
      return this._processNotification$body$VmService(H.assertSubtype(json, "$isMap", [P.String, null], "$asMap"));
    },
    _processNotification$body$VmService: function(json) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter(null),
        $async$self = this, t1, method, params;
      var $async$_processNotification$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$asx(json);
              method = H.stringTypeCheck(t1.$index(json, "method"));
              params = H.interceptedTypeCheck(t1.$index(json, "params"), "$isMap");
              $async$goto = method === "streamNotify" ? 2 : 4;
              break;
            case 2:
              // then
              t1 = J.getInterceptor$asx(params);
              $async$self._getEventController$1(H.stringTypeCheck(t1.$index(params, "streamId"))).add$1(0, H.interceptedTypeCheck(S.createServiceObject(t1.$index(params, "event")), "$isEvent0"));
              // goto join
              $async$goto = 3;
              break;
            case 4:
              // else
              $async$goto = 5;
              return P._asyncAwait($async$self._routeRequest$2(method, params), $async$_processNotification$1);
            case 5:
              // returning from await.
            case 3:
              // join
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$_processNotification$1, $async$completer);
    },
    _routeRequest$2: function(method, params) {
      return this._routeRequest$body$VmService(method, params);
    },
    _routeRequest$body$VmService: function(method, params) {
      var $async$goto = 0,
        $async$completer = P._makeAsyncAwaitCompleter([P.Map,,,]),
        $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, e, st, t1, exception, $async$exception;
      var $async$_routeRequest$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$handler = 4;
              t1 = $async$self._services;
              $async$goto = t1.containsKey$1(0, method) ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return P._asyncAwait(t1.$index(0, method).call$1(H.assertSubtype(params, "$isMap", [P.String, null], "$asMap")), $async$_routeRequest$2);
            case 9:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // join
              t1 = P.LinkedHashMap__makeLiteral(["error", P.LinkedHashMap_LinkedHashMap$_literal(["code", -32601, "message", "Method not found '" + H.S(method) + "'"], P.String, P.Object)]);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$currentError;
              e = H.unwrapException($async$exception);
              st = H.getTraceFromException($async$exception);
              t1 = P.LinkedHashMap__makeLiteral(["error", P.LinkedHashMap_LinkedHashMap$_literal(["code", -32000, "message", "Unexpected Server Error " + H.S(e) + "\n" + H.S(st)], P.String, P.Object)]);
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$_routeRequest$2, $async$completer);
    },
    set$_disposeHandler: function(_disposeHandler) {
      this._disposeHandler = H.functionTypeCheck(_disposeHandler, {func: 1, ret: [P.Future,,]});
    }
  };
  S.VmService_dispose_closure.prototype = {
    call$1: function(c) {
      return H.interceptedTypeCheck(c, "$isCompleter").completeError$1("disposed");
    },
    $signature: 254
  };
  S.RPCError.prototype = {
    get$details: function(_) {
      var t1 = this.data;
      return H.stringTypeCheck(t1 == null ? null : J.$index$asx(t1, "details"));
    },
    toString$0: function(_) {
      var _this = this,
        t1 = _this.message,
        t2 = _this.code,
        t3 = _this.callingMethod;
      if (_this.get$details(_this) == null)
        return H.S(t1) + " (" + H.S(t2) + ") from " + H.S(t3) + "()";
      else
        return H.S(t1) + " (" + H.S(t2) + ") from " + H.S(t3) + "():\n" + H.S(_this.get$details(_this));
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  S.ExtensionData.prototype = {
    toString$0: function(_) {
      return "[ExtensionData " + H.S(this.data) + "]";
    }
  };
  S._NullLog.prototype = {$isLog: 1};
  S.AllocationProfile.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "AllocationProfile");
      t2 = _this.memoryUsage.toJson$0();
      t3 = _this.members;
      t4 = [P.Map, P.String,,];
      t5 = H.getTypeArgumentByIndex(t3, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["memoryUsage", t2, "members", new H.MappedListIterable(t3, H.functionTypeCheck(new S.AllocationProfile_toJson_closure(), {func: 1, ret: t4, args: [t5]}), [t5, t4]).toList$0(0)], t1, null));
      S._setIfNotNull(json, "dateLastAccumulatorReset", _this.dateLastAccumulatorReset);
      S._setIfNotNull(json, "dateLastServiceGC", _this.dateLastServiceGC);
      return json;
    },
    toString$0: function(_) {
      return "[AllocationProfile type: " + H.S(this.type) + ", memoryUsage: " + H.S(this.memoryUsage) + ", members: " + H.S(this.members) + "]";
    },
    set$members: function(members) {
      this.members = H.assertSubtype(members, "$isList", [S.ClassHeapStats], "$asList");
    }
  };
  S.AllocationProfile_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isClassHeapStats").toJson$0();
    },
    $signature: 255
  };
  S.BoundField.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["decl", this.decl.toJson$0(), "value", this.value.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[BoundField decl: " + H.S(this.decl) + ", value: " + H.S(this.value) + "]";
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  S.BoundVariable.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "BoundVariable");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "value", _this.value.toJson$0(), "declarationTokenPos", _this.declarationTokenPos, "scopeStartTokenPos", _this.scopeStartTokenPos, "scopeEndTokenPos", _this.scopeEndTokenPos], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[BoundVariable type: " + H.S(_this.type) + ", name: " + H.S(_this.name) + ", value: " + H.S(_this.value) + ", declarationTokenPos: " + H.S(_this.declarationTokenPos) + ", scopeStartTokenPos: " + H.S(_this.scopeStartTokenPos) + ", scopeEndTokenPos: " + H.S(_this.scopeEndTokenPos) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  S.Breakpoint.prototype = {
    toJson$0: function() {
      var _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Breakpoint");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["breakpointNumber", _this.breakpointNumber, "resolved", _this.resolved, "location", _this.location.toJson$0()], P.String, null));
      S._setIfNotNull(json, "isSyntheticAsyncContinuation", _this.isSyntheticAsyncContinuation);
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Breakpoint && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Breakpoint type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", breakpointNumber: " + H.S(_this.breakpointNumber) + ", resolved: " + H.S(_this.resolved) + ", location: " + H.S(_this.location) + "]";
    }
  };
  S.ClassRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Class");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ClassRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[ClassRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Class.prototype = {
    toJson$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, _this = this, _null = null,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Class");
      t1 = _this.name;
      t2 = _this.isAbstract;
      t3 = _this.isConst;
      t4 = _this.library.toJson$0();
      t5 = _this.interfaces;
      t6 = [P.Map, P.String,,];
      t7 = H.getTypeArgumentByIndex(t5, 0);
      t7 = new H.MappedListIterable(t5, H.functionTypeCheck(new S.Class_toJson_closure(), {func: 1, ret: t6, args: [t7]}), [t7, t6]).toList$0(0);
      t5 = _this.fields;
      t8 = H.getTypeArgumentByIndex(t5, 0);
      t8 = new H.MappedListIterable(t5, H.functionTypeCheck(new S.Class_toJson_closure0(), {func: 1, ret: t6, args: [t8]}), [t8, t6]).toList$0(0);
      t5 = _this.functions;
      t9 = H.getTypeArgumentByIndex(t5, 0);
      t9 = new H.MappedListIterable(t5, H.functionTypeCheck(new S.Class_toJson_closure1(), {func: 1, ret: t6, args: [t9]}), [t9, t6]).toList$0(0);
      t5 = _this.subclasses;
      t10 = H.getTypeArgumentByIndex(t5, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", t1, "abstract", t2, "const", t3, "library", t4, "interfaces", t7, "fields", t8, "functions", t9, "subclasses", new H.MappedListIterable(t5, H.functionTypeCheck(new S.Class_toJson_closure2(), {func: 1, ret: t6, args: [t10]}), [t10, t6]).toList$0(0)], P.String, _null));
      t6 = _this.error;
      S._setIfNotNull(json, "error", t6 == null ? _null : t6.toJson$0());
      t1 = _this.location;
      S._setIfNotNull(json, "location", t1 == null ? _null : t1.toJson$0());
      t1 = _this.superClass;
      S._setIfNotNull(json, "super", t1 == null ? _null : t1.toJson$0());
      t1 = _this.superType;
      S._setIfNotNull(json, "superType", t1 == null ? _null : t1.toJson$0());
      t1 = _this.mixin;
      S._setIfNotNull(json, "mixin", t1 == null ? _null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Class && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Class]";
    },
    set$interfaces: function(interfaces) {
      this.interfaces = H.assertSubtype(interfaces, "$isList", [S.InstanceRef], "$asList");
    },
    set$fields: function(fields) {
      this.fields = H.assertSubtype(fields, "$isList", [S.FieldRef], "$asList");
    },
    set$functions: function(functions) {
      this.functions = H.assertSubtype(functions, "$isList", [S.FuncRef], "$asList");
    },
    set$subclasses: function(subclasses) {
      this.subclasses = H.assertSubtype(subclasses, "$isList", [S.ClassRef], "$asList");
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Class_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isInstanceRef").toJson$0();
    },
    $signature: 94
  };
  S.Class_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFieldRef").toJson$0();
    },
    $signature: 95
  };
  S.Class_toJson_closure1.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFuncRef").toJson$0();
    },
    $signature: 96
  };
  S.Class_toJson_closure2.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isClassRef").toJson$0();
    },
    $signature: 59
  };
  S.ClassHeapStats.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "ClassHeapStats");
      t2 = _this.accumulatedSize;
      t3 = _this.bytesCurrent;
      t4 = _this.instancesAccumulated;
      t5 = _this.instancesCurrent;
      t6 = _this.classRef.toJson$0();
      t7 = _this.new_;
      t8 = P.int;
      t7.toString;
      t9 = H.getTypeArgumentByIndex(t7, 0);
      t9 = new H.MappedListIterable(t7, H.functionTypeCheck(new S.ClassHeapStats_toJson_closure(), {func: 1, ret: t8, args: [t9]}), [t9, t8]).toList$0(0);
      t7 = _this.old;
      t7.toString;
      t10 = H.getTypeArgumentByIndex(t7, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["accumulatedSize", t2, "bytesCurrent", t3, "instancesAccumulated", t4, "instancesCurrent", t5, "class", t6, "new", t9, "old", new H.MappedListIterable(t7, H.functionTypeCheck(new S.ClassHeapStats_toJson_closure0(), {func: 1, ret: t8, args: [t10]}), [t10, t8]).toList$0(0), "promotedBytes", _this.promotedBytes, "promotedInstances", _this.promotedInstances], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[ClassHeapStats]";
    },
    set$new_: function(new_) {
      this.new_ = H.assertSubtype(new_, "$isList", [P.int], "$asList");
    },
    set$old: function(old) {
      this.old = H.assertSubtype(old, "$isList", [P.int], "$asList");
    },
    get$classRef: function() {
      return this.classRef;
    }
  };
  S.ClassHeapStats_toJson_closure.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.ClassHeapStats_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.ClassList.prototype = {
    toJson$0: function() {
      var t2, t3, t4,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "ClassList");
      t2 = this.classes;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["classes", new H.MappedListIterable(t2, H.functionTypeCheck(new S.ClassList_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[ClassList type: " + H.S(this.type) + ", classes: " + H.S(this.classes) + "]";
    },
    set$classes: function(_, classes) {
      this.classes = H.assertSubtype(classes, "$isList", [S.ClassRef], "$asList");
    }
  };
  S.ClassList_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isClassRef").toJson$0();
    },
    $signature: 59
  };
  S.CodeRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Code");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "kind", this.kind], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.CodeRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[CodeRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", kind: " + H.S(_this.kind) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.Code.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "Code");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "kind", this.kind], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Code && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Code type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", kind: " + H.S(_this.kind) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.ContextRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Context");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["length", this.length], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ContextRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[ContextRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", length: " + H.S(this.length) + "]";
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  S.Context.prototype = {
    toJson$0: function() {
      var t1, t2, t3, t4, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Context");
      t1 = _this.length;
      t2 = _this.variables;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["length", t1, "variables", new H.MappedListIterable(t2, H.functionTypeCheck(new S.Context_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0)], P.String, null));
      t3 = _this.parent;
      S._setIfNotNull(json, "parent", t3 == null ? null : t3.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Context && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Context type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", length: " + H.S(_this.length) + ", variables: " + H.S(_this.variables) + "]";
    },
    set$variables: function(variables) {
      this.variables = H.assertSubtype(variables, "$isList", [S.ContextElement], "$asList");
    },
    get$length: function(receiver) {
      return this.length;
    }
  };
  S.Context_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isContextElement").toJson$0();
    },
    $signature: 261
  };
  S.ContextElement.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["value", this.value.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[ContextElement value: " + H.S(this.value) + "]";
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  S.ErrorRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Error");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", this.kind, "message", this.message], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ErrorRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[ErrorRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", kind: " + H.S(_this.kind) + ", message: " + H.S(_this.message) + "]";
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  S.Error0.prototype = {
    toJson$0: function() {
      var t1, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Error");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", _this.kind, "message", _this.message], P.String, null));
      t1 = _this.exception;
      S._setIfNotNull(json, "exception", t1 == null ? null : t1.toJson$0());
      t1 = _this.stacktrace;
      S._setIfNotNull(json, "stacktrace", t1 == null ? null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Error0 && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Error type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", kind: " + H.S(_this.kind) + ", message: " + H.S(_this.message) + "]";
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  S.Event0.prototype = {
    toJson$0: function() {
      var t2, t3, _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.$indexSet(0, "type", "Event");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", _this.kind, "timestamp", _this.timestamp], t1, _null));
      t1 = _this.isolate;
      S._setIfNotNull(json, "isolate", t1 == null ? _null : t1.toJson$0());
      t1 = _this.vm;
      S._setIfNotNull(json, "vm", t1 == null ? _null : t1.toJson$0());
      t1 = _this.breakpoint;
      S._setIfNotNull(json, "breakpoint", t1 == null ? _null : t1.toJson$0());
      t1 = _this.pauseBreakpoints;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = [P.Map, P.String,,];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Event_toJson_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "pauseBreakpoints", t1 == null ? _null : t1.toList$0(0));
      t1 = _this.topFrame;
      S._setIfNotNull(json, "topFrame", t1 == null ? _null : t1.toJson$0());
      t1 = _this.exception;
      S._setIfNotNull(json, "exception", t1 == null ? _null : t1.toJson$0());
      S._setIfNotNull(json, "bytes", _this.bytes);
      t1 = _this.inspectee;
      S._setIfNotNull(json, "inspectee", t1 == null ? _null : t1.toJson$0());
      S._setIfNotNull(json, "extensionRPC", _this.extensionRPC);
      S._setIfNotNull(json, "extensionKind", _this.extensionKind);
      t1 = _this.extensionData;
      S._setIfNotNull(json, "extensionData", t1 == null ? _null : t1.data);
      t1 = _this.timelineEvents;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = [P.Map, P.String,,];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Event_toJson_closure0(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "timelineEvents", t1 == null ? _null : t1.toList$0(0));
      S._setIfNotNull(json, "atAsyncSuspension", _this.atAsyncSuspension);
      S._setIfNotNull(json, "status", _this.status);
      t1 = _this.logRecord;
      S._setIfNotNull(json, "logRecord", t1 == null ? _null : t1.toJson$0());
      S._setIfNotNull(json, "service", _this.service);
      S._setIfNotNull(json, "method", _this.method);
      S._setIfNotNull(json, "alias", _this.alias);
      return json;
    },
    toString$0: function(_) {
      return "[Event type: " + H.S(this.type) + ", kind: " + H.S(this.kind) + ", timestamp: " + H.S(this.timestamp) + "]";
    },
    set$pauseBreakpoints: function(pauseBreakpoints) {
      this.pauseBreakpoints = H.assertSubtype(pauseBreakpoints, "$isList", [S.Breakpoint], "$asList");
    },
    set$timelineEvents: function(timelineEvents) {
      this.timelineEvents = H.assertSubtype(timelineEvents, "$isList", [S.TimelineEvent], "$asList");
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.Event_toJson_closure.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isBreakpoint");
      return f == null ? null : f.toJson$0();
    },
    $signature: 99
  };
  S.Event_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isTimelineEvent") == null ? null : P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
    },
    $signature: 100
  };
  S.FieldRef.prototype = {
    toJson$0: function() {
      var _this = this,
        json = _this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Field");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "owner", _this.owner.toJson$0(), "declaredType", _this.declaredType.toJson$0(), "const", _this.isConst, "final", _this.isFinal, "static", _this.isStatic], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.FieldRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[FieldRef]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$owner: function() {
      return this.owner;
    }
  };
  S.Field.prototype = {
    toJson$0: function() {
      var t1, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Field");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "owner", _this.owner.toJson$0(), "declaredType", _this.declaredType.toJson$0(), "const", _this.isConst, "final", _this.isFinal, "static", _this.isStatic], P.String, null));
      t1 = _this.staticValue;
      S._setIfNotNull(json, "staticValue", t1 == null ? null : t1.toJson$0());
      t1 = _this.location;
      S._setIfNotNull(json, "location", t1 == null ? null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Field && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Field]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$owner: function() {
      return this.owner;
    }
  };
  S.Flag.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "comment", _this.comment, "modified", _this.modified], t1, null));
      S._setIfNotNull(json, "valueAsString", _this.valueAsString);
      return json;
    },
    toString$0: function(_) {
      return "[Flag name: " + H.S(this.name) + ", comment: " + H.S(this.comment) + ", modified: " + H.S(this.modified) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$valueAsString: function(receiver) {
      return this.valueAsString;
    }
  };
  S.FlagList.prototype = {
    toJson$0: function() {
      var t2, t3, t4,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "FlagList");
      t2 = this.flags;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["flags", new H.MappedListIterable(t2, H.functionTypeCheck(new S.FlagList_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[FlagList type: " + H.S(this.type) + ", flags: " + H.S(this.flags) + "]";
    },
    set$flags: function(flags) {
      this.flags = H.assertSubtype(flags, "$isList", [S.Flag], "$asList");
    }
  };
  S.FlagList_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFlag").toJson$0();
    },
    $signature: 264
  };
  S.Frame.prototype = {
    toJson$0: function() {
      var t2, t3, _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.$indexSet(0, "type", "Frame");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["index", _this.index], t1, _null));
      t1 = _this.$function;
      S._setIfNotNull(json, "function", t1 == null ? _null : t1.toJson$0());
      t1 = _this.code;
      S._setIfNotNull(json, "code", t1 == null ? _null : t1.toJson$0());
      t1 = _this.location;
      S._setIfNotNull(json, "location", t1 == null ? _null : t1.toJson$0());
      t1 = _this.vars;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = [P.Map, P.String,,];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Frame_toJson_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "vars", t1 == null ? _null : t1.toList$0(0));
      S._setIfNotNull(json, "kind", _this.kind);
      return json;
    },
    toString$0: function(_) {
      return "[Frame type: " + H.S(this.type) + ", index: " + H.S(this.index) + "]";
    },
    set$vars: function(vars) {
      this.vars = H.assertSubtype(vars, "$isList", [S.BoundVariable], "$asList");
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.Frame_toJson_closure.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isBoundVariable");
      return f == null ? null : f.toJson$0();
    },
    $signature: 265
  };
  S.FuncRef.prototype = {
    toJson$0: function() {
      var _this = this,
        json = _this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Function");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "owner", _this.owner.toJson$0(), "static", _this.isStatic, "const", _this.isConst], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.FuncRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[FuncRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", owner: " + H.S(_this.owner) + ", isStatic: " + H.S(_this.isStatic) + ", isConst: " + H.S(_this.isConst) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$owner: function() {
      return this.owner;
    }
  };
  S.Func.prototype = {
    toJson$0: function() {
      var t1, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Function");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", _this.name, "owner", _this.owner.toJson$0()], P.String, null));
      t1 = _this.location;
      S._setIfNotNull(json, "location", t1 == null ? null : t1.toJson$0());
      t1 = _this.code;
      S._setIfNotNull(json, "code", t1 == null ? null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Func && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Func type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", owner: " + H.S(_this.owner) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    },
    get$owner: function() {
      return this.owner;
    }
  };
  S.InstanceRef.prototype = {
    InstanceRef$_fromJson$1: function(json) {
      var t2, _this = this,
        t1 = J.getInterceptor$asx(json);
      _this.kind = H.stringTypeCheck(t1.$index(json, "kind"));
      _this.classRef = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "class")), "$isClassRef");
      _this.valueAsString = H.stringTypeCheck(t1.$index(json, "valueAsString"));
      t2 = t1.$index(json, "valueAsStringIsTruncated");
      _this.valueAsStringIsTruncated = H.boolTypeCheck(t2 == null ? false : t2);
      _this.length = H.intTypeCheck(t1.$index(json, "length"));
      _this.name = H.stringTypeCheck(t1.$index(json, "name"));
      _this.typeClass = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "typeClass")), "$isClassRef");
      _this.parameterizedClass = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "parameterizedClass")), "$isClassRef");
      _this.pattern = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "pattern")), "$isInstanceRef");
    },
    toJson$0: function() {
      var t1, _this = this, _null = null,
        json = _this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Instance");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", _this.kind, "class", _this.classRef.toJson$0()], P.String, _null));
      S._setIfNotNull(json, "valueAsString", _this.valueAsString);
      t1 = _this.valueAsStringIsTruncated;
      S._setIfNotNull(json, "valueAsStringIsTruncated", t1);
      S._setIfNotNull(json, "length", _this.length);
      S._setIfNotNull(json, "name", _this.name);
      t1 = _this.typeClass;
      S._setIfNotNull(json, "typeClass", t1 == null ? _null : t1.toJson$0());
      t1 = _this.parameterizedClass;
      S._setIfNotNull(json, "parameterizedClass", t1 == null ? _null : t1.toJson$0());
      t1 = _this.pattern;
      S._setIfNotNull(json, "pattern", t1 == null ? _null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.InstanceRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[InstanceRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", kind: " + H.S(_this.kind) + ", classRef: " + H.S(_this.classRef) + "]";
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$classRef: function() {
      return this.classRef;
    },
    get$valueAsString: function(receiver) {
      return this.valueAsString;
    },
    get$length: function(receiver) {
      return this.length;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Instance.prototype = {
    Instance$_fromJson$1: function(json) {
      var t2, _this = this, _null = null,
        _s8_ = "elements",
        _s12_ = "associations",
        t1 = J.getInterceptor$asx(json);
      _this.kind = H.stringTypeCheck(t1.$index(json, "kind"));
      _this.valueAsString = H.stringTypeCheck(t1.$index(json, "valueAsString"));
      t2 = t1.$index(json, "valueAsStringIsTruncated");
      _this.valueAsStringIsTruncated = H.boolTypeCheck(t2 == null ? false : t2);
      _this.length = H.intTypeCheck(t1.$index(json, "length"));
      _this.offset = H.intTypeCheck(t1.$index(json, "offset"));
      _this.count = H.intTypeCheck(t1.$index(json, "count"));
      _this.name = H.stringTypeCheck(t1.$index(json, "name"));
      _this.typeClass = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "typeClass")), "$isClassRef");
      _this.parameterizedClass = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "parameterizedClass")), "$isClassRef");
      _this.set$fields(t1.$index(json, "fields") == null ? _null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t1.$index(json, "fields")), "$isIterable"), true, S.BoundField));
      _this.elements = t1.$index(json, _s8_) == null ? _null : P.List_List$from(H.listSuperNativeTypeCheck(S.createServiceObject(t1.$index(json, _s8_)), "$isIterable"), true, _null);
      _this.set$associations(t1.$index(json, _s12_) == null ? _null : P.List_List$from(H.listSuperNativeTypeCheck(S._createSpecificObject(t1.$index(json, _s12_), S.vm_service_lib_MapAssociation_parse$closure()), "$isIterable"), true, S.MapAssociation));
      _this.bytes = H.stringTypeCheck(t1.$index(json, "bytes"));
      _this.closureFunction = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "closureFunction")), "$isFuncRef");
      _this.mirrorReferent = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "mirrorReferent")), "$isInstanceRef");
      _this.pattern = H.stringTypeCheck(t1.$index(json, "pattern"));
      _this.isCaseSensitive = H.boolTypeCheck(t1.$index(json, "isCaseSensitive"));
      _this.isMultiLine = H.boolTypeCheck(t1.$index(json, "isMultiLine"));
      _this.propertyKey = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "propertyKey")), "$isInstanceRef");
      _this.propertyValue = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "propertyValue")), "$isInstanceRef");
      _this.typeArguments = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "typeArguments")), "$isTypeArgumentsRef");
      _this.parameterIndex = H.intTypeCheck(t1.$index(json, "parameterIndex"));
      _this.targetType = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "targetType")), "$isInstanceRef");
      _this.bound = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "bound")), "$isInstanceRef");
    },
    toJson$0: function() {
      var t1, t2, t3, _this = this, _null = null,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Instance");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", _this.kind], P.String, _null));
      S._setIfNotNull(json, "valueAsString", _this.valueAsString);
      t1 = _this.valueAsStringIsTruncated;
      S._setIfNotNull(json, "valueAsStringIsTruncated", t1);
      S._setIfNotNull(json, "length", _this.length);
      S._setIfNotNull(json, "offset", _this.offset);
      S._setIfNotNull(json, "count", _this.count);
      S._setIfNotNull(json, "name", _this.name);
      t1 = _this.typeClass;
      S._setIfNotNull(json, "typeClass", t1 == null ? _null : t1.toJson$0());
      t1 = _this.parameterizedClass;
      S._setIfNotNull(json, "parameterizedClass", t1 == null ? _null : t1.toJson$0());
      t1 = _this.fields;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = [P.Map, P.String,,];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Instance_toJson_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "fields", t1 == null ? _null : t1.toList$0(0));
      t1 = _this.elements;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Instance_toJson_closure0(), {func: 1, ret: null, args: [t2]}), [t2, null]);
        t1 = t2;
      }
      S._setIfNotNull(json, "elements", t1 == null ? _null : t1.toList$0(0));
      t1 = _this.associations;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = [P.Map, P.String,,];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Instance_toJson_closure1(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "associations", t1 == null ? _null : t1.toList$0(0));
      S._setIfNotNull(json, "bytes", _this.bytes);
      t1 = _this.closureFunction;
      S._setIfNotNull(json, "closureFunction", t1 == null ? _null : t1.toJson$0());
      t1 = _this.mirrorReferent;
      S._setIfNotNull(json, "mirrorReferent", t1 == null ? _null : t1.toJson$0());
      S._setIfNotNull(json, "pattern", _this.pattern);
      S._setIfNotNull(json, "isCaseSensitive", _this.isCaseSensitive);
      S._setIfNotNull(json, "isMultiLine", _this.isMultiLine);
      t1 = _this.propertyKey;
      S._setIfNotNull(json, "propertyKey", t1 == null ? _null : t1.toJson$0());
      t1 = _this.propertyValue;
      S._setIfNotNull(json, "propertyValue", t1 == null ? _null : t1.toJson$0());
      t1 = _this.typeArguments;
      S._setIfNotNull(json, "typeArguments", t1 == null ? _null : t1.toJson$0());
      S._setIfNotNull(json, "parameterIndex", _this.parameterIndex);
      t1 = _this.targetType;
      S._setIfNotNull(json, "targetType", t1 == null ? _null : t1.toJson$0());
      t1 = _this.bound;
      S._setIfNotNull(json, "bound", t1 == null ? _null : t1.toJson$0());
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Instance && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Instance type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + "]";
    },
    set$fields: function(fields) {
      this.fields = H.assertSubtype(fields, "$isList", [S.BoundField], "$asList");
    },
    set$associations: function(associations) {
      this.associations = H.assertSubtype(associations, "$isList", [S.MapAssociation], "$asList");
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$valueAsString: function(receiver) {
      return this.valueAsString;
    },
    get$length: function(receiver) {
      return this.length;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Instance_toJson_closure.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isBoundField");
      return f == null ? null : f.toJson$0();
    },
    $signature: 266
  };
  S.Instance_toJson_closure0.prototype = {
    call$1: function(f) {
      return f == null ? null : f.toJson$0();
    },
    $signature: 4
  };
  S.Instance_toJson_closure1.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isMapAssociation");
      return f == null ? null : f.toJson$0();
    },
    $signature: 267
  };
  S.IsolateRef.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "@Isolate");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["id", this.id, "number", this.number, "name", this.name], t1, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.IsolateRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[IsolateRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", number: " + H.S(_this.number) + ", name: " + H.S(_this.name) + "]";
    },
    get$id: function(receiver) {
      return this.id;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Isolate.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.$indexSet(0, "type", "Isolate");
      t2 = _this.id;
      t3 = _this.number;
      t4 = _this.name;
      t5 = _this.startTime;
      t6 = _this.runnable;
      t7 = _this.livePorts;
      t8 = _this.pauseOnExit;
      t9 = _this.pauseEvent.toJson$0();
      t10 = _this.libraries;
      t11 = [P.Map, P.String,,];
      t12 = H.getTypeArgumentByIndex(t10, 0);
      t12 = new H.MappedListIterable(t10, H.functionTypeCheck(new S.Isolate_toJson_closure(), {func: 1, ret: t11, args: [t12]}), [t12, t11]).toList$0(0);
      t10 = _this.breakpoints;
      t13 = H.getTypeArgumentByIndex(t10, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["id", t2, "number", t3, "name", t4, "startTime", t5, "runnable", t6, "livePorts", t7, "pauseOnExit", t8, "pauseEvent", t9, "libraries", t12, "breakpoints", new H.MappedListIterable(t10, H.functionTypeCheck(new S.Isolate_toJson_closure0(), {func: 1, ret: t11, args: [t13]}), [t13, t11]).toList$0(0), "exceptionPauseMode", _this.exceptionPauseMode], t1, _null));
      t11 = _this.rootLib;
      S._setIfNotNull(json, "rootLib", t11 == null ? _null : t11.toJson$0());
      t2 = _this.error;
      S._setIfNotNull(json, "error", t2 == null ? _null : t2.toJson$0());
      t2 = _this.extensionRPCs;
      if (t2 == null)
        t1 = _null;
      else {
        t3 = H.getTypeArgumentByIndex(t2, 0);
        t1 = new H.MappedListIterable(t2, H.functionTypeCheck(new S.Isolate_toJson_closure1(), {func: 1, ret: t1, args: [t3]}), [t3, t1]);
      }
      S._setIfNotNull(json, "extensionRPCs", t1 == null ? _null : t1.toList$0(0));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Isolate && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Isolate]";
    },
    set$libraries: function(libraries) {
      this.libraries = H.assertSubtype(libraries, "$isList", [S.LibraryRef], "$asList");
    },
    set$breakpoints: function(breakpoints) {
      this.breakpoints = H.assertSubtype(breakpoints, "$isList", [S.Breakpoint], "$asList");
    },
    set$extensionRPCs: function(extensionRPCs) {
      this.extensionRPCs = H.assertSubtype(extensionRPCs, "$isList", [P.String], "$asList");
    },
    get$id: function(receiver) {
      return this.id;
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Isolate_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isLibraryRef").toJson$0();
    },
    $signature: 268
  };
  S.Isolate_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isBreakpoint").toJson$0();
    },
    $signature: 99
  };
  S.Isolate_toJson_closure1.prototype = {
    call$1: function(f) {
      return H.stringTypeCheck(f);
    },
    $signature: 5
  };
  S.InstanceSet.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "InstanceSet");
      t2 = this.totalCount;
      t3 = this.instances;
      t4 = [P.Map, P.String,,];
      t5 = H.getTypeArgumentByIndex(t3, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["totalCount", t2, "instances", new H.MappedListIterable(t3, H.functionTypeCheck(new S.InstanceSet_toJson_closure(), {func: 1, ret: t4, args: [t5]}), [t5, t4]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[InstanceSet type: " + H.S(this.type) + ", totalCount: " + H.S(this.totalCount) + ", instances: " + H.S(this.instances) + "]";
    },
    set$instances: function(instances) {
      this.instances = H.assertSubtype(instances, "$isList", [S.ObjRef], "$asList");
    }
  };
  S.InstanceSet_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isObjRef").toJson$0();
    },
    $signature: 269
  };
  S.LibraryRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Library");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name, "uri", this.uri], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.LibraryRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[LibraryRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", uri: " + H.S(_this.uri) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Library.prototype = {
    toJson$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Library");
      t1 = _this.name;
      t2 = _this.uri;
      t3 = _this.debuggable;
      t4 = _this.dependencies;
      t5 = [P.Map, P.String,,];
      t6 = H.getTypeArgumentByIndex(t4, 0);
      t6 = new H.MappedListIterable(t4, H.functionTypeCheck(new S.Library_toJson_closure(), {func: 1, ret: t5, args: [t6]}), [t6, t5]).toList$0(0);
      t4 = _this.scripts;
      t7 = H.getTypeArgumentByIndex(t4, 0);
      t7 = new H.MappedListIterable(t4, H.functionTypeCheck(new S.Library_toJson_closure0(), {func: 1, ret: t5, args: [t7]}), [t7, t5]).toList$0(0);
      t4 = _this.variables;
      t8 = H.getTypeArgumentByIndex(t4, 0);
      t8 = new H.MappedListIterable(t4, H.functionTypeCheck(new S.Library_toJson_closure1(), {func: 1, ret: t5, args: [t8]}), [t8, t5]).toList$0(0);
      t4 = _this.functions;
      t9 = H.getTypeArgumentByIndex(t4, 0);
      t9 = new H.MappedListIterable(t4, H.functionTypeCheck(new S.Library_toJson_closure2(), {func: 1, ret: t5, args: [t9]}), [t9, t5]).toList$0(0);
      t4 = _this.classes;
      t10 = H.getTypeArgumentByIndex(t4, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", t1, "uri", t2, "debuggable", t3, "dependencies", t6, "scripts", t7, "variables", t8, "functions", t9, "classes", new H.MappedListIterable(t4, H.functionTypeCheck(new S.Library_toJson_closure3(), {func: 1, ret: t5, args: [t10]}), [t10, t5]).toList$0(0)], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Library && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Library]";
    },
    set$dependencies: function(dependencies) {
      this.dependencies = H.assertSubtype(dependencies, "$isList", [S.LibraryDependency], "$asList");
    },
    set$scripts: function(scripts) {
      this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
    },
    set$variables: function(variables) {
      this.variables = H.assertSubtype(variables, "$isList", [S.FieldRef], "$asList");
    },
    set$functions: function(functions) {
      this.functions = H.assertSubtype(functions, "$isList", [S.FuncRef], "$asList");
    },
    set$classes: function(_, classes) {
      this.classes = H.assertSubtype(classes, "$isList", [S.ClassRef], "$asList");
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.Library_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isLibraryDependency").toJson$0();
    },
    $signature: 270
  };
  S.Library_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isScriptRef").toJson$0();
    },
    $signature: 60
  };
  S.Library_toJson_closure1.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFieldRef").toJson$0();
    },
    $signature: 95
  };
  S.Library_toJson_closure2.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFuncRef").toJson$0();
    },
    $signature: 96
  };
  S.Library_toJson_closure3.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isClassRef").toJson$0();
    },
    $signature: 59
  };
  S.LibraryDependency.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["isImport", _this.isImport, "isDeferred", _this.isDeferred, "prefix", _this.prefix, "target", _this.target.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[LibraryDependency isImport: " + H.S(_this.isImport) + ", isDeferred: " + H.S(_this.isDeferred) + ", prefix: " + H.S(_this.prefix) + ", target: " + H.S(_this.target) + "]";
    }
  };
  S.LogRecord.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "LogRecord");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["message", _this.message.toJson$0(), "time", _this.time, "level", _this.level, "sequenceNumber", _this.sequenceNumber, "loggerName", _this.loggerName.toJson$0(), "zone", _this.zone.toJson$0(), "error", _this.error.toJson$0(), "stackTrace", _this.stackTrace.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[LogRecord]";
    },
    get$message: function(receiver) {
      return this.message;
    }
  };
  S.MapAssociation.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["key", this.key.toJson$0(), "value", this.value.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[MapAssociation key: " + H.S(this.key) + ", value: " + H.S(this.value) + "]";
    },
    get$key: function(receiver) {
      return this.key;
    },
    get$value: function(receiver) {
      return this.value;
    }
  };
  S.MemoryUsage.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "MemoryUsage");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["externalUsage", this.externalUsage, "heapCapacity", this.heapCapacity, "heapUsage", this.heapUsage], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[MemoryUsage type: " + H.S(_this.type) + ", externalUsage: " + H.S(_this.externalUsage) + ", heapCapacity: " + H.S(_this.heapCapacity) + ", heapUsage: " + H.S(_this.heapUsage) + "]";
    }
  };
  S.Message0.prototype = {
    toJson$0: function() {
      var _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.$indexSet(0, "type", "Message");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["index", _this.index, "name", _this.name, "messageObjectId", _this.messageObjectId, "size", _this.size], t1, _null));
      t1 = _this.handler;
      S._setIfNotNull(json, "handler", t1 == null ? _null : t1.toJson$0());
      t1 = _this.location;
      S._setIfNotNull(json, "location", t1 == null ? _null : t1.toJson$0());
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Message type: " + H.S(_this.type) + ", index: " + H.S(_this.index) + ", name: " + H.S(_this.name) + ", messageObjectId: " + H.S(_this.messageObjectId) + ", size: " + H.S(_this.size) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.NullValRef.prototype = {
    toJson$0: function() {
      var json = this.super$InstanceRef$toJson();
      json.$indexSet(0, "type", "@Null");
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.NullValRef && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[NullValRef type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", kind: " + H.S(_this.kind) + ", classRef: " + H.S(_this.classRef) + "]";
    }
  };
  S.NullVal.prototype = {
    toJson$0: function() {
      var json = this.super$Instance$toJson();
      json.$indexSet(0, "type", "Null");
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.NullVal && this.id == other.id;
    },
    toString$0: function(_) {
      return "[NullVal type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", kind: " + H.S(this.kind) + "]";
    }
  };
  S.ObjRef.prototype = {
    ObjRef$_fromJson$1: function(json) {
      var t1 = J.getInterceptor$asx(json);
      this.id = H.stringTypeCheck(t1.$index(json, "id"));
      this.fixedId = H.boolTypeCheck(t1.$index(json, "fixedId"));
    },
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "@Object");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["id", this.id], t1, null));
      S._setIfNotNull(json, "fixedId", this.fixedId);
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ObjRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[ObjRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + "]";
    },
    get$id: function(receiver) {
      return this.id;
    }
  };
  S.Obj.prototype = {
    Obj$_fromJson$1: function(json) {
      var _this = this,
        t1 = J.getInterceptor$asx(json);
      _this.id = H.stringTypeCheck(t1.$index(json, "id"));
      _this.fixedId = H.boolTypeCheck(t1.$index(json, "fixedId"));
      _this.classRef = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "class")), "$isClassRef");
      _this.size = H.intTypeCheck(t1.$index(json, "size"));
    },
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "Object");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["id", _this.id], t1, null));
      S._setIfNotNull(json, "fixedId", _this.fixedId);
      t1 = _this.classRef;
      S._setIfNotNull(json, "class", t1 == null ? null : t1.toJson$0());
      S._setIfNotNull(json, "size", _this.size);
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Obj && this.id == other.id;
    },
    toString$0: function(_) {
      return "[Obj type: " + H.S(this.type) + ", id: " + H.S(this.id) + "]";
    },
    get$id: function(receiver) {
      return this.id;
    },
    get$classRef: function() {
      return this.classRef;
    }
  };
  S.ReloadReport.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "ReloadReport");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["success", this.success], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[ReloadReport type: " + H.S(this.type) + ", success: " + H.S(this.success) + "]";
    }
  };
  S.Response.prototype = {
    toJson$0: function() {
      var t1 = this.json,
        t2 = P.String,
        result = t1 == null ? P.LinkedHashMap_LinkedHashMap$_empty(t2, null) : P.LinkedHashMap_LinkedHashMap$of(t1, t2, null);
      t1 = this.type;
      result.$indexSet(0, "type", t1 == null ? "Response" : t1);
      return result;
    },
    toString$0: function(_) {
      return "[Response type: " + H.S(this.type) + "]";
    },
    get$json: function(receiver) {
      return this.json;
    }
  };
  S.Sentinel.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "Sentinel");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", this.kind, "valueAsString", this.valueAsString], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[Sentinel type: " + H.S(this.type) + ", kind: " + H.S(this.kind) + ", valueAsString: " + H.S(this.valueAsString) + "]";
    },
    get$kind: function(receiver) {
      return this.kind;
    },
    get$valueAsString: function(receiver) {
      return this.valueAsString;
    }
  };
  S.ScriptRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@Script");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["uri", this.uri], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.ScriptRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[ScriptRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", uri: " + H.S(this.uri) + "]";
    }
  };
  S.Script.prototype = {
    Script$_fromJson$1: function(json) {
      var _this = this,
        _s13_ = "tokenPosTable",
        t1 = J.getInterceptor$asx(json);
      _this.uri = H.stringTypeCheck(t1.$index(json, "uri"));
      _this.library = H.interceptedTypeCheck(S.createServiceObject(t1.$index(json, "library")), "$isLibraryRef");
      _this.lineOffset = H.intTypeCheck(t1.$index(json, "lineOffset"));
      _this.columnOffset = H.intTypeCheck(t1.$index(json, "columnOffset"));
      _this.source = H.stringTypeCheck(t1.$index(json, "source"));
      _this.set$tokenPosTable(t1.$index(json, _s13_) == null ? null : P.List_List$from(H.listSuperNativeTypeCheck(J.map$1$ax(t1.$index(json, _s13_), new S.Script$_fromJson_closure()), "$isIterable"), true, [P.List, P.int]));
    },
    toJson$0: function() {
      var t1, t2, t3, _this = this,
        json = _this.super$Obj$toJson();
      json.$indexSet(0, "type", "Script");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["uri", _this.uri, "library", _this.library.toJson$0()], P.String, null));
      S._setIfNotNull(json, "lineOffset", _this.lineOffset);
      S._setIfNotNull(json, "columnOffset", _this.columnOffset);
      S._setIfNotNull(json, "source", _this.source);
      t1 = _this.tokenPosTable;
      if (t1 == null)
        t1 = null;
      else {
        t2 = [P.List, P.int];
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Script_toJson_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "tokenPosTable", t1 == null ? null : t1.toList$0(0));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.Script && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Script type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", uri: " + H.S(_this.uri) + ", library: " + H.S(_this.library) + "]";
    },
    set$tokenPosTable: function(tokenPosTable) {
      this.tokenPosTable = H.assertSubtype(tokenPosTable, "$isList", [[P.List, P.int]], "$asList");
    }
  };
  S.Script$_fromJson_closure.prototype = {
    call$1: function(list) {
      return P.List_List$from(H.listSuperNativeTypeCheck(list, "$isIterable"), true, P.int);
    },
    $signature: 272
  };
  S.Script_toJson_closure.prototype = {
    call$1: function(f) {
      H.assertSubtype(f, "$isList", [P.int], "$asList");
      return f == null ? null : J.toList$0$ax(f);
    },
    $signature: 273
  };
  S.ScriptList.prototype = {
    toJson$0: function() {
      var t2, t3, t4,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "ScriptList");
      t2 = this.scripts;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["scripts", new H.MappedListIterable(t2, H.functionTypeCheck(new S.ScriptList_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[ScriptList type: " + H.S(this.type) + ", scripts: " + H.S(this.scripts) + "]";
    },
    set$scripts: function(scripts) {
      this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
    }
  };
  S.ScriptList_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isScriptRef").toJson$0();
    },
    $signature: 60
  };
  S.SourceLocation.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "SourceLocation");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["script", this.script.toJson$0(), "tokenPos", this.tokenPos], t1, null));
      S._setIfNotNull(json, "endTokenPos", this.endTokenPos);
      return json;
    },
    toString$0: function(_) {
      return "[SourceLocation type: " + H.S(this.type) + ", script: " + H.S(this.script) + ", tokenPos: " + H.S(this.tokenPos) + "]";
    }
  };
  S.SourceReport.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "SourceReport");
      t2 = this.ranges;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      t4 = new H.MappedListIterable(t2, H.functionTypeCheck(new S.SourceReport_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0);
      t2 = this.scripts;
      t5 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["ranges", t4, "scripts", new H.MappedListIterable(t2, H.functionTypeCheck(new S.SourceReport_toJson_closure0(), {func: 1, ret: t3, args: [t5]}), [t5, t3]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[SourceReport type: " + H.S(this.type) + ", ranges: " + H.S(this.ranges) + ", scripts: " + H.S(this.scripts) + "]";
    },
    set$ranges: function(ranges) {
      this.ranges = H.assertSubtype(ranges, "$isList", [S.SourceReportRange], "$asList");
    },
    set$scripts: function(scripts) {
      this.scripts = H.assertSubtype(scripts, "$isList", [S.ScriptRef], "$asList");
    }
  };
  S.SourceReport_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isSourceReportRange").toJson$0();
    },
    $signature: 274
  };
  S.SourceReport_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isScriptRef").toJson$0();
    },
    $signature: 60
  };
  S.SourceReportCoverage.prototype = {
    toJson$0: function() {
      var t5,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null),
        t2 = this.hits,
        t3 = P.int,
        t4 = H.getTypeArgumentByIndex(t2, 0);
      t4 = new H.MappedListIterable(t2, H.functionTypeCheck(new S.SourceReportCoverage_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0);
      t2 = this.misses;
      t5 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["hits", t4, "misses", new H.MappedListIterable(t2, H.functionTypeCheck(new S.SourceReportCoverage_toJson_closure0(), {func: 1, ret: t3, args: [t5]}), [t5, t3]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[SourceReportCoverage hits: " + H.S(this.hits) + ", misses: " + H.S(this.misses) + "]";
    },
    set$hits: function(hits) {
      this.hits = H.assertSubtype(hits, "$isList", [P.int], "$asList");
    },
    set$misses: function(misses) {
      this.misses = H.assertSubtype(misses, "$isList", [P.int], "$asList");
    }
  };
  S.SourceReportCoverage_toJson_closure.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.SourceReportCoverage_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.SourceReportRange.prototype = {
    toJson$0: function() {
      var t2, t3, _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["scriptIndex", _this.scriptIndex, "startPos", _this.startPos, "endPos", _this.endPos, "compiled", _this.compiled], t1, _null));
      t1 = _this.error;
      S._setIfNotNull(json, "error", t1 == null ? _null : t1.toJson$0());
      t1 = _this.coverage;
      S._setIfNotNull(json, "coverage", t1 == null ? _null : t1.toJson$0());
      t1 = _this.possibleBreakpoints;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = P.int;
        t3 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.SourceReportRange_toJson_closure(), {func: 1, ret: t2, args: [t3]}), [t3, t2]);
        t1 = t2;
      }
      S._setIfNotNull(json, "possibleBreakpoints", t1 == null ? _null : t1.toList$0(0));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[SourceReportRange scriptIndex: " + H.S(_this.scriptIndex) + ", startPos: " + H.S(_this.startPos) + ", endPos: " + H.S(_this.endPos) + ", compiled: " + H.S(_this.compiled) + "]";
    },
    set$possibleBreakpoints: function(possibleBreakpoints) {
      this.possibleBreakpoints = H.assertSubtype(possibleBreakpoints, "$isList", [P.int], "$asList");
    }
  };
  S.SourceReportRange_toJson_closure.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.Stack.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, _this = this, _null = null,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, _null);
      json.$indexSet(0, "type", "Stack");
      t2 = _this.frames;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      t4 = new H.MappedListIterable(t2, H.functionTypeCheck(new S.Stack_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0);
      t2 = _this.messages;
      t5 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["frames", t4, "messages", new H.MappedListIterable(t2, H.functionTypeCheck(new S.Stack_toJson_closure0(), {func: 1, ret: t3, args: [t5]}), [t5, t3]).toList$0(0)], t1, _null));
      t1 = _this.asyncCausalFrames;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t2 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Stack_toJson_closure1(), {func: 1, ret: t3, args: [t2]}), [t2, t3]);
        t1 = t2;
      }
      S._setIfNotNull(json, "asyncCausalFrames", t1 == null ? _null : t1.toList$0(0));
      t1 = _this.awaiterFrames;
      if (t1 == null)
        t1 = _null;
      else {
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t3 = new H.MappedListIterable(t1, H.functionTypeCheck(new S.Stack_toJson_closure2(), {func: 1, ret: t3, args: [t2]}), [t2, t3]);
        t1 = t3;
      }
      S._setIfNotNull(json, "awaiterFrames", t1 == null ? _null : t1.toList$0(0));
      return json;
    },
    toString$0: function(_) {
      return "[Stack type: " + H.S(this.type) + ", frames: " + H.S(this.frames) + ", messages: " + H.S(this.messages) + "]";
    },
    set$frames: function($frames) {
      this.frames = H.assertSubtype($frames, "$isList", [S.Frame], "$asList");
    },
    set$asyncCausalFrames: function(asyncCausalFrames) {
      this.asyncCausalFrames = H.assertSubtype(asyncCausalFrames, "$isList", [S.Frame], "$asList");
    },
    set$awaiterFrames: function(awaiterFrames) {
      this.awaiterFrames = H.assertSubtype(awaiterFrames, "$isList", [S.Frame], "$asList");
    },
    set$messages: function(messages) {
      this.messages = H.assertSubtype(messages, "$isList", [S.Message0], "$asList");
    }
  };
  S.Stack_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isFrame").toJson$0();
    },
    $signature: 43
  };
  S.Stack_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isMessage0").toJson$0();
    },
    $signature: 276
  };
  S.Stack_toJson_closure1.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isFrame");
      return f == null ? null : f.toJson$0();
    },
    $signature: 43
  };
  S.Stack_toJson_closure2.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isFrame");
      return f == null ? null : f.toJson$0();
    },
    $signature: 43
  };
  S.Success.prototype = {
    toJson$0: function() {
      var json = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      json.$indexSet(0, "type", "Success");
      return json;
    },
    toString$0: function(_) {
      return "[Success type: " + H.S(this.type) + "]";
    }
  };
  S.Timeline.prototype = {
    toJson$0: function() {
      var t2, t3, t4,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "Timeline");
      t2 = this.traceEvents;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["traceEvents", new H.MappedListIterable(t2, H.functionTypeCheck(new S.Timeline_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0), "timeOriginMicros", this.timeOriginMicros, "timeExtentMicros", this.timeExtentMicros], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[Timeline type: " + H.S(_this.type) + ", traceEvents: " + H.S(_this.traceEvents) + ", timeOriginMicros: " + H.S(_this.timeOriginMicros) + ", timeExtentMicros: " + H.S(_this.timeExtentMicros) + "]";
    },
    set$traceEvents: function(traceEvents) {
      this.traceEvents = H.assertSubtype(traceEvents, "$isList", [S.TimelineEvent], "$asList");
    }
  };
  S.Timeline_toJson_closure.prototype = {
    call$1: function(f) {
      H.interceptedTypeCheck(f, "$isTimelineEvent").toString;
      return P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
    },
    $signature: 100
  };
  S.TimelineEvent.prototype = {
    toJson$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
    },
    toString$0: function(_) {
      return "[TimelineEvent ]";
    }
  };
  S.TimelineFlags.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "TimelineFlags");
      t2 = this.recorderName;
      t3 = this.availableStreams;
      t4 = H.getTypeArgumentByIndex(t3, 0);
      t4 = new H.MappedListIterable(t3, H.functionTypeCheck(new S.TimelineFlags_toJson_closure(), {func: 1, ret: t1, args: [t4]}), [t4, t1]).toList$0(0);
      t3 = this.recordedStreams;
      t5 = H.getTypeArgumentByIndex(t3, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["recorderName", t2, "availableStreams", t4, "recordedStreams", new H.MappedListIterable(t3, H.functionTypeCheck(new S.TimelineFlags_toJson_closure0(), {func: 1, ret: t1, args: [t5]}), [t5, t1]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[TimelineFlags type: " + H.S(_this.type) + ", recorderName: " + H.S(_this.recorderName) + ", availableStreams: " + H.S(_this.availableStreams) + ", recordedStreams: " + H.S(_this.recordedStreams) + "]";
    },
    set$availableStreams: function(availableStreams) {
      this.availableStreams = H.assertSubtype(availableStreams, "$isList", [P.String], "$asList");
    },
    set$recordedStreams: function(recordedStreams) {
      this.recordedStreams = H.assertSubtype(recordedStreams, "$isList", [P.String], "$asList");
    }
  };
  S.TimelineFlags_toJson_closure.prototype = {
    call$1: function(f) {
      return H.stringTypeCheck(f);
    },
    $signature: 5
  };
  S.TimelineFlags_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.stringTypeCheck(f);
    },
    $signature: 5
  };
  S.Timestamp.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "Timestamp");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["timestamp", this.timestamp], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[Timestamp type: " + H.S(this.type) + ", timestamp: " + H.S(this.timestamp) + "]";
    }
  };
  S.TypeArgumentsRef.prototype = {
    toJson$0: function() {
      var json = this.super$ObjRef$toJson();
      json.$indexSet(0, "type", "@TypeArguments");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.TypeArgumentsRef && this.id == other.id;
    },
    toString$0: function(_) {
      return "[TypeArgumentsRef type: " + H.S(this.type) + ", id: " + H.S(this.id) + ", name: " + H.S(this.name) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.TypeArguments.prototype = {
    toJson$0: function() {
      var t1, t2, t3, t4,
        json = this.super$Obj$toJson();
      json.$indexSet(0, "type", "TypeArguments");
      t1 = this.name;
      t2 = this.types;
      t3 = [P.Map, P.String,,];
      t4 = H.getTypeArgumentByIndex(t2, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", t1, "types", new H.MappedListIterable(t2, H.functionTypeCheck(new S.TypeArguments_toJson_closure(), {func: 1, ret: t3, args: [t4]}), [t4, t3]).toList$0(0)], P.String, null));
      return json;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.id);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other instanceof S.TypeArguments && this.id == other.id;
    },
    toString$0: function(_) {
      var _this = this;
      return "[TypeArguments type: " + H.S(_this.type) + ", id: " + H.S(_this.id) + ", name: " + H.S(_this.name) + ", types: " + H.S(_this.types) + "]";
    },
    set$types: function(_, types) {
      this.types = H.assertSubtype(types, "$isList", [S.InstanceRef], "$asList");
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.TypeArguments_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isInstanceRef").toJson$0();
    },
    $signature: 94
  };
  S.UnresolvedSourceLocation.prototype = {
    toJson$0: function() {
      var t1, _this = this,
        json = P.LinkedHashMap_LinkedHashMap$_empty(P.String, null);
      json.$indexSet(0, "type", "UnresolvedSourceLocation");
      t1 = _this.script;
      S._setIfNotNull(json, "script", t1 == null ? null : t1.toJson$0());
      S._setIfNotNull(json, "scriptUri", _this.scriptUri);
      S._setIfNotNull(json, "tokenPos", _this.tokenPos);
      S._setIfNotNull(json, "line", _this.line);
      S._setIfNotNull(json, "column", _this.column);
      return json;
    },
    toString$0: function(_) {
      return "[UnresolvedSourceLocation type: " + H.S(this.type) + "]";
    }
  };
  S.Version.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "Version");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["major", this.major, "minor", this.minor], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[Version type: " + H.S(this.type) + ", major: " + H.S(this.major) + ", minor: " + H.S(this.minor) + "]";
    }
  };
  S.VMRef.prototype = {
    toJson$0: function() {
      var t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "@VM");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[VMRef type: " + H.S(this.type) + ", name: " + H.S(this.name) + "]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.VM.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "VM");
      t2 = _this.name;
      t3 = _this.architectureBits;
      t4 = _this.targetCPU;
      t5 = _this.hostCPU;
      t6 = _this.version;
      t7 = _this.pid;
      t8 = _this.startTime;
      t9 = _this.isolates;
      t10 = [P.Map, P.String,,];
      t11 = H.getTypeArgumentByIndex(t9, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["name", t2, "architectureBits", t3, "targetCPU", t4, "hostCPU", t5, "version", t6, "pid", t7, "startTime", t8, "isolates", new H.MappedListIterable(t9, H.functionTypeCheck(new S.VM_toJson_closure(), {func: 1, ret: t10, args: [t11]}), [t11, t10]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[VM]";
    },
    set$isolates: function(isolates) {
      this.isolates = H.assertSubtype(isolates, "$isList", [S.IsolateRef], "$asList");
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  S.VM_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isIsolateRef").toJson$0();
    },
    $signature: 277
  };
  S.CpuProfile.prototype = {
    toJson$0: function() {
      var t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "_CpuProfile");
      t2 = _this.sampleCount;
      t3 = _this.samplePeriod;
      t4 = _this.stackDepth;
      t5 = _this.timeSpan;
      t6 = _this.timeOriginMicros;
      t7 = _this.timeExtentMicros;
      t8 = _this.codes;
      t9 = [P.Map, P.String,,];
      t10 = H.getTypeArgumentByIndex(t8, 0);
      t10 = new H.MappedListIterable(t8, H.functionTypeCheck(new S.CpuProfile_toJson_closure(), {func: 1, ret: t9, args: [t10]}), [t10, t9]).toList$0(0);
      t8 = _this.functions;
      t11 = H.getTypeArgumentByIndex(t8, 0);
      t9 = new H.MappedListIterable(t8, H.functionTypeCheck(new S.CpuProfile_toJson_closure0(), {func: 1, ret: t9, args: [t11]}), [t11, t9]).toList$0(0);
      t11 = _this.exclusiveCodeTrie;
      t8 = P.int;
      t12 = H.getTypeArgumentByIndex(t11, 0);
      t12 = new H.MappedListIterable(t11, H.functionTypeCheck(new S.CpuProfile_toJson_closure1(), {func: 1, ret: t8, args: [t12]}), [t12, t8]).toList$0(0);
      t11 = _this.inclusiveCodeTrie;
      t13 = H.getTypeArgumentByIndex(t11, 0);
      t13 = new H.MappedListIterable(t11, H.functionTypeCheck(new S.CpuProfile_toJson_closure2(), {func: 1, ret: t8, args: [t13]}), [t13, t8]).toList$0(0);
      t11 = _this.exclusiveFunctionTrie;
      t14 = H.getTypeArgumentByIndex(t11, 0);
      t14 = new H.MappedListIterable(t11, H.functionTypeCheck(new S.CpuProfile_toJson_closure3(), {func: 1, ret: t8, args: [t14]}), [t14, t8]).toList$0(0);
      t11 = _this.inclusiveFunctionTrie;
      t15 = H.getTypeArgumentByIndex(t11, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["sampleCount", t2, "samplePeriod", t3, "stackDepth", t4, "timeSpan", t5, "timeOriginMicros", t6, "timeExtentMicros", t7, "codes", t10, "functions", t9, "exclusiveCodeTrie", t12, "inclusiveCodeTrie", t13, "exclusiveFunctionTrie", t14, "inclusiveFunctionTrie", new H.MappedListIterable(t11, H.functionTypeCheck(new S.CpuProfile_toJson_closure4(), {func: 1, ret: t8, args: [t15]}), [t15, t8]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[_CpuProfile]";
    },
    set$codes: function(codes) {
      this.codes = H.assertSubtype(codes, "$isList", [S.CodeRegion], "$asList");
    },
    set$functions: function(functions) {
      this.functions = H.assertSubtype(functions, "$isList", [S.ProfileFunction], "$asList");
    },
    set$exclusiveCodeTrie: function(exclusiveCodeTrie) {
      this.exclusiveCodeTrie = H.assertSubtype(exclusiveCodeTrie, "$isList", [P.int], "$asList");
    },
    set$inclusiveCodeTrie: function(inclusiveCodeTrie) {
      this.inclusiveCodeTrie = H.assertSubtype(inclusiveCodeTrie, "$isList", [P.int], "$asList");
    },
    set$exclusiveFunctionTrie: function(exclusiveFunctionTrie) {
      this.exclusiveFunctionTrie = H.assertSubtype(exclusiveFunctionTrie, "$isList", [P.int], "$asList");
    },
    set$inclusiveFunctionTrie: function(inclusiveFunctionTrie) {
      this.inclusiveFunctionTrie = H.assertSubtype(inclusiveFunctionTrie, "$isList", [P.int], "$asList");
    }
  };
  S.CpuProfile_toJson_closure.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isCodeRegion").toJson$0();
    },
    $signature: 278
  };
  S.CpuProfile_toJson_closure0.prototype = {
    call$1: function(f) {
      return H.interceptedTypeCheck(f, "$isProfileFunction").toJson$0();
    },
    $signature: 279
  };
  S.CpuProfile_toJson_closure1.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.CpuProfile_toJson_closure2.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.CpuProfile_toJson_closure3.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.CpuProfile_toJson_closure4.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.CodeRegion.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", _this.kind, "inclusiveTicks", _this.inclusiveTicks, "exclusiveTicks", _this.exclusiveTicks, "code", _this.code.toJson$0()], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[CodeRegion kind: " + H.S(_this.kind) + ", inclusiveTicks: " + H.S(_this.inclusiveTicks) + ", exclusiveTicks: " + H.S(_this.exclusiveTicks) + ", code: " + H.S(_this.code) + "]";
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.ProfileFunction.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null),
        t2 = _this.kind,
        t3 = _this.inclusiveTicks,
        t4 = _this.exclusiveTicks,
        t5 = _this.$function.toJson$0(),
        t6 = _this.codes,
        t7 = P.int,
        t8 = H.getTypeArgumentByIndex(t6, 0);
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["kind", t2, "inclusiveTicks", t3, "exclusiveTicks", t4, "function", t5, "codes", new H.MappedListIterable(t6, H.functionTypeCheck(new S.ProfileFunction_toJson_closure(), {func: 1, ret: t7, args: [t8]}), [t8, t7]).toList$0(0)], t1, null));
      return json;
    },
    toString$0: function(_) {
      var _this = this;
      return "[ProfileFunction kind: " + H.S(_this.kind) + ", inclusiveTicks: " + H.S(_this.inclusiveTicks) + ", exclusiveTicks: " + H.S(_this.exclusiveTicks) + ", function: " + H.S(_this.$function) + ", codes: " + H.S(_this.codes) + "]";
    },
    set$codes: function(codes) {
      this.codes = H.assertSubtype(codes, "$isList", [P.int], "$asList");
    },
    get$kind: function(receiver) {
      return this.kind;
    }
  };
  S.ProfileFunction_toJson_closure.prototype = {
    call$1: function(f) {
      return H.intTypeCheck(f);
    },
    $signature: 8
  };
  S.HeapSpace.prototype = {
    toJson$0: function() {
      var _this = this,
        t1 = P.String,
        json = P.LinkedHashMap_LinkedHashMap$_empty(t1, null);
      json.$indexSet(0, "type", "HeapSpace");
      json.addAll$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["avgCollectionPeriodMillis", _this.avgCollectionPeriodMillis, "capacity", _this.capacity, "collections", _this.collections, "external", _this.external, "name", _this.name, "time", _this.time, "used", _this.used], t1, null));
      return json;
    },
    toString$0: function(_) {
      return "[HeapSpace]";
    },
    get$name: function(receiver) {
      return this.name;
    }
  };
  F.main_closure.prototype = {
    call$0: function() {
      var framework, e, t1, t2, t3, t4, t5, t6, t7, t8, isolateManager, serviceExtensionManager, framework0, app, exception, _null = null;
      P.print("DevTools version 0.1.2.");
      $._isDarkTheme = P.Uri_parse(J.toString$0$(window.location), 0, _null).get$queryParameters().$index(0, "theme") === "dark";
      $._cssColors.clear$0(0);
      t1 = P.Null;
      t2 = [t1];
      t3 = [t1];
      t1 = [t1];
      t4 = P.String;
      t5 = [P.StreamController, P.bool];
      t6 = [P.List, P.String];
      t2 = new R.ServiceConnectionManager(new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncBroadcastStreamController(_null, _null, [U.VmServiceWrapper]), new P._AsyncBroadcastStreamController(_null, _null, t2), new P._AsyncCompleter(new P._Future($.Zone__current, t3), t1), P.LinkedHashMap_LinkedHashMap$_empty(t4, t5), P.LinkedHashMap_LinkedHashMap$_empty(t4, t6));
      t7 = S.IsolateRef;
      t8 = H.setRuntimeTypeInfo([], [t7]);
      t7 = [t7];
      isolateManager = new R.IsolateManager(t8, new P._AsyncBroadcastStreamController(_null, _null, t7), new P._AsyncBroadcastStreamController(_null, _null, t7), new P._AsyncBroadcastStreamController(_null, _null, t7), new P._AsyncCompleter(new P._Future($.Zone__current, t3), t1));
      serviceExtensionManager = isolateManager._serviceExtensionManager = new R.ServiceExtensionManager(P.LinkedHashMap_LinkedHashMap$_empty(t4, t5), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.StreamController, R.ServiceExtensionState]), P.LinkedHashSet_LinkedHashSet(t4), P.LinkedHashMap_LinkedHashMap$_empty(t4, R.ServiceExtensionState), P.LinkedHashSet_LinkedHashSet(t4), new P._AsyncCompleter(new P._Future($.Zone__current, t3), t1));
      t2._isolateManager = serviceExtensionManager._isolateManager = isolateManager;
      t2._serviceExtensionManager = serviceExtensionManager;
      $.globals.$indexSet(0, C.Type_ServiceConnectionManager_qdG, t2);
      t1 = new A.MessageBus();
      t1.set$_controller(new P._AsyncBroadcastStreamController(_null, _null, [A.BusEvent]));
      $.globals.$indexSet(0, C.Type_MessageBus_MAi, t1);
      t1 = N.Screen;
      t2 = H.setRuntimeTypeInfo([], [t1]);
      t3 = -1;
      t5 = new P._Future($.Zone__current, [t3]);
      framework0 = new F.PerfToolFramework(t2, P.LinkedHashMap_LinkedHashMap$_empty(t1, A.CoreElement), new P._AsyncCompleter(t5, [t3]), new X.MessageManager(new A.CoreElement(document.querySelector("#messages-container")), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.Set, X.Message]), H.setRuntimeTypeInfo([], [t4])));
      framework0.Framework$0();
      t1 = W.Event;
      W._EventStreamSubscription$(window, "error", H.functionTypeCheck(framework0.get$_gAReportExceptions(), {func: 1, ret: -1, args: [t1]}), false, t1);
      framework0.initGlobalUI$0();
      app = new R.App(framework0, P.LinkedHashMap_LinkedHashMap$_empty(t4, {func: 1, ret: [P.Future,,], args: [,]}));
      t1 = app.get$devToolsReady();
      app._register$1$2("devToolsReady", t1, t3);
      app._register$1$2("echo", app.get$echo(), t3);
      app._register$1$2("switchPage", app.get$switchPage(), t3);
      app._register$1$2("currentPageId", app.get$currentPageId(), t4);
      app._register$1$2("connectDialog.isVisible", app.get$connectDialogIsVisible(), t3);
      app._register$1$2("connectDialog.connectTo", app.get$connectDialogConnectTo(), t3);
      app._register$1$2("logging.clearLogs", app.get$logsClearLogs(), t3);
      app._register$1$2("logging.logCount", app.get$logsLogCount(), P.int);
      app._register$1$2("debugger.getState", app.get$debuggerGetState(), t4);
      app._register$1$2("debugger.getLocation", app.get$debuggerGetLocation(), t4);
      app._register$1$2("debugger.resume", app.get$debuggerResume(), t3);
      app._register$1$2("debugger.pause", app.get$debuggerPause(), t3);
      app._register$1$2("debugger.step", app.get$debuggerStep(), t3);
      app._register$1$2("debugger.clearBreakpoints", app.get$debuggerClearBreakpoints(), t3);
      app._register$1$2("debugger.addBreakpoint", app.get$debuggerAddBreakpoint(), t3);
      app._register$1$2("debugger.setExceptionPauseMode", app.get$debuggerSetExceptionPauseMode(), t3);
      app._register$1$2("debugger.getBreakpoints", app.get$debuggerGetBreakpoints(), t6);
      app._register$1$2("debugger.supportsScripts", app.get$debuggerSupportsScripts(), P.bool);
      app._register$1$2("debugger.getScripts", app.get$debuggerGetScripts(), t6);
      app._register$1$2("debugger.getCallStackFrames", app.get$debuggerGetCallStackFrames(), t6);
      app._register$1$2("debugger.getVariables", app.get$debuggerGetVariables(), t6);
      app._register$1$2("debugger.getConsoleContents", app.get$debuggerGetConsoleContents(), t4);
      app._bind$0();
      t5.then$1$1(t1, t3);
      framework = framework0;
      try {
        t1 = self.gtagsEnabled();
        t2 = window.localStorage;
        t3 = self.getDevToolsPropertyID();
        t2.toString;
        if (t2.getItem(H.stringTypeCheck(t3)) != null) {
          t2 = window.localStorage;
          t3 = self.getDevToolsPropertyID();
          t2.toString;
          t3 = t2.getItem(H.stringTypeCheck(t3)).length === 0;
          t2 = t3;
        } else
          t2 = true;
        if (J.$and$bn(t1, t2)) {
          t1 = framework.analyticsDialog;
          t2 = t1.parent.element.style;
          t2.display = "initial";
          J.focus$0$x(t1.acceptButton.element);
        }
      } catch (exception) {
        e = H.unwrapException(exception);
        window;
        if (typeof console != "undefined")
          window.console.error(e);
      }
      t1 = G.browser();
      t1.toString;
      if (t1 != $.$get$chrome()) {
        t1 = G.browser();
        t1.toString;
        framework.disableAppWithError$2("ERROR: You are running DevTools on " + (t1 == $.$get$internetExplorer() || G.browser() == $.$get$Browser_UnknownBrowser() ? "an unsupported browser" : G.browser().name) + ", but DevTools only runs on Chrome.", "Reopen this url in a Chrome browser to use DevTools.");
        return;
      }
      E.FrameworkCore_initVmService(new F.main__closure(framework), _null).then$1$1(new F.main__closure0(framework), _null);
      framework.loadScreenFromLocation$0();
    },
    "call*": "call$0",
    $requiredArgCount: 0,
    $signature: 0
  };
  F.main__closure.prototype = {
    call$2: function(title, error) {
      this.framework.showError$2(title, error);
    },
    $signature: 25
  };
  F.main__closure0.prototype = {
    call$1: function(connected) {
      var t1, t2;
      if (!H.boolConversionCheck(H.boolTypeCheck(connected))) {
        t1 = this.framework;
        t2 = t1.connectDialog.parent.element.style;
        t2.display = "initial";
        t1 = t1.snapshotMessage.parent.element.style;
        t1.display = "initial";
        J.get$children$x(document.querySelector("#content")).clear$0(0);
      }
    },
    $signature: 9
  };
  F.main_closure0.prototype = {
    call$2: function(error, stack) {
      F.error(H.S(error) + "\n" + H.S(stack), true);
      P.print(H.S(error) + "\n" + H.S(stack));
    },
    "call*": "call$2",
    $requiredArgCount: 2,
    $signature: 12
  };
  (function aliases() {
    var _ = J.Interceptor.prototype;
    _.super$Interceptor$toString = _.toString$0;
    _.super$Interceptor$noSuchMethod = _.noSuchMethod$1;
    _ = J.JavaScriptObject.prototype;
    _.super$JavaScriptObject$toString = _.toString$0;
    _ = H.JsLinkedHashMap.prototype;
    _.super$JsLinkedHashMap$internalContainsKey = _.internalContainsKey$1;
    _.super$JsLinkedHashMap$internalGet = _.internalGet$1;
    _.super$JsLinkedHashMap$internalSet = _.internalSet$2;
    _.super$JsLinkedHashMap$internalRemove = _.internalRemove$1;
    _ = P._BroadcastStreamController.prototype;
    _.super$_BroadcastStreamController$_addEventError = _._addEventError$0;
    _ = P.Stream.prototype;
    _.super$Stream$transform = _.transform$1$1;
    _ = P._BufferingStreamSubscription.prototype;
    _.super$_BufferingStreamSubscription$_add = _._add$1;
    _.super$_BufferingStreamSubscription$_addError = _._addError$2;
    _ = P._HashMap.prototype;
    _.super$_HashMap$_containsKey = _._containsKey$1;
    _.super$_HashMap$_get = _._get$1;
    _.super$_HashMap$_set = _._set$2;
    _ = P.ListMixin.prototype;
    _.super$ListMixin$setRange = _.setRange$4;
    _ = P.Iterable.prototype;
    _.super$Iterable$where = _.where$1;
    _ = P.Object.prototype;
    _.super$Object$toString = _.toString$0;
    _ = W.Element.prototype;
    _.super$Element$createFragment = _.createFragment$3$treeSanitizer$validator;
    _ = W.EventTarget.prototype;
    _.super$EventTarget$addEventListener = _.addEventListener$3;
    _ = W._SimpleNodeValidator.prototype;
    _.super$_SimpleNodeValidator$allowsAttribute = _.allowsAttribute$3;
    _ = P.JsObject.prototype;
    _.super$JsObject$$index = _.$index;
    _.super$JsObject$$indexSet = _.$indexSet;
    _ = Z.CpuProfilerView.prototype;
    _.super$CpuProfilerView$update = _.update$0;
    _ = S.Color.prototype;
    _.super$Color$$eq = _.$eq;
    _.super$Color$toString = _.toString$0;
    _ = U.Diagnosticable.prototype;
    _.super$Diagnosticable$debugFillProperties = _.debugFillProperties$1;
    _ = U.DiagnosticableTree.prototype;
    _.super$DiagnosticableTree$toDiagnosticsNode = _.toDiagnosticsNode$2$name$style;
    _ = G.BaseRequest.prototype;
    _.super$BaseRequest$finalize = _.finalize$0;
    _ = Y.SourceSpanMixin.prototype;
    _.super$SourceSpanMixin$compareTo = _.compareTo$1;
    _.super$SourceSpanMixin$$eq = _.$eq;
    _ = S.InstanceRef.prototype;
    _.super$InstanceRef$toJson = _.toJson$0;
    _ = S.Instance.prototype;
    _.super$Instance$toJson = _.toJson$0;
    _ = S.ObjRef.prototype;
    _.super$ObjRef$toJson = _.toJson$0;
    _ = S.Obj.prototype;
    _.super$Obj$toJson = _.toJson$0;
  })();
  (function installTearOffs() {
    var _static_2 = hunkHelpers._static_2,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_0_i = hunkHelpers._instance_0i,
      _static_0 = hunkHelpers._static_0,
      _static_1 = hunkHelpers._static_1,
      _static = hunkHelpers.installStaticTearOff,
      _instance_0_u = hunkHelpers._instance_0u,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance = hunkHelpers.installInstanceTearOff,
      _instance_2_i = hunkHelpers._instance_2i;
    _static_2(J, "_interceptors_JSArray__compareAny$closure", "JSArray__compareAny", 83);
    var _;
    _instance_1_u(_ = H.CastStreamSubscription.prototype, "get$__internal$_onData", "__internal$_onData$1", 18);
    _instance_0_i(_, "get$resume", "resume$0", 1);
    _static_0(H, "_js_helper_Primitives_dateNow$closure", "Primitives_dateNow", 102);
    _static_1(H, "_js_helper___stringIdentity$closure", "_stringIdentity", 5);
    _static_1(P, "async__AsyncRun__scheduleImmediateJsOverride$closure", "_AsyncRun__scheduleImmediateJsOverride", 54);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", "_AsyncRun__scheduleImmediateWithSetImmediate", 54);
    _static_1(P, "async__AsyncRun__scheduleImmediateWithTimer$closure", "_AsyncRun__scheduleImmediateWithTimer", 54);
    _static_1(P, "async_Future__kTrue$closure", "Future__kTrue", 11);
    _static_0(P, "async___startMicrotaskLoop$closure", "_startMicrotaskLoop", 1);
    _static_1(P, "async___nullDataHandler$closure", "_nullDataHandler", 18);
    _static(P, "async___nullErrorHandler$closure", 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_nullErrorHandler", function(error) {
      return P._nullErrorHandler(error, null);
    }], 28, 0);
    _static_0(P, "async___nullDoneHandler$closure", "_nullDoneHandler", 1);
    _static(P, "async___rootHandleUncaughtError$closure", 5, null, ["call$5"], ["_rootHandleUncaughtError"], 282, 0);
    _static(P, "async___rootRun$closure", 4, null, ["call$1$4", "call$4"], ["_rootRun", function($self, $parent, zone, f) {
      return P._rootRun($self, $parent, zone, f, null);
    }], 283, 1);
    _static(P, "async___rootRunUnary$closure", 5, null, ["call$2$5", "call$5"], ["_rootRunUnary", function($self, $parent, zone, f, arg) {
      return P._rootRunUnary($self, $parent, zone, f, arg, null, null);
    }], 284, 1);
    _static(P, "async___rootRunBinary$closure", 6, null, ["call$3$6", "call$6"], ["_rootRunBinary", function($self, $parent, zone, f, arg1, arg2) {
      return P._rootRunBinary($self, $parent, zone, f, arg1, arg2, null, null, null);
    }], 285, 1);
    _static(P, "async___rootRegisterCallback$closure", 4, null, ["call$1$4", "call$4"], ["_rootRegisterCallback", function($self, $parent, zone, f) {
      return P._rootRegisterCallback($self, $parent, zone, f, null);
    }], 286, 0);
    _static(P, "async___rootRegisterUnaryCallback$closure", 4, null, ["call$2$4", "call$4"], ["_rootRegisterUnaryCallback", function($self, $parent, zone, f) {
      return P._rootRegisterUnaryCallback($self, $parent, zone, f, null, null);
    }], 287, 0);
    _static(P, "async___rootRegisterBinaryCallback$closure", 4, null, ["call$3$4", "call$4"], ["_rootRegisterBinaryCallback", function($self, $parent, zone, f) {
      return P._rootRegisterBinaryCallback($self, $parent, zone, f, null, null, null);
    }], 288, 0);
    _static(P, "async___rootErrorCallback$closure", 5, null, ["call$5"], ["_rootErrorCallback"], 289, 0);
    _static(P, "async___rootScheduleMicrotask$closure", 4, null, ["call$4"], ["_rootScheduleMicrotask"], 290, 0);
    _static(P, "async___rootCreateTimer$closure", 5, null, ["call$5"], ["_rootCreateTimer"], 291, 0);
    _static(P, "async___rootCreatePeriodicTimer$closure", 5, null, ["call$5"], ["_rootCreatePeriodicTimer"], 292, 0);
    _static(P, "async___rootPrint$closure", 4, null, ["call$4"], ["_rootPrint"], 293, 0);
    _static_1(P, "async___printToZone$closure", "_printToZone", 75);
    _static(P, "async___rootFork$closure", 5, null, ["call$5"], ["_rootFork"], 294, 0);
    _instance_0_u(_ = P._BroadcastSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_1_i(_ = P._BroadcastStreamController.prototype, "get$add", "add$1", 18);
    _instance_0_i(_, "get$close", "close$0", 10);
    _instance_2_u(_, "get$_addError", "_addError$2", 98);
    _instance(P._Completer.prototype, "get$completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["completeError$2", "completeError$1"], 28, 0);
    _instance(P._SyncCompleter.prototype, "get$complete", 1, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["complete$1", "complete$0"], 160, 0);
    _instance(P._Future.prototype, "get$_completeError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["_completeError$2", "_completeError$1"], 28, 0);
    _instance_1_i(_ = P._StreamController.prototype, "get$add", "add$1", 18);
    _instance(_, "get$addError", 0, 1, function() {
      return [null];
    }, ["call$2", "call$1"], ["addError$2", "addError$1"], 28, 0);
    _instance_0_i(_, "get$close", "close$0", 10);
    _instance_2_u(_, "get$_addError", "_addError$2", 98);
    _instance_0_u(_ = P._ControllerSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_0_i(_ = P._BufferingStreamSubscription.prototype, "get$resume", "resume$0", 1);
    _instance_0_u(_, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_0_i(_ = P._DoneStreamSubscription.prototype, "get$resume", "resume$0", 1);
    _instance_0_u(_, "get$_sendDone", "_sendDone$0", 1);
    _instance_0_u(_ = P._ForwardingStreamSubscription.prototype, "get$_onPause", "_onPause$0", 1);
    _instance_0_u(_, "get$_onResume", "_onResume$0", 1);
    _instance_1_u(_, "get$_handleData", "_handleData$1", 18);
    _instance_2_u(_, "get$_handleError", "_handleError$2", 194);
    _instance_0_u(_, "get$_handleDone", "_handleDone$0", 1);
    _static_2(P, "collection___defaultEquals$closure", "_defaultEquals", 295);
    _static_1(P, "collection___defaultHashCode$closure", "_defaultHashCode", 80);
    _static_2(P, "collection_ListMixin__compareAny$closure", "ListMixin__compareAny", 83);
    _instance(P._LinkedHashSet.prototype, "get$_newSimilarSet", 0, 0, null, ["call$1$0", "call$0"], ["_newSimilarSet$1$0", "_newSimilarSet$0"], 224, 0);
    _static_1(P, "convert___defaultToEncodable$closure", "_defaultToEncodable", 4);
    _instance_1_i(_ = P._ByteCallbackSink.prototype, "get$add", "add$1", 18);
    _instance_0_i(_, "get$close", "close$0", 1);
    _static_1(P, "core__identityHashCode$closure", "identityHashCode", 76);
    _static_2(P, "core__identical$closure", "identical", 103);
    _static_1(P, "core_Uri_decodeComponent$closure", "Uri_decodeComponent", 5);
    _static(W, "html__Html5NodeValidator__standardAttributeValidator$closure", 4, null, ["call$4"], ["_Html5NodeValidator__standardAttributeValidator"], 69, 0);
    _static(W, "html__Html5NodeValidator__uriAttributeValidator$closure", 4, null, ["call$4"], ["_Html5NodeValidator__uriAttributeValidator"], 69, 0);
    _instance_0_i(W.Body.prototype, "get$json", "json$0", 10);
    _instance_2_i(W.HttpRequest.prototype, "get$setRequestHeader", "setRequestHeader$2", 32);
    _instance_0_i(W.PushMessageData.prototype, "get$json", "json$0", 203);
    _instance_0_i(W._EventStreamSubscription.prototype, "get$resume", "resume$0", 1);
    _instance_1_u(P.CssClassSetImpl.prototype, "get$_validateToken", "_validateToken$1", 5);
    _static_1(P, "js___convertToJS$closure", "_convertToJS", 4);
    _static_1(P, "js___convertToDart$closure", "_convertToDart", 93);
    _instance_2_u(_ = U.DeepCollectionEquality.prototype, "get$equals", "equals$2", 103);
    _instance_1_i(_, "get$hash", "hash$1", 76);
    _instance_1_u(_, "get$isValidKey", "isValidKey$1", 30);
    _instance_0_u(O.LineChart.prototype, "get$_updateSize", "_updateSize$0", 1);
    _static_2(F, "breakpoints_view___breakpointComparator$closure", "_breakpointComparator", 297);
    _instance(_ = X.DebuggerScreen.prototype, "get$debuggerShortcuts", 0, 4, null, ["call$4"], ["debuggerShortcuts$4"], 68, 0);
    _instance_1_u(_, "get$_debugger$_handleConnectionStart", "_debugger$_handleConnectionStart$1", 105);
    _instance_1_u(_, "get$_handleIsolateChanged", "_handleIsolateChanged$1", 162);
    _instance_1_u(_, "get$_debugger$_handleConnectionStop", "_debugger$_handleConnectionStop$1", 7);
    _instance_1_u(_ = S.DebuggerState.prototype, "get$_debugger_state$_handleIsolateEvent", "_debugger_state$_handleIsolateEvent$1", 15);
    _instance_1_u(_, "get$getShortScriptName", "getShortScriptName$1", 5);
    _instance_0_u(X.PopupView.prototype, "get$hidePopup", "hidePopup$0", 1);
    _instance_1_u(N.Framework.prototype, "get$handlePopState", "handlePopState$1", 275);
    _instance_0_u(N.Toast.prototype, "get$_hide", "_hide$0", 1);
    _instance_1_u(_ = D.InspectorScreen.prototype, "get$_inspector$_handleConnectionStart", "_inspector$_handleConnectionStart$1", 105);
    _instance_1_u(_, "get$_inspector$_handleConnectionStop", "_inspector$_handleConnectionStop$1", 7);
    _instance_0_u(_, "get$_refreshInspector", "_refreshInspector$0", 1);
    _instance_2_u(_ = Z.InspectorController.prototype, "get$highlightShowNode", "highlightShowNode$2", 110);
    _instance_0_i(_, "get$refresh", "refresh$0", 26);
    _instance_1_u(_, "get$maybeUpdateValueUI", "maybeUpdateValueUI$1", 112);
    _instance_1_u(_, "get$_onExpand", "_onExpand$1", 113);
    _instance_0_u(_, "get$selectionChanged", "selectionChanged$0", 1);
    _instance_2_u(_, "get$_inspector_controller$_onNodeAdded", "_inspector_controller$_onNodeAdded$2", 114);
    _instance_1_u(_ = E.InspectorService.prototype, "get$onDebugVmServiceReceived", "onDebugVmServiceReceived$1", 15);
    _instance_1_u(_, "get$onExtensionVmServiceRecieved", "onExtensionVmServiceRecieved$1", 15);
    _instance_1_u(K.InspectorTree.prototype, "get$onTap", "onTap$1", 78);
    _instance_1_i(K.InspectorTreeFixedRowHeight.prototype, "get$onMouseMove", "onMouseMove$1", 117);
    _instance_1_u(_ = E.InspectorTreeCanvas.prototype, "get$_updateForContainerResize", "_updateForContainerResize$1", 119);
    _instance_2_u(_, "get$_inspector_tree_canvas$_paintCallback", "_inspector_tree_canvas$_paintCallback$2", 85);
    _instance_0_i(_, "get$onMouseLeave", "onMouseLeave$0", 1);
    _instance_1_u(_ = K.InspectorTreeHtml.prototype, "get$onMouseClick", "onMouseClick$1", 48);
    _instance_1_i(_, "get$onMouseMove", "onMouseMove$1", 48);
    _instance_1_i(_, "get$onMouseLeave", "onMouseLeave$1", 48);
    _instance_0_i(_ = Y.LoggingScreen.prototype, "get$_clear", "_clear$0", 1);
    _instance_1_u(_, "get$_handleConnectionStart", "_handleConnectionStart$1", 38);
    _instance_1_u(_, "get$_logging$_handleExtensionEvent", "_logging$_handleExtensionEvent$1", 15);
    _instance_1_u(_, "get$_logging$_handleGCEvent", "_logging$_handleGCEvent$1", 15);
    _instance_1_u(_, "get$_handleDeveloperLogEvent", "_handleDeveloperLogEvent$1", 15);
    _instance_1_u(_, "get$_handleConnectionStop", "_handleConnectionStop$1", 7);
    _instance_1_u(Y._StdoutEventHandler.prototype, "get$handle", "handle$1", 15);
    _instance_1_u(_ = F.PerfToolFramework.prototype, "get$_gAReportExceptions", "_gAReportExceptions$1", 23);
    _instance_0_u(_, "get$_handleIsolateSelect", "_handleIsolateSelect$0", 1);
    _instance(_, "get$_rebuildIsolateSelect", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["_rebuildIsolateSelect$1", "_rebuildIsolateSelect$0"], 129, 0);
    _instance_0_u(F.Status.prototype, "get$dispose", "dispose$0", 1);
    _instance(_ = V.MemoryScreen.prototype, "get$memoryShortcuts", 0, 4, null, ["call$4"], ["memoryShortcuts$4"], 68, 0);
    _instance(_, "get$_callbackPopupSelectClass", 0, 0, null, ["call$1", "call$0"], ["_callbackPopupSelectClass$1", "_callbackPopupSelectClass$0"], 132, 0);
    _instance_0_u(_, "get$_resetAllocatorCounts", "_resetAllocatorCounts$0", 26);
    _instance_0_u(_, "get$_search", "_search$0", 26);
    _instance(_, "get$_loadAllocationProfile", 0, 0, null, ["call$1$reset", "call$0"], ["_loadAllocationProfile$1$reset", "_loadAllocationProfile$0"], 133, 0);
    _instance_0_u(_, "get$_gcNow", "_gcNow$0", 17);
    _instance_1_i(_, "get$select", "select$1", 134);
    _instance_1_u(_, "get$_handleHistoryClicks", "_handleHistoryClicks$1", 135);
    _instance_1_u(_, "get$hoverInstanceAllocations", "hoverInstanceAllocations$1", 136);
    _instance_1_u(_ = T.MemoryController.prototype, "get$_memory_controller$_handleConnectionStart", "_memory_controller$_handleConnectionStart$1", 38);
    _instance_1_u(_, "get$_memory_controller$_handleConnectionStop", "_memory_controller$_handleConnectionStop$1", 7);
    _instance_1_u(M.MemoryPlotly.prototype, "get$_doubleClick", "_doubleClick$1", 52);
    _instance_1_u(_ = T.MemoryTracker.prototype, "get$_handleGCEvent", "_handleGCEvent$1", 15);
    _instance_0_u(_, "get$_pollMemory", "_pollMemory$0", 17);
    _instance_1_u(X.MessageManager.prototype, "get$_showMessage", "_showMessage$1", 156);
    _instance_1_u(_ = R.App.prototype, "get$devToolsReady", "devToolsReady$1", 53);
    _instance_1_u(_, "get$echo", "echo$1", 53);
    _instance_1_u(_, "get$switchPage", "switchPage$1", 53);
    _instance(_, "get$currentPageId", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["currentPageId$1", "currentPageId$0"], 39, 0);
    _instance(_, "get$connectDialogIsVisible", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["connectDialogIsVisible$1", "connectDialogIsVisible$0"], 72, 0);
    _instance(_, "get$connectDialogConnectTo", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["connectDialogConnectTo$1", "connectDialogConnectTo$0"], 16, 0);
    _instance(_, "get$logsClearLogs", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["logsClearLogs$1", "logsClearLogs$0"], 16, 0);
    _instance(_, "get$logsLogCount", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["logsLogCount$1", "logsLogCount$0"], 164, 0);
    _instance(_, "get$debuggerGetState", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetState$1", "debuggerGetState$0"], 39, 0);
    _instance(_, "get$debuggerGetConsoleContents", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetConsoleContents$1", "debuggerGetConsoleContents$0"], 39, 0);
    _instance(_, "get$debuggerGetLocation", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetLocation$1", "debuggerGetLocation$0"], 39, 0);
    _instance(_, "get$debuggerResume", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerResume$1", "debuggerResume$0"], 16, 0);
    _instance(_, "get$debuggerPause", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerPause$1", "debuggerPause$0"], 16, 0);
    _instance(_, "get$debuggerStep", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerStep$1", "debuggerStep$0"], 16, 0);
    _instance(_, "get$debuggerClearBreakpoints", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerClearBreakpoints$1", "debuggerClearBreakpoints$0"], 16, 0);
    _instance(_, "get$debuggerGetBreakpoints", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetBreakpoints$1", "debuggerGetBreakpoints$0"], 40, 0);
    _instance(_, "get$debuggerSupportsScripts", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerSupportsScripts$1", "debuggerSupportsScripts$0"], 72, 0);
    _instance(_, "get$debuggerGetScripts", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetScripts$1", "debuggerGetScripts$0"], 40, 0);
    _instance(_, "get$debuggerGetCallStackFrames", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetCallStackFrames$1", "debuggerGetCallStackFrames$0"], 40, 0);
    _instance(_, "get$debuggerGetVariables", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerGetVariables$1", "debuggerGetVariables$0"], 40, 0);
    _instance(_, "get$debuggerAddBreakpoint", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerAddBreakpoint$1", "debuggerAddBreakpoint$0"], 16, 0);
    _instance(_, "get$debuggerSetExceptionPauseMode", 0, 0, function() {
      return [null];
    }, ["call$1", "call$0"], ["debuggerSetExceptionPauseMode$1", "debuggerSetExceptionPauseMode$0"], 16, 0);
    _instance_0_u(_ = V.PerformanceScreen.prototype, "get$_loadSnapshot", "_loadSnapshot$0", 1);
    _instance_0_u(_, "get$_reset", "_reset$0", 1);
    _instance_1_u(_, "get$_performance$_handleConnectionStart", "_performance$_handleConnectionStart$1", 38);
    _instance_1_u(_, "get$_performance$_handleConnectionStop", "_performance$_handleConnectionStop$1", 7);
    _instance_0_u(V.CpuTracker.prototype, "get$_pollCpu", "_pollCpu$0", 1);
    _instance_1_u(R.IsolateManager.prototype, "get$_handleIsolateEvent", "_handleIsolateEvent$1", 104);
    _instance_1_u(R.ServiceExtensionManager.prototype, "get$_handleExtensionEvent", "_handleExtensionEvent$1", 104);
    _static_2(E, "cpu_profile_model__stackFrameIdCompare$closure", "stackFrameIdCompare", 298);
    _instance_1_u(N.BottomUpProfileProcessor.prototype, "get$cascadeSampleCounts", "cascadeSampleCounts$1", 27);
    _instance_2_u(_ = F.FlameChartCanvas.prototype, "get$_paintCallback", "_paintCallback$2", 85);
    _instance_1_u(_, "get$_onTap", "_onTap$1", 78);
    _instance_1_u(_, "get$_handleMouseWheel", "_handleMouseWheel$1", 81);
    _instance_1_u(_ = K.FrameEventsChart.prototype, "get$_selectItem", "_selectItem$1", 205);
    _instance_1_u(_, "get$_frame_events_chart$_handleMouseWheel", "_frame_events_chart$_handleMouseWheel$1", 81);
    _instance_1_u(_ = A.PlotlyDivGraph.prototype, "get$_plotlyClick", "_plotlyClick$1", 52);
    _instance_1_u(_, "get$_plotlyHover", "_plotlyHover$1", 52);
    _instance_1_u(Y.TimelineController.prototype, "get$recordTraceForTimelineEvent", "recordTraceForTimelineEvent$1", 46);
    _instance_1_u(Q.TimelineEvent0.prototype, "get$_addChild", "_addChild$1", 46);
    _instance_0_u(_ = X.TimelineScreen.prototype, "get$_exitOfflineMode", "_exitOfflineMode$0", 1);
    _instance_0_u(_, "get$_pauseRecording", "_pauseRecording$0", 26);
    _instance_0_u(_, "get$_resumeRecording", "_resumeRecording$0", 26);
    _instance_0_u(_, "get$clearTimeline", "clearTimeline$0", 1);
    _instance_0_u(_, "get$_exportTimeline", "_exportTimeline$0", 1);
    _instance_1_u(_ = N.TimelineService.prototype, "get$_timeline_service$_handleConnectionStart", "_timeline_service$_handleConnectionStart$1", 38);
    _instance_1_u(_, "get$_timeline_service$_handleConnectionStop", "_timeline_service$_handleConnectionStop$1", 7);
    _instance_1_u(X.TreeNode0.prototype, "get$addChild", "addChild$1", 18);
    _static(N, "custom___defaultRenderer$closure", 1, null, ["call$1$1", "call$1"], ["_defaultRenderer", function(item) {
      return N._defaultRenderer(item, null);
    }], 299, 0);
    _instance(N.TreeToggle.prototype, "get$toggle", 1, 0, null, ["call$2$onlyCollapse$onlyExpand", "call$0", "call$1$onlyCollapse", "call$1$onlyExpand"], ["toggle$2$onlyCollapse$onlyExpand", "toggle$0", "toggle$1$onlyCollapse", "toggle$1$onlyExpand"], 219, 0);
    _instance(_ = A.CoreElement.prototype, "get$attribute", 0, 1, null, ["call$2", "call$1"], ["attribute$2", "attribute$1"], 221, 0);
    _instance(_, "get$clazz", 0, 1, null, ["call$2$removeOthers", "call$1"], ["clazz$2$removeOthers", "clazz$1"], 222, 0);
    _instance_1_i(_, "get$add", "add$1", 4);
    _instance_1_u(_, "get$over", "over$1", 88);
    _instance_1_u(_, "get$leave", "leave$1", 88);
    _instance_0_u(_, "get$dispose", "dispose$0", 1);
    _instance_1_u(R.HtmlTreeNavigator.prototype, "get$handleKeyPress", "handleKeyPress$1", 231);
    _instance_0_u(B.DelayedTimer.prototype, "get$_fire", "_fire$0", 1);
    _static_1(T, "intl_Intl__throwLocaleError$closure", "Intl__throwLocaleError", 5);
    _static_1(T, "intl_DateFormat_localeExists$closure", "DateFormat_localeExists", 11);
    _static_1(T, "intl_NumberFormat_localeExists$closure", "NumberFormat_localeExists", 11);
    _instance_1_u(M.Context0.prototype, "get$extension", "extension$1", 5);
    _static_1(L, "browser__Chrome__isChrome$closure", "_Chrome__isChrome", 24);
    _static_1(L, "browser__Firefox__isFirefox$closure", "_Firefox__isFirefox", 24);
    _static_1(L, "browser__Safari__isSafari$closure", "_Safari__isSafari", 24);
    _static_1(L, "browser__WKWebView__isWKWebView$closure", "_WKWebView__isWKWebView", 24);
    _static_1(L, "browser__InternetExplorer__isInternetExplorer$closure", "_InternetExplorer__isInternetExplorer", 24);
    _instance(Y.SourceSpanMixin.prototype, "get$message", 1, 1, null, ["call$2$color", "call$1"], ["message$2$color", "message$1"], 250, 0);
    _static_1(S, "vm_service_lib_ExtensionData_parse$closure", "ExtensionData_parse", 301);
    _static_1(S, "vm_service_lib_AllocationProfile_parse$closure", "AllocationProfile_parse", 302);
    _static_1(S, "vm_service_lib_BoundField_parse$closure", "BoundField_parse", 303);
    _static_1(S, "vm_service_lib_BoundVariable_parse$closure", "BoundVariable_parse", 304);
    _static_1(S, "vm_service_lib_Breakpoint_parse$closure", "Breakpoint_parse", 305);
    _static_1(S, "vm_service_lib_ClassRef_parse$closure", "ClassRef_parse", 306);
    _static_1(S, "vm_service_lib_Class_parse$closure", "Class_parse", 307);
    _static_1(S, "vm_service_lib_ClassHeapStats_parse$closure", "ClassHeapStats_parse", 308);
    _static_1(S, "vm_service_lib_ClassList_parse$closure", "ClassList_parse", 309);
    _static_1(S, "vm_service_lib_CodeRef_parse$closure", "CodeRef_parse", 310);
    _static_1(S, "vm_service_lib_Code_parse$closure", "Code_parse", 311);
    _static_1(S, "vm_service_lib_ContextRef_parse$closure", "ContextRef_parse", 312);
    _static_1(S, "vm_service_lib_Context_parse$closure", "Context_parse", 313);
    _static_1(S, "vm_service_lib_ContextElement_parse$closure", "ContextElement_parse", 314);
    _static_1(S, "vm_service_lib_ErrorRef_parse$closure", "ErrorRef_parse", 315);
    _static_1(S, "vm_service_lib_Error_parse$closure", "Error_parse", 316);
    _static_1(S, "vm_service_lib_Event_parse$closure", "Event_parse", 317);
    _static_1(S, "vm_service_lib_FieldRef_parse$closure", "FieldRef_parse", 318);
    _static_1(S, "vm_service_lib_Field_parse$closure", "Field_parse", 319);
    _static_1(S, "vm_service_lib_Flag_parse$closure", "Flag_parse", 320);
    _static_1(S, "vm_service_lib_FlagList_parse$closure", "FlagList_parse", 321);
    _static_1(S, "vm_service_lib_Frame_parse$closure", "Frame_parse", 322);
    _static_1(S, "vm_service_lib_FuncRef_parse$closure", "FuncRef_parse", 323);
    _static_1(S, "vm_service_lib_Func_parse$closure", "Func_parse", 324);
    _static_1(S, "vm_service_lib_InstanceRef_parse$closure", "InstanceRef_parse", 325);
    _static_1(S, "vm_service_lib_Instance_parse$closure", "Instance_parse", 326);
    _static_1(S, "vm_service_lib_IsolateRef_parse$closure", "IsolateRef_parse", 327);
    _static_1(S, "vm_service_lib_Isolate_parse$closure", "Isolate_parse", 328);
    _static_1(S, "vm_service_lib_InstanceSet_parse$closure", "InstanceSet_parse", 329);
    _static_1(S, "vm_service_lib_LibraryRef_parse$closure", "LibraryRef_parse", 330);
    _static_1(S, "vm_service_lib_Library_parse$closure", "Library_parse", 331);
    _static_1(S, "vm_service_lib_LibraryDependency_parse$closure", "LibraryDependency_parse", 332);
    _static_1(S, "vm_service_lib_LogRecord_parse$closure", "LogRecord_parse", 333);
    _static_1(S, "vm_service_lib_MapAssociation_parse$closure", "MapAssociation_parse", 334);
    _static_1(S, "vm_service_lib_MemoryUsage_parse$closure", "MemoryUsage_parse", 335);
    _static_1(S, "vm_service_lib_Message_parse$closure", "Message_parse", 336);
    _static_1(S, "vm_service_lib_NullValRef_parse$closure", "NullValRef_parse", 337);
    _static_1(S, "vm_service_lib_NullVal_parse$closure", "NullVal_parse", 338);
    _static_1(S, "vm_service_lib_ObjRef_parse$closure", "ObjRef_parse", 339);
    _static_1(S, "vm_service_lib_Obj_parse$closure", "Obj_parse", 340);
    _static_1(S, "vm_service_lib_ReloadReport_parse$closure", "ReloadReport_parse", 341);
    _static_1(S, "vm_service_lib_Response_parse$closure", "Response_parse", 342);
    _static_1(S, "vm_service_lib_Sentinel_parse$closure", "Sentinel_parse", 343);
    _static_1(S, "vm_service_lib_ScriptRef_parse$closure", "ScriptRef_parse", 344);
    _static_1(S, "vm_service_lib_Script_parse$closure", "Script_parse", 345);
    _static_1(S, "vm_service_lib_ScriptList_parse$closure", "ScriptList_parse", 346);
    _static_1(S, "vm_service_lib_SourceLocation_parse$closure", "SourceLocation_parse", 347);
    _static_1(S, "vm_service_lib_SourceReport_parse$closure", "SourceReport_parse", 348);
    _static_1(S, "vm_service_lib_SourceReportCoverage_parse$closure", "SourceReportCoverage_parse", 349);
    _static_1(S, "vm_service_lib_SourceReportRange_parse$closure", "SourceReportRange_parse", 350);
    _static_1(S, "vm_service_lib_Stack_parse$closure", "Stack_parse", 351);
    _static_1(S, "vm_service_lib_Success_parse$closure", "Success_parse", 352);
    _static_1(S, "vm_service_lib_Timeline_parse$closure", "Timeline_parse", 353);
    _static_1(S, "vm_service_lib_TimelineEvent_parse$closure", "TimelineEvent_parse", 354);
    _static_1(S, "vm_service_lib_TimelineFlags_parse$closure", "TimelineFlags_parse", 355);
    _static_1(S, "vm_service_lib_Timestamp_parse$closure", "Timestamp_parse", 356);
    _static_1(S, "vm_service_lib_TypeArgumentsRef_parse$closure", "TypeArgumentsRef_parse", 357);
    _static_1(S, "vm_service_lib_TypeArguments_parse$closure", "TypeArguments_parse", 358);
    _static_1(S, "vm_service_lib_UnresolvedSourceLocation_parse$closure", "UnresolvedSourceLocation_parse", 359);
    _static_1(S, "vm_service_lib_Version_parse$closure", "Version_parse", 360);
    _static_1(S, "vm_service_lib_VMRef_parse$closure", "VMRef_parse", 361);
    _static_1(S, "vm_service_lib_VM_parse$closure", "VM_parse", 362);
    _static_1(S, "vm_service_lib_CpuProfile_parse$closure", "CpuProfile_parse", 363);
    _static_1(S, "vm_service_lib_CodeRegion_parse$closure", "CodeRegion_parse", 364);
    _static_1(S, "vm_service_lib_ProfileFunction_parse$closure", "ProfileFunction_parse", 365);
    _static_1(S, "vm_service_lib_HeapSpace_parse$closure", "HeapSpace_parse", 244);
    _instance_1_u(S.VmService.prototype, "get$_processMessage", "_processMessage$1", 7);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(P.Object, null);
    _inheritMany(P.Object, [H.JS_CONST, J.Interceptor, J.JSObject, J.ArrayIterator, P.Stream, H.CastStreamSubscription, P.Iterable, H.CastIterator, H.Closure, P._ListBase_Object_ListMixin, H.ListIterator, P.Iterator, H.EmptyIterator, H.FixedLengthListMixin, H.UnmodifiableListMixin, H.Symbol, P.MapView, H.ConstantMap, H.JSInvocationMirror, H.TypeErrorDecoder, P.Error, H.ExceptionAndStackTrace, H._StackTrace, H.TypeImpl, P.MapMixin, H.LinkedHashMapCell, H.LinkedHashMapKeyIterator, H.JSSyntaxRegExp, H._MatchImplementation, H._AllMatchesIterator, H.StringMatch, H._StringAllMatchesIterator, P._TimerImpl, P._AsyncAwaitCompleter, P._IterationMarker, P._SyncStarIterator, P._BufferingStreamSubscription, P._BroadcastStreamController, P.Future, P.Completer, P._Completer, P._FutureListener, P._Future, P._AsyncCallbackEntry, P.StreamSubscription, P.StreamTransformerBase, P.StreamController, P._StreamController, P._SyncStreamControllerDispatch, P._AsyncStreamControllerDispatch, P._PendingEvents, P._DelayedEvent, P._DelayedDone, P._DoneStreamSubscription, P._StreamIterator, P.Timer, P.AsyncError, P._ZoneFunction, P.ZoneSpecification, P._ZoneSpecification, P.ZoneDelegate, P.Zone, P._ZoneDelegate, P._Zone, P._HashMapKeyIterator, P._SetBase, P._LinkedHashSetCell, P._LinkedHashSetIterator, P.ListMixin, P._MapBaseValueIterator, P._UnmodifiableMapMixin, P._ListQueueIterator, P.SetMixin, P._SetBase_Object_SetMixin, P._SplayTreeNode, P._SplayTree, P._SplayTreeIterator, P.Codec, P._Base64Encoder, P._Base64Decoder, P.ChunkedConversionSink, P.HtmlEscapeMode, P._JsonStringifier, P._JsonPrettyPrintMixin, P._Utf8Encoder, P._Utf8Decoder, P.bool, P.DateTime, P.num, P.Duration, P.OutOfMemoryError, P.StackOverflowError, P._Exception, P.FormatException, P.Expando, P.Function, P.List, P.Map, P.MapEntry, P.Null, P.Match, P.RegExp, P.RegExpMatch, P.StackTrace, P.Stopwatch, P.String, P.RuneIterator, P.StringBuffer, P.Symbol0, P.Type, P._Uri, P.UriData, P._SimpleUri, W.CssStyleDeclarationBase, W.ScrollAlignment, W.CanvasImageSource, W._Html5NodeValidator, W.ImmutableListMixin, W.NodeValidatorBuilder, W._SimpleNodeValidator, W._SvgNodeValidator, W.FixedSizeListIterator, W._DOMWindowCrossFrame, W.NodeValidator, W._SameOriginUriPolicy, W._ValidatingTreeSanitizer, P._StructuredClone, P._AcceptStructuredClone, P.JsObject, P.Point, P._RectangleBase, P.ByteBuffer, P.ByteData, P.Int8List, P.Uint8List, P.Uint8ClampedList, P.Int16List, P.Uint16List, P.Int32List, P.Uint32List, P.Float32List, P.Float64List, X.ProxyHolder, X.Position, R.JsEventListener, M.CanonicalizedMap, U.DefaultEquality, U.IterableEquality, U.ListEquality, U._UnorderedEquality, U._MapEntry, U.MapEquality, U.DeepCollectionEquality, Y.HeapPriorityQueue, B.Pair, O.LineChart, L.ConnectedApp, A.BusEvent, A.MessageBus, F.BreakpointsView, A.CoreElement, S.CallStackView, O.ConsoleArea, N.Screen, X.SourcePosition, X.SourceEditor, X.ScriptAndPosition, S.DebuggerState, X.ListDirection, X.ScriptsView, X.ScriptsMatcher, V.VariablesView, N.ChildProvider, B.EvalOnDartLibrary, B.LibraryNotFound, N.Framework, N.StatusLine, N.ActionsContainer, N.SetStateMixin, N.StatusItem, N.ConnectDialog, N.SnapshotMessage, N.AnalyticsOptInDialog, U.Diagnosticable, M.InspectorSourceLocation, S.Category, S.FlutterWidget, S.Catalog, Z.InspectorController, E.InspectorService, E.ObjectGroup, E.FlutterTreeType, E.InspectorServiceClient, E.InspectorInstanceRef, E.InspectorObjectGroupManager, K.PaintEntry, K.InspectorTreeNodeRenderBuilder, K.InspectorTreeNodeRender, K.InspectorTreeNode, K.InspectorTreeRow, K.InspectorTree, M.InspectorTreeWeb, Y._StdoutEventHandler, Y.LogData, Q.Column, F.Status, V.NavigationState, V.NavigationPath, T.MemoryController, A.MemoryDataView, M.MemoryPlotly, M.EventTimeline, T.MemoryTracker, T.HeapSample, T.ClassHeapDetailStats, T.InstanceSummary, S.Response, X.MessageManager, X.Message, X.MessageType, R.App, V.CpuTracker, V.PerfData, V._CalcProfile, E.ListDirection0, E.PopupListView, E.AutoCompleteMatcher, E.ToggleableServiceExtensionDescription, R.ServiceConnectionManager, R.IsolateManager, R.ServiceExtensionManager, R.ServiceExtensionState, R.VmServiceCapabilities, Q.HoverCellData, Q._Table_Object_SetStateMixin, Q.ColumnAlignment, Q.SortOrder, E.CpuProfileData, X.TreeNode0, N.CpuProfileProtocol, N.BottomUpProfileProcessor, Z.CpuProfilerViewType, F.FlameChart, F.FlameChartRow, F.FlameChartNode, F.TimelineGrid0, K.FrameFlameChartItem, Y.FramesBarPlotly, Y.SelectTrace, Y.Selection, Y.TimelineController, Q.TimelineData, Q.TimelineFrame, Q.TimelineEventType, Q.TraceEvent, Q.TraceEventWrapper, O.TimelineProtocol, N.TimelineService, N.SelectableTreeNodeItem, N.ActionButton, F.DragScroll, A.TrustedHtmlTreeSanitizer, S.Color, S.OffsetBase, S.Rect, S._HashEnd, S.FontStyle, S.FontWeight, U.DiagnosticLevel, U.DiagnosticsTreeStyle, U.TextTreeConfiguration, U._PrefixedStringBuilder, U._NoDefaultValue, U.DiagnosticsNode, U.DiagnosticPropertiesBuilder, U._WordWrapParseMode, U.TextStyle, Y.HtmlIconRenderer, S.Icon, S.CustomIconMaker, S.IconKind, S.ColorIconMaker, K.ThemedColor, X.TreeNavigator, X.Tree, X.TreeNode, R.HtmlTreeNavigator, Y.ServiceExtensionButton, T._CanvasChunk, T._ChunkPosition, T._ViewportCanvas_Object_SetStateMixin, B.Property, B.DelayedTimer, B.RateLimiter, B.TimeUnit, B.TimeRange, U.VmServiceWrapper, U.TrackedFuture, E.BaseClient, G.BaseRequest, T.BaseResponse, U.Client, E.ClientException, R.MediaType, B.DateSymbols, T.DateFormat, T._DateFormatField, T.NumberFormat, T._NumberFormatParser, T._StringIterator, B.NumberSymbols, X.UninitializedLocaleData, X.LocaleDataException, M.Context0, O.Style, X.ParsedPath, X.PathException, L.Browser, G._HtmlNavigator, G.NavigatorProvider, B.WrappedFuture, U._Wrapper, Y.SourceFile, D.SourceLocationMixin, Y.SourceSpanMixin, U.Highlighter, V.SourceLocation0, V.SourceSpan, G.SourceSpanException, X.StringScanner, S.VmService, S.RPCError, S.ExtensionData, S._NullLog, S.BoundField, S.ContextElement, S.Flag, S.LibraryDependency, S.MapAssociation, S.SourceReportCoverage, S.SourceReportRange, S.TimelineEvent, S.CodeRegion, S.ProfileFunction]);
    _inheritMany(J.Interceptor, [J.JSBool, J.JSNull, J.JavaScriptObject, J.JSArray, J.JSNumber, J.JSString, H.NativeByteBuffer, H.NativeTypedData, W.EventTarget, W.AccessibleNodeList, W.Event, W.Blob, W.BluetoothRemoteGattDescriptor, W.Body, W.CanvasRenderingContext2D, W.Client0, W.Credential, W.CredentialUserData, W.CssRule, W.CssStyleValue, W.CssTransformComponent, W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase, W.DataTransferItem, W.DataTransferItemList, W.ReportBody, W.DomError, W.DomException, W._DomRectList_Interceptor_ListMixin, W.DomRectReadOnly, W._DomStringList_Interceptor_ListMixin, W.DomTokenList, W.Entry, W._FileList_Interceptor_ListMixin, W.FileSystem, W.FontFace, W.Gamepad, W.GamepadButton, W.History, W._HtmlCollection_Interceptor_ListMixin, W.ImageData, W.Location, W.MediaDeviceInfo, W.MediaError, W.MediaList, W._MidiInputMap_Interceptor_MapMixin, W._MidiOutputMap_Interceptor_MapMixin, W.MimeType, W._MimeTypeArray_Interceptor_ListMixin, W.NavigatorUserMediaError, W._NodeList_Interceptor_ListMixin, W.OverconstrainedError, W.PerformanceEntry, W.PerformanceServerTiming, W.Plugin, W._PluginArray_Interceptor_ListMixin, W.PositionError, W.PushMessageData, W.RelatedApplication, W.ResizeObserver, W.ResizeObserverEntry, W.RtcLegacyStatsReport, W._RtcStatsReport_Interceptor_MapMixin, W.SpeechGrammar, W._SpeechGrammarList_Interceptor_ListMixin, W.SpeechRecognitionResult, W.SpeechSynthesisVoice, W._Storage_Interceptor_MapMixin, W.StyleSheet, W._TextTrackCueList_Interceptor_ListMixin, W.TimeRanges, W.Touch, W._TouchList_Interceptor_ListMixin, W.TrackDefaultList, W.Url, W.VideoTrack, W.VttRegion, W.__CssRuleList_Interceptor_ListMixin, W.__GamepadList_Interceptor_ListMixin, W.__NamedNodeMap_Interceptor_ListMixin, W.__SpeechRecognitionResultList_Interceptor_ListMixin, W.__StyleSheetList_Interceptor_ListMixin, P.Cursor, P.Index, P.KeyRange, P.ObjectStore, P.Observation, P.Angle, P.Length, P._LengthList_Interceptor_ListMixin, P.Number, P._NumberList_Interceptor_ListMixin, P.PointList, P._StringList_Interceptor_ListMixin, P.Transform, P._TransformList_Interceptor_ListMixin, P.AudioBuffer, P.AudioParam, P._AudioParamMap_Interceptor_MapMixin, P.AudioTrack, P.ActiveInfo, P.SqlError, P._SqlResultSetRowList_Interceptor_ListMixin]);
    _inheritMany(J.JavaScriptObject, [J.PlainJavaScriptObject, J.UnknownJavaScriptObject, J.JavaScriptFunction, F.GtagEvent, F.GtagException, O.Plotly, O.TraceData, O.Data, O.Marker, O.Line, O.Transform0, O.Title, O.Layout, O.Shape, O.Legend, O.HoverLabel, O.Font, O.AxisLayout, O.RangeSelector, O.Button, O.Margin, O.RangeSlider, O.Configuration, O.DataEvent, O.LegendDataEvent, O.Point1, O.HoverFX, A._SplitOptions, A.Splitter]);
    _inherit(J.JSUnmodifiableArray, J.JSArray);
    _inheritMany(J.JSNumber, [J.JSInt, J.JSDouble]);
    _inheritMany(P.Stream, [H.CastStream, P._StreamImpl, P.StreamView, P._ForwardingStream, P._BoundSubscriptionStream, W._EventStream, X.Observable, R.ConcatStream, D.DeferStream]);
    _inheritMany(P.Iterable, [H._CastIterableBase, H.EfficientLengthIterable, H.MappedIterable, H.WhereIterable, H.TakeIterable, H.SkipIterable, H._ConstantMapKeyIterable, P.IterableBase, H._StringAllMatchesIterable, P.Runes]);
    _inheritMany(H._CastIterableBase, [H.CastIterable, H.__CastListBase__CastIterableBase_ListMixin, H.CastSet, H.CastQueue]);
    _inherit(H._EfficientLengthCastIterable, H.CastIterable);
    _inherit(H._CastListBase, H.__CastListBase__CastIterableBase_ListMixin);
    _inheritMany(H.Closure, [H._CastListBase_sort_closure, H.CastSet_removeWhere_closure, H.ConstantMap_map_closure, H.ConstantStringMap_values_closure, H.Instantiation, H.Primitives_initTicker_closure, H.Primitives_functionNoSuchMethod_closure, H.unwrapException_saveStackTrace, H.TearOffClosure, H.JsLinkedHashMap_values_closure, H.JsLinkedHashMap_addAll_closure, H.initHooks_closure, H.initHooks_closure0, H.initHooks_closure1, P._AsyncRun__initializeScheduleImmediate_internalCallback, P._AsyncRun__initializeScheduleImmediate_closure, P._AsyncRun__scheduleImmediateJsOverride_internalCallback, P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback, P._TimerImpl_internalCallback, P._TimerImpl$periodic_closure, P._AsyncAwaitCompleter_complete_closure, P._AsyncAwaitCompleter_completeError_closure, P._awaitOnObject_closure, P._awaitOnObject_closure0, P._wrapJsFunctionForAsync_closure, P._SyncBroadcastStreamController__sendData_closure, P._SyncBroadcastStreamController__sendError_closure, P._SyncBroadcastStreamController__sendDone_closure, P.Future_Future_closure, P.Future_wait_handleError, P.Future_wait_closure, P.Future_forEach_closure, P.Future_doWhile_closure, P._Future__addListener_closure, P._Future__prependListeners_closure, P._Future__chainForeignFuture_closure, P._Future__chainForeignFuture_closure0, P._Future__chainForeignFuture_closure1, P._Future__asyncComplete_closure, P._Future__chainFuture_closure, P._Future__asyncCompleteError_closure, P._Future__propagateToListeners_handleWhenCompleteCallback, P._Future__propagateToListeners_handleWhenCompleteCallback_closure, P._Future__propagateToListeners_handleValueCallback, P._Future__propagateToListeners_handleError, P.Stream_Stream$fromIterable_closure, P.Stream_asyncMap_onListen, P.Stream_asyncMap_onListen_closure, P.Stream_asyncMap_closure, P.Stream_asyncMap_closure1, P.Stream_asyncMap_closure2, P.Stream_asyncMap_closure0, P.Stream_contains_closure, P.Stream_contains__closure, P.Stream_contains__closure0, P.Stream_contains_closure0, P.Stream_length_closure, P.Stream_length_closure0, P.Stream_toList_closure, P.Stream_toList_closure0, P.Stream_first_closure, P.Stream_first_closure0, P._StreamController__subscribe_closure, P._StreamController__recordCancel_complete, P._BufferingStreamSubscription__sendError_sendError, P._BufferingStreamSubscription__sendDone_sendDone, P._PendingEvents_schedule_closure, P._cancelAndError_closure, P._cancelAndErrorClosure_closure, P._cancelAndValue_closure, P._CustomZone_bindCallback_closure, P._CustomZone_bindUnaryCallback_closure, P._CustomZone_bindCallbackGuarded_closure, P._CustomZone_bindUnaryCallbackGuarded_closure, P._rootHandleUncaughtError_closure, P._RootZone_bindCallback_closure, P._RootZone_bindCallbackGuarded_closure, P._RootZone_bindUnaryCallbackGuarded_closure, P.runZoned_closure, P._HashMap_values_closure, P._CustomHashMap_closure, P._LinkedCustomHashMap_closure, P.LinkedHashMap_LinkedHashMap$from_closure, P.MapBase_mapToString_closure, P.MapMixin_entries_closure, P.SplayTreeMap_closure, P._JsonMap_values_closure, P._JsonStringifier_writeMap_closure, P._JsonPrettyPrintMixin_writeMap_closure, P.NoSuchMethodError_toString_closure, P.Duration_toString_sixDigits, P.Duration_toString_twoDigits, P.Uri_splitQueryString_closure, P.Uri__parseIPv4Address_error, P.Uri_parseIPv6Address_error, P.Uri_parseIPv6Address_parseHex, P._Uri__Uri$notSimple_closure, P._Uri__checkNonWindowsPathReservedCharacters_closure, P._Uri__makePath_closure, P._Uri__makeQuery_writeParameter, P._Uri__makeQuery_closure, P._createTables_closure, P._createTables_build, P._createTables_setChars, P._createTables_setRange, W.promiseToFuture_closure, W.promiseToFuture_closure0, W.Element_Element$html_closure, W.Entry_remove_closure, W.Entry_remove_closure0, W.MidiInputMap_keys_closure, W.MidiInputMap_values_closure, W.MidiOutputMap_keys_closure, W.MidiOutputMap_values_closure, W.RtcStatsReport_keys_closure, W.RtcStatsReport_values_closure, W.Storage_keys_closure, W.Storage_values_closure, W.Window_animationFrame_closure, W._EventStreamSubscription_closure, W.NodeValidatorBuilder_allowsElement_closure, W.NodeValidatorBuilder_allowsAttribute_closure, W._SimpleNodeValidator_closure, W._SimpleNodeValidator_closure0, W._TemplatingNodeValidator_closure, W._ValidatingTreeSanitizer_sanitizeTree_walk, P._StructuredClone_walk_closure, P._AcceptStructuredClone_walk_closure, P.convertDartToNative_Dictionary_closure, P.convertNativePromiseToDartFuture_closure, P.convertNativePromiseToDartFuture_closure0, P.CssClassSetImpl_add_closure, P.CssClassSetImpl_addAll_closure, P.CssClassSetImpl_removeAll_closure, P.CssClassSetImpl_removeWhere_closure, P.CssClassSetImpl_clear_closure, P.FilteredElementList__iterable_closure, P.FilteredElementList__iterable_closure0, P.FilteredElementList_removeRange_closure, P.JsObject__convertDataTree__convert, P._convertToJS_closure, P._convertToJS_closure0, P._wrapToDart_closure, P._wrapToDart_closure0, P._wrapToDart_closure1, P._convertDataTree__convert, P.AudioParamMap_keys_closure, P.AudioParamMap_values_closure, X.ProxyHolder_onEvent_closure, X.ProxyHolder_onEvent_closure0, R.JsEventListener_stream_closure, R.JsEventListener_stream__closure, R.JsEventListener_stream__closure0, R.JsEventListener_stream__closure1, R.JsEventListener_stream__closure2, R.JsEventListener_stream_closure0, M.CanonicalizedMap_addAll_closure, M.CanonicalizedMap_entries_closure, M.CanonicalizedMap_forEach_closure, M.CanonicalizedMap_keys_closure, M.CanonicalizedMap_map_closure, M.CanonicalizedMap_values_closure, M.CanonicalizedMap_toString_closure, M._isToStringVisiting_closure, B.defaultCompare_closure, O.LineChart_closure, O.LineChart__updateSize_closure, L.ConnectedApp__libraryUriAvailable_closure, A.MessageBus_onEvent_closure, F._breakpointComparator_getRef, F._breakpointComparator_getPos, F.BreakpointsView_closure, F.BreakpointsView__closure, F.BreakOnExceptionControl_closure, F.BreakOnExceptionControl_closure0, S.CallStackView_closure, O.ConsoleArea_appendText_closure, X.DebuggerScreen_createContent__updateResumeButton, X.DebuggerScreen_createContent__updatePauseButton, X.DebuggerScreen_createContent_closure, X.DebuggerScreen_createContent_closure0, X.DebuggerScreen_createContent_closure1, X.DebuggerScreen_createContent_closure2, X.DebuggerScreen_createContent_closure3, X.DebuggerScreen_createContent_closure4, X.DebuggerScreen_createContent_closure5, X.DebuggerScreen_createContent__closure, X.DebuggerScreen_createContent_closure6, X.DebuggerScreen_createContent_closure7, X.DebuggerScreen_createContent_closure8, X.DebuggerScreen_createContent_closure9, X.DebuggerScreen_createContent_closure10, X.DebuggerScreen_createContent_closure11, X.DebuggerScreen_createContent_closure12, X.DebuggerScreen_createContent_closure13, X.DebuggerScreen_createContent_closure14, X.DebuggerScreen_createContent_closure15, X.DebuggerScreen_createContent_closure16, X.DebuggerScreen_createContent_closure17, X.DebuggerScreen_createContent_closure18, X.DebuggerScreen_createContent_closure19, X.DebuggerScreen__hookupListeners_closure, X.DebuggerScreen__buildMenuNav_closure, X.DebuggerScreen__buildMenuNav_closure0, X.DebuggerScreen__buildMenuNav_closure1, X.DebuggerScreen__buildMenuNav_closure2, X.DebuggerScreen__buildMenuNav_closure3, X.DebuggerScreen__buildMenuNav_closure4, X.DebuggerScreen__buildMenuNav_closure5, X.DebuggerScreen__buildMenuNav_closure6, X.DebuggerScreen__buildMenuNav_closure7, X.DebuggerScreen__buildMenuNav_closure8, X.DebuggerScreen__buildMenuNav_closure9, X.DebuggerScreen__handleConnectionStart_closure, X.DebuggerScreen__handleConnectionStart_closure0, X.DebuggerScreen__handleIsolateChanged_closure, X.DebuggerScreen__handleIsolateChanged_closure0, X.SourceEditor_closure, X.SourceEditor__closure, X.SourceEditor__closure0, X.SourceEditor__refreshMarkers_closure, X.SourceEditor__refreshMarkers_closure0, S.DebuggerState_clearBreakpoints_closure, S.DebuggerState_addBreakpointByPathFragment_closure, S.DebuggerState_addBreakpointByPathFragment_closure0, X.ScriptsView_closure, X.ScriptsView_showScripts_closure, X.ScriptsView_showScripts_closure0, X.ScriptsView_showScripts_closure1, X.ScriptsMatcher_start_closure, X.ScriptsMatcher_reset_closure, X.ScriptsMatcher__startMatching_closure, X.ScriptsMatcher_displayMatchingScripts_closure, X.ScriptsMatcher_displayMatchingScripts_closure0, V.VariablesView_closure, V.VariablesView__closure, V.VariablesView___closure, V.VariablesChildProvider_getChildren_closure, V.VariablesChildProvider_getChildren_closure0, B.EvalOnDartLibrary_closure, B.EvalOnDartLibrary_eval_closure, B.EvalOnDartLibrary_addRequest_wrappedRequest, B.EvalOnDartLibrary_getObjHelper_closure, N.Framework__initDragDrop_closure, N.Framework__initDragDrop_closure0, N.Framework__onDrop_closure, N.Framework__importTimeline_closure, N.Framework__importTimeline_closure0, N.Framework_exitOfflineMode_closure, N.Framework__hookupShortcuts_closure, N.Framework_loadScreenFromLocation_closure, N.Framework_loadScreenFromLocation__closure, N.Framework_loadScreenFromLocation__closure0, N.Framework_getScreen_closure, N.Framework_getScreen_closure0, N.Framework_load_closure, N.Framework_load__closure, N.ActionsContainer_removeAction_closure, N.SetStateMixin_setState_closure, N.Toast_show_closure, N.ConnectDialog_closure, N.ConnectDialog_closure0, N.ConnectDialog__tryConnect_handleConnectError, N.ConnectDialog__tryConnect_closure, N.ConnectDialog__tryConnect_closure0, N.ConnectDialog__connect_closure, N.AnalyticsOptInDialog_closure, N.AnalyticsOptInDialog_closure0, M._invertMap_closure, D.InspectorScreen__handleConnectionStart_closure, D.InspectorScreen__handleConnectionStart_closure0, D.InspectorScreen__handleConnectionStart_closure1, Z.InspectorController_closure, E.InspectorService_create_closure, E.InspectorService_create_closure0, E.InspectorService_create_lookupFunctionNames, E.ObjectGroup__callServiceExtension_closure, E.ObjectGroup_getDartObjectProperties_closure, K.InspectorTreeNode_renderObject_radix, K.InspectorTree_root_closure, K.InspectorTree_selection_closure, K.InspectorTree_hover_closure, K.InspectorTree_nodeChanged_closure, K.InspectorTree_removeNodeFromParent_closure, K.InspectorTree_appendChild_closure, K.InspectorTree_expandPath_closure, K.InspectorTree_onTapIcon_closure, K.InspectorTree_onTapIcon_closure0, E.IconPaintEntry_attach_closure, E.IconPaintEntry_attach__closure, E.InspectorTreeCanvas_setState_closure, E.InspectorTreeCanvas_paintRow_isVisible, E.InspectorTreeCanvas_paintRow__endPath, E.InspectorTreeCanvas_paintRow__maybeStart, K.InspectorTreeHtml_setState_closure, K.InspectorTreeHtml_animateToTargets_closure, Y.LoggingScreen_createContent_closure, Y.LoggingScreen_createContent_closure0, Y.LoggingScreen_createContent_closure1, Y.LoggingScreen_createContent_closure2, Y.LoggingScreen__handleConnectionStart_closure, Y.LoggingScreen__handleConnectionStart_closure0, Y.LoggingScreen__handleDeveloperLogEvent_closure, Y._StdoutEventHandler_handle_closure, Y.LogDetailsUI_setData_closure, Y.LogDetailsUI_setData_closure0, F.PerfToolFramework_initGlobalUI_closure, F.PerfToolFramework_initGlobalUI_closure0, F.PerfToolFramework_initGlobalUI_closure1, F.PerfToolFramework_initGlobalUI_closure2, F.PerfToolFramework_disableAppWithError_closure, F.PerfToolFramework_addScreens_getDebuggerDisabledTooltip, F.PerfToolFramework__initHotReloadRestartServiceListeners_closure, F.PerfToolFramework__initHotReloadRestartServiceListeners_closure0, F.PerfToolFramework__buildReloadButton_closure, F.PerfToolFramework__buildRestartButton_closure, V.MemoryScreen_createContent_closure, V.MemoryScreen_createContent_closure0, V.MemoryScreen_createContent_closure1, V.MemoryScreen_createContent_closure2, V.MemoryScreen_createContent_closure3, V.MemoryScreen_selectClassInstance_closure, V.MemoryScreen_selectClassInstance_closure0, V.MemoryScreen_selectClassAndInstanceInField_closure, V.MemoryScreen_selectClassAndInstanceInField_closure0, V.MemoryScreen_selectClassAndInstanceInField__closure, V.MemoryScreen__createHeapStatsTableView_closure, V.MemoryScreen__createInstanceListTableView_closure, V.MemoryScreen__createInstanceListTableView_closure0, V.MemoryScreen__handleHistoryClicks_closure, V.MemoryScreen__maybeCloseHover_closure, V.MemoryScreen_hoverInstanceAllocations_closure, V.MemoryScreen_hoverInstanceAllocations__closure, V.MemoryScreen__createInstanceView_closure, V.NavigationPath_displayPathsAsLinks_closure, A.MemoryChart_closure, T.MemoryController__handleConnectionStart_closure, T.MemoryController_startTimeline_closure, T.MemoryController_getAllocationProfile_closure, T.MemoryController_getAllocationProfile_closure0, T.MemoryController_getInstances_closure, A.MemoryDataView_closure, A.MemoryDataView__closure, A.MemoryDataView___closure, M.MemoryPlotly_getMemoryLayout_getYAxis, M.MemoryPlotly_getMemoryLayout_getLegend, T.MemoryTracker__pollMemory_closure, T.MemoryTracker__recalculate_closure, T.MemoryTracker__recalculate_closure0, T.MemoryTracker__recalculate_closure1, T.MemoryTracker__recalculate_closure2, T.MemoryTracker_getHeaps_closure, O.InboundReferences_closure, O._searchClass_closure, O._searchClass_closure0, X.MessageManager_removeAll_closure, X.MessageManager_addMessage_closure, X.MessageManager_addMessage_closure0, X.Message__buildFlash_closure, R.App__bind_closure, R.App__bind__closure, R.App__bind__closure0, R.App_debuggerGetBreakpoints_closure, R.App_debuggerGetScripts_closure, R.App_debuggerGetCallStackFrames_closure, R.App_debuggerGetVariables_closure, V.PerformanceScreen_createContent_closure, V.PerformanceScreen__loadSnapshot_closure, V.PerformanceScreen__loadSnapshot_closure0, V.PerformanceScreen__loadSnapshot_closure1, V.PerformanceScreen__reset_closure, V.PerformanceScreen__reset_closure0, V.PerformanceScreen__reset_closure1, V.PerformanceScreen__createTableView_closure, V.PerformanceScreen__process_closure, V.PerformanceScreen__process_closure0, V.PerformanceScreen__handleConnectionStart_closure, V.PerformanceScreen__handleConnectionStart__closure, E.PopupListView_closure, E.PopupListView_setList_closure, E.PopupAutoCompleteView__initialize_closure, E.PopupAutoCompleteView__initialize_closure0, E.PopupAutoCompleteView__initialize__closure, E.PopupAutoCompleteView__initialize_closure1, E.PopupAutoCompleteView__hookupListeners_closure, E.AutoCompleteMatcher_start_closure, E.AutoCompleteMatcher_reset_closure, E.AutoCompleteMatcher__startMatching_closure, E.AutoCompleteMatcher_displayMatchingItems_closure, E.AutoCompleteMatcher_displayMatchingItems_closure0, R.connect_closure, R.connect__closure, R.connect___closure, R.connect__closure0, R.connect__closure1, R.connect_closure0, R.convertBroadcastToSingleSubscriber_closure, R.convertBroadcastToSingleSubscriber__closure, R.convertBroadcastToSingleSubscriber_closure0, E.closure, E.closure0, R.ServiceConnectionManager__getServiceRegistrationController_closure, R.ServiceConnectionManager_vmServiceOpened_closure, R.ServiceConnectionManager_vmServiceOpened_closure0, R.ServiceConnectionManager_vmServiceOpened_closure1, R.IsolateManager_selectIsolate_closure, R.IsolateManager_selectIsolate_closure0, R.IsolateManager__initSelectedIsolate_closure, R.IsolateManager__initSelectedIsolate_closure0, R.ServiceExtensionManager_resetAvailableExtensions_closure, R.ServiceExtensionManager__getServiceExtensionController_closure, R.ServiceExtensionManager__getServiceExtensionStateController_closure, R._getStreamController_closure, Q.Table$virtual_closure, Q.Table__init_closure, Q.Table_setRows_closure, Q.Table_setRows__closure, Q.Table_setRows_closure0, Q.Table_setRows_closure1, Q.Table_scrollTo_closure, Q.Table__scheduleRebuild_closure, Q.Table__sortData_closure, Q.Table__rebuildVirtualTable_closure, Q.Table__rebuildVirtualTable__closure, Q.Table__buildTableRows_selectRow, Q.Table__buildTableRows_hoverCell, Q.Table__buildTableRows_closure, Q.Table__buildTableRows_closure0, Q.Table__buildTableRows_closure1, Q.TreeTable__sortData__addToSortedData, Q.TreeTable__sortData__addToSortedData_closure, Q.TreeTable__sortData_closure, Q.TreeTable__sortData_closure0, Q.TreeTable_collapseNode_cascadingRemove, Q.TreeTable_expandNode_expand, Q.TreeColumn_renderToElement_closure, R.CpuFlameChart_rebuildView_closure, E.CpuProfileData_subProfile_closure, N.CpuProfileProtocol_processData_closure, N.BottomUpProfileProcessor_mergeRoots_closure, Y.CpuCallTree__init_closure, Y.CpuCallTree__init_closure0, Y.CpuBottomUp__init_closure, Y.CpuBottomUp__init_closure0, F.EventDetails_closure, F.EventDetails__initTabNav_closure, F.EventDetails__initListeners_closure, F.EventDetails__initListeners_closure0, F.EventDetails__initListeners_closure1, F.EventDetails__initListeners_closure2, F._CpuProfiler_update_closure, F._CpuProfiler__removeMessage_closure, F.FlameChart__initRows_calculateLeftForStackFrame, F.FlameChart__initRows_createChartNodes, F.FlameChart_getNodeInRow_binarySearchForNode, F.FlameChartCanvas_closure, F.FlameChartCanvas__initAsciiMeasurements_closure, F.FlameChartNode_paint_closure, K.FrameEventsChart__initListeners_closure, K.FrameEventsChart__render_drawSubtree, K.FrameEventsChart__render_drawTimelineBackground, K.FrameEventsChart__render_drawUiEvents, K.FrameEventsChart__render_drawGpuEvents, K.FrameEventsChart__render_drawTimelineGrid, K.FrameFlameChartItem_setOnClick_closure, A.FramesBarChart_closure, A.FramesBarChart_closure0, A.PlotlyDivGraph_createPlot_closure, Y.TimelineController_loadOfflineData_closure, Q.TimelineFrame_closure, Q.TimelineEvent_isUiEventFlow_closure, Q.TimelineEvent_isGpuEventFlow_closure, Q.TimelineEvent_maybeRemoveDuplicate__maybeRemoveDuplicate, Q.TimelineEvent_addChild__putChildInTree, O.TimelineProtocol_closure, O.TimelineProtocol_processTraceEvent_closure, O.TimelineProtocol__handleFrameStartEvent_closure, O.TimelineProtocol__handleFrameEndEvent_closure, O.TimelineProtocol__handleDurationCompleteEvent_closure, O.TimelineProtocol_maybeAddPendingEvents_closure, O.TimelineProtocol_eventOccursWithinFrameBounds_satisfiesUiGpuOrder, O.TimelineProtocol__getAndSortWellFormedFrames_closure, O.TimelineProtocol__getAndSortWellFormedFrames_closure0, X.TimelineScreen__initListeners_closure, X.TimelineScreen__initListeners_closure0, N.TimelineService__handleConnectionStart_closure, N.TimelineService_startTimeline_closure, N.TimelineService_startTimeline_closure0, E.waitForDimensionsComputed_closure, N.SelectableList_setItems_closure, N.SelectableList__hookup_closure, N.SelectableList__hookup_closure0, N.SelectableTree__addItemToTree_closure, N.SelectableTree__addItemToTree_closure0, N.SelectableTree__addItemToTree_closure1, N.SelectableTree__addItemToTree_closure2, N.SelectableTree__addItemToTree__closure, N.SelectableTree__addItemToTree__closure0, N.SelectableTree__buildTree_closure, N.SelectableTree__buildTree_closure0, F.DragScroll_enableDragScrolling_closure, F.DragScroll_enableDragScrolling_closure0, F.DragScroll_enableDragScrolling_closure1, A.CoreElement_add_closure, A.CoreElement_replace_closure, A.CoreElement_onClick_closure, A.CoreElement_onFocus_closure, A.CoreElement_onBlur_closure, A.CoreElement_onMouseOver_closure, A.CoreElement_onMouseLeave_closure, A.CoreElement_click_closure, A.CoreElement_dblclick_closure, A.CoreElement_focus_closure, A.CoreElement_blur_closure, A.CoreElement_over_closure, A.CoreElement_leave_closure, U.TextRenderer_renderToString_visitor, U.TextRenderer_renderToString_closure, Y._UrlIconRenderer_loadImage_closure, Y._CustomIconRenderer__buildImageAsync_closure, Y._MaterialIconRenderer_loadImage_closure, Y._MaterialIconRenderer_loadImage_closure0, Y._MaterialIconRenderer_createCanvasSource__drawIcon, Y._MaterialIconRenderer_createCanvasSource_closure, S.CustomIconMaker_getCustomIcon_closure, S.ColorIconMaker_getCustomIcon_closure, K.FlutterMaterialIcons_getIconForCodePoint_closure, N.PSelect_onChange_closure, N.PSelect_change_closure, N.PTabNav_closure, Y.ServiceExtensionButton_closure, Y.ServiceExtensionButton_closure0, Y.ServiceExtensionButton__updateState_closure, T.ViewportCanvas_closure, T.ViewportCanvas_closure0, T.ViewportCanvas_closure1, T.ViewportCanvas_closure2, T.ViewportCanvas_closure3, T.ViewportCanvas__scheduleRebuild_closure, T.ViewportCanvas_scrollToRect_closure, B.executeWithDelay_closure, B.RateLimiter_scheduleRequest_closure, B.RateLimiter_scheduleRequest_closure0, G.get_closure, G.BaseRequest_closure, G.BaseRequest_closure0, O.BrowserClient_send_closure, O.BrowserClient_send__closure, O.BrowserClient_send__closure0, O.BrowserClient_send_closure0, Z.ByteStream_toBytes_closure, U.Response_fromStream_closure, Z.CaseInsensitiveMap$from_closure, Z.CaseInsensitiveMap$from_closure0, R.MediaType_MediaType$parse_closure, R.MediaType_toString_closure, R.MediaType_toString__closure, N.expectQuotedString_closure, T.DateFormat_format_closure, T.DateFormat__fieldConstructors_closure, T.DateFormat__fieldConstructors_closure0, T.DateFormat__fieldConstructors_closure1, T.NumberFormat$decimalPattern_closure, M.Context_join_closure, M.Context_joinAll_closure, M.Context_split_closure, M._validateArgList_closure, X.ParsedPath_normalize_closure, X.ParsedPath__splitExtension_closure, X.ParsedPath__splitExtension_closure0, L.Browser_getCurrentBrowser_closure, L.Browser_getCurrentBrowser_closure0, R.ConcatStream__buildController_closure, R.ConcatStream__buildController_closure1, R.ConcatStream__buildController_closure_moveNext, R.ConcatStream__buildController__moveNext_closure, R.ConcatStream__buildController_closure2, R.ConcatStream__buildController_closure3, R.ConcatStream__buildController_closure0, U.BehaviorSubject_BehaviorSubject_closure, U.BehaviorSubject_BehaviorSubject__closure, U.BehaviorSubject_BehaviorSubject$seeded_closure, U.BehaviorSubject_BehaviorSubject$seeded__closure, G.StartWithStreamTransformer__buildTransformer_closure, G.StartWithStreamTransformer__buildTransformer__closure0, G.StartWithStreamTransformer__buildTransformer__closure1, G.StartWithStreamTransformer__buildTransformer__closure2, G.StartWithStreamTransformer__buildTransformer__closure, U.Highlighter__writeFirstLine_closure, U.Highlighter__writeFirstLine_closure0, U.Highlighter__writeFirstLine_closure1, U.Highlighter__writeFirstLine_closure2, U.Highlighter__writeIntermediateLines_closure, U.Highlighter__writeLastLine_closure, U.Highlighter__writeLastLine_closure0, U.Highlighter__writeLastLine_closure1, U.Highlighter__writeSidebar_closure, A.flexSplit_closure, A.flexSplit_closure0, A.flexSplitBidirectional_createSplitter, A.flexSplitBidirectional_closure, S.createServiceObject_closure, S._createSpecificObject_closure, S.VmService_dispose_closure, S.AllocationProfile_toJson_closure, S.Class_toJson_closure, S.Class_toJson_closure0, S.Class_toJson_closure1, S.Class_toJson_closure2, S.ClassHeapStats_toJson_closure, S.ClassHeapStats_toJson_closure0, S.ClassList_toJson_closure, S.Context_toJson_closure, S.Event_toJson_closure, S.Event_toJson_closure0, S.FlagList_toJson_closure, S.Frame_toJson_closure, S.Instance_toJson_closure, S.Instance_toJson_closure0, S.Instance_toJson_closure1, S.Isolate_toJson_closure, S.Isolate_toJson_closure0, S.Isolate_toJson_closure1, S.InstanceSet_toJson_closure, S.Library_toJson_closure, S.Library_toJson_closure0, S.Library_toJson_closure1, S.Library_toJson_closure2, S.Library_toJson_closure3, S.Script$_fromJson_closure, S.Script_toJson_closure, S.ScriptList_toJson_closure, S.SourceReport_toJson_closure, S.SourceReport_toJson_closure0, S.SourceReportCoverage_toJson_closure, S.SourceReportCoverage_toJson_closure0, S.SourceReportRange_toJson_closure, S.Stack_toJson_closure, S.Stack_toJson_closure0, S.Stack_toJson_closure1, S.Stack_toJson_closure2, S.Timeline_toJson_closure, S.TimelineFlags_toJson_closure, S.TimelineFlags_toJson_closure0, S.TypeArguments_toJson_closure, S.VM_toJson_closure, S.CpuProfile_toJson_closure, S.CpuProfile_toJson_closure0, S.CpuProfile_toJson_closure1, S.CpuProfile_toJson_closure2, S.CpuProfile_toJson_closure3, S.CpuProfile_toJson_closure4, S.ProfileFunction_toJson_closure, F.main_closure, F.main__closure, F.main__closure0, F.main_closure0]);
    _inherit(H.CastList, H._CastListBase);
    _inherit(P.ListBase, P._ListBase_Object_ListMixin);
    _inheritMany(P.ListBase, [H.UnmodifiableListBase, W._ChildrenElementList, W._FrozenElementList, W._ChildNodeListLazy, P.FilteredElementList]);
    _inherit(H.CodeUnits, H.UnmodifiableListBase);
    _inheritMany(H.EfficientLengthIterable, [H.ListIterable, H.EmptyIterable, H.LinkedHashMapKeyIterable, P._HashMapKeyIterable, P._MapBaseValueIterable, P._SplayTreeKeyIterable, P._SplayTreeValueIterable, P.Set]);
    _inheritMany(H.ListIterable, [H.SubListIterable, H.MappedListIterable, H.ReversedListIterable, P.ListQueue, P._JsonMapKeyIterable]);
    _inherit(H.EfficientLengthMappedIterable, H.MappedIterable);
    _inheritMany(P.Iterator, [H.MappedIterator, H.WhereIterator, H.TakeIterator, H.SkipIterator]);
    _inherit(H.EfficientLengthTakeIterable, H.TakeIterable);
    _inherit(H.EfficientLengthSkipIterable, H.SkipIterable);
    _inherit(P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, P.MapView);
    _inherit(P.UnmodifiableMapView, P._UnmodifiableMapView_MapView__UnmodifiableMapMixin);
    _inherit(H.ConstantMapView, P.UnmodifiableMapView);
    _inheritMany(H.ConstantMap, [H.ConstantStringMap, H.GeneralConstantMap]);
    _inherit(H.Instantiation1, H.Instantiation);
    _inheritMany(P.Error, [H.NullError, H.JsNoSuchMethodError, H.UnknownJsTypeError, H.TypeErrorImplementation, H.CastErrorImplementation, H.RuntimeError, P.AssertionError, P.JsonUnsupportedObjectError, P.NullThrownError, P.ArgumentError, P.NoSuchMethodError, P.UnsupportedError, P.UnimplementedError, P.StateError, P.ConcurrentModificationError, P.CyclicInitializationError]);
    _inheritMany(H.TearOffClosure, [H.StaticClosure, H.BoundClosure]);
    _inherit(H._AssertionError, P.AssertionError);
    _inherit(P.MapBase, P.MapMixin);
    _inheritMany(P.MapBase, [H.JsLinkedHashMap, P._HashMap, P._JsonMap, W._AttributeMap]);
    _inheritMany(P.IterableBase, [H._AllMatchesIterable, P._SyncStarIterable, T._StringIterable]);
    _inheritMany(H.NativeTypedData, [H.NativeByteData, H.NativeTypedArray]);
    _inheritMany(H.NativeTypedArray, [H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin]);
    _inherit(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfDouble, H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inherit(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin);
    _inherit(H.NativeTypedArrayOfInt, H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin);
    _inheritMany(H.NativeTypedArrayOfDouble, [H.NativeFloat32List, H.NativeFloat64List]);
    _inheritMany(H.NativeTypedArrayOfInt, [H.NativeInt16List, H.NativeInt32List, H.NativeInt8List, H.NativeUint16List, H.NativeUint32List, H.NativeUint8ClampedList, H.NativeUint8List]);
    _inheritMany(P._StreamImpl, [P._ControllerStream, P._GeneratedStreamImpl]);
    _inherit(P._BroadcastStream, P._ControllerStream);
    _inheritMany(P._BufferingStreamSubscription, [P._ControllerSubscription, P._ForwardingStreamSubscription]);
    _inherit(P._BroadcastSubscription, P._ControllerSubscription);
    _inheritMany(P._BroadcastStreamController, [P._SyncBroadcastStreamController, P._AsyncBroadcastStreamController]);
    _inheritMany(P._Completer, [P._AsyncCompleter, P._SyncCompleter]);
    _inheritMany(P._StreamController, [P._AsyncStreamController, P._SyncStreamController]);
    _inheritMany(P._PendingEvents, [P._IterablePendingEvents, P._StreamImplEvents]);
    _inheritMany(P._DelayedEvent, [P._DelayedData, P._DelayedError]);
    _inheritMany(P._ForwardingStream, [P._WhereStream, P._MapStream]);
    _inheritMany(P.StreamTransformerBase, [P._StreamSubscriptionTransformer, P.Converter, G.StartWithStreamTransformer]);
    _inheritMany(P._Zone, [P._CustomZone, P._RootZone]);
    _inheritMany(P._HashMap, [P._IdentityHashMap, P._CustomHashMap]);
    _inheritMany(H.JsLinkedHashMap, [P._LinkedIdentityHashMap, P._LinkedCustomHashMap]);
    _inherit(P._LinkedHashSet, P._SetBase);
    _inherit(P.SetBase, P._SetBase_Object_SetMixin);
    _inherit(P._SplayTreeMapNode, P._SplayTreeNode);
    _inherit(P._SplayTreeMap__SplayTree_MapMixin, P._SplayTree);
    _inherit(P.SplayTreeMap, P._SplayTreeMap__SplayTree_MapMixin);
    _inheritMany(P._SplayTreeIterator, [P._SplayTreeKeyIterator, P._SplayTreeValueIterator, P._SplayTreeNodeIterator]);
    _inheritMany(P.Codec, [P.Encoding, P.Base64Codec, P.JsonCodec]);
    _inheritMany(P.Encoding, [P.AsciiCodec, P.Latin1Codec, P.Utf8Codec]);
    _inheritMany(P.Converter, [P._UnicodeSubsetEncoder, P._UnicodeSubsetDecoder, P.Base64Encoder, P.Base64Decoder, P.HtmlEscape, P.JsonEncoder, P.JsonDecoder, P.Utf8Encoder, P.Utf8Decoder]);
    _inheritMany(P._UnicodeSubsetEncoder, [P.AsciiEncoder, P.Latin1Encoder]);
    _inheritMany(P._UnicodeSubsetDecoder, [P.AsciiDecoder, P.Latin1Decoder]);
    _inherit(P.ByteConversionSink, P.ChunkedConversionSink);
    _inherit(P.ByteConversionSinkBase, P.ByteConversionSink);
    _inherit(P._ByteCallbackSink, P.ByteConversionSinkBase);
    _inherit(P.JsonCyclicError, P.JsonUnsupportedObjectError);
    _inherit(P._JsonStringStringifier, P._JsonStringifier);
    _inherit(P.__JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin, P._JsonStringStringifier);
    _inherit(P._JsonStringStringifierPretty, P.__JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin);
    _inheritMany(P.num, [P.double, P.int]);
    _inheritMany(P.ArgumentError, [P.RangeError, P.IndexError]);
    _inherit(P._DataUri, P._Uri);
    _inheritMany(W.EventTarget, [W.Node, W.Animation, W.BackgroundFetchRegistration, W.BroadcastChannel, W.FileReader, W.FileWriter, W.HttpRequestEventTarget, W.MediaKeySession, W.MediaStream, W.MediaStreamTrack, W.MessagePort, W.MidiPort, W.PaymentRequest, W.PresentationAvailability, W.PresentationConnection, W.RtcDataChannel, W.WorkerGlobalScope, W.SourceBuffer, W._SourceBufferList_EventTarget_ListMixin, W.TextTrack, W.TextTrackCue, W._TextTrackList_EventTarget_ListMixin, W.VideoTrackList, W.Window, P.Database, P.AudioTrackList, P.BaseAudioContext]);
    _inheritMany(W.Node, [W.Element, W.CharacterData, W.Document, W._Attr]);
    _inheritMany(W.Element, [W.HtmlElement, P.SvgElement]);
    _inheritMany(W.HtmlElement, [W.AnchorElement, W.AreaElement, W.BaseElement, W.BodyElement, W.ButtonElement, W.CanvasElement, W.DataElement, W.DivElement, W.EmbedElement, W.FieldSetElement, W.FormElement, W.IFrameElement, W.ImageElement, W.InputElement, W.LIElement, W.MapElement, W.MediaElement, W.MetaElement, W.MeterElement, W.ObjectElement, W.OptionElement, W.OutputElement, W.ParamElement, W.ProgressElement0, W.SelectElement, W.SlotElement, W.TableElement, W.TableRowElement, W.TableSectionElement, W.TemplateElement, W.TextAreaElement, W.TrackElement]);
    _inheritMany(W.Event, [W.ApplicationCacheErrorEvent, W.ExtendableEvent, W.CloseEvent, W.ErrorEvent, W.UIEvent, W.MediaKeyMessageEvent, W.MessageEvent, W.PopStateEvent, W.PresentationConnectionCloseEvent, W.ProgressEvent, W.SpeechRecognitionError, W.SpeechSynthesisEvent, W.StorageEvent]);
    _inherit(W.BackgroundFetchEvent, W.ExtendableEvent);
    _inherit(W.CssKeyframesRule, W.CssRule);
    _inheritMany(W.CssStyleValue, [W.CssKeywordValue, W.CssNumericValue, W.CssTransformValue, W.CssUnparsedValue]);
    _inherit(W.CssPerspective, W.CssTransformComponent);
    _inherit(W.CssStyleDeclaration, W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase);
    _inherit(W.CssUnitValue, W.CssNumericValue);
    _inheritMany(W.ReportBody, [W.DeprecationReport, W.InterventionReport]);
    _inherit(W._DomRectList_Interceptor_ListMixin_ImmutableListMixin, W._DomRectList_Interceptor_ListMixin);
    _inherit(W.DomRectList, W._DomRectList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._DomStringList_Interceptor_ListMixin_ImmutableListMixin, W._DomStringList_Interceptor_ListMixin);
    _inherit(W.DomStringList, W._DomStringList_Interceptor_ListMixin_ImmutableListMixin);
    _inheritMany(W.Credential, [W.FederatedCredential, W.PasswordCredential]);
    _inherit(W.File, W.Blob);
    _inherit(W._FileList_Interceptor_ListMixin_ImmutableListMixin, W._FileList_Interceptor_ListMixin);
    _inherit(W.FileList, W._FileList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin, W._HtmlCollection_Interceptor_ListMixin);
    _inherit(W.HtmlCollection, W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.HttpRequest, W.HttpRequestEventTarget);
    _inheritMany(W.UIEvent, [W.KeyboardEvent, W.MouseEvent]);
    _inherit(W.MidiInputMap, W._MidiInputMap_Interceptor_MapMixin);
    _inherit(W.MidiOutputMap, W._MidiOutputMap_Interceptor_MapMixin);
    _inherit(W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin, W._MimeTypeArray_Interceptor_ListMixin);
    _inherit(W.MimeTypeArray, W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._NodeList_Interceptor_ListMixin_ImmutableListMixin, W._NodeList_Interceptor_ListMixin);
    _inherit(W.NodeList, W._NodeList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._PluginArray_Interceptor_ListMixin_ImmutableListMixin, W._PluginArray_Interceptor_ListMixin);
    _inherit(W.PluginArray, W._PluginArray_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.RtcStatsReport, W._RtcStatsReport_Interceptor_MapMixin);
    _inherit(W.SharedWorkerGlobalScope, W.WorkerGlobalScope);
    _inherit(W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin, W._SourceBufferList_EventTarget_ListMixin);
    _inherit(W.SourceBufferList, W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin);
    _inherit(W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin, W._SpeechGrammarList_Interceptor_ListMixin);
    _inherit(W.SpeechGrammarList, W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.Storage, W._Storage_Interceptor_MapMixin);
    _inherit(W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin, W._TextTrackCueList_Interceptor_ListMixin);
    _inherit(W.TextTrackCueList, W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin, W._TextTrackList_EventTarget_ListMixin);
    _inherit(W.TextTrackList, W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin);
    _inherit(W._TouchList_Interceptor_ListMixin_ImmutableListMixin, W._TouchList_Interceptor_ListMixin);
    _inherit(W.TouchList, W._TouchList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.VideoElement, W.MediaElement);
    _inherit(W.WheelEvent, W.MouseEvent);
    _inherit(W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin, W.__CssRuleList_Interceptor_ListMixin);
    _inherit(W._CssRuleList, W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._DomRect, W.DomRectReadOnly);
    _inherit(W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin, W.__GamepadList_Interceptor_ListMixin);
    _inherit(W._GamepadList, W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin, W.__NamedNodeMap_Interceptor_ListMixin);
    _inherit(W._NamedNodeMap, W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin, W.__SpeechRecognitionResultList_Interceptor_ListMixin);
    _inherit(W._SpeechRecognitionResultList, W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin, W.__StyleSheetList_Interceptor_ListMixin);
    _inherit(W._StyleSheetList, W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(W._ElementAttributeMap, W._AttributeMap);
    _inherit(P.CssClassSetImpl, P.SetBase);
    _inheritMany(P.CssClassSetImpl, [W._ElementCssClassSet, P.AttributeClassSet]);
    _inherit(W._ElementEventStreamImpl, W._EventStream);
    _inherit(W._EventStreamSubscription, P.StreamSubscription);
    _inherit(W._TemplatingNodeValidator, W._SimpleNodeValidator);
    _inherit(P._StructuredCloneDart2Js, P._StructuredClone);
    _inherit(P._AcceptStructuredCloneDart2Js, P._AcceptStructuredClone);
    _inherit(P.CursorWithValue, P.Cursor);
    _inheritMany(P.JsObject, [P.JsFunction, P._JsArray_JsObject_ListMixin]);
    _inherit(P.JsArray, P._JsArray_JsObject_ListMixin);
    _inherit(P.Rectangle, P._RectangleBase);
    _inherit(P._LengthList_Interceptor_ListMixin_ImmutableListMixin, P._LengthList_Interceptor_ListMixin);
    _inherit(P.LengthList, P._LengthList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P._NumberList_Interceptor_ListMixin_ImmutableListMixin, P._NumberList_Interceptor_ListMixin);
    _inherit(P.NumberList, P._NumberList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P.ScriptElement, P.SvgElement);
    _inherit(P._StringList_Interceptor_ListMixin_ImmutableListMixin, P._StringList_Interceptor_ListMixin);
    _inherit(P.StringList, P._StringList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P._TransformList_Interceptor_ListMixin_ImmutableListMixin, P._TransformList_Interceptor_ListMixin);
    _inherit(P.TransformList, P._TransformList_Interceptor_ListMixin_ImmutableListMixin);
    _inherit(P.AudioParamMap, P._AudioParamMap_Interceptor_MapMixin);
    _inherit(P.OfflineAudioContext, P.BaseAudioContext);
    _inherit(P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin, P._SqlResultSetRowList_Interceptor_ListMixin);
    _inherit(P.SqlResultSetRowList, P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin);
    _inheritMany(X.ProxyHolder, [X.CodeMirror, X.Doc, X.LineHandle]);
    _inherit(U.SetEquality, U._UnorderedEquality);
    _inheritMany(A.CoreElement, [F.BreakOnExceptionControl, X.PopupView, N.Toast, Y.LogDetailsUI, A.MemoryChart, E.PopupAutoCompleteView, Z.CpuProfilerView, F.EventDetails, F._CpuProfiler, N.PTabNavTab, K.FrameEventsChart, K.TimelineGrid, K.TimelineGridItem, A._FramesBarChart_CoreElement_SetStateMixin, A.PlotlyDivGraph, N.ProgressElement, N.Spinner, N.SelectableList, N._SelectableTree_CoreElement_Tree, N.TreeToggle, N.PSelect, N.PButton, N.PFlash, N.PTabNav, N.PNavMenu, N.PNavMenuItem]);
    _inheritMany(N.Screen, [X.DebuggerScreen, D.InspectorScreen, Y.LoggingScreen, F.NotFoundScreen, V._MemoryScreen_Screen_SetStateMixin, V.PerformanceScreen, X.TimelineScreen]);
    _inheritMany(N.ChildProvider, [V.VariablesChildProvider, A.MemoryDataChildProvider]);
    _inherit(U.DiagnosticableTree, U.Diagnosticable);
    _inherit(M.RemoteDiagnosticsNode, U.DiagnosticableTree);
    _inherit(E.FlutterInspectorLibraryNotFound, B.LibraryNotFound);
    _inheritMany(K.InspectorTree, [K.InspectorTreeFixedRowHeight, K.InspectorTreeHtml]);
    _inheritMany(K.PaintEntry, [E.CanvasPaintEntry, K.HtmlPaintEntry]);
    _inheritMany(E.CanvasPaintEntry, [E.IconPaintEntry0, E.TextPaintEntry]);
    _inheritMany(K.InspectorTreeNodeRenderBuilder, [E.InspectorTreeNodeRenderCanvasBuilder, K.InspectorTreeNodeRenderHtmlBuilder]);
    _inheritMany(K.InspectorTreeNodeRender, [E.InspectorTreeNodeCanvasRender, K.InspectorTreeNodeHtmlRender]);
    _inheritMany(K.InspectorTreeNode, [E.InspectorTreeNodeCanvas, K.InspectorTreeNodeHtml]);
    _inherit(E.InspectorTreeCanvas, K.InspectorTreeFixedRowHeight);
    _inheritMany(K.HtmlPaintEntry, [K.IconPaintEntry, K.HtmlTextPaintEntry]);
    _inheritMany(Q.Column, [Y.LogKindColumn, Y.LogWhenColumn, Y.LogMessageColumn, Z.MemoryColumnClassName, Z.MemoryColumnSize, Z.MemoryColumnInstanceCount, Z.MemoryColumnInstanceAccumulatedCount, Z.MemoryColumnSimple, V.PerfColumnInclusive, V.PerfColumnSelf, V.PerfColumnMethodName, Q.TreeColumn, Y.SelfTimeColumn, Y.TotalTimeColumn, Y.SourceColumn]);
    _inherit(F.PerfToolFramework, N.Framework);
    _inherit(V.MemoryScreen, V._MemoryScreen_Screen_SetStateMixin);
    _inheritMany(S.Response, [O.InboundReferences, O.InboundReference, S.AllocationProfile, S.BoundVariable, S.Obj, S.ObjRef, S.ClassHeapStats, S.ClassList, S.Event0, S.FlagList, S.Frame, S.IsolateRef, S.Isolate, S.InstanceSet, S.LogRecord, S.MemoryUsage, S.Message0, S.ReloadReport, S.Sentinel, S.ScriptList, S.SourceLocation, S.SourceReport, S.Stack, S.Success, S.Timeline, S.TimelineFlags, S.Timestamp, S.UnresolvedSourceLocation, S.Version, S.VMRef, S.VM, S.CpuProfile, S.HeapSpace]);
    _inherit(V.CpuChart, O.LineChart);
    _inherit(Q.Table, Q._Table_Object_SetStateMixin);
    _inherit(Q.TreeTable, Q.Table);
    _inheritMany(Z.CpuProfilerView, [R.CpuFlameChart, Y.CpuCallTree, Y.CpuBottomUp]);
    _inheritMany(X.TreeNode0, [E.CpuStackFrame, Q.TimelineEvent0]);
    _inherit(Y.MethodNameColumn, Q.TreeColumn);
    _inherit(F.CpuProfilerTab, N.PTabNavTab);
    _inherit(F.FlameChartCanvas, F.FlameChart);
    _inherit(A.FramesBarChart, A._FramesBarChart_CoreElement_SetStateMixin);
    _inherit(Q.OfflineTimelineData, Q.TimelineData);
    _inherit(Q.OfflineTimelineEvent, Q.TimelineEvent0);
    _inherit(F.GtagEventDevTools, F.GtagEvent);
    _inherit(F.GtagExceptionDevTools, F.GtagException);
    _inherit(N._SelectableTree_CoreElement_Tree_TreeNavigator, N._SelectableTree_CoreElement_Tree);
    _inherit(N._SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator, N._SelectableTree_CoreElement_Tree_TreeNavigator);
    _inherit(N.SelectableTree, N._SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator);
    _inherit(S.ColorSwatch, S.Color);
    _inheritMany(S.ColorSwatch, [S.MaterialColor, S.MaterialAccentColor]);
    _inheritMany(S.OffsetBase, [S.Offset, S.Size]);
    _inheritMany(U.DiagnosticsNode, [U.DiagnosticsProperty, U.DiagnosticableNode]);
    _inherit(U._DiagnosticableTreeNode, U.DiagnosticableNode);
    _inheritMany(Y.HtmlIconRenderer, [Y._UrlIconRenderer, Y._ColorIconRenderer, Y._CustomIconRenderer, Y._MaterialIconRenderer]);
    _inheritMany(S.Icon, [S.UrlIcon, S.CustomIcon, S.ColorIcon, K.MaterialIcon]);
    _inherit(T.ViewportCanvas, T._ViewportCanvas_Object_SetStateMixin);
    _inherit(O.BrowserClient, E.BaseClient);
    _inherit(Z.ByteStream, P.StreamView);
    _inherit(O.Request, G.BaseRequest);
    _inheritMany(T.BaseResponse, [U.Response0, X.StreamedResponse]);
    _inherit(Z.CaseInsensitiveMap, M.CanonicalizedMap);
    _inheritMany(T._DateFormatField, [T._DateFormatLiteralField, T._DateFormatQuotedField, T._DateFormatPatternField]);
    _inherit(B.InternalStyle, O.Style);
    _inheritMany(B.InternalStyle, [E.PosixStyle, F.UrlStyle, L.WindowsStyle]);
    _inheritMany(L.Browser, [L._Chrome, L._Firefox, L._Safari, L._WKWebView, L._InternetExplorer]);
    _inherit(K.AsObservableFuture, B.WrappedFuture);
    _inherit(F.Subject, X.Observable);
    _inherit(U.BehaviorSubject, F.Subject);
    _inherit(Y.FileLocation, D.SourceLocationMixin);
    _inheritMany(Y.SourceSpanMixin, [Y._FileSpan, V.SourceSpanBase]);
    _inherit(G.SourceSpanFormatException, G.SourceSpanException);
    _inherit(X.SourceSpanWithContext, V.SourceSpanBase);
    _inherit(E.StringScannerException, G.SourceSpanFormatException);
    _inheritMany(S.Obj, [S.Breakpoint, S.Class, S.Context, S.Error0, S.Field, S.Func, S.Instance, S.Library, S.Script, S.TypeArguments]);
    _inheritMany(S.ObjRef, [S.ClassRef, S.CodeRef, S.Code, S.ContextRef, S.ErrorRef, S.FieldRef, S.FuncRef, S.InstanceRef, S.LibraryRef, S.ScriptRef, S.TypeArgumentsRef]);
    _inherit(S.NullValRef, S.InstanceRef);
    _inherit(S.NullVal, S.Instance);
    _mixin(H.UnmodifiableListBase, H.UnmodifiableListMixin);
    _mixin(H.__CastListBase__CastIterableBase_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin, P.ListMixin);
    _mixin(H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin, H.FixedLengthListMixin);
    _mixin(P._AsyncStreamController, P._AsyncStreamControllerDispatch);
    _mixin(P._SyncStreamController, P._SyncStreamControllerDispatch);
    _mixin(P._ListBase_Object_ListMixin, P.ListMixin);
    _mixin(P._SetBase_Object_SetMixin, P.SetMixin);
    _mixin(P._SplayTreeMap__SplayTree_MapMixin, P.MapMixin);
    _mixin(P._UnmodifiableMapView_MapView__UnmodifiableMapMixin, P._UnmodifiableMapMixin);
    _mixin(P.__JsonStringStringifierPretty__JsonStringStringifier__JsonPrettyPrintMixin, P._JsonPrettyPrintMixin);
    _mixin(W._CssStyleDeclaration_Interceptor_CssStyleDeclarationBase, W.CssStyleDeclarationBase);
    _mixin(W._DomRectList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._DomRectList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._DomStringList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._DomStringList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._FileList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._FileList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._HtmlCollection_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._HtmlCollection_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._MidiInputMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._MidiOutputMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._MimeTypeArray_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._MimeTypeArray_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._NodeList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._NodeList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._PluginArray_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._PluginArray_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._RtcStatsReport_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._SourceBufferList_EventTarget_ListMixin, P.ListMixin);
    _mixin(W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._SpeechGrammarList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._SpeechGrammarList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._Storage_Interceptor_MapMixin, P.MapMixin);
    _mixin(W._TextTrackCueList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._TextTrackCueList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._TextTrackList_EventTarget_ListMixin, P.ListMixin);
    _mixin(W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W._TouchList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W._TouchList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__CssRuleList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__CssRuleList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__GamepadList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__GamepadList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__NamedNodeMap_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__NamedNodeMap_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__SpeechRecognitionResultList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__SpeechRecognitionResultList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(W.__StyleSheetList_Interceptor_ListMixin, P.ListMixin);
    _mixin(W.__StyleSheetList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._JsArray_JsObject_ListMixin, P.ListMixin);
    _mixin(P._LengthList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._LengthList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._NumberList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._NumberList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._StringList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._StringList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._TransformList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._TransformList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(P._AudioParamMap_Interceptor_MapMixin, P.MapMixin);
    _mixin(P._SqlResultSetRowList_Interceptor_ListMixin, P.ListMixin);
    _mixin(P._SqlResultSetRowList_Interceptor_ListMixin_ImmutableListMixin, W.ImmutableListMixin);
    _mixin(V._MemoryScreen_Screen_SetStateMixin, N.SetStateMixin);
    _mixin(Q._Table_Object_SetStateMixin, N.SetStateMixin);
    _mixin(A._FramesBarChart_CoreElement_SetStateMixin, N.SetStateMixin);
    _mixin(N._SelectableTree_CoreElement_Tree, X.Tree);
    _mixin(N._SelectableTree_CoreElement_Tree_TreeNavigator, X.TreeNavigator);
    _mixin(N._SelectableTree_CoreElement_Tree_TreeNavigator_HtmlTreeNavigator, R.HtmlTreeNavigator);
    _mixin(T._ViewportCanvas_Object_SetStateMixin, N.SetStateMixin);
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    C.BodyElement_methods = W.BodyElement.prototype;
    C.CanvasElement_methods = W.CanvasElement.prototype;
    C.CanvasRenderingContext2D_methods = W.CanvasRenderingContext2D.prototype;
    C.CssStyleDeclaration_methods = W.CssStyleDeclaration.prototype;
    C.DivElement_methods = W.DivElement.prototype;
    C.FileList_methods = W.FileList.prototype;
    C.FileReader_methods = W.FileReader.prototype;
    C.HttpRequest_methods = W.HttpRequest.prototype;
    C.InputElement_methods = W.InputElement.prototype;
    C.Interceptor_methods = J.Interceptor.prototype;
    C.JSArray_methods = J.JSArray.prototype;
    C.JSDouble_methods = J.JSDouble.prototype;
    C.JSInt_methods = J.JSInt.prototype;
    C.JSNull_methods = J.JSNull.prototype;
    C.JSNumber_methods = J.JSNumber.prototype;
    C.JSString_methods = J.JSString.prototype;
    C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
    C.NativeFloat32List_methods = H.NativeFloat32List.prototype;
    C.NativeUint32List_methods = H.NativeUint32List.prototype;
    C.NativeUint8List_methods = H.NativeUint8List.prototype;
    C.NodeList_methods = W.NodeList.prototype;
    C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
    C.TableElement_methods = W.TableElement.prototype;
    C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
    C.WheelEvent_methods = W.WheelEvent.prototype;
    C.Window_methods = W.Window.prototype;
    C.AsciiDecoder_false_127 = new P.AsciiDecoder(false, 127);
    C.AsciiEncoder_127 = new P.AsciiEncoder(127);
    C.C_AsciiCodec = new P.AsciiCodec();
    C.C_Base64Encoder = new P.Base64Encoder();
    C.C_Base64Codec = new P.Base64Codec();
    C.C_Base64Decoder = new P.Base64Decoder();
    C.C_DefaultEquality = new U.DefaultEquality([null]);
    C.C_DeepCollectionEquality = new U.DeepCollectionEquality();
    C.C_EmptyIterator = new H.EmptyIterator([P.Null]);
    C.HtmlEscapeMode_p2v = new P.HtmlEscapeMode("unknown", true, true, true, true);
    C.C_HtmlEscape = new P.HtmlEscape();
    C.C_JS_CONST6 = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
    C.C_JS_CONST = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
    C.C_JS_CONST5 = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
    C.C_JS_CONST0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
    C.C_JS_CONST1 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
    C.C_JS_CONST4 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
    C.C_JS_CONST3 = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
    C.C_JS_CONST2 = function(hooks) { return hooks; }
;
    C.C_JsonCodec = new P.JsonCodec();
    C.C_Latin1Codec = new P.Latin1Codec();
    C.C_OutOfMemoryError = new P.OutOfMemoryError();
    C.C_TrustedHtmlTreeSanitizer = new A.TrustedHtmlTreeSanitizer();
    C.C_Utf8Codec = new P.Utf8Codec();
    C.C_Utf8Encoder = new P.Utf8Encoder();
    C.C__DelayedDone = new P._DelayedDone();
    C.C__HashEnd = new S._HashEnd();
    C.C__NoDefaultValue = new U._NoDefaultValue();
    C.C__RootZone = new P._RootZone();
    C.Color_4278190080 = new S.Color(4278190080);
    C.Color_4290493371 = new S.Color(4290493371);
    C.Color_4292138970 = new S.Color(4292138970);
    C.Color_4293980400 = new S.Color(4293980400);
    C.ColumnAlignment_0 = new Q.ColumnAlignment("ColumnAlignment.left");
    C.ColumnAlignment_1 = new Q.ColumnAlignment("ColumnAlignment.right");
    C.ColumnAlignment_2 = new Q.ColumnAlignment("ColumnAlignment.center");
    C.CpuProfilerViewType_0 = new Z.CpuProfilerViewType("CpuProfilerViewType.flameChart");
    C.CpuProfilerViewType_1 = new Z.CpuProfilerViewType("CpuProfilerViewType.bottomUp");
    C.CpuProfilerViewType_2 = new Z.CpuProfilerViewType("CpuProfilerViewType.callTree");
    C.DiagnosticLevel_0 = new U.DiagnosticLevel(0, "DiagnosticLevel.hidden");
    C.DiagnosticLevel_1 = new U.DiagnosticLevel(1, "DiagnosticLevel.fine");
    C.DiagnosticLevel_2 = new U.DiagnosticLevel(2, "DiagnosticLevel.debug");
    C.DiagnosticLevel_3 = new U.DiagnosticLevel(3, "DiagnosticLevel.info");
    C.DiagnosticLevel_4 = new U.DiagnosticLevel(4, "DiagnosticLevel.warning");
    C.DiagnosticLevel_9 = new U.DiagnosticLevel(9, "DiagnosticLevel.error");
    C.DiagnosticsTreeStyle_0 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.sparse");
    C.DiagnosticsTreeStyle_1 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.offstage");
    C.DiagnosticsTreeStyle_10 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.shallow");
    C.DiagnosticsTreeStyle_11 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.truncateChildren");
    C.DiagnosticsTreeStyle_2 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.dense");
    C.DiagnosticsTreeStyle_3 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.transition");
    C.DiagnosticsTreeStyle_4 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.error");
    C.DiagnosticsTreeStyle_5 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.whitespace");
    C.DiagnosticsTreeStyle_6 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.flat");
    C.DiagnosticsTreeStyle_7 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.singleLine");
    C.DiagnosticsTreeStyle_8 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.headerLine");
    C.DiagnosticsTreeStyle_9 = new U.DiagnosticsTreeStyle("DiagnosticsTreeStyle.indentedSingleLine");
    C.Duration_0 = new P.Duration(0);
    C.Duration_1000 = new P.Duration(1000);
    C.Duration_100000 = new P.Duration(100000);
    C.Duration_1000000 = new P.Duration(1000000);
    C.Duration_10000000 = new P.Duration(10000000);
    C.Duration_166000 = new P.Duration(166000);
    C.Duration_200000 = new P.Duration(200000);
    C.Duration_3000000 = new P.Duration(3000000);
    C.Duration_4000000 = new P.Duration(4000000);
    C.Duration_50000 = new P.Duration(50000);
    C.Duration_500000 = new P.Duration(500000);
    C.FlutterTreeType_0 = new E.FlutterTreeType("FlutterTreeType.widget");
    C.FlutterTreeType_1 = new E.FlutterTreeType("FlutterTreeType.renderObject");
    C.FontStyle_1 = new S.FontStyle("FontStyle.italic");
    C.UrlIcon_8qt = new S.UrlIcon("/icons/custom/info.png", false);
    C.IconKind_0KV = new S.IconKind("info", C.UrlIcon_8qt, C.UrlIcon_8qt);
    C.UrlIcon_MIe = new S.UrlIcon("/icons/custom/class.png", false);
    C.UrlIcon_Ccz = new S.UrlIcon("/icons/custom/class_abstract.png", false);
    C.IconKind_Q7f = new S.IconKind("class", C.UrlIcon_MIe, C.UrlIcon_Ccz);
    C.UrlIcon_trF = new S.UrlIcon("/icons/custom/method.png", false);
    C.UrlIcon_o8Y = new S.UrlIcon("/icons/custom/method_abstract.png", false);
    C.IconKind_jzj = new S.IconKind("method", C.UrlIcon_trF, C.UrlIcon_o8Y);
    C.JsonDecoder_null = new P.JsonDecoder(null);
    C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
    C.Latin1Decoder_false_255 = new P.Latin1Decoder(false, 255);
    C.Latin1Encoder_255 = new P.Latin1Encoder(255);
    C.ListDirection_0 = new X.ListDirection("ListDirection.pageUp");
    C.ListDirection_00 = new E.ListDirection0("ListDirection.pageUp");
    C.ListDirection_1 = new X.ListDirection("ListDirection.pageDown");
    C.ListDirection_10 = new E.ListDirection0("ListDirection.pageDown");
    C.ListDirection_2 = new X.ListDirection("ListDirection.home");
    C.ListDirection_20 = new E.ListDirection0("ListDirection.home");
    C.ListDirection_3 = new X.ListDirection("ListDirection.end");
    C.ListDirection_30 = new E.ListDirection0("ListDirection.end");
    C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(makeConstList([127, 2047, 65535, 1114111]), [P.int]);
    C.List_2Vk = H.setRuntimeTypeInfo(makeConstList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
    C.List_2Zi = H.setRuntimeTypeInfo(makeConstList(["*::class", "*::dir", "*::draggable", "*::hidden", "*::id", "*::inert", "*::itemprop", "*::itemref", "*::itemscope", "*::lang", "*::spellcheck", "*::title", "*::translate", "A::accesskey", "A::coords", "A::hreflang", "A::name", "A::shape", "A::tabindex", "A::target", "A::type", "AREA::accesskey", "AREA::alt", "AREA::coords", "AREA::nohref", "AREA::shape", "AREA::tabindex", "AREA::target", "AUDIO::controls", "AUDIO::loop", "AUDIO::mediagroup", "AUDIO::muted", "AUDIO::preload", "BDO::dir", "BODY::alink", "BODY::bgcolor", "BODY::link", "BODY::text", "BODY::vlink", "BR::clear", "BUTTON::accesskey", "BUTTON::disabled", "BUTTON::name", "BUTTON::tabindex", "BUTTON::type", "BUTTON::value", "CANVAS::height", "CANVAS::width", "CAPTION::align", "COL::align", "COL::char", "COL::charoff", "COL::span", "COL::valign", "COL::width", "COLGROUP::align", "COLGROUP::char", "COLGROUP::charoff", "COLGROUP::span", "COLGROUP::valign", "COLGROUP::width", "COMMAND::checked", "COMMAND::command", "COMMAND::disabled", "COMMAND::label", "COMMAND::radiogroup", "COMMAND::type", "DATA::value", "DEL::datetime", "DETAILS::open", "DIR::compact", "DIV::align", "DL::compact", "FIELDSET::disabled", "FONT::color", "FONT::face", "FONT::size", "FORM::accept", "FORM::autocomplete", "FORM::enctype", "FORM::method", "FORM::name", "FORM::novalidate", "FORM::target", "FRAME::name", "H1::align", "H2::align", "H3::align", "H4::align", "H5::align", "H6::align", "HR::align", "HR::noshade", "HR::size", "HR::width", "HTML::version", "IFRAME::align", "IFRAME::frameborder", "IFRAME::height", "IFRAME::marginheight", "IFRAME::marginwidth", "IFRAME::width", "IMG::align", "IMG::alt", "IMG::border", "IMG::height", "IMG::hspace", "IMG::ismap", "IMG::name", "IMG::usemap", "IMG::vspace", "IMG::width", "INPUT::accept", "INPUT::accesskey", "INPUT::align", "INPUT::alt", "INPUT::autocomplete", "INPUT::autofocus", "INPUT::checked", "INPUT::disabled", "INPUT::inputmode", "INPUT::ismap", "INPUT::list", "INPUT::max", "INPUT::maxlength", "INPUT::min", "INPUT::multiple", "INPUT::name", "INPUT::placeholder", "INPUT::readonly", "INPUT::required", "INPUT::size", "INPUT::step", "INPUT::tabindex", "INPUT::type", "INPUT::usemap", "INPUT::value", "INS::datetime", "KEYGEN::disabled", "KEYGEN::keytype", "KEYGEN::name", "LABEL::accesskey", "LABEL::for", "LEGEND::accesskey", "LEGEND::align", "LI::type", "LI::value", "LINK::sizes", "MAP::name", "MENU::compact", "MENU::label", "MENU::type", "METER::high", "METER::low", "METER::max", "METER::min", "METER::value", "OBJECT::typemustmatch", "OL::compact", "OL::reversed", "OL::start", "OL::type", "OPTGROUP::disabled", "OPTGROUP::label", "OPTION::disabled", "OPTION::label", "OPTION::selected", "OPTION::value", "OUTPUT::for", "OUTPUT::name", "P::align", "PRE::width", "PROGRESS::max", "PROGRESS::min", "PROGRESS::value", "SELECT::autocomplete", "SELECT::disabled", "SELECT::multiple", "SELECT::name", "SELECT::required", "SELECT::size", "SELECT::tabindex", "SOURCE::type", "TABLE::align", "TABLE::bgcolor", "TABLE::border", "TABLE::cellpadding", "TABLE::cellspacing", "TABLE::frame", "TABLE::rules", "TABLE::summary", "TABLE::width", "TBODY::align", "TBODY::char", "TBODY::charoff", "TBODY::valign", "TD::abbr", "TD::align", "TD::axis", "TD::bgcolor", "TD::char", "TD::charoff", "TD::colspan", "TD::headers", "TD::height", "TD::nowrap", "TD::rowspan", "TD::scope", "TD::valign", "TD::width", "TEXTAREA::accesskey", "TEXTAREA::autocomplete", "TEXTAREA::cols", "TEXTAREA::disabled", "TEXTAREA::inputmode", "TEXTAREA::name", "TEXTAREA::placeholder", "TEXTAREA::readonly", "TEXTAREA::required", "TEXTAREA::rows", "TEXTAREA::tabindex", "TEXTAREA::wrap", "TFOOT::align", "TFOOT::char", "TFOOT::charoff", "TFOOT::valign", "TH::abbr", "TH::align", "TH::axis", "TH::bgcolor", "TH::char", "TH::charoff", "TH::colspan", "TH::headers", "TH::height", "TH::nowrap", "TH::rowspan", "TH::scope", "TH::valign", "TH::width", "THEAD::align", "THEAD::char", "THEAD::charoff", "THEAD::valign", "TR::align", "TR::bgcolor", "TR::char", "TR::charoff", "TR::valign", "TRACK::default", "TRACK::kind", "TRACK::label", "TRACK::srclang", "UL::compact", "UL::type", "VIDEO::controls", "VIDEO::height", "VIDEO::loop", "VIDEO::mediagroup", "VIDEO::muted", "VIDEO::preload", "VIDEO::width"]), [P.String]);
    C.List_3US = H.setRuntimeTypeInfo(makeConstList(["S", "M", "T", "W", "T", "F", "S"]), [P.String]);
    C.List_6xs = H.setRuntimeTypeInfo(makeConstList(["Before Christ", "Anno Domini"]), [P.String]);
    C.List_AM_PM = H.setRuntimeTypeInfo(makeConstList(["AM", "PM"]), [P.String]);
    C.List_BC_AD = H.setRuntimeTypeInfo(makeConstList(["BC", "AD"]), [P.String]);
    C.List_BmV = H.setRuntimeTypeInfo(makeConstList(["package:flutter/src/widgets/widget_inspector.dart", "package:flutter_web/src/widgets/widget_inspector.dart"]), [P.String]);
    C.List_CVk = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_JYB = H.setRuntimeTypeInfo(makeConstList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
    C.List_Q1_Q2_Q3_Q4 = H.setRuntimeTypeInfo(makeConstList(["Q1", "Q2", "Q3", "Q4"]), [P.String]);
    C.List_bJM = H.setRuntimeTypeInfo(makeConstList(["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]), [P.String]);
    C.List_cIc = H.setRuntimeTypeInfo(makeConstList(["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]), [P.String]);
    C.List_ego = H.setRuntimeTypeInfo(makeConstList(["HEAD", "AREA", "BASE", "BASEFONT", "BR", "COL", "COLGROUP", "EMBED", "FRAME", "FRAMESET", "HR", "IMAGE", "IMG", "INPUT", "ISINDEX", "LINK", "META", "PARAM", "SOURCE", "STYLE", "TITLE", "WBR"]), [P.String]);
    C.List_empty2 = H.setRuntimeTypeInfo(makeConstList([]), [U.DiagnosticsNode]);
    C.List_empty1 = H.setRuntimeTypeInfo(makeConstList([]), [P.Null]);
    C.List_empty3 = H.setRuntimeTypeInfo(makeConstList([]), [M.RemoteDiagnosticsNode]);
    C.List_empty0 = H.setRuntimeTypeInfo(makeConstList([]), [P.String]);
    C.List_empty = makeConstList([]);
    C.List_gRj = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_gc6 = H.setRuntimeTypeInfo(makeConstList(["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]), [P.String]);
    C.List_h8w = H.setRuntimeTypeInfo(makeConstList(["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]), [P.String]);
    C.UrlIcon_cI8 = new S.UrlIcon("/icons/inspector/balloonInformation.png", false);
    C.Category_cdS = new S.Category("Accessibility", C.UrlIcon_cI8);
    C.UrlIcon_1b4 = new S.UrlIcon("/icons/inspector/resume.png", false);
    C.Category_FIw = new S.Category("Animation and Motion", C.UrlIcon_1b4);
    C.UrlIcon_xw8 = new S.UrlIcon("/icons/inspector/any_type.png", false);
    C.Category_X3x = new S.Category("Assets, Images, and Icons", C.UrlIcon_xw8);
    C.UrlIcon_aWL = new S.UrlIcon("/icons/inspector/threads.png", false);
    C.Category_GJf = new S.Category("Async", C.UrlIcon_aWL);
    C.Category_Basics_null = new S.Category("Basics", null);
    C.Category_smQ = new S.Category("Cupertino (iOS-style widgets)", null);
    C.UrlIcon_cAH = new S.UrlIcon("/icons/inspector/renderer.png", false);
    C.Category_Fb0 = new S.Category("Input", C.UrlIcon_cAH);
    C.UrlIcon_43h = new S.UrlIcon("/icons/inspector/colors.png", false);
    C.Category_gg4 = new S.Category("Painting and effects", C.UrlIcon_43h);
    C.UrlIcon_aDp = new S.UrlIcon("/icons/inspector/scrollbar.png", false);
    C.Category_a7E = new S.Category("Scrolling", C.UrlIcon_aDp);
    C.UrlIcon_fXI = new S.UrlIcon("/icons/inspector/value.png", false);
    C.Category_QLA = new S.Category("Stack", C.UrlIcon_fXI);
    C.UrlIcon_ViB = new S.UrlIcon("/icons/inspector/atrule.png", false);
    C.Category_Phi = new S.Category("Styling", C.UrlIcon_ViB);
    C.UrlIcon_cAH0 = new S.UrlIcon("/icons/inspector/textArea.png", false);
    C.Category_C0x = new S.Category("Text", C.UrlIcon_cAH0);
    C.List_mya = H.setRuntimeTypeInfo(makeConstList([C.Category_cdS, C.Category_FIw, C.Category_X3x, C.Category_GJf, C.Category_Basics_null, C.Category_smQ, C.Category_Fb0, C.Category_gg4, C.Category_a7E, C.Category_QLA, C.Category_Phi, C.Category_C0x]), [S.Category]);
    C.UrlIcon_23h = new S.UrlIcon("/icons/debug_paint.png", false);
    C.ToggleableServiceExtensionDescription_2L7 = new E.ToggleableServiceExtensionDescription("ext.flutter.debugPaint", "Debug Paint", C.UrlIcon_23h, true, false, "Hide Debug Paint", "Show Debug Paint", "inspector", "debugPaint", [P.bool]);
    C.ToggleableServiceExtensionDescription_4yw = new E.ToggleableServiceExtensionDescription("ext.flutter.debugPaintBaselinesEnabled", "Paint Baselines", C.UrlIcon_cAH0, true, false, "Hide Paint Baselines", "Show Paint Baselines", "inspector", "paintBaseline", [P.bool]);
    C.UrlIcon_zgw = new S.UrlIcon("/icons/repaint_rainbow.png", false);
    C.ToggleableServiceExtensionDescription_FEs = new E.ToggleableServiceExtensionDescription("ext.flutter.repaintRainbow", "Repaint Rainbow", C.UrlIcon_zgw, true, false, "Hide Repaint Rainbow", "Show Repaint Rainbow", "inspector", "repaintRainbow", [P.bool]);
    C.UrlIcon_Amm = new S.UrlIcon("/icons/general/performance_overlay.svg", false);
    C.ToggleableServiceExtensionDescription_7N7 = new E.ToggleableServiceExtensionDescription("ext.flutter.showPerformanceOverlay", "Performance Overlay", C.UrlIcon_Amm, true, false, "Hide Performance Overlay", "Show Performance Overlay", "inspector", "performanceOverlay", [P.bool]);
    C.UrlIcon_0 = new S.UrlIcon("/icons/debug_banner.png", false);
    C.ToggleableServiceExtensionDescription_ACQ = new E.ToggleableServiceExtensionDescription("ext.flutter.debugAllowBanner", "Debug Banner", C.UrlIcon_0, true, false, "Hide Debug Banner", "Show Debug Banner", "inspector", "debugBanner", [P.bool]);
    C.UrlIcon_wwd = new S.UrlIcon("/icons/perf/GreyProgr.png", false);
    C.ToggleableServiceExtensionDescription_yvr = new E.ToggleableServiceExtensionDescription("ext.flutter.profileWidgetBuilds", "Track Widget Rebuilds", C.UrlIcon_wwd, true, false, "Do Not Track Widget Rebuilds", "Track Widget Rebuilds", "performance", "trackRebuilds", [P.bool]);
    C.UrlIcon_Dfi = new S.UrlIcon("/icons/general/locate.png", false);
    C.ToggleableServiceExtensionDescription_reb = new E.ToggleableServiceExtensionDescription("ext.flutter.inspector.show", "Select Widget Mode", C.UrlIcon_Dfi, true, false, "Disable Select Widget Mode", "Enable Select Widget Mode", "inspector", "selectWidgetMode", [P.bool]);
    C.UrlIcon_UIA = new S.UrlIcon("/icons/phone.png", false);
    C.ToggleableServiceExtensionDescription_4uk = new E.ToggleableServiceExtensionDescription("ext.flutter.platformOverride", "iOS", C.UrlIcon_UIA, "iOS", "android", "Toggle iOS Platform", "Toggle iOS Platform", "inspector", "iOS", [P.String]);
    C.UrlIcon_Db0 = new S.UrlIcon("/icons/history.svg", false);
    C.ToggleableServiceExtensionDescription_iL9 = new E.ToggleableServiceExtensionDescription("ext.flutter.timeDilation", "Slow Animations", C.UrlIcon_Db0, 5, 1, "Disable Slow Animations", "Enable Slow Animations", "inspector", "slowAnimation", [P.num]);
    C.List_nBB = H.setRuntimeTypeInfo(makeConstList([C.ToggleableServiceExtensionDescription_2L7, C.ToggleableServiceExtensionDescription_4yw, C.ToggleableServiceExtensionDescription_FEs, C.ToggleableServiceExtensionDescription_7N7, C.ToggleableServiceExtensionDescription_ACQ, C.ToggleableServiceExtensionDescription_yvr, C.ToggleableServiceExtensionDescription_reb, C.ToggleableServiceExtensionDescription_4uk, C.ToggleableServiceExtensionDescription_iL9]), [[E.ToggleableServiceExtensionDescription,,]]);
    C.List_nxB = H.setRuntimeTypeInfo(makeConstList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qNA = H.setRuntimeTypeInfo(makeConstList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
    C.List_qg40 = H.setRuntimeTypeInfo(makeConstList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_qg4 = H.setRuntimeTypeInfo(makeConstList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]), [P.int]);
    C.List_qpm = H.setRuntimeTypeInfo(makeConstList(["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]), [P.String]);
    C.List_wMy = H.setRuntimeTypeInfo(makeConstList(["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]), [P.String]);
    C.List_wSV = H.setRuntimeTypeInfo(makeConstList(["bind", "if", "ref", "repeat", "syntax"]), [P.String]);
    C.List_yrN = H.setRuntimeTypeInfo(makeConstList(["A::href", "AREA::href", "BLOCKQUOTE::cite", "BODY::background", "COMMAND::icon", "DEL::cite", "FORM::action", "IMG::src", "INPUT::src", "INS::cite", "Q::cite", "VIDEO::poster"]), [P.String]);
    C.List_EQM = H.setRuntimeTypeInfo(makeConstList(["d", "E", "EEEE", "LLL", "LLLL", "M", "Md", "MEd", "MMM", "MMMd", "MMMEd", "MMMM", "MMMMd", "MMMMEEEEd", "QQQ", "QQQQ", "y", "yM", "yMd", "yMEd", "yMMM", "yMMMd", "yMMMEd", "yMMMM", "yMMMMd", "yMMMMEEEEd", "yQQQ", "yQQQQ", "H", "Hm", "Hms", "j", "jm", "jms", "jmv", "jmz", "jz", "m", "ms", "s", "v", "z", "zzzz", "ZZZZ"]), [P.String]);
    C.Map_EQGBe = new H.ConstantStringMap(44, {d: "d", E: "EEE", EEEE: "EEEE", LLL: "LLL", LLLL: "LLLL", M: "L", Md: "M/d", MEd: "EEE, M/d", MMM: "LLL", MMMd: "MMM d", MMMEd: "EEE, MMM d", MMMM: "LLLL", MMMMd: "MMMM d", MMMMEEEEd: "EEEE, MMMM d", QQQ: "QQQ", QQQQ: "QQQQ", y: "y", yM: "M/y", yMd: "M/d/y", yMEd: "EEE, M/d/y", yMMM: "MMM y", yMMMd: "MMM d, y", yMMMEd: "EEE, MMM d, y", yMMMM: "MMMM y", yMMMMd: "MMMM d, y", yMMMMEEEEd: "EEEE, MMMM d, y", yQQQ: "QQQ y", yQQQQ: "QQQQ y", H: "HH", Hm: "HH:mm", Hms: "HH:mm:ss", j: "h a", jm: "h:mm a", jms: "h:mm:ss a", jmv: "h:mm a v", jmz: "h:mm a z", jz: "h a z", m: "m", ms: "mm:ss", s: "s", v: "v", z: "z", zzzz: "zzzz", ZZZZ: "ZZZZ"}, C.List_EQM, [P.String, P.String]);
    C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty0, [P.String, P.String]);
    C.List_empty4 = H.setRuntimeTypeInfo(makeConstList([]), [P.Symbol0]);
    C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty4, [P.Symbol0, null]);
    C.List_kTd = H.setRuntimeTypeInfo(makeConstList(["sparse", "offstage", "dense", "transition", "whitespace", "error", "flat", "singleLine", "headerLine", "indentedSingleLine", "shallow", "truncateChildren"]), [P.String]);
    C.Map_kT33h = new H.ConstantStringMap(12, {sparse: C.DiagnosticsTreeStyle_0, offstage: C.DiagnosticsTreeStyle_1, dense: C.DiagnosticsTreeStyle_2, transition: C.DiagnosticsTreeStyle_3, whitespace: C.DiagnosticsTreeStyle_5, error: C.DiagnosticsTreeStyle_4, flat: C.DiagnosticsTreeStyle_6, singleLine: C.DiagnosticsTreeStyle_7, headerLine: C.DiagnosticsTreeStyle_8, indentedSingleLine: C.DiagnosticsTreeStyle_9, shallow: C.DiagnosticsTreeStyle_10, truncateChildren: C.DiagnosticsTreeStyle_11}, C.List_kTd, [P.String, U.DiagnosticsTreeStyle]);
    C.List_omH = H.setRuntimeTypeInfo(makeConstList(["hidden", "fine", "debug", "info", "warning", "hint", "fix", "contract", "violation", "error", "off"]), [P.String]);
    C.DiagnosticLevel_5 = new U.DiagnosticLevel(5, "DiagnosticLevel.hint");
    C.DiagnosticLevel_6 = new U.DiagnosticLevel(6, "DiagnosticLevel.fix");
    C.DiagnosticLevel_7 = new U.DiagnosticLevel(7, "DiagnosticLevel.contract");
    C.DiagnosticLevel_8 = new U.DiagnosticLevel(8, "DiagnosticLevel.violation");
    C.DiagnosticLevel_10 = new U.DiagnosticLevel(10, "DiagnosticLevel.off");
    C.Map_omyhD = new H.ConstantStringMap(11, {hidden: C.DiagnosticLevel_0, fine: C.DiagnosticLevel_1, debug: C.DiagnosticLevel_2, info: C.DiagnosticLevel_3, warning: C.DiagnosticLevel_4, hint: C.DiagnosticLevel_5, fix: C.DiagnosticLevel_6, contract: C.DiagnosticLevel_7, violation: C.DiagnosticLevel_8, error: C.DiagnosticLevel_9, off: C.DiagnosticLevel_10}, C.List_omH, [P.String, U.DiagnosticLevel]);
    C.Map_yXAeS = new H.GeneralConstantMap([0, "FontWeight.w100", 1, "FontWeight.w200", 2, "FontWeight.w300", 3, "FontWeight.w400", 4, "FontWeight.w500", 5, "FontWeight.w600", 6, "FontWeight.w700", 7, "FontWeight.w800", 8, "FontWeight.w900"], [P.int, P.String]);
    C.Color_4294638330 = new S.Color(4294638330);
    C.Color_4294309365 = new S.Color(4294309365);
    C.Color_4293848814 = new S.Color(4293848814);
    C.Color_4292927712 = new S.Color(4292927712);
    C.Color_4292269782 = new S.Color(4292269782);
    C.Color_4290624957 = new S.Color(4290624957);
    C.Color_4288585374 = new S.Color(4288585374);
    C.Color_4285887861 = new S.Color(4285887861);
    C.Color_4284572001 = new S.Color(4284572001);
    C.Color_4282532418 = new S.Color(4282532418);
    C.Color_4281348144 = new S.Color(4281348144);
    C.Color_4280361249 = new S.Color(4280361249);
    C.Map_HFpTk = new H.GeneralConstantMap([50, C.Color_4294638330, 100, C.Color_4294309365, 200, C.Color_4293848814, 300, C.Color_4292927712, 350, C.Color_4292269782, 400, C.Color_4290624957, 500, C.Color_4288585374, 600, C.Color_4285887861, 700, C.Color_4284572001, 800, C.Color_4282532418, 850, C.Color_4281348144, 900, C.Color_4280361249], [P.int, S.Color]);
    C.MaterialColor_Map_HFpTk_4288585374 = new S.MaterialColor(C.Map_HFpTk, 4288585374);
    C.Color_4294964192 = new S.Color(4294964192);
    C.Color_4294959282 = new S.Color(4294959282);
    C.Color_4294954112 = new S.Color(4294954112);
    C.Color_4294948685 = new S.Color(4294948685);
    C.Color_4294944550 = new S.Color(4294944550);
    C.Color_4294940672 = new S.Color(4294940672);
    C.Color_4294675456 = new S.Color(4294675456);
    C.Color_4294278144 = new S.Color(4294278144);
    C.Color_4293880832 = new S.Color(4293880832);
    C.Color_4293284096 = new S.Color(4293284096);
    C.Map_JNZaB = new H.GeneralConstantMap([50, C.Color_4294964192, 100, C.Color_4294959282, 200, C.Color_4294954112, 300, C.Color_4294948685, 400, C.Color_4294944550, 500, C.Color_4294940672, 600, C.Color_4294675456, 700, C.Color_4294278144, 800, C.Color_4293880832, 900, C.Color_4293284096], [P.int, S.Color]);
    C.MaterialColor_Map_JNZaB_4294940672 = new S.MaterialColor(C.Map_JNZaB, 4294940672);
    C.Color_4294962158 = new S.Color(4294962158);
    C.Color_4294954450 = new S.Color(4294954450);
    C.Color_4293892762 = new S.Color(4293892762);
    C.Color_4293227379 = new S.Color(4293227379);
    C.Color_4293874512 = new S.Color(4293874512);
    C.Color_4294198070 = new S.Color(4294198070);
    C.Color_4293212469 = new S.Color(4293212469);
    C.Color_4292030255 = new S.Color(4292030255);
    C.Color_4291176488 = new S.Color(4291176488);
    C.Color_4290190364 = new S.Color(4290190364);
    C.Map_JNc9P = new H.GeneralConstantMap([50, C.Color_4294962158, 100, C.Color_4294954450, 200, C.Color_4293892762, 300, C.Color_4293227379, 400, C.Color_4293874512, 500, C.Color_4294198070, 600, C.Color_4293212469, 700, C.Color_4292030255, 800, C.Color_4291176488, 900, C.Color_4290190364], [P.int, S.Color]);
    C.MaterialColor_Map_JNc9P_4294198070 = new S.MaterialColor(C.Map_JNc9P, 4294198070);
    C.Color_4287215096 = new S.Color(4287215096);
    C.MaterialIcon_6we = new K.MaterialIcon("refresh", C.Color_4287215096, 18, 0, 18);
    C.Color_4280559918 = new S.Color(4280559918);
    C.ThemedColor_Color_4280559918_Color_4287215096 = new K.ThemedColor(C.Color_4280559918, C.Color_4287215096);
    C.MaterialIcon_JaK = new K.MaterialIcon("file_download", C.ThemedColor_Color_4280559918_Color_4287215096, 32, 0, 18);
    C.MaterialIcon_Osx = new K.MaterialIcon("refresh", C.Color_4278190080, 18, 0, 18);
    C.MaterialIcon_RgB = new K.MaterialIcon("open_in_new", C.MaterialColor_Map_HFpTk_4288585374, 18, 0, 18);
    C.MaterialIcon_ifn = new K.MaterialIcon("clear", C.ThemedColor_Color_4280559918_Color_4287215096, 18, 0, 18);
    C.MaterialIcon_ref = new K.MaterialIcon("block", C.ThemedColor_Color_4280559918_Color_4287215096, 18, 0, 18);
    C.MessageType_1 = new X.MessageType("MessageType.warning");
    C.MessageType_2 = new X.MessageType("MessageType.error");
    C.ScrollAlignment_BOTTOM = new W.ScrollAlignment("BOTTOM");
    C.ScrollAlignment_CENTER = new W.ScrollAlignment("CENTER");
    C.ScrollAlignment_TOP = new W.ScrollAlignment("TOP");
    C.Size_0_0 = new S.Size(0, 0);
    C.SortOrder_0 = new Q.SortOrder("SortOrder.ascending");
    C.SortOrder_1 = new Q.SortOrder("SortOrder.descending");
    C.Symbol_89P = new H.Symbol("Intl.locale");
    C.Symbol_call = new H.Symbol("call");
    C.ThemedColor_Color_4278190080_Color_4290493371 = new K.ThemedColor(C.Color_4278190080, C.Color_4290493371);
    C.TextStyle_Ure = new U.TextStyle(true, C.ThemedColor_Color_4278190080_Color_4290493371, null, null, null, null, null, null, null, null, null, null, null, null);
    C.FontWeight_6 = new S.FontWeight(6);
    C.TextStyle_cyO = new U.TextStyle(true, C.ThemedColor_Color_4278190080_Color_4290493371, null, null, C.FontWeight_6, null, null, null, null, null, null, null, null, null);
    C.TextStyle_w66 = new U.TextStyle(true, null, null, 14, null, null, null, null, null, null, null, null, null, null);
    C.TextStyle_wXq = new U.TextStyle(true, C.ThemedColor_Color_4278190080_Color_4290493371, null, null, null, C.FontStyle_1, null, null, null, null, null, null, null, null);
    C.Color_1511726883 = new S.Color(1511726883);
    C.ThemedColor_Color_1511726883_Color_1511726883 = new K.ThemedColor(C.Color_1511726883, C.Color_1511726883);
    C.Color_1727987712 = new S.Color(1727987712);
    C.Color_1727175833 = new S.Color(1727175833);
    C.ThemedColor_Color_1727987712_Color_1727175833 = new K.ThemedColor(C.Color_1727987712, C.Color_1727175833);
    C.Color_2164195328 = new S.Color(2164195328);
    C.Color_2580420892 = new S.Color(2580420892);
    C.ThemedColor_Color_2164195328_Color_2580420892 = new K.ThemedColor(C.Color_2164195328, C.Color_2580420892);
    C.Color_4291348680 = new S.Color(4291348680);
    C.ThemedColor_Color_4278190080_Color_4291348680 = new K.ThemedColor(C.Color_4278190080, C.Color_4291348680);
    C.ThemedColor_Color_4278190080_Color_4293980400 = new K.ThemedColor(C.Color_4278190080, C.Color_4293980400);
    C.Color_4278190335 = new S.Color(4278190335);
    C.Color_4279786209 = new S.Color(4279786209);
    C.ThemedColor_Color_4278190335_Color_4279786209 = new K.ThemedColor(C.Color_4278190335, C.Color_4279786209);
    C.Color_4278278043 = new S.Color(4278278043);
    C.Color_4279785917 = new S.Color(4279785917);
    C.ThemedColor_Color_4278278043_Color_4279785917 = new K.ThemedColor(C.Color_4278278043, C.Color_4279785917);
    C.Color_4278351805 = new S.Color(4278351805);
    C.ThemedColor_Color_4278351805_Color_4278278043 = new K.ThemedColor(C.Color_4278351805, C.Color_4278278043);
    C.Color_4279854802 = new S.Color(4279854802);
    C.ThemedColor_Color_4278351805_Color_4279854802 = new K.ThemedColor(C.Color_4278351805, C.Color_4279854802);
    C.Color_4278356177 = new S.Color(4278356177);
    C.Color_4279923688 = new S.Color(4279923688);
    C.ThemedColor_Color_4278356177_Color_4279923688 = new K.ThemedColor(C.Color_4278356177, C.Color_4279923688);
    C.Color_4278430196 = new S.Color(4278430196);
    C.Color_4278426597 = new S.Color(4278426597);
    C.ThemedColor_Color_4278430196_Color_4278426597 = new K.ThemedColor(C.Color_4278430196, C.Color_4278426597);
    C.Color_4294638588 = new S.Color(4294638588);
    C.ThemedColor_Color_4280559918_Color_4294638588 = new K.ThemedColor(C.Color_4280559918, C.Color_4294638588);
    C.Color_4280923894 = new S.Color(4280923894);
    C.Color_4284914934 = new S.Color(4284914934);
    C.ThemedColor_Color_4280923894_Color_4284914934 = new K.ThemedColor(C.Color_4280923894, C.Color_4284914934);
    C.Color_4282735204 = new S.Color(4282735204);
    C.Color_4291811548 = new S.Color(4291811548);
    C.ThemedColor_Color_4282735204_Color_4291811548 = new K.ThemedColor(C.Color_4282735204, C.Color_4291811548);
    C.Color_4283417591 = new S.Color(4283417591);
    C.ThemedColor_Color_4283417591_Color_4280923894 = new K.ThemedColor(C.Color_4283417591, C.Color_4280923894);
    C.Color_4287280375 = new S.Color(4287280375);
    C.ThemedColor_Color_4283417591_Color_4287280375 = new K.ThemedColor(C.Color_4283417591, C.Color_4287280375);
    C.Color_4286611584 = new S.Color(4286611584);
    C.ThemedColor_Color_4286611584_Color_4286611584 = new K.ThemedColor(C.Color_4286611584, C.Color_4286611584);
    C.Color_4286698746 = new S.Color(4286698746);
    C.Color_4288593657 = new S.Color(4288593657);
    C.ThemedColor_Color_4286698746_Color_4288593657 = new K.ThemedColor(C.Color_4286698746, C.Color_4288593657);
    C.Color_4289450719 = new S.Color(4289450719);
    C.Color_4286166774 = new S.Color(4286166774);
    C.ThemedColor_Color_4289450719_Color_4286166774 = new K.ThemedColor(C.Color_4289450719, C.Color_4286166774);
    C.Color_4290098613 = new S.Color(4290098613);
    C.Color_4291414473 = new S.Color(4291414473);
    C.ThemedColor_Color_4290098613_Color_4291414473 = new K.ThemedColor(C.Color_4290098613, C.Color_4291414473);
    C.Color_4291477317 = new S.Color(4291477317);
    C.Color_4284704103 = new S.Color(4284704103);
    C.ThemedColor_Color_4291477317_Color_4284704103 = new K.ThemedColor(C.Color_4291477317, C.Color_4284704103);
    C.Color_4291611852 = new S.Color(4291611852);
    C.Color_4283979864 = new S.Color(4283979864);
    C.ThemedColor_Color_4291611852_Color_4283979864 = new K.ThemedColor(C.Color_4291611852, C.Color_4283979864);
    C.ThemedColor_Color_4292138970_Color_4292138970 = new K.ThemedColor(C.Color_4292138970, C.Color_4292138970);
    C.Color_4294967295 = new S.Color(4294967295);
    C.ThemedColor_Color_4292138970_Color_4294967295 = new K.ThemedColor(C.Color_4292138970, C.Color_4294967295);
    C.Color_4294375158 = new S.Color(4294375158);
    C.Color_4280295716 = new S.Color(4280295716);
    C.ThemedColor_Color_4294375158_Color_4280295716 = new K.ThemedColor(C.Color_4294375158, C.Color_4280295716);
    C.Color_4281151025 = new S.Color(4281151025);
    C.ThemedColor_Color_4294375158_Color_4281151025 = new K.ThemedColor(C.Color_4294375158, C.Color_4281151025);
    C.ThemedColor_Color_4294675456_Color_4293284096 = new K.ThemedColor(C.Color_4294675456, C.Color_4293284096);
    C.ThemedColor_Color_4294967295_Color_4278190080 = new K.ThemedColor(C.Color_4294967295, C.Color_4278190080);
    C.ThemedColor_Color_4294967295_Color_4281151025 = new K.ThemedColor(C.Color_4294967295, C.Color_4281151025);
    C.Color_4294967181 = new S.Color(4294967181);
    C.Color_4294967040 = new S.Color(4294967040);
    C.Color_4294961664 = new S.Color(4294961664);
    C.Color_4294956544 = new S.Color(4294956544);
    C.Map_iTwHq = new H.GeneralConstantMap([100, C.Color_4294967181, 200, C.Color_4294967040, 400, C.Color_4294961664, 700, C.Color_4294956544], [P.int, S.Color]);
    C.MaterialAccentColor_Map_iTwHq_4294967040 = new S.MaterialAccentColor(C.Map_iTwHq, 4294967040);
    C.Color_4282796364 = new S.Color(4282796364);
    C.ThemedColor_W3G = new K.ThemedColor(C.MaterialAccentColor_Map_iTwHq_4294967040, C.Color_4282796364);
    C.Color_4288059030 = new S.Color(4288059030);
    C.ThemedColor_chs = new K.ThemedColor(C.MaterialColor_Map_HFpTk_4288585374, C.Color_4288059030);
    C.TimeUnit_0 = new B.TimeUnit("TimeUnit.microseconds");
    C.TimeUnit_1 = new B.TimeUnit("TimeUnit.milliseconds");
    C.TimelineEventType_0 = new Q.TimelineEventType(0, "TimelineEventType.ui");
    C.TimelineEventType_1 = new Q.TimelineEventType(1, "TimelineEventType.gpu");
    C.TimelineEventType_2 = new Q.TimelineEventType(2, "TimelineEventType.unknown");
    C.Type_ByteBuffer_RkP = H.createRuntimeType(P.ByteBuffer);
    C.Type_ByteData_zNC = H.createRuntimeType(P.ByteData);
    C.Type_ErrorRef_oM2 = H.createRuntimeType(S.ErrorRef);
    C.Type_Error_A6W = H.createRuntimeType(S.Error0);
    C.Type_FieldRef_EkK = H.createRuntimeType(S.FieldRef);
    C.Type_Float32List_LB7 = H.createRuntimeType(P.Float32List);
    C.Type_Float64List_LB7 = H.createRuntimeType(P.Float64List);
    C.Type_InstanceRef_4dw = H.createRuntimeType(S.InstanceRef);
    C.Type_Int16List_uXf = H.createRuntimeType(P.Int16List);
    C.Type_Int32List_O50 = H.createRuntimeType(P.Int32List);
    C.Type_Int8List_ekJ = H.createRuntimeType(P.Int8List);
    C.Type_JSObject_8k0 = H.createRuntimeType(J.JSObject);
    C.Type_MessageBus_MAi = H.createRuntimeType(A.MessageBus);
    C.Type_Null_Yyn = H.createRuntimeType(P.Null);
    C.Type_RPCError_SOa = H.createRuntimeType(S.RPCError);
    C.Type_ServiceConnectionManager_qdG = H.createRuntimeType(R.ServiceConnectionManager);
    C.Type_String_k8F = H.createRuntimeType(P.String);
    C.Type_Uint16List_2bx = H.createRuntimeType(P.Uint16List);
    C.Type_Uint32List_2bx = H.createRuntimeType(P.Uint32List);
    C.Type_Uint8ClampedList_Jik = H.createRuntimeType(P.Uint8ClampedList);
    C.Type_Uint8List_WLA = H.createRuntimeType(P.Uint8List);
    C.Type_bool_lhE = H.createRuntimeType(P.bool);
    C.Type_double_K1J = H.createRuntimeType(P.double);
    C.Type_int_tHn = H.createRuntimeType(P.int);
    C.Type_num_cv7 = H.createRuntimeType(P.num);
    C.UrlIcon_46y = new S.UrlIcon("/icons/general/pause_white@2x.png", true);
    C.UrlIcon_EOZ = new S.UrlIcon("icons/hot-reload-white.png", false);
    C.UrlIcon_JmU = new S.UrlIcon("/icons/general/resume_white_disabled@2x.png", true);
    C.UrlIcon_QOR = new S.UrlIcon("/icons/memory/ic_search.png", false);
    C.UrlIcon_gTM = new S.UrlIcon("/icons/memory/snapshot_color.png", false);
    C.UrlIcon_ifH = new S.UrlIcon("icons/hot-restart-white.png", false);
    C.UrlIcon_k6U = new S.UrlIcon("/icons/memory/ic_filter_list_alt_black.png", true);
    C.UrlIcon_lyL = new S.UrlIcon("/icons/general/pause_black@2x.png", true);
    C.UrlIcon_m7u = new S.UrlIcon("/icons/memory/ic_delete_outline_black.png", true);
    C.UrlIcon_omH = new S.UrlIcon("/icons/memory/reset_icon.png", true);
    C.UrlIcon_y9i = new S.UrlIcon("/icons/general/resume_black_disabled@2x.png", false);
    C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
    C._WordWrapParseMode_0 = new U._WordWrapParseMode("_WordWrapParseMode.inSpace");
    C._WordWrapParseMode_1 = new U._WordWrapParseMode("_WordWrapParseMode.inWord");
    C._WordWrapParseMode_2 = new U._WordWrapParseMode("_WordWrapParseMode.atBreak");
    C._ZoneFunction_3bB = new P._ZoneFunction(C.C__RootZone, P.async___rootCreatePeriodicTimer$closure(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1, args: [P.Timer]}]}]);
    C._ZoneFunction_7G2 = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterBinaryCallback$closure(), [P.Function]);
    C._ZoneFunction_Eeh = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterUnaryCallback$closure(), [P.Function]);
    C._ZoneFunction_NMc = new P._ZoneFunction(C.C__RootZone, P.async___rootHandleUncaughtError$closure(), [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]);
    C._ZoneFunction__RootZone__rootCreateTimer = new P._ZoneFunction(C.C__RootZone, P.async___rootCreateTimer$closure(), [{func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1}]}]);
    C._ZoneFunction__RootZone__rootErrorCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootErrorCallback$closure(), [{func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}]);
    C._ZoneFunction__RootZone__rootFork = new P._ZoneFunction(C.C__RootZone, P.async___rootFork$closure(), [{func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, [P.Map,,,]]}]);
    C._ZoneFunction__RootZone__rootPrint = new P._ZoneFunction(C.C__RootZone, P.async___rootPrint$closure(), [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}]);
    C._ZoneFunction__RootZone__rootRegisterCallback = new P._ZoneFunction(C.C__RootZone, P.async___rootRegisterCallback$closure(), [P.Function]);
    C._ZoneFunction__RootZone__rootRun = new P._ZoneFunction(C.C__RootZone, P.async___rootRun$closure(), [P.Function]);
    C._ZoneFunction__RootZone__rootRunBinary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunBinary$closure(), [P.Function]);
    C._ZoneFunction__RootZone__rootRunUnary = new P._ZoneFunction(C.C__RootZone, P.async___rootRunUnary$closure(), [P.Function]);
    C._ZoneFunction__RootZone__rootScheduleMicrotask = new P._ZoneFunction(C.C__RootZone, P.async___rootScheduleMicrotask$closure(), [{func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}]);
    C._ZoneSpecification_ALf = new P._ZoneSpecification(null, null, null, null, null, null, null, null, null, null, null, null, null);
  })();
  var init = {mangledGlobalNames: {int: "int", double: "double", num: "num", String: "String", bool: "bool", Null: "Null", List: "List"}, mangledNames: {}, getTypeFromName: getGlobalFromName, metadata: [], types: [{func: 1, ret: P.Null}, {func: 1, ret: -1}, {func: 1, ret: P.Null, args: [,]}, {func: 1, ret: P.Null, args: [W.MouseEvent]}, {func: 1, args: [,]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, ret: P.Null, args: [W.Event]}, {func: 1, ret: -1, args: [,]}, {func: 1, ret: P.int, args: [P.int]}, {func: 1, ret: P.Null, args: [P.bool]}, {func: 1, ret: [P.Future,,]}, {func: 1, ret: P.bool, args: [,]}, {func: 1, ret: P.Null, args: [,,]}, {func: 1, ret: -1, args: [P.String,,]}, {func: 1, ret: P.Null, args: [W.KeyboardEvent]}, {func: 1, ret: -1, args: [S.Event0]}, {func: 1, ret: [P.Future, -1], opt: [,]}, {func: 1, ret: [P.Future, P.Null]}, {func: 1, ret: -1, args: [P.Object]}, {func: 1, ret: P.Null, args: [P.String]}, {func: 1, ret: P.bool, args: [P.String]}, {func: 1, ret: P.Null, args: [A.BusEvent]}, {func: 1, ret: P.Null, args: [W.ProgressEvent]}, {func: 1, ret: -1, args: [W.Event]}, {func: 1, ret: P.bool, args: [G.NavigatorProvider]}, {func: 1, ret: P.Null, args: [P.String,,]}, {func: 1, ret: [P.Future, -1]}, {func: 1, ret: -1, args: [E.CpuStackFrame]}, {func: 1, ret: -1, args: [P.Object], opt: [P.StackTrace]}, {func: 1, ret: -1, args: [[P.Set, P.String]]}, {func: 1, ret: P.bool, args: [P.Object]}, {func: 1, ret: P.Null, args: [, P.StackTrace]}, {func: 1, ret: -1, args: [P.String, P.String]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: P.Null, args: [S.Event0]}, {func: 1, ret: P.Null, args: [S.IsolateRef]}, {func: 1, ret: P.int, args: [P.int, S.HeapSpace]}, {func: 1, ret: P.bool, args: [N.Screen]}, {func: 1, ret: -1, args: [U.VmServiceWrapper]}, {func: 1, ret: [P.Future, P.String], opt: [,]}, {func: 1, ret: [P.Future, [P.List, P.String]], opt: [,]}, {func: 1, ret: P.bool, args: [W.MouseEvent]}, {func: 1, ret: P.bool, args: [W.Element]}, {func: 1, ret: [P.Map, P.String,,], args: [S.Frame]}, {func: 1, ret: P.bool, args: [S.ScriptRef]}, {func: 1, ret: [P.List, S.ScriptRef]}, {func: 1, ret: -1, args: [Q.TimelineEvent0]}, {func: 1, ret: P.Null, args: [W.CanvasImageSource]}, {func: 1, ret: -1, args: [W.MouseEvent]}, {func: 1, ret: P.Null, args: [-1]}, {func: 1, ret: P.Null, args: [P.Timer]}, {func: 1, ret: [P.Future, P.Null], args: [P.Timer]}, {func: 1, ret: -1, args: [O.DataEvent]}, {func: 1, ret: [P.Future, -1], args: [,]}, {func: 1, ret: -1, args: [{func: 1, ret: -1}]}, {func: 1, ret: [P.Future, S.Success]}, {func: 1, ret: -1, args: [Q.TimelineFrame]}, {func: 1, ret: P.bool, args: [Q.TimelineEvent0]}, {func: 1, ret: P.bool, args: [W.Event]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ClassRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ScriptRef]}, {func: 1, ret: -1, named: {disabled: P.bool}}, {func: 1, ret: P.Null, args: [P.Object]}, {func: 1, ret: P.Null, args: [P.int]}, {func: 1, ret: P.Null, args: [P.num]}, {func: 1, ret: P.bool, args: [W.NodeValidator]}, {func: 1, ret: P.String, args: [T.InstanceSummary]}, {func: 1, ret: P.Null, args: [P.Null]}, {func: 1, ret: P.bool, args: [P.bool, P.bool, P.bool, P.String]}, {func: 1, ret: P.bool, args: [W.Element, P.String, P.String, W._Html5NodeValidator]}, {func: 1, ret: [P.List, S.Breakpoint]}, {func: 1, ret: P.bool}, {func: 1, ret: [P.Future, P.bool], opt: [,]}, {func: 1, ret: P.bool, args: [W.Node]}, {func: 1, ret: W.Element, args: [A.CoreElement]}, {func: 1, ret: -1, args: [P.String]}, {func: 1, ret: P.int, args: [P.Object]}, {func: 1, ret: P.bool, args: [S.IsolateRef]}, {func: 1, ret: -1, args: [S.Offset]}, {func: 1, ret: P.Null, args: [[P.List,,], W.ResizeObserver]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: -1, args: [W.WheelEvent]}, {func: 1, ret: P.num, args: [P.int]}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: Q.TraceEvent, args: [[P.Map, P.String,,]]}, {func: 1, ret: -1, args: [W.CanvasRenderingContext2D, S.Rect]}, {func: 1, ret: Q.TimelineFrame}, {func: 1, ret: [P.Future, P.Null], args: [P.bool]}, {func: 1, ret: [P.StreamSubscription, W.Event], args: [{func: 1, ret: -1}]}, {func: 1, ret: -1, args: [P.num]}, {func: 1, ret: P.Null, args: [W.FontFace]}, {func: 1, ret: P.String, args: [P.Match]}, {func: 1, ret: -1, opt: [[P.Future,,]]}, {func: 1, ret: P.Object, args: [,]}, {func: 1, ret: [P.Map, P.String,,], args: [S.InstanceRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.FieldRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.FuncRef]}, {func: 1, ret: -1, args: [P.Uint8List, P.String, P.int]}, {func: 1, ret: -1, args: [P.Object, P.StackTrace]}, {func: 1, ret: [P.Map, P.String,,], args: [S.Breakpoint]}, {func: 1, ret: [P.Map, P.String,,], args: [S.TimelineEvent]}, {func: 1, args: [,,]}, {func: 1, ret: P.int}, {func: 1, ret: P.bool, args: [P.Object, P.Object]}, {func: 1, ret: [P.Future, -1], args: [S.Event0]}, {func: 1, ret: -1, args: [S.VmService]}, {func: 1, ret: P.bool, args: [P.double]}, {func: 1, ret: P.bool, args: [N.ActionButton]}, {func: 1, args: [P.num]}, {func: 1, ret: M.InspectorTreeWeb, named: {onExpand: {func: 1, ret: -1, args: [K.InspectorTreeNode]}, onHover: {func: 1, ret: -1, args: [K.InspectorTreeNode, S.Icon]}, onNodeAdded: {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]}, onSelectionChange: {func: 1, ret: -1}, summaryTree: P.bool, treeType: E.FlutterTreeType}}, {func: 1, ret: P.bool, args: [K.InspectorTreeNode, S.Icon]}, {func: 1, ret: P.JsObject, args: [,]}, {func: 1, ret: -1, args: [E.InspectorInstanceRef]}, {func: 1, ret: -1, args: [K.InspectorTreeNode]}, {func: 1, ret: -1, args: [K.InspectorTreeNode, M.RemoteDiagnosticsNode]}, {func: 1, ret: [P.Future, [P.Set, P.String]]}, {func: 1, args: [,,,]}, {func: 1, ret: [P.Future, -1], args: [S.Offset]}, {func: 1, ret: P.Null, args: [,,,,]}, {func: 1, ret: -1, args: [S.Size]}, {func: 1, ret: P.Null, args: [,,,]}, {func: 1, ret: P.Null, args: [{func: 1, ret: -1}]}, {func: 1, ret: [P.Map, P.String, P.String], args: [[P.Map, P.String, P.String], P.String]}, {func: 1, ret: -1, opt: [S.Color]}, {func: 1, ret: -1, args: [P.String, P.int]}, {func: 1, ret: -1, args: [P.String], opt: [,]}, {func: 1, ret: P.Null, args: [Y.LogData]}, {func: 1, ret: P.String, args: [S.LibraryRef]}, {func: 1, ret: [P.Future, P.String]}, {func: 1, ret: -1, opt: [S.IsolateRef]}, {func: 1, ret: P.bool, args: [A.BusEvent]}, {func: 1, ret: P.String}, {func: 1, ret: -1, opt: [P.bool]}, {func: 1, ret: [P.Future, -1], named: {reset: P.bool}}, {func: 1, ret: -1, args: [T.InstanceSummary]}, {func: 1, ret: -1, args: [A.CoreElement]}, {func: 1, ret: -1, args: [[Q.HoverCellData, T.InstanceSummary]]}, {func: 1, ret: S.ScriptRef, args: [,]}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, ret: [P.Future, P.Null], args: [T.ClassHeapDetailStats]}, {func: 1, ret: A.CoreElement, args: [S.Breakpoint]}, {func: 1, ret: [P.Future, P.Null], args: [P.String, P.String, P.bool]}, {func: 1, ret: [P.Future, P.String], args: [S.BoundField]}, {func: 1, ret: P.Null, args: [T.MemoryTracker]}, {func: 1, ret: P.Null, args: [S.Script]}, {func: 1, ret: T.ClassHeapDetailStats, args: [S.ClassHeapStats]}, {func: 1, ret: P.bool, args: [T.ClassHeapDetailStats]}, {func: 1, ret: T.InstanceSummary, args: [S.ObjRef]}, {func: 1, ret: A.CoreElement, args: [S.BoundField]}, {func: 1, ret: P.Null, args: [P.int,,]}, {func: 1, ret: O.AxisLayout, args: [[P.List, P.num]]}, {func: 1, ret: O.Legend, opt: [P.bool]}, {func: 1, ret: [P.Future, S.Isolate], args: [S.IsolateRef]}, {func: 1, ret: A.CoreElement, args: [S.Frame]}, {func: 1, ret: S.HeapSpace, args: [,]}, {func: 1, ret: O.InboundReference, args: [,]}, {func: 1, ret: -1, args: [X.Message]}, {func: 1, ret: P.bool, args: [X.Message]}, {func: 1, ret: P.Null, args: [X.Message]}, {func: 1, ret: [P.Set, X.Message]}, {func: 1, ret: -1, opt: [P.Object]}, {func: 1, ret: P.Null, args: [,], opt: [P.StackTrace]}, {func: 1, ret: -1, args: [S.IsolateRef]}, {func: 1, ret: P.Uint8List, args: [P.int]}, {func: 1, ret: [P.Future, P.int], opt: [,]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: P.Null, args: [P.String, P.int,,]}, {func: 1, ret: P.String, args: [S.Breakpoint]}, {func: 1, ret: P.String, args: [S.ScriptRef]}, {func: 1, ret: P.String, args: [S.Frame]}, {func: 1, ret: P.String, args: [S.BoundVariable]}, {func: 1, ret: [P.Future, P.Null], args: [S.CpuProfile]}, {func: 1, ret: P.Null, args: [S.Success]}, {func: 1, ret: P.Null, args: [V.PerfData]}, {func: 1, ret: P.bool, args: [S.ProfileFunction]}, {func: 1, ret: V.PerfData, args: [S.ProfileFunction]}, {func: 1, ret: [P.Future, P.Null], args: [,]}, {func: 1, args: [W.MessageEvent]}, {func: 1, ret: P.ByteData, args: [W.ProgressEvent]}, {func: 1, ret: [P._Future,,], args: [,]}, {func: 1, ret: P.Null, args: [W.CloseEvent]}, {func: 1, ret: P.String, args: [,]}, {func: 1, ret: [E.ToggleableServiceExtensionDescription,,], args: [,]}, {func: 1, ret: -1, args: [-1]}, {func: 1, ret: [P.Future, P.Null], args: [P.String]}, {func: 1, args: [P.String]}, {func: 1, ret: P.Null, args: [W.DomException]}, {func: 1, ret: P.Null, args: [P.String, [P.StreamController, P.bool]]}, {func: 1, ret: -1, args: [W.Element, P.int]}, {func: 1, ret: -1, args: [A.CoreElement, A.CoreElement, P.int]}, {func: 1, ret: P.Null, args: [E.CpuStackFrame]}, {func: 1, ret: P.bool, args: [[P.Map, P.String,,]]}, {func: 1, ret: [P.Future, P.Null], args: [[P.List, S.Breakpoint]]}, {func: 1, ret: P.bool, args: [E.CpuStackFrame]}, {func: 1, ret: -1, args: [, P.StackTrace]}, {func: 1, ret: P.Null, args: [N.PTabNavTab]}, {func: 1, ret: [P.Future, P.Null], args: [S.Frame]}, {func: 1, ret: [P.Future, P.Null], args: [K.FrameFlameChartItem]}, {func: 1, ret: [P.Future, -1], args: [Q.TimelineEvent0]}, {func: 1, ret: [P.Future, P.Null], args: [Q.OfflineTimelineData]}, {func: 1, ret: P.double, args: [E.CpuStackFrame]}, {func: 1, ret: -1, args: [E.CpuStackFrame, P.int]}, {func: 1, ret: F.FlameChartNode}, {func: 1, ret: P.Object}, {func: 1, ret: [P.Future, P.Null], args: [S.ScriptRef]}, {func: 1, ret: -1, args: [K.FrameFlameChartItem]}, {func: 1, ret: -1, args: [Q.TimelineEvent0, P.int, A.CoreElement], named: {includeDuration: P.bool}}, {func: 1, ret: P.Null, args: [Q.TimelineFrame]}, {func: 1, ret: [P.Future, P.String], args: [S.BoundVariable]}, {func: 1, ret: [P.Future, P.Null], args: [S.Breakpoint]}, {func: 1, ret: P.Null, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}, {func: 1, ret: -1, named: {parent: Q.TimelineEvent0}}, {func: 1, ret: [Y.HeapPriorityQueue, Q.TraceEventWrapper], args: [P.int]}, {func: 1, ret: P.Null, args: [[P.List, S.Breakpoint]]}, {func: 1, ret: P.int, args: [Q.TimelineEvent0, Q.TimelineEvent0]}, {func: 1, ret: P.bool, args: [Q.TimelineFrame]}, {func: 1, ret: P.int, args: [Q.TimelineFrame, Q.TimelineFrame]}, {func: 1, ret: K.FrameEventsChart, args: [Q.OfflineTimelineData]}, {func: 1, ret: P.bool, args: [Q.TraceEvent]}, {func: 1, ret: -1, named: {onlyCollapse: P.bool, onlyExpand: P.bool}}, {func: 1, args: [W.Event]}, {func: 1, ret: -1, args: [P.String], opt: [P.bool]}, {func: 1, ret: -1, args: [P.String], named: {removeOthers: P.bool}}, {func: 1, args: [, P.String]}, {func: 1, bounds: [P.Object], ret: [P.Set, 0]}, {func: 1, ret: -1, args: [U.DiagnosticsNode]}, {func: 1, ret: P.bool, args: [U.DiagnosticsNode]}, {func: 1, ret: -1, args: [W.Node, W.Node]}, {func: 1, ret: S.CustomIcon}, {func: 1, ret: S.ColorIcon}, {func: 1, ret: K.MaterialIcon}, {func: 1, ret: -1, args: [W.KeyboardEvent]}, {func: 1, ret: P.bool, args: [P.bool]}, {func: 1, ret: P.Null, args: [R.ServiceExtensionState]}, {func: 1, ret: [P.Future, U.Response0], args: [U.Client]}, {func: 1, ret: P.bool, args: [P.String, P.String]}, {func: 1, ret: P.int, args: [P.String]}, {func: 1, ret: -1, args: [[P.List, P.int]]}, {func: 1, ret: U.Response0, args: [P.Uint8List]}, {func: 1, ret: R.MediaType}, {func: 1, ret: P.Null, args: [P.String, P.String]}, {func: 1, ret: [P.Future, -1], args: [S.Breakpoint]}, {func: 1, ret: -1, args: [T._DateFormatField]}, {func: 1, ret: T._DateFormatQuotedField, args: [,,]}, {func: 1, ret: S.HeapSpace, args: [[P.Map, P.String,,]]}, {func: 1, ret: T._DateFormatLiteralField, args: [,,]}, {func: 1, ret: P.String, args: [B.NumberSymbols]}, {func: 1, ret: P.bool, args: [L.Browser]}, {func: 1, ret: L.Browser}, {func: 1, ret: {futureOr: 1, type: P.bool}}, {func: 1, ret: P.String, args: [P.String], named: {color: null}}, {func: 1, args: [P.Object, P.Object, P.num, P.int]}, {func: 1, args: [P.Object, P.num, P.int]}, {func: 1, ret: A.CoreElement, args: [S.ScriptRef]}, {func: 1, ret: -1, args: [[P.Completer,,]]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ClassHeapStats]}, {func: 1, ret: P.int, args: [S.ScriptRef, S.ScriptRef]}, {func: 1, ret: P.bool, args: [[P.Set, P.String]]}, {func: 1, ret: A.CoreElement, args: [S.BoundVariable]}, {func: 1, ret: P.Null, args: [P.Symbol0,,]}, {func: 1, ret: S.BoundVariable, args: [S.MapAssociation]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ContextElement]}, {func: 1, ret: S.BoundVariable, args: [S.BoundField]}, {func: 1, ret: W.Element, args: [W.Node]}, {func: 1, ret: [P.Map, P.String,,], args: [S.Flag]}, {func: 1, ret: [P.Map, P.String,,], args: [S.BoundVariable]}, {func: 1, ret: [P.Map, P.String,,], args: [S.BoundField]}, {func: 1, ret: [P.Map, P.String,,], args: [S.MapAssociation]}, {func: 1, ret: [P.Map, P.String,,], args: [S.LibraryRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ObjRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.LibraryDependency]}, {func: 1, ret: [P.Future, S.InstanceRef]}, {func: 1, ret: [P.List, P.int], args: [,]}, {func: 1, ret: [P.List, P.int], args: [[P.List, P.int]]}, {func: 1, ret: [P.Map, P.String,,], args: [S.SourceReportRange]}, {func: 1, ret: -1, args: [W.PopStateEvent]}, {func: 1, ret: [P.Map, P.String,,], args: [S.Message0]}, {func: 1, ret: [P.Map, P.String,,], args: [S.IsolateRef]}, {func: 1, ret: [P.Map, P.String,,], args: [S.CodeRegion]}, {func: 1, ret: [P.Map, P.String,,], args: [S.ProfileFunction]}, {func: 1, ret: P.JsFunction, args: [,]}, {func: 1, ret: [P.JsArray,,], args: [,]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone,, P.StackTrace]}, {func: 1, bounds: [P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}, {func: 1, bounds: [P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}, 1]}, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: 0, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}, 1, 2]}, {func: 1, bounds: [P.Object], ret: {func: 1, ret: 0}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0}]}, {func: 1, bounds: [P.Object, P.Object], ret: {func: 1, ret: 0, args: [1]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1]}]}, {func: 1, bounds: [P.Object, P.Object, P.Object], ret: {func: 1, ret: 0, args: [1, 2]}, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: 0, args: [1, 2]}]}, {func: 1, ret: P.AsyncError, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Object, P.StackTrace]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, {func: 1, ret: -1}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1}]}, {func: 1, ret: P.Timer, args: [P.Zone, P.ZoneDelegate, P.Zone, P.Duration, {func: 1, ret: -1, args: [P.Timer]}]}, {func: 1, ret: -1, args: [P.Zone, P.ZoneDelegate, P.Zone, P.String]}, {func: 1, ret: P.Zone, args: [P.Zone, P.ZoneDelegate, P.Zone, P.ZoneSpecification, [P.Map,,,]]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: N.Screen}, {func: 1, ret: P.int, args: [S.Breakpoint, S.Breakpoint]}, {func: 1, ret: P.int, args: [P.String, P.String]}, {func: 1, bounds: [P.Object], ret: A.CoreElement, args: [0]}, {func: 1, ret: P.Null, args: [N.Screen, A.CoreElement]}, {func: 1, ret: S.ExtensionData, args: [[P.Map,,,]]}, {func: 1, ret: S.AllocationProfile, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.BoundField, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.BoundVariable, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Breakpoint, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Class, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassHeapStats, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ClassList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CodeRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Code, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ContextRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Context, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ContextElement, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ErrorRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Error0, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Event0, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FieldRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Field, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Flag, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FlagList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Frame, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.FuncRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Func, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.InstanceRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Instance, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.IsolateRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Isolate, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.InstanceSet, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.LibraryRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Library, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.LibraryDependency, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.LogRecord, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.MapAssociation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.MemoryUsage, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Message0, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.NullValRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.NullVal, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ObjRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Obj, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ReloadReport, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Response, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Sentinel, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ScriptRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Script, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ScriptList, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceLocation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReport, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReportCoverage, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.SourceReportRange, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Stack, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Success, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Timeline, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TimelineEvent, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TimelineFlags, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Timestamp, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TypeArgumentsRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.TypeArguments, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.UnresolvedSourceLocation, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.Version, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.VMRef, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.VM, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CpuProfile, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.CodeRegion, args: [[P.Map, P.String,,]]}, {func: 1, ret: S.ProfileFunction, args: [[P.Map, P.String,,]]}, {func: 1, ret: T._DateFormatPatternField, args: [,,]}], interceptorsByTag: null, leafTags: null};
  (function staticFields() {
    $.printToZone = null;
    $.Primitives_timerFrequency = null;
    $.Primitives_timerTicks = null;
    $.Closure_functionCounter = 0;
    $.BoundClosure_selfFieldNameCache = null;
    $.BoundClosure_receiverFieldNameCache = null;
    $._inTypeAssertion = false;
    $.getTagFunction = null;
    $.alternateTagFunction = null;
    $.prototypeForTagFunction = null;
    $.dispatchRecordsForInstanceTags = null;
    $.interceptorsForUncacheableTags = null;
    $.initNativeDispatchFlag = null;
    $._nextCallback = null;
    $._lastCallback = null;
    $._lastPriorityCallback = null;
    $._isInCallbackLoop = false;
    $.Zone__current = C.C__RootZone;
    $._RootZone__rootDelegate = null;
    $._toStringVisiting = [];
    $.Encoding__nameToEncoding = P.LinkedHashMap_LinkedHashMap$_literal(["iso_8859-1:1987", C.C_Latin1Codec, "iso-ir-100", C.C_Latin1Codec, "iso_8859-1", C.C_Latin1Codec, "iso-8859-1", C.C_Latin1Codec, "latin1", C.C_Latin1Codec, "l1", C.C_Latin1Codec, "ibm819", C.C_Latin1Codec, "cp819", C.C_Latin1Codec, "csisolatin1", C.C_Latin1Codec, "iso-ir-6", C.C_AsciiCodec, "ansi_x3.4-1968", C.C_AsciiCodec, "ansi_x3.4-1986", C.C_AsciiCodec, "iso_646.irv:1991", C.C_AsciiCodec, "iso646-us", C.C_AsciiCodec, "us-ascii", C.C_AsciiCodec, "us", C.C_AsciiCodec, "ibm367", C.C_AsciiCodec, "cp367", C.C_AsciiCodec, "csascii", C.C_AsciiCodec, "ascii", C.C_AsciiCodec, "csutf8", C.C_Utf8Codec, "utf-8", C.C_Utf8Codec], P.String, P.Encoding);
    $.Expando__keyCount = 0;
    $.Stopwatch__frequency = null;
    $.Element__parseDocument = null;
    $.Element__parseRange = null;
    $.Element__defaultValidator = null;
    $.Element__defaultSanitizer = null;
    $._Html5NodeValidator__attributeValidators = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.Function);
    $.Device__isOpera = null;
    $.Device__isIE = null;
    $.Device__isFirefox = null;
    $.Device__isWebKit = null;
    $.Device__cachedCssPrefix = null;
    $.CodeMirror__instances = P.LinkedHashMap_LinkedHashMap$_empty(P.JsObject, X.CodeMirror);
    $._toStringVisiting0 = [];
    $.offlineMode = false;
    $.globals = P.LinkedHashMap_LinkedHashMap$_empty(P.Type, null);
    $.Category__categories = null;
    $.Catalog__cachedCatalog = null;
    $.Catalog__instance = null;
    $._inspectorDependenciesLoaded = false;
    $.InspectorService_nextGroupId = 0;
    $._asciiMeasurements = null;
    $._traceEventWrapperId = 0;
    $.debugHandledTraceEvents = H.setRuntimeTypeInfo([], [[P.Map, P.String,,]]);
    $._lastGaError = null;
    $._userAppType = "";
    $._userBuildType = "";
    $._userPlatformType = "";
    $._devtoolsPlatformType = "";
    $._devtoolsChrome = "";
    $._ideLaunched = "";
    $._analyticsComputed = false;
    $._computing = false;
    $._stillWaiting = 0;
    $.uiColorPalette = H.setRuntimeTypeInfo([C.ThemedColor_Color_4286698746_Color_4288593657, C.ThemedColor_Color_4283417591_Color_4287280375, C.ThemedColor_Color_4280923894_Color_4284914934], [K.ThemedColor]);
    $.gpuColorPalette = H.setRuntimeTypeInfo([C.ThemedColor_Color_4278356177_Color_4279923688, C.ThemedColor_Color_4278351805_Color_4279854802, C.ThemedColor_Color_4278278043_Color_4279785917], [K.ThemedColor]);
    $._cssColors = P.LinkedHashMap_LinkedHashMap$_empty(S.Color, P.String);
    $._MaterialIconRenderer__iconsFont = null;
    $._MaterialIconRenderer__iconsFontFuture = null;
    $._MaterialIconRenderer__fontLoaded = false;
    $.FlutterMaterialIcons__iconCache = P.LinkedHashMap_LinkedHashMap$_empty(P.String, K.MaterialIcon);
    $._isDarkTheme = false;
    $._hiddenPages = null;
    $.Intl__defaultLocale = null;
    $.DateFormat__useNativeDigitsByDefault = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.bool);
    $.currencyFractionDigits = P.LinkedHashMap_LinkedHashMap$_literal(["ADP", 0, "AFN", 0, "ALL", 0, "AMD", 0, "BHD", 3, "BIF", 0, "BYN", 2, "BYR", 0, "CAD", 2, "CHF", 2, "CLF", 4, "CLP", 0, "COP", 0, "CRC", 2, "CZK", 2, "DEFAULT", 2, "DJF", 0, "DKK", 2, "ESP", 0, "GNF", 0, "GYD", 0, "HUF", 2, "IDR", 0, "IQD", 0, "IRR", 0, "ISK", 0, "ITL", 0, "JOD", 3, "JPY", 0, "KMF", 0, "KPW", 0, "KRW", 0, "KWD", 3, "LAK", 0, "LBP", 0, "LUF", 0, "LYD", 3, "MGA", 0, "MGF", 0, "MMK", 0, "MNT", 0, "MRO", 0, "MUR", 0, "NOK", 2, "OMR", 3, "PKR", 0, "PYG", 0, "RSD", 0, "RWF", 0, "SEK", 2, "SLL", 0, "SOS", 0, "STD", 0, "SYP", 0, "TMM", 0, "TND", 3, "TRL", 0, "TWD", 2, "TZS", 0, "UGX", 0, "UYI", 0, "UZS", 0, "VND", 0, "VUV", 0, "XAF", 0, "XOF", 0, "XPF", 0, "YER", 0, "ZMK", 0, "ZWD", 0], P.String, P.int);
    $.cachedDateSymbols = null;
    $.lastDateSymbolLocale = null;
    $._currentUriBase = null;
    $._current = null;
    $.Browser_navigator = null;
    $._browser = null;
    $._typeFactories = P.LinkedHashMap_LinkedHashMap$_literal(["AllocationProfile", S.vm_service_lib_AllocationProfile_parse$closure(), "BoundField", S.vm_service_lib_BoundField_parse$closure(), "BoundVariable", S.vm_service_lib_BoundVariable_parse$closure(), "Breakpoint", S.vm_service_lib_Breakpoint_parse$closure(), "@Class", S.vm_service_lib_ClassRef_parse$closure(), "Class", S.vm_service_lib_Class_parse$closure(), "ClassHeapStats", S.vm_service_lib_ClassHeapStats_parse$closure(), "ClassList", S.vm_service_lib_ClassList_parse$closure(), "@Code", S.vm_service_lib_CodeRef_parse$closure(), "Code", S.vm_service_lib_Code_parse$closure(), "@Context", S.vm_service_lib_ContextRef_parse$closure(), "Context", S.vm_service_lib_Context_parse$closure(), "ContextElement", S.vm_service_lib_ContextElement_parse$closure(), "@Error", S.vm_service_lib_ErrorRef_parse$closure(), "Error", S.vm_service_lib_Error_parse$closure(), "Event", S.vm_service_lib_Event_parse$closure(), "ExtensionData", S.vm_service_lib_ExtensionData_parse$closure(), "@Field", S.vm_service_lib_FieldRef_parse$closure(), "Field", S.vm_service_lib_Field_parse$closure(), "Flag", S.vm_service_lib_Flag_parse$closure(), "FlagList", S.vm_service_lib_FlagList_parse$closure(), "Frame", S.vm_service_lib_Frame_parse$closure(), "@Function", S.vm_service_lib_FuncRef_parse$closure(), "Function", S.vm_service_lib_Func_parse$closure(), "@Instance", S.vm_service_lib_InstanceRef_parse$closure(), "Instance", S.vm_service_lib_Instance_parse$closure(), "@Isolate", S.vm_service_lib_IsolateRef_parse$closure(), "Isolate", S.vm_service_lib_Isolate_parse$closure(), "InstanceSet", S.vm_service_lib_InstanceSet_parse$closure(), "@Library", S.vm_service_lib_LibraryRef_parse$closure(), "Library", S.vm_service_lib_Library_parse$closure(), "LibraryDependency", S.vm_service_lib_LibraryDependency_parse$closure(), "LogRecord", S.vm_service_lib_LogRecord_parse$closure(), "MapAssociation", S.vm_service_lib_MapAssociation_parse$closure(), "MemoryUsage", S.vm_service_lib_MemoryUsage_parse$closure(), "Message", S.vm_service_lib_Message_parse$closure(), "@Null", S.vm_service_lib_NullValRef_parse$closure(), "Null", S.vm_service_lib_NullVal_parse$closure(), "@Object", S.vm_service_lib_ObjRef_parse$closure(), "Object", S.vm_service_lib_Obj_parse$closure(), "ReloadReport", S.vm_service_lib_ReloadReport_parse$closure(), "Response", S.vm_service_lib_Response_parse$closure(), "Sentinel", S.vm_service_lib_Sentinel_parse$closure(), "@Script", S.vm_service_lib_ScriptRef_parse$closure(), "Script", S.vm_service_lib_Script_parse$closure(), "ScriptList", S.vm_service_lib_ScriptList_parse$closure(), "SourceLocation", S.vm_service_lib_SourceLocation_parse$closure(), "SourceReport", S.vm_service_lib_SourceReport_parse$closure(), "SourceReportCoverage", S.vm_service_lib_SourceReportCoverage_parse$closure(), "SourceReportRange", S.vm_service_lib_SourceReportRange_parse$closure(), "Stack", S.vm_service_lib_Stack_parse$closure(), "Success", S.vm_service_lib_Success_parse$closure(), "Timeline", S.vm_service_lib_Timeline_parse$closure(), "TimelineEvent", S.vm_service_lib_TimelineEvent_parse$closure(), "TimelineFlags", S.vm_service_lib_TimelineFlags_parse$closure(), "Timestamp", S.vm_service_lib_Timestamp_parse$closure(), "@TypeArguments", S.vm_service_lib_TypeArgumentsRef_parse$closure(), "TypeArguments", S.vm_service_lib_TypeArguments_parse$closure(), "UnresolvedSourceLocation", S.vm_service_lib_UnresolvedSourceLocation_parse$closure(), "Version", S.vm_service_lib_Version_parse$closure(), "@VM", S.vm_service_lib_VMRef_parse$closure(), "VM", S.vm_service_lib_VM_parse$closure(), "_CpuProfile", S.vm_service_lib_CpuProfile_parse$closure(), "CodeRegion", S.vm_service_lib_CodeRegion_parse$closure(), "ProfileFunction", S.vm_service_lib_ProfileFunction_parse$closure(), "HeapSpace", S.vm_service_lib_HeapSpace_parse$closure()], P.String, P.Function);
  })();
  (function lazyInitializers() {
    var _lazy = hunkHelpers.lazy;
    _lazy($, "DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
      return H.getIsolateAffinityTag("_$dart_dartClosure");
    });
    _lazy($, "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
      return H.getIsolateAffinityTag("_$dart_js");
    });
    _lazy($, "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
        toString: function() {
          return "$receiver$";
        }
      }));
    });
    _lazy($, "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          null.$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        var $argumentsExpr$ = '$arguments$';
        try {
          (void 0).$method$($argumentsExpr$);
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
    });
    _lazy($, "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          null.$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
    });
    _lazy($, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
      return H.TypeErrorDecoder_extractPattern(function() {
        try {
          (void 0).$method$;
        } catch (e) {
          return e.message;
        }
      }());
    });
    _lazy($, "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
      return P._AsyncRun__initializeScheduleImmediate();
    });
    _lazy($, "Future__nullFuture", "$get$Future__nullFuture", function() {
      return P._Future$zoneValue(null, C.C__RootZone, P.Null);
    });
    _lazy($, "_RootZone__rootMap", "$get$_RootZone__rootMap", function() {
      var _null = null;
      return P.HashMap_HashMap(_null, _null, _null, _null, _null);
    });
    _lazy($, "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
      return P.Utf8Decoder__makeDecoder();
    });
    _lazy($, "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
      return H.NativeInt8List__create1(H._ensureNativeList(H.setRuntimeTypeInfo([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2], [P.int])));
    });
    _lazy($, "_Uri__isWindowsCached", "$get$_Uri__isWindowsCached", function() {
      return typeof process != "undefined" && Object.prototype.toString.call(process) == "[object process]" && process.platform == "win32";
    });
    _lazy($, "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
      return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$");
    });
    _lazy($, "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
      return new Error().stack != void 0;
    });
    _lazy($, "_scannerTables", "$get$_scannerTables", function() {
      return P._createTables();
    });
    _lazy($, "CssStyleDeclaration__propertyCache", "$get$CssStyleDeclaration__propertyCache", function() {
      return {};
    });
    _lazy($, "_Html5NodeValidator__allowedElements", "$get$_Html5NodeValidator__allowedElements", function() {
      return P.LinkedHashSet_LinkedHashSet$from(["A", "ABBR", "ACRONYM", "ADDRESS", "AREA", "ARTICLE", "ASIDE", "AUDIO", "B", "BDI", "BDO", "BIG", "BLOCKQUOTE", "BR", "BUTTON", "CANVAS", "CAPTION", "CENTER", "CITE", "CODE", "COL", "COLGROUP", "COMMAND", "DATA", "DATALIST", "DD", "DEL", "DETAILS", "DFN", "DIR", "DIV", "DL", "DT", "EM", "FIELDSET", "FIGCAPTION", "FIGURE", "FONT", "FOOTER", "FORM", "H1", "H2", "H3", "H4", "H5", "H6", "HEADER", "HGROUP", "HR", "I", "IFRAME", "IMG", "INPUT", "INS", "KBD", "LABEL", "LEGEND", "LI", "MAP", "MARK", "MENU", "METER", "NAV", "NOBR", "OL", "OPTGROUP", "OPTION", "OUTPUT", "P", "PRE", "PROGRESS", "Q", "S", "SAMP", "SECTION", "SELECT", "SMALL", "SOURCE", "SPAN", "STRIKE", "STRONG", "SUB", "SUMMARY", "SUP", "TABLE", "TBODY", "TD", "TEXTAREA", "TFOOT", "TH", "THEAD", "TIME", "TR", "TRACK", "TT", "U", "UL", "VAR", "VIDEO", "WBR"], P.String);
    });
    _lazy($, "CssClassSetImpl__validTokenRE", "$get$CssClassSetImpl__validTokenRE", function() {
      return P.RegExp_RegExp("^\\S+$");
    });
    _lazy($, "context", "$get$context", function() {
      return H.interceptedTypeCheck(P._wrapToDart(self), "$isJsObject");
    });
    _lazy($, "_DART_OBJECT_PROPERTY_NAME", "$get$_DART_OBJECT_PROPERTY_NAME", function() {
      return H.getIsolateAffinityTag("_$dart_dartObject");
    });
    _lazy($, "_dartProxyCtor", "$get$_dartProxyCtor", function() {
      return function DartObject(o) {
        this.o = o;
      };
    });
    _lazy($, "diagnosticLevelToName", "$get$diagnosticLevelToName", function() {
      return M._invertMap(C.Map_omyhD, U.DiagnosticLevel, P.String);
    });
    _lazy($, "treeStyleToName", "$get$treeStyleToName", function() {
      return M._invertMap(C.Map_kT33h, U.DiagnosticsTreeStyle, P.String);
    });
    _lazy($, "RemoteDiagnosticsNode_iconMaker", "$get$RemoteDiagnosticsNode_iconMaker", function() {
      return S.CustomIconMaker$();
    });
    _lazy($, "unimportant", "$get$unimportant", function() {
      var _null = null;
      return U.TextStyle$(K.ThemedColor$(C.MaterialColor_Map_HFpTk_4288585374.get$shade500(), C.MaterialColor_Map_HFpTk_4288585374.get$shade400()), _null, _null, _null, _null, _null, _null, _null, _null, _null, true, _null, _null, _null);
    });
    _lazy($, "warning", "$get$warning", function() {
      var _null = null;
      return U.TextStyle$(K.ThemedColor$(C.MaterialColor_Map_JNZaB_4294940672.get$shade500(), C.MaterialColor_Map_JNZaB_4294940672.get$shade400()), _null, _null, _null, _null, _null, _null, _null, _null, _null, true, _null, _null, _null);
    });
    _lazy($, "error0", "$get$error", function() {
      var _null = null;
      return U.TextStyle$(K.ThemedColor$(C.MaterialColor_Map_JNc9P_4294198070.get$shade500(), C.MaterialColor_Map_JNc9P_4294198070.get$shade400()), _null, _null, _null, _null, _null, _null, _null, _null, _null, true, _null, _null, _null);
    });
    _lazy($, "_primaryDescriptionPattern", "$get$_primaryDescriptionPattern", function() {
      return P.RegExp_RegExp("([\\w ]+)[-#]?(.*)");
    });
    _lazy($, "_colorIconMaker", "$get$_colorIconMaker", function() {
      return new S.ColorIconMaker(P.LinkedHashMap_LinkedHashMap$_empty(S.Color, S.Icon));
    });
    _lazy($, "_customIconMaker", "$get$_customIconMaker", function() {
      return S.CustomIconMaker$();
    });
    _lazy($, "defaultIcon", "$get$defaultIcon", function() {
      return $.$get$_customIconMaker().fromInfo$1("Default");
    });
    _lazy($, "collapseArrow", "$get$collapseArrow", function() {
      return K.MaterialIcon$("arrow_drop_down", C.MaterialColor_Map_HFpTk_4288585374, 0, 32, C.JSInt_methods.toInt$0(13));
    });
    _lazy($, "expandArrow", "$get$expandArrow", function() {
      return K.MaterialIcon$("arrow_drop_down", C.MaterialColor_Map_HFpTk_4288585374, -1.5707963267948966, 32, C.JSInt_methods.toInt$0(13));
    });
    _lazy($, "InspectorTreeNodeRenderCanvasBuilder__measurementCanvas", "$get$InspectorTreeNodeRenderCanvasBuilder__measurementCanvas", function() {
      return C.CanvasElement_methods.get$context2D(W.CanvasElement_CanvasElement(1, 1));
    });
    _lazy($, "timeFormat", "$get$timeFormat", function() {
      var t1 = new T.DateFormat();
      t1._locale = T.Intl_verifiedLocale(null, T.intl_DateFormat_localeExists$closure(), T.intl_Intl__throwLocaleError$closure());
      t1.addPattern$1("HH:mm:ss.SSS");
      return t1;
    });
    _lazy($, "MemoryPlotly_rssColor", "$get$MemoryPlotly_rssColor", function() {
      return Y.colorToCss(C.ThemedColor_Color_4294675456_Color_4293284096);
    });
    _lazy($, "MemoryPlotly_capacityColor", "$get$MemoryPlotly_capacityColor", function() {
      return Y.colorToCss(C.ThemedColor_Color_4282735204_Color_4291811548);
    });
    _lazy($, "MemoryPlotly_externalColor", "$get$MemoryPlotly_externalColor", function() {
      return Y.colorToCss(C.ThemedColor_Color_4278351805_Color_4278278043);
    });
    _lazy($, "MemoryPlotly_usedColor", "$get$MemoryPlotly_usedColor", function() {
      return Y.colorToCss(C.ThemedColor_Color_4283417591_Color_4280923894);
    });
    _lazy($, "MemoryPlotly_gcColor", "$get$MemoryPlotly_gcColor", function() {
      return Y.colorToCss(C.ThemedColor_Color_4278430196_Color_4278426597);
    });
    _lazy($, "trackWidgetCreationWarning", "$get$trackWidgetCreationWarning", function() {
      var _null = null,
        t1 = A.div(_null, _null, _null);
      t1.add$1(0, A.span(_null, _null, "The "));
      t1.add$1(0, A.a("https://flutter.github.io/devtools/inspector#track-widget-creation", "_blank;", "widget creation tracking feature"));
      t1.add$1(0, A.span(_null, _null, " is not enabled. "));
      t1.add$1(0, A.span(_null, _null, "This feature allows the Flutter inspector to present \nthe widget tree in a manner similar to how the UI was defined in your source\ncode. Without it, the tree of nodes in the widget tree are much deeper, and it\ncan be more difficult to understand how the runtime widget hierarchy corresponds\nto your application\u2019s UI."));
      return X.Message$(C.MessageType_1, H.setRuntimeTypeInfo([t1, A.div(_null, _null, "To fix this, relaunch your application by running \n'flutter run --track-widget-creation' (or run your application from VS Code or\nIntelliJ).")], [A.CoreElement]), "trackWidgetCreationWarningId", _null, _null);
    });
    _lazy($, "debugWarning", "$get$debugWarning", function() {
      var _null = null,
        t1 = A.div(_null, _null, "You are running your app in debug mode. Debug mode frame rendering times are not indicative of release performance."),
        t2 = A.div(_null, _null, _null);
      t2.add$1(0, A.span(_null, _null, "Relaunch your application with the '--profile' argument, or \n"));
      t2.add$1(0, A.a("https://flutter.dev/docs/testing/ui-performance#run-in-profile-mode", "_blank;", "relaunch in profile mode from VS Code or IntelliJ"));
      t2.add$1(0, A.span(_null, _null, "."));
      return X.Message$(C.MessageType_1, H.setRuntimeTypeInfo([t1, t2], [A.CoreElement]), "debugWarningId", _null, _null);
    });
    _lazy($, "toggleableExtensionsWhitelist", "$get$toggleableExtensionsWhitelist", function() {
      var map = P.LinkedHashMap_LinkedHashMap(null, null, P.String, [E.ToggleableServiceExtensionDescription,,]);
      P.MapBase__fillMapWithMappedIterable(map, C.List_nBB, new E.closure(), new E.closure0());
      return map;
    });
    _lazy($, "_selectedFrameFlameChartItemController", "$get$_selectedFrameFlameChartItemController", function() {
      return P.StreamController_StreamController$broadcast(null, null, false, K.FrameFlameChartItem);
    });
    _lazy($, "_dragScroll", "$get$_dragScroll", function() {
      return F.DragScroll$();
    });
    _lazy($, "debugFrameTracking", "$get$debugFrameTracking", function() {
      return P.StringBuffer$("");
    });
    _lazy($, "_devicePixelRatio", "$get$_devicePixelRatio", function() {
      return W.window().devicePixelRatio;
    });
    _lazy($, "Rect_zero", "$get$Rect_zero", function() {
      return new S.Rect(H.NativeFloat32List__create1(H._checkLength(4)));
    });
    _lazy($, "sparseTextConfiguration", "$get$sparseTextConfiguration", function() {
      return U.TextTreeConfiguration$(true, "", ":", "", "", "", "", "", true, false, "\n", true, "\u2502", "", "\u2514\u2500", "\u251c\u2500", " ", " ", "\u2502 ", "  ", "", true, "");
    });
    _lazy($, "dashedTextConfiguration", "$get$dashedTextConfiguration", function() {
      return U.TextTreeConfiguration$(true, "", ":", "", "", "", "", "", true, false, "\n", true, "\u254e", "", "\u2514\u254c", "\u254e\u254c", " ", " ", "\u2502 ", "  ", "", true, "");
    });
    _lazy($, "denseTextConfiguration", "$get$denseTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", false, false, "\n", false, "\u2502", "", "\u2514", "\u251c", "", "", "\u2502", " ", ", ", true, "");
    });
    _lazy($, "transitionTextConfiguration", "$get$transitionTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, ":", " \u2550\u2550\u2550", "", "", "", "  ", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, true, "\n", true, "\u2502", "", "\u2558\u2550\u2566\u2550\u2550 ", "\u255e\u2550\u2566\u2550\u2550 ", " \u2551 ", "", "", "", "", true, "");
    });
    _lazy($, "errorTextConfiguration", "$get$errorTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, "", ":", "", "\u2550\u2550\u2561 ", "", "", " \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550", false, false, "\n", true, "\u2502", "\u2550\u2550\u2550\u2550\u2550", "\u2558\u2550\u2566", "\u255e\u2550\u2566", " \u2551 ", "", "", "", "", true, " \u255e\u2550\u2550");
    });
    _lazy($, "whitespaceTextConfiguration", "$get$whitespaceTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", true, "");
    });
    _lazy($, "flatTextConfiguration", "$get$flatTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, "", "", "", "", "", "", "", "", "", true, "");
    });
    _lazy($, "singleLineTextConfiguration", "$get$singleLineTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
    });
    _lazy($, "headerLineTextConfiguration", "$get$headerLineTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, "", ":", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
    });
    _lazy($, "singleLineTextConfigurationIndented", "$get$singleLineTextConfigurationIndented", function() {
      return U.TextTreeConfiguration$(false, "", "\n  ", ")", "", "(", "", "", true, false, "", false, "", "", "", "", "", "", "", "", ", ", false, "");
    });
    _lazy($, "shallowTextConfiguration", "$get$shallowTextConfiguration", function() {
      return U.TextTreeConfiguration$(false, ":", ":", "", "", "", "", "", false, false, "\n", true, " ", "", "", "", " ", "  ", "", "", "", false, "");
    });
    _lazy($, "_indentPattern", "$get$_indentPattern", function() {
      return P.RegExp_RegExp("^ *(?:[-+*] |[0-9]+[.):] )?");
    });
    _lazy($, "rendererExpando", "$get$rendererExpando", function() {
      if (typeof WeakMap == "function")
        var t1 = new WeakMap();
      else {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        t1 = "expando$key$" + t1;
      }
      return new P.Expando(t1, "IconRenderer", [[Y.HtmlIconRenderer, S.Icon]]);
    });
    _lazy($, "nf", "$get$nf", function() {
      return T.NumberFormat$decimalPattern();
    });
    _lazy($, "_escapedChar", "$get$_escapedChar", function() {
      return P.RegExp_RegExp('["\\x00-\\x1F\\x7F]');
    });
    _lazy($, "token", "$get$token", function() {
      return P.RegExp_RegExp('[^()<>@,;:"\\\\/[\\]?={} \\t\\x00-\\x1F\\x7F]+');
    });
    _lazy($, "_lws", "$get$_lws", function() {
      return P.RegExp_RegExp("(?:\\r\\n)?[ \\t]+");
    });
    _lazy($, "_quotedString", "$get$_quotedString", function() {
      return P.RegExp_RegExp('"(?:[^"\\x00-\\x1F\\x7F]|\\\\.)*"');
    });
    _lazy($, "_quotedPair", "$get$_quotedPair", function() {
      return P.RegExp_RegExp("\\\\(.)");
    });
    _lazy($, "nonToken", "$get$nonToken", function() {
      return P.RegExp_RegExp('[()<>@,;:"\\\\/\\[\\]?={} \\t\\x00-\\x1F\\x7F]');
    });
    _lazy($, "whitespace", "$get$whitespace", function() {
      return P.RegExp_RegExp("(?:" + $.$get$_lws().pattern + ")*");
    });
    _lazy($, "en_USSymbols", "$get$en_USSymbols", function() {
      return new B.DateSymbols("en_US", C.List_BC_AD, C.List_6xs, C.List_qpm, C.List_qpm, C.List_cIc, C.List_cIc, C.List_h8w, C.List_h8w, C.List_wMy, C.List_wMy, C.List_gc6, C.List_gc6, C.List_3US, C.List_Q1_Q2_Q3_Q4, C.List_bJM, C.List_AM_PM);
    });
    _lazy($, "DateFormat__matchers", "$get$DateFormat__matchers", function() {
      return H.setRuntimeTypeInfo([P.RegExp_RegExp("^'(?:[^']|'')*'"), P.RegExp_RegExp("^(?:G+|y+|M+|k+|S+|E+|a+|h+|K+|H+|c+|L+|Q+|d+|D+|m+|s+|v+|z+|Z+)"), P.RegExp_RegExp("^[^'GyMkSEahKHcLQdDmsvzZ]+")], [P.RegExp]);
    });
    _lazy($, "DateFormat__asciiZeroCodeUnit", "$get$DateFormat__asciiZeroCodeUnit", function() {
      return 48;
    });
    _lazy($, "_DateFormatQuotedField__twoEscapedQuotes", "$get$_DateFormatQuotedField__twoEscapedQuotes", function() {
      return P.RegExp_RegExp("''");
    });
    _lazy($, "NumberFormat__ln10", "$get$NumberFormat__ln10", function() {
      return P.log(10);
    });
    _lazy($, "NumberFormat__maxInt", "$get$NumberFormat__maxInt", function() {
      return typeof 1 === "number" ? P.pow(2, 52) : C.JSInt_methods.floor$0(1e300);
    });
    _lazy($, "NumberFormat__maxDigits", "$get$NumberFormat__maxDigits", function() {
      return C.JSDouble_methods.ceil$0(P.log($.$get$NumberFormat__maxInt()) / P.log(10));
    });
    _lazy($, "numberFormatSymbols", "$get$numberFormatSymbols", function() {
      var _s1_ = ",", _s1_0 = "\xa0", _s1_1 = "%", _s1_2 = "0", _s1_3 = "+", _s1_4 = "-", _s1_5 = "E", _s1_6 = "\u2030", _s1_7 = "\u221e", _s3_ = "NaN",
        _s9_ = "#,##0.###",
        _s3_0 = "#E0", _s6_ = "#,##0%",
        _s9_0 = "\xa4#,##0.00",
        _s1_8 = ".",
        _s2_ = "\u200e+",
        _s2_0 = "\u200e-",
        _s9_1 = "\u0644\u064a\u0633\xa0\u0631\u0642\u0645\u064b\u0627",
        _s10_ = "\xa4\xa0#,##0.00",
        _s10_0 = "#,##0.00\xa0\xa4",
        _s7_ = "#,##0\xa0%",
        _s12_ = "#,##,##0.###",
        _s3_1 = "EUR", _s3_2 = "USD",
        _s21_ = "\xa4\xa0#,##0.00;\xa4-#,##0.00",
        _s3_3 = "CHF",
        _s9_2 = "#,##,##0%",
        _s13_ = "\xa4\xa0#,##,##0.00",
        _s3_4 = "INR", _s1_9 = "\u2212",
        _s4_ = "\xd710^",
        _s5_ = "[#E0]",
        _s12_0 = "\xa4#,##,##0.00",
        _s24_ = "\u200f#,##0.00\xa0\xa4;\u200f-#,##0.00\xa0\xa4";
      return P.LinkedHashMap_LinkedHashMap$_literal(["af", B.NumberSymbols$(_s9_0, _s9_, _s1_, "ZAR", _s1_5, _s1_0, _s1_7, _s1_4, "af", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "am", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "ETB", _s1_5, _s1_, _s1_7, _s1_4, "am", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ar", B.NumberSymbols$(_s10_, _s9_, _s1_8, "EGP", _s1_5, _s1_, _s1_7, _s2_0, "ar", _s9_1, "\u200e%\u200e", _s6_, _s1_6, _s2_, _s3_0, _s1_2), "ar_DZ", B.NumberSymbols$(_s10_, _s9_, _s1_, "DZD", _s1_5, _s1_8, _s1_7, _s2_0, "ar_DZ", _s9_1, "\u200e%\u200e", _s6_, _s1_6, _s2_, _s3_0, _s1_2), "ar_EG", B.NumberSymbols$(_s10_0, _s9_, "\u066b", "EGP", "\u0627\u0633", "\u066c", _s1_7, "\u061c-", "ar_EG", "\u0644\u064a\u0633\xa0\u0631\u0642\u0645", "\u066a\u061c", _s6_, "\u0609", "\u061c+", _s3_0, "\u0660"), "az", B.NumberSymbols$(_s10_, _s9_, _s1_, "AZN", _s1_5, _s1_8, _s1_7, _s1_4, "az", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "be", B.NumberSymbols$(_s10_0, _s9_, _s1_, "BYN", _s1_5, _s1_0, _s1_7, _s1_4, "be", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "bg", B.NumberSymbols$("0.00\xa0\xa4", _s9_, _s1_, "BGN", _s1_5, _s1_0, _s1_7, _s1_4, "bg", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "bn", B.NumberSymbols$("#,##,##0.00\xa4", _s12_, _s1_8, "BDT", _s1_5, _s1_, _s1_7, _s1_4, "bn", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, "\u09e6"), "br", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_4, "br", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "bs", B.NumberSymbols$(_s10_0, _s9_, _s1_, "BAM", _s1_5, _s1_8, _s1_7, _s1_4, "bs", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "ca", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "ca", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "chr", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_2, _s1_5, _s1_, _s1_7, _s1_4, "chr", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "cs", B.NumberSymbols$(_s10_0, _s9_, _s1_, "CZK", _s1_5, _s1_0, _s1_7, _s1_4, "cs", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "cy", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "GBP", _s1_5, _s1_, _s1_7, _s1_4, "cy", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "da", B.NumberSymbols$(_s10_0, _s9_, _s1_, "DKK", _s1_5, _s1_8, _s1_7, _s1_4, "da", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "de", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "de", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "de_AT", B.NumberSymbols$(_s10_, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_4, "de_AT", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "de_CH", B.NumberSymbols$(_s21_, _s9_, _s1_8, _s3_3, _s1_5, "\u2019", _s1_7, _s1_4, "de_CH", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "el", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, "e", _s1_8, _s1_7, _s1_4, "el", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_2, _s1_5, _s1_, _s1_7, _s1_4, "en", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_AU", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "AUD", "e", _s1_, _s1_7, _s1_4, "en_AU", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_CA", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "CAD", "e", _s1_, _s1_7, _s1_4, "en_CA", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_GB", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "GBP", _s1_5, _s1_, _s1_7, _s1_4, "en_GB", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_IE", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_1, _s1_5, _s1_, _s1_7, _s1_4, "en_IE", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_IN", B.NumberSymbols$(_s13_, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "en_IN", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s3_0, _s1_2), "en_MY", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "MYR", _s1_5, _s1_, _s1_7, _s1_4, "en_MY", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_SG", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "SGD", _s1_5, _s1_, _s1_7, _s1_4, "en_SG", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_US", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_2, _s1_5, _s1_, _s1_7, _s1_4, "en_US", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "en_ZA", B.NumberSymbols$(_s9_0, _s9_, _s1_, "ZAR", _s1_5, _s1_0, _s1_7, _s1_4, "en_ZA", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "es", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "es", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "es_419", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "MXN", _s1_5, _s1_, _s1_7, _s1_4, "es_419", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "es_ES", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "es_ES", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "es_MX", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "MXN", _s1_5, _s1_, _s1_7, _s1_4, "es_MX", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "es_US", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_2, _s1_5, _s1_, _s1_7, _s1_4, "es_US", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "et", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s4_, _s1_0, _s1_7, _s1_9, "et", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "eu", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_9, "eu", _s3_, _s1_1, "%\xa0#,##0", _s1_6, _s1_3, _s3_0, _s1_2), "fa", B.NumberSymbols$("\u200e\xa4#,##0.00", _s9_, "\u066b", "IRR", "\xd7\u06f1\u06f0^", "\u066c", _s1_7, "\u200e\u2212", "fa", "\u0646\u0627\u0639\u062f\u062f", "\u066a", _s6_, "\u0609", _s2_, _s3_0, "\u06f0"), "fi", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_9, "fi", "ep\xe4luku", _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "fil", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "PHP", _s1_5, _s1_, _s1_7, _s1_4, "fil", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "fr", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_4, "fr", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "fr_CA", B.NumberSymbols$(_s10_0, _s9_, _s1_, "CAD", _s1_5, _s1_0, _s1_7, _s1_4, "fr_CA", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "fr_CH", B.NumberSymbols$("#,##0.00\xa0\xa4;-#,##0.00\xa0\xa4", _s9_, _s1_, _s3_3, _s1_5, _s1_0, _s1_7, _s1_4, "fr_CH", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ga", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_1, _s1_5, _s1_, _s1_7, _s1_4, "ga", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "gl", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "gl", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "gsw", B.NumberSymbols$(_s10_0, _s9_, _s1_8, _s3_3, _s1_5, "\u2019", _s1_7, _s1_9, "gsw", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "gu", B.NumberSymbols$(_s12_0, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "gu", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s5_, _s1_2), "haw", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_2, _s1_5, _s1_, _s1_7, _s1_4, "haw", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "he", B.NumberSymbols$(_s24_, _s9_, _s1_8, "ILS", _s1_5, _s1_, _s1_7, _s2_0, "he", _s3_, _s1_1, _s6_, _s1_6, _s2_, _s3_0, _s1_2), "hi", B.NumberSymbols$(_s12_0, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "hi", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s5_, _s1_2), "hr", B.NumberSymbols$(_s10_0, _s9_, _s1_, "HRK", _s1_5, _s1_8, _s1_7, _s1_4, "hr", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "hu", B.NumberSymbols$(_s10_0, _s9_, _s1_, "HUF", _s1_5, _s1_0, _s1_7, _s1_4, "hu", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "hy", B.NumberSymbols$(_s10_0, _s9_, _s1_, "AMD", _s1_5, _s1_0, _s1_7, _s1_4, "hy", "\u0548\u0579\u0539", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "id", B.NumberSymbols$(_s9_0, _s9_, _s1_, "IDR", _s1_5, _s1_8, _s1_7, _s1_4, "id", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "in", B.NumberSymbols$(_s9_0, _s9_, _s1_, "IDR", _s1_5, _s1_8, _s1_7, _s1_4, "in", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "is", B.NumberSymbols$(_s10_0, _s9_, _s1_, "ISK", _s1_5, _s1_8, _s1_7, _s1_4, "is", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "it", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "it", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "it_CH", B.NumberSymbols$(_s21_, _s9_, _s1_8, _s3_3, _s1_5, "\u2019", _s1_7, _s1_4, "it_CH", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "iw", B.NumberSymbols$(_s24_, _s9_, _s1_8, "ILS", _s1_5, _s1_, _s1_7, _s2_0, "iw", _s3_, _s1_1, _s6_, _s1_6, _s2_, _s3_0, _s1_2), "ja", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "JPY", _s1_5, _s1_, _s1_7, _s1_4, "ja", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ka", B.NumberSymbols$(_s10_0, _s9_, _s1_, "GEL", _s1_5, _s1_0, _s1_7, _s1_4, "ka", "\u10d0\u10e0\xa0\u10d0\u10e0\u10d8\u10e1\xa0\u10e0\u10d8\u10ea\u10ee\u10d5\u10d8", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "kk", B.NumberSymbols$(_s10_0, _s9_, _s1_, "KZT", _s1_5, _s1_0, _s1_7, _s1_4, "kk", "\u0441\u0430\u043d\xa0\u0435\u043c\u0435\u0441", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "km", B.NumberSymbols$("#,##0.00\xa4", _s9_, _s1_, "KHR", _s1_5, _s1_8, _s1_7, _s1_4, "km", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "kn", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "kn", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ko", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "KRW", _s1_5, _s1_, _s1_7, _s1_4, "ko", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ky", B.NumberSymbols$(_s10_0, _s9_, _s1_, "KGS", _s1_5, _s1_0, _s1_7, _s1_4, "ky", "\u0441\u0430\u043d\xa0\u044d\u043c\u0435\u0441", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ln", B.NumberSymbols$(_s10_0, _s9_, _s1_, "CDF", _s1_5, _s1_8, _s1_7, _s1_4, "ln", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "lo", B.NumberSymbols$("\xa4#,##0.00;\xa4-#,##0.00", _s9_, _s1_, "LAK", _s1_5, _s1_8, _s1_7, _s1_4, "lo", "\u0e9a\u0ecd\u0ec8\u200b\u0ec1\u0ea1\u0ec8\u0e99\u200b\u0ec2\u0e95\u200b\u0ec0\u0ea5\u0e81", _s1_1, _s6_, _s1_6, _s1_3, "#", _s1_2), "lt", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s4_, _s1_0, _s1_7, _s1_9, "lt", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "lv", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_4, "lv", "NS", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "mk", B.NumberSymbols$(_s10_0, _s9_, _s1_, "MKD", _s1_5, _s1_8, _s1_7, _s1_4, "mk", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ml", B.NumberSymbols$(_s9_0, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "ml", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "mn", B.NumberSymbols$(_s10_, _s9_, _s1_8, "MNT", _s1_5, _s1_, _s1_7, _s1_4, "mn", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "mr", B.NumberSymbols$(_s9_0, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "mr", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s5_, "\u0966"), "ms", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "MYR", _s1_5, _s1_, _s1_7, _s1_4, "ms", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "mt", B.NumberSymbols$(_s9_0, _s9_, _s1_8, _s3_1, _s1_5, _s1_, _s1_7, _s1_4, "mt", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "my", B.NumberSymbols$(_s10_0, _s9_, _s1_8, "MMK", _s1_5, _s1_, _s1_7, _s1_4, "my", "\u1002\u100f\u1014\u103a\u1038\u1019\u101f\u102f\u1010\u103a\u101e\u1031\u102c", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, "\u1040"), "nb", B.NumberSymbols$(_s10_, _s9_, _s1_, "NOK", _s1_5, _s1_0, _s1_7, _s1_9, "nb", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "ne", B.NumberSymbols$(_s10_, _s9_, _s1_8, "NPR", _s1_5, _s1_, _s1_7, _s1_4, "ne", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, "\u0966"), "nl", B.NumberSymbols$("\xa4\xa0#,##0.00;\xa4\xa0-#,##0.00", _s9_, _s1_, _s3_1, _s1_5, _s1_8, _s1_7, _s1_4, "nl", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "no", B.NumberSymbols$(_s10_, _s9_, _s1_, "NOK", _s1_5, _s1_0, _s1_7, _s1_9, "no", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "no_NO", B.NumberSymbols$(_s10_, _s9_, _s1_, "NOK", _s1_5, _s1_0, _s1_7, _s1_9, "no_NO", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "or", B.NumberSymbols$(_s13_, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "or", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s3_0, _s1_2), "pa", B.NumberSymbols$(_s13_, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "pa", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s5_, _s1_2), "pl", B.NumberSymbols$(_s10_0, _s9_, _s1_, "PLN", _s1_5, _s1_0, _s1_7, _s1_4, "pl", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ps", B.NumberSymbols$(_s10_0, _s9_, "\u066b", "AFN", "\xd7\u06f1\u06f0^", "\u066c", _s1_7, "\u200e-\u200e", "ps", _s3_, "\u066a", _s6_, "\u0609", "\u200e+\u200e", _s3_0, "\u06f0"), "pt", B.NumberSymbols$(_s10_, _s9_, _s1_, "BRL", _s1_5, _s1_8, _s1_7, _s1_4, "pt", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "pt_BR", B.NumberSymbols$(_s10_, _s9_, _s1_, "BRL", _s1_5, _s1_8, _s1_7, _s1_4, "pt_BR", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "pt_PT", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, _s1_5, _s1_0, _s1_7, _s1_4, "pt_PT", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ro", B.NumberSymbols$(_s10_0, _s9_, _s1_, "RON", _s1_5, _s1_8, _s1_7, _s1_4, "ro", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "ru", B.NumberSymbols$(_s10_0, _s9_, _s1_, "RUB", _s1_5, _s1_0, _s1_7, _s1_4, "ru", "\u043d\u0435\xa0\u0447\u0438\u0441\u043b\u043e", _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "si", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "LKR", _s1_5, _s1_, _s1_7, _s1_4, "si", _s3_, _s1_1, _s6_, _s1_6, _s1_3, "#", _s1_2), "sk", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, "e", _s1_0, _s1_7, _s1_4, "sk", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "sl", B.NumberSymbols$(_s10_0, _s9_, _s1_, _s3_1, "e", _s1_8, _s1_7, _s1_9, "sl", _s3_, _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "sq", B.NumberSymbols$(_s10_0, _s9_, _s1_, "ALL", _s1_5, _s1_0, _s1_7, _s1_4, "sq", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "sr", B.NumberSymbols$(_s10_0, _s9_, _s1_, "RSD", _s1_5, _s1_8, _s1_7, _s1_4, "sr", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "sr_Latn", B.NumberSymbols$(_s10_0, _s9_, _s1_, "RSD", _s1_5, _s1_8, _s1_7, _s1_4, "sr_Latn", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "sv", B.NumberSymbols$(_s10_0, _s9_, _s1_, "SEK", _s4_, _s1_0, _s1_7, _s1_9, "sv", "\xa4\xa4\xa4", _s1_1, _s7_, _s1_6, _s1_3, _s3_0, _s1_2), "sw", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "TZS", _s1_5, _s1_, _s1_7, _s1_4, "sw", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ta", B.NumberSymbols$(_s13_, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "ta", _s3_, _s1_1, _s9_2, _s1_6, _s1_3, _s3_0, _s1_2), "te", B.NumberSymbols$(_s12_0, _s12_, _s1_8, _s3_4, _s1_5, _s1_, _s1_7, _s1_4, "te", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "th", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "THB", _s1_5, _s1_, _s1_7, _s1_4, "th", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "tl", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "PHP", _s1_5, _s1_, _s1_7, _s1_4, "tl", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "tr", B.NumberSymbols$(_s9_0, _s9_, _s1_, "TRY", _s1_5, _s1_8, _s1_7, _s1_4, "tr", _s3_, _s1_1, "%#,##0", _s1_6, _s1_3, _s3_0, _s1_2), "uk", B.NumberSymbols$(_s10_0, _s9_, _s1_, "UAH", "\u0415", _s1_0, _s1_7, _s1_4, "uk", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "ur", B.NumberSymbols$(_s10_, _s9_, _s1_8, "PKR", _s1_5, _s1_, _s1_7, _s2_0, "ur", _s3_, _s1_1, _s6_, _s1_6, _s2_, _s3_0, _s1_2), "uz", B.NumberSymbols$(_s10_0, _s9_, _s1_, "UZS", _s1_5, _s1_0, _s1_7, _s1_4, "uz", "son\xa0emas", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "vi", B.NumberSymbols$(_s10_0, _s9_, _s1_, "VND", _s1_5, _s1_8, _s1_7, _s1_4, "vi", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "zh", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "CNY", _s1_5, _s1_, _s1_7, _s1_4, "zh", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "zh_CN", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "CNY", _s1_5, _s1_, _s1_7, _s1_4, "zh_CN", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "zh_HK", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "HKD", _s1_5, _s1_, _s1_7, _s1_4, "zh_HK", "\u975e\u6578\u503c", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "zh_TW", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "TWD", _s1_5, _s1_, _s1_7, _s1_4, "zh_TW", "\u975e\u6578\u503c", _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2), "zu", B.NumberSymbols$(_s9_0, _s9_, _s1_8, "ZAR", _s1_5, _s1_, _s1_7, _s1_4, "zu", _s3_, _s1_1, _s6_, _s1_6, _s1_3, _s3_0, _s1_2)], P.String, B.NumberSymbols);
    });
    _lazy($, "_dateTimeSymbols", "$get$_dateTimeSymbols", function() {
      return X.UninitializedLocaleData$("initializeDateFormatting(<locale>)", $.$get$en_USSymbols(), B.DateSymbols);
    });
    _lazy($, "dateTimePatterns", "$get$dateTimePatterns", function() {
      return X.UninitializedLocaleData$("initializeDateFormatting(<locale>)", C.Map_EQGBe, [P.Map, P.String, P.String]);
    });
    _lazy($, "context0", "$get$context0", function() {
      return new M.Context0($.$get$Style_platform());
    });
    _lazy($, "Style_posix", "$get$Style_posix", function() {
      return new E.PosixStyle(P.RegExp_RegExp("/"), P.RegExp_RegExp("[^/]$"), P.RegExp_RegExp("^/"));
    });
    _lazy($, "Style_windows", "$get$Style_windows", function() {
      return new L.WindowsStyle(P.RegExp_RegExp("[/\\\\]"), P.RegExp_RegExp("[^/\\\\]$"), P.RegExp_RegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])"), P.RegExp_RegExp("^[/\\\\](?![/\\\\])"));
    });
    _lazy($, "Style_url", "$get$Style_url", function() {
      return new F.UrlStyle(P.RegExp_RegExp("/"), P.RegExp_RegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$"), P.RegExp_RegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*"), P.RegExp_RegExp("^/"));
    });
    _lazy($, "Style_platform", "$get$Style_platform", function() {
      return O.Style__getPlatformStyle();
    });
    _lazy($, "Browser_UnknownBrowser", "$get$Browser_UnknownBrowser", function() {
      return L.Browser$("Unknown", null, null, null);
    });
    _lazy($, "Browser__knownBrowsers", "$get$Browser__knownBrowsers", function() {
      return H.setRuntimeTypeInfo([$.$get$chrome(), $.$get$firefox(), $.$get$safari(), $.$get$internetExplorer(), $.$get$wkWebView()], [L.Browser]);
    });
    _lazy($, "chrome", "$get$chrome", function() {
      return new L._Chrome("Chrome", L.browser__Chrome__isChrome$closure());
    });
    _lazy($, "firefox", "$get$firefox", function() {
      return new L._Firefox("Firefox", L.browser__Firefox__isFirefox$closure());
    });
    _lazy($, "safari", "$get$safari", function() {
      return new L._Safari("Safari", L.browser__Safari__isSafari$closure());
    });
    _lazy($, "internetExplorer", "$get$internetExplorer", function() {
      return new L._InternetExplorer("Internet Explorer", L.browser__InternetExplorer__isInternetExplorer$closure());
    });
    _lazy($, "wkWebView", "$get$wkWebView", function() {
      return new L._WKWebView("WKWebView", L.browser__WKWebView__isWKWebView$closure());
    });
    _lazy($, "_slashAutoEscape", "$get$_slashAutoEscape", function() {
      return P.RegExp_RegExp("/").pattern === "\\/";
    });
  })();
  (function nativeSupport() {
    !function() {
      var intern = function(s) {
        var o = {};
        o[s] = 1;
        return Object.keys(hunkHelpers.convertToFastObject(o))[0];
      };
      init.getIsolateTag = function(name) {
        return intern("___dart_" + name + init.isolateTag);
      };
      var tableProperty = "___dart_isolate_tags_";
      var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
      var rootProperty = "_ZxYxX";
      for (var i = 0;; i++) {
        var property = intern(rootProperty + "_" + i + "_");
        if (!(property in usedProperties)) {
          usedProperties[property] = 1;
          init.isolateTag = property;
          break;
        }
      }
      init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
    }();
    hunkHelpers.setOrUpdateInterceptorsByTag({AnimationEffectReadOnly: J.Interceptor, AnimationEffectTiming: J.Interceptor, AnimationEffectTimingReadOnly: J.Interceptor, AnimationTimeline: J.Interceptor, AnimationWorkletGlobalScope: J.Interceptor, AuthenticatorAssertionResponse: J.Interceptor, AuthenticatorAttestationResponse: J.Interceptor, AuthenticatorResponse: J.Interceptor, BackgroundFetchFetch: J.Interceptor, BackgroundFetchManager: J.Interceptor, BackgroundFetchSettledFetch: J.Interceptor, BarProp: J.Interceptor, BarcodeDetector: J.Interceptor, BudgetState: J.Interceptor, CacheStorage: J.Interceptor, CanvasGradient: J.Interceptor, CanvasPattern: J.Interceptor, Clients: J.Interceptor, CookieStore: J.Interceptor, Coordinates: J.Interceptor, CredentialsContainer: J.Interceptor, Crypto: J.Interceptor, CryptoKey: J.Interceptor, CSS: J.Interceptor, CSSVariableReferenceValue: J.Interceptor, CustomElementRegistry: J.Interceptor, DataTransfer: J.Interceptor, DeprecatedStorageInfo: J.Interceptor, DeprecatedStorageQuota: J.Interceptor, DetectedBarcode: J.Interceptor, DetectedFace: J.Interceptor, DetectedText: J.Interceptor, DeviceAcceleration: J.Interceptor, DeviceRotationRate: J.Interceptor, DirectoryReader: J.Interceptor, DocumentOrShadowRoot: J.Interceptor, DocumentTimeline: J.Interceptor, DOMImplementation: J.Interceptor, Iterator: J.Interceptor, DOMMatrix: J.Interceptor, DOMMatrixReadOnly: J.Interceptor, DOMParser: J.Interceptor, DOMPoint: J.Interceptor, DOMPointReadOnly: J.Interceptor, DOMQuad: J.Interceptor, DOMStringMap: J.Interceptor, External: J.Interceptor, FaceDetector: J.Interceptor, FontFaceSource: J.Interceptor, FormData: J.Interceptor, GamepadPose: J.Interceptor, Geolocation: J.Interceptor, Position: J.Interceptor, Headers: J.Interceptor, HTMLHyperlinkElementUtils: J.Interceptor, IdleDeadline: J.Interceptor, ImageBitmap: J.Interceptor, ImageBitmapRenderingContext: J.Interceptor, ImageCapture: J.Interceptor, InputDeviceCapabilities: J.Interceptor, IntersectionObserver: J.Interceptor, IntersectionObserverEntry: J.Interceptor, KeyframeEffect: J.Interceptor, KeyframeEffectReadOnly: J.Interceptor, MediaCapabilities: J.Interceptor, MediaCapabilitiesInfo: J.Interceptor, MediaKeyStatusMap: J.Interceptor, MediaKeySystemAccess: J.Interceptor, MediaKeys: J.Interceptor, MediaKeysPolicy: J.Interceptor, MediaMetadata: J.Interceptor, MediaSession: J.Interceptor, MediaSettingsRange: J.Interceptor, MemoryInfo: J.Interceptor, MessageChannel: J.Interceptor, Metadata: J.Interceptor, MutationObserver: J.Interceptor, WebKitMutationObserver: J.Interceptor, MutationRecord: J.Interceptor, NavigationPreloadManager: J.Interceptor, Navigator: J.Interceptor, NavigatorAutomationInformation: J.Interceptor, NavigatorConcurrentHardware: J.Interceptor, NavigatorCookies: J.Interceptor, NodeFilter: J.Interceptor, NodeIterator: J.Interceptor, NonDocumentTypeChildNode: J.Interceptor, NonElementParentNode: J.Interceptor, NoncedElement: J.Interceptor, OffscreenCanvasRenderingContext2D: J.Interceptor, PaintRenderingContext2D: J.Interceptor, PaintSize: J.Interceptor, PaintWorkletGlobalScope: J.Interceptor, Path2D: J.Interceptor, PaymentAddress: J.Interceptor, PaymentInstruments: J.Interceptor, PaymentManager: J.Interceptor, PaymentResponse: J.Interceptor, PerformanceNavigation: J.Interceptor, PerformanceObserver: J.Interceptor, PerformanceObserverEntryList: J.Interceptor, PerformanceTiming: J.Interceptor, Permissions: J.Interceptor, PhotoCapabilities: J.Interceptor, Presentation: J.Interceptor, PresentationReceiver: J.Interceptor, PushManager: J.Interceptor, PushSubscription: J.Interceptor, PushSubscriptionOptions: J.Interceptor, Range: J.Interceptor, ReportingObserver: J.Interceptor, RTCCertificate: J.Interceptor, RTCIceCandidate: J.Interceptor, mozRTCIceCandidate: J.Interceptor, RTCRtpContributingSource: J.Interceptor, RTCRtpReceiver: J.Interceptor, RTCRtpSender: J.Interceptor, RTCSessionDescription: J.Interceptor, mozRTCSessionDescription: J.Interceptor, RTCStatsResponse: J.Interceptor, Screen: J.Interceptor, ScrollState: J.Interceptor, ScrollTimeline: J.Interceptor, Selection: J.Interceptor, SharedArrayBuffer: J.Interceptor, SpeechRecognitionAlternative: J.Interceptor, StaticRange: J.Interceptor, StorageManager: J.Interceptor, StyleMedia: J.Interceptor, StylePropertyMap: J.Interceptor, StylePropertyMapReadonly: J.Interceptor, SyncManager: J.Interceptor, TextDetector: J.Interceptor, TextMetrics: J.Interceptor, TrackDefault: J.Interceptor, TreeWalker: J.Interceptor, TrustedHTML: J.Interceptor, TrustedScriptURL: J.Interceptor, TrustedURL: J.Interceptor, UnderlyingSourceBase: J.Interceptor, URLSearchParams: J.Interceptor, VRCoordinateSystem: J.Interceptor, VRDisplayCapabilities: J.Interceptor, VREyeParameters: J.Interceptor, VRFrameData: J.Interceptor, VRFrameOfReference: J.Interceptor, VRPose: J.Interceptor, VRStageBounds: J.Interceptor, VRStageBoundsPoint: J.Interceptor, VRStageParameters: J.Interceptor, ValidityState: J.Interceptor, VideoPlaybackQuality: J.Interceptor, WorkletAnimation: J.Interceptor, WorkletGlobalScope: J.Interceptor, XPathEvaluator: J.Interceptor, XPathExpression: J.Interceptor, XPathNSResolver: J.Interceptor, XPathResult: J.Interceptor, XMLSerializer: J.Interceptor, XSLTProcessor: J.Interceptor, Bluetooth: J.Interceptor, BluetoothCharacteristicProperties: J.Interceptor, BluetoothRemoteGATTServer: J.Interceptor, BluetoothRemoteGATTService: J.Interceptor, BluetoothUUID: J.Interceptor, BudgetService: J.Interceptor, Cache: J.Interceptor, DOMFileSystemSync: J.Interceptor, DirectoryEntrySync: J.Interceptor, DirectoryReaderSync: J.Interceptor, EntrySync: J.Interceptor, FileEntrySync: J.Interceptor, FileReaderSync: J.Interceptor, FileWriterSync: J.Interceptor, HTMLAllCollection: J.Interceptor, Mojo: J.Interceptor, MojoHandle: J.Interceptor, MojoWatcher: J.Interceptor, NFC: J.Interceptor, PagePopupController: J.Interceptor, Report: J.Interceptor, SubtleCrypto: J.Interceptor, USBAlternateInterface: J.Interceptor, USBConfiguration: J.Interceptor, USBDevice: J.Interceptor, USBEndpoint: J.Interceptor, USBInTransferResult: J.Interceptor, USBInterface: J.Interceptor, USBIsochronousInTransferPacket: J.Interceptor, USBIsochronousInTransferResult: J.Interceptor, USBIsochronousOutTransferPacket: J.Interceptor, USBIsochronousOutTransferResult: J.Interceptor, USBOutTransferResult: J.Interceptor, WorkerLocation: J.Interceptor, WorkerNavigator: J.Interceptor, Worklet: J.Interceptor, IDBFactory: J.Interceptor, IDBObserver: J.Interceptor, IDBObserverChanges: J.Interceptor, SVGAnimatedAngle: J.Interceptor, SVGAnimatedBoolean: J.Interceptor, SVGAnimatedEnumeration: J.Interceptor, SVGAnimatedInteger: J.Interceptor, SVGAnimatedLength: J.Interceptor, SVGAnimatedLengthList: J.Interceptor, SVGAnimatedNumber: J.Interceptor, SVGAnimatedNumberList: J.Interceptor, SVGAnimatedPreserveAspectRatio: J.Interceptor, SVGAnimatedRect: J.Interceptor, SVGAnimatedString: J.Interceptor, SVGAnimatedTransformList: J.Interceptor, SVGMatrix: J.Interceptor, SVGPoint: J.Interceptor, SVGPreserveAspectRatio: J.Interceptor, SVGRect: J.Interceptor, SVGUnitTypes: J.Interceptor, AudioListener: J.Interceptor, AudioWorkletGlobalScope: J.Interceptor, AudioWorkletProcessor: J.Interceptor, PeriodicWave: J.Interceptor, ANGLEInstancedArrays: J.Interceptor, ANGLE_instanced_arrays: J.Interceptor, WebGLBuffer: J.Interceptor, WebGLCanvas: J.Interceptor, WebGLColorBufferFloat: J.Interceptor, WebGLCompressedTextureASTC: J.Interceptor, WebGLCompressedTextureATC: J.Interceptor, WEBGL_compressed_texture_atc: J.Interceptor, WebGLCompressedTextureETC1: J.Interceptor, WEBGL_compressed_texture_etc1: J.Interceptor, WebGLCompressedTextureETC: J.Interceptor, WebGLCompressedTexturePVRTC: J.Interceptor, WEBGL_compressed_texture_pvrtc: J.Interceptor, WebGLCompressedTextureS3TC: J.Interceptor, WEBGL_compressed_texture_s3tc: J.Interceptor, WebGLCompressedTextureS3TCsRGB: J.Interceptor, WebGLDebugRendererInfo: J.Interceptor, WEBGL_debug_renderer_info: J.Interceptor, WebGLDebugShaders: J.Interceptor, WEBGL_debug_shaders: J.Interceptor, WebGLDepthTexture: J.Interceptor, WEBGL_depth_texture: J.Interceptor, WebGLDrawBuffers: J.Interceptor, WEBGL_draw_buffers: J.Interceptor, EXTsRGB: J.Interceptor, EXT_sRGB: J.Interceptor, EXTBlendMinMax: J.Interceptor, EXT_blend_minmax: J.Interceptor, EXTColorBufferFloat: J.Interceptor, EXTColorBufferHalfFloat: J.Interceptor, EXTDisjointTimerQuery: J.Interceptor, EXTDisjointTimerQueryWebGL2: J.Interceptor, EXTFragDepth: J.Interceptor, EXT_frag_depth: J.Interceptor, EXTShaderTextureLOD: J.Interceptor, EXT_shader_texture_lod: J.Interceptor, EXTTextureFilterAnisotropic: J.Interceptor, EXT_texture_filter_anisotropic: J.Interceptor, WebGLFramebuffer: J.Interceptor, WebGLGetBufferSubDataAsync: J.Interceptor, WebGLLoseContext: J.Interceptor, WebGLExtensionLoseContext: J.Interceptor, WEBGL_lose_context: J.Interceptor, OESElementIndexUint: J.Interceptor, OES_element_index_uint: J.Interceptor, OESStandardDerivatives: J.Interceptor, OES_standard_derivatives: J.Interceptor, OESTextureFloat: J.Interceptor, OES_texture_float: J.Interceptor, OESTextureFloatLinear: J.Interceptor, OES_texture_float_linear: J.Interceptor, OESTextureHalfFloat: J.Interceptor, OES_texture_half_float: J.Interceptor, OESTextureHalfFloatLinear: J.Interceptor, OES_texture_half_float_linear: J.Interceptor, OESVertexArrayObject: J.Interceptor, OES_vertex_array_object: J.Interceptor, WebGLProgram: J.Interceptor, WebGLQuery: J.Interceptor, WebGLRenderbuffer: J.Interceptor, WebGLRenderingContext: J.Interceptor, WebGL2RenderingContext: J.Interceptor, WebGLSampler: J.Interceptor, WebGLShader: J.Interceptor, WebGLShaderPrecisionFormat: J.Interceptor, WebGLSync: J.Interceptor, WebGLTexture: J.Interceptor, WebGLTimerQueryEXT: J.Interceptor, WebGLTransformFeedback: J.Interceptor, WebGLUniformLocation: J.Interceptor, WebGLVertexArrayObject: J.Interceptor, WebGLVertexArrayObjectOES: J.Interceptor, WebGL: J.Interceptor, WebGL2RenderingContextBase: J.Interceptor, Database: J.Interceptor, SQLResultSet: J.Interceptor, SQLTransaction: J.Interceptor, ArrayBuffer: H.NativeByteBuffer, ArrayBufferView: H.NativeTypedData, DataView: H.NativeByteData, Float32Array: H.NativeFloat32List, Float64Array: H.NativeFloat64List, Int16Array: H.NativeInt16List, Int32Array: H.NativeInt32List, Int8Array: H.NativeInt8List, Uint16Array: H.NativeUint16List, Uint32Array: H.NativeUint32List, Uint8ClampedArray: H.NativeUint8ClampedList, CanvasPixelArray: H.NativeUint8ClampedList, Uint8Array: H.NativeUint8List, HTMLBRElement: W.HtmlElement, HTMLContentElement: W.HtmlElement, HTMLDListElement: W.HtmlElement, HTMLDataListElement: W.HtmlElement, HTMLDetailsElement: W.HtmlElement, HTMLDialogElement: W.HtmlElement, HTMLHRElement: W.HtmlElement, HTMLHeadElement: W.HtmlElement, HTMLHeadingElement: W.HtmlElement, HTMLHtmlElement: W.HtmlElement, HTMLLabelElement: W.HtmlElement, HTMLLegendElement: W.HtmlElement, HTMLLinkElement: W.HtmlElement, HTMLMenuElement: W.HtmlElement, HTMLModElement: W.HtmlElement, HTMLOListElement: W.HtmlElement, HTMLOptGroupElement: W.HtmlElement, HTMLParagraphElement: W.HtmlElement, HTMLPictureElement: W.HtmlElement, HTMLPreElement: W.HtmlElement, HTMLQuoteElement: W.HtmlElement, HTMLScriptElement: W.HtmlElement, HTMLShadowElement: W.HtmlElement, HTMLSourceElement: W.HtmlElement, HTMLSpanElement: W.HtmlElement, HTMLStyleElement: W.HtmlElement, HTMLTableCaptionElement: W.HtmlElement, HTMLTableCellElement: W.HtmlElement, HTMLTableDataCellElement: W.HtmlElement, HTMLTableHeaderCellElement: W.HtmlElement, HTMLTableColElement: W.HtmlElement, HTMLTimeElement: W.HtmlElement, HTMLTitleElement: W.HtmlElement, HTMLUListElement: W.HtmlElement, HTMLUnknownElement: W.HtmlElement, HTMLDirectoryElement: W.HtmlElement, HTMLFontElement: W.HtmlElement, HTMLFrameElement: W.HtmlElement, HTMLFrameSetElement: W.HtmlElement, HTMLMarqueeElement: W.HtmlElement, HTMLElement: W.HtmlElement, AccessibleNodeList: W.AccessibleNodeList, HTMLAnchorElement: W.AnchorElement, Animation: W.Animation, ApplicationCacheErrorEvent: W.ApplicationCacheErrorEvent, HTMLAreaElement: W.AreaElement, BackgroundFetchClickEvent: W.BackgroundFetchEvent, BackgroundFetchEvent: W.BackgroundFetchEvent, BackgroundFetchFailEvent: W.BackgroundFetchEvent, BackgroundFetchedEvent: W.BackgroundFetchEvent, BackgroundFetchRegistration: W.BackgroundFetchRegistration, HTMLBaseElement: W.BaseElement, Blob: W.Blob, BluetoothRemoteGATTDescriptor: W.BluetoothRemoteGattDescriptor, Body: W.Body, Request: W.Body, Response: W.Body, HTMLBodyElement: W.BodyElement, BroadcastChannel: W.BroadcastChannel, HTMLButtonElement: W.ButtonElement, HTMLCanvasElement: W.CanvasElement, CanvasRenderingContext2D: W.CanvasRenderingContext2D, CDATASection: W.CharacterData, CharacterData: W.CharacterData, Comment: W.CharacterData, ProcessingInstruction: W.CharacterData, Text: W.CharacterData, Client: W.Client0, WindowClient: W.Client0, CloseEvent: W.CloseEvent, PublicKeyCredential: W.Credential, Credential: W.Credential, CredentialUserData: W.CredentialUserData, CSSKeyframesRule: W.CssKeyframesRule, MozCSSKeyframesRule: W.CssKeyframesRule, WebKitCSSKeyframesRule: W.CssKeyframesRule, CSSKeywordValue: W.CssKeywordValue, CSSNumericValue: W.CssNumericValue, CSSPerspective: W.CssPerspective, CSSCharsetRule: W.CssRule, CSSConditionRule: W.CssRule, CSSFontFaceRule: W.CssRule, CSSGroupingRule: W.CssRule, CSSImportRule: W.CssRule, CSSKeyframeRule: W.CssRule, MozCSSKeyframeRule: W.CssRule, WebKitCSSKeyframeRule: W.CssRule, CSSMediaRule: W.CssRule, CSSNamespaceRule: W.CssRule, CSSPageRule: W.CssRule, CSSStyleRule: W.CssRule, CSSSupportsRule: W.CssRule, CSSViewportRule: W.CssRule, CSSRule: W.CssRule, CSSStyleDeclaration: W.CssStyleDeclaration, MSStyleCSSProperties: W.CssStyleDeclaration, CSS2Properties: W.CssStyleDeclaration, CSSImageValue: W.CssStyleValue, CSSPositionValue: W.CssStyleValue, CSSResourceValue: W.CssStyleValue, CSSURLImageValue: W.CssStyleValue, CSSStyleValue: W.CssStyleValue, CSSMatrixComponent: W.CssTransformComponent, CSSRotation: W.CssTransformComponent, CSSScale: W.CssTransformComponent, CSSSkew: W.CssTransformComponent, CSSTranslation: W.CssTransformComponent, CSSTransformComponent: W.CssTransformComponent, CSSTransformValue: W.CssTransformValue, CSSUnitValue: W.CssUnitValue, CSSUnparsedValue: W.CssUnparsedValue, HTMLDataElement: W.DataElement, DataTransferItem: W.DataTransferItem, DataTransferItemList: W.DataTransferItemList, DeprecationReport: W.DeprecationReport, HTMLDivElement: W.DivElement, Document: W.Document, HTMLDocument: W.Document, XMLDocument: W.Document, DOMError: W.DomError, DOMException: W.DomException, ClientRectList: W.DomRectList, DOMRectList: W.DomRectList, DOMRectReadOnly: W.DomRectReadOnly, DOMStringList: W.DomStringList, DOMTokenList: W.DomTokenList, Element: W.Element, HTMLEmbedElement: W.EmbedElement, DirectoryEntry: W.Entry, Entry: W.Entry, FileEntry: W.Entry, ErrorEvent: W.ErrorEvent, AnimationEvent: W.Event, AnimationPlaybackEvent: W.Event, BeforeInstallPromptEvent: W.Event, BeforeUnloadEvent: W.Event, BlobEvent: W.Event, ClipboardEvent: W.Event, CustomEvent: W.Event, DeviceMotionEvent: W.Event, DeviceOrientationEvent: W.Event, FontFaceSetLoadEvent: W.Event, GamepadEvent: W.Event, HashChangeEvent: W.Event, MediaEncryptedEvent: W.Event, MediaQueryListEvent: W.Event, MediaStreamEvent: W.Event, MediaStreamTrackEvent: W.Event, MIDIConnectionEvent: W.Event, MIDIMessageEvent: W.Event, MutationEvent: W.Event, PageTransitionEvent: W.Event, PaymentRequestUpdateEvent: W.Event, PresentationConnectionAvailableEvent: W.Event, PromiseRejectionEvent: W.Event, RTCDataChannelEvent: W.Event, RTCDTMFToneChangeEvent: W.Event, RTCPeerConnectionIceEvent: W.Event, RTCTrackEvent: W.Event, SecurityPolicyViolationEvent: W.Event, SensorErrorEvent: W.Event, SpeechRecognitionEvent: W.Event, TrackEvent: W.Event, TransitionEvent: W.Event, WebKitTransitionEvent: W.Event, VRDeviceEvent: W.Event, VRDisplayEvent: W.Event, VRSessionEvent: W.Event, MojoInterfaceRequestEvent: W.Event, USBConnectionEvent: W.Event, IDBVersionChangeEvent: W.Event, AudioProcessingEvent: W.Event, OfflineAudioCompletionEvent: W.Event, WebGLContextEvent: W.Event, Event: W.Event, InputEvent: W.Event, AbsoluteOrientationSensor: W.EventTarget, Accelerometer: W.EventTarget, AccessibleNode: W.EventTarget, AmbientLightSensor: W.EventTarget, ApplicationCache: W.EventTarget, DOMApplicationCache: W.EventTarget, OfflineResourceList: W.EventTarget, BatteryManager: W.EventTarget, EventSource: W.EventTarget, FontFaceSet: W.EventTarget, Gyroscope: W.EventTarget, LinearAccelerationSensor: W.EventTarget, Magnetometer: W.EventTarget, MediaDevices: W.EventTarget, MediaQueryList: W.EventTarget, MediaRecorder: W.EventTarget, MediaSource: W.EventTarget, MIDIAccess: W.EventTarget, NetworkInformation: W.EventTarget, Notification: W.EventTarget, OffscreenCanvas: W.EventTarget, OrientationSensor: W.EventTarget, Performance: W.EventTarget, PermissionStatus: W.EventTarget, PresentationConnectionList: W.EventTarget, PresentationRequest: W.EventTarget, RelativeOrientationSensor: W.EventTarget, RemotePlayback: W.EventTarget, RTCDTMFSender: W.EventTarget, RTCPeerConnection: W.EventTarget, webkitRTCPeerConnection: W.EventTarget, mozRTCPeerConnection: W.EventTarget, ScreenOrientation: W.EventTarget, Sensor: W.EventTarget, ServiceWorker: W.EventTarget, ServiceWorkerContainer: W.EventTarget, ServiceWorkerRegistration: W.EventTarget, SharedWorker: W.EventTarget, SpeechRecognition: W.EventTarget, SpeechSynthesis: W.EventTarget, SpeechSynthesisUtterance: W.EventTarget, VR: W.EventTarget, VRDevice: W.EventTarget, VRDisplay: W.EventTarget, VRSession: W.EventTarget, VisualViewport: W.EventTarget, WebSocket: W.EventTarget, Worker: W.EventTarget, WorkerPerformance: W.EventTarget, BluetoothDevice: W.EventTarget, BluetoothRemoteGATTCharacteristic: W.EventTarget, Clipboard: W.EventTarget, MojoInterfaceInterceptor: W.EventTarget, USB: W.EventTarget, IDBOpenDBRequest: W.EventTarget, IDBVersionChangeRequest: W.EventTarget, IDBRequest: W.EventTarget, IDBTransaction: W.EventTarget, AnalyserNode: W.EventTarget, RealtimeAnalyserNode: W.EventTarget, AudioBufferSourceNode: W.EventTarget, AudioDestinationNode: W.EventTarget, AudioNode: W.EventTarget, AudioScheduledSourceNode: W.EventTarget, AudioWorkletNode: W.EventTarget, BiquadFilterNode: W.EventTarget, ChannelMergerNode: W.EventTarget, AudioChannelMerger: W.EventTarget, ChannelSplitterNode: W.EventTarget, AudioChannelSplitter: W.EventTarget, ConstantSourceNode: W.EventTarget, ConvolverNode: W.EventTarget, DelayNode: W.EventTarget, DynamicsCompressorNode: W.EventTarget, GainNode: W.EventTarget, AudioGainNode: W.EventTarget, IIRFilterNode: W.EventTarget, MediaElementAudioSourceNode: W.EventTarget, MediaStreamAudioDestinationNode: W.EventTarget, MediaStreamAudioSourceNode: W.EventTarget, OscillatorNode: W.EventTarget, Oscillator: W.EventTarget, PannerNode: W.EventTarget, AudioPannerNode: W.EventTarget, webkitAudioPannerNode: W.EventTarget, ScriptProcessorNode: W.EventTarget, JavaScriptAudioNode: W.EventTarget, StereoPannerNode: W.EventTarget, WaveShaperNode: W.EventTarget, EventTarget: W.EventTarget, AbortPaymentEvent: W.ExtendableEvent, CanMakePaymentEvent: W.ExtendableEvent, ExtendableMessageEvent: W.ExtendableEvent, FetchEvent: W.ExtendableEvent, ForeignFetchEvent: W.ExtendableEvent, InstallEvent: W.ExtendableEvent, NotificationEvent: W.ExtendableEvent, PaymentRequestEvent: W.ExtendableEvent, PushEvent: W.ExtendableEvent, SyncEvent: W.ExtendableEvent, ExtendableEvent: W.ExtendableEvent, FederatedCredential: W.FederatedCredential, HTMLFieldSetElement: W.FieldSetElement, File: W.File, FileList: W.FileList, FileReader: W.FileReader, DOMFileSystem: W.FileSystem, FileWriter: W.FileWriter, FontFace: W.FontFace, HTMLFormElement: W.FormElement, Gamepad: W.Gamepad, GamepadButton: W.GamepadButton, History: W.History, HTMLCollection: W.HtmlCollection, HTMLFormControlsCollection: W.HtmlCollection, HTMLOptionsCollection: W.HtmlCollection, XMLHttpRequest: W.HttpRequest, XMLHttpRequestUpload: W.HttpRequestEventTarget, XMLHttpRequestEventTarget: W.HttpRequestEventTarget, HTMLIFrameElement: W.IFrameElement, ImageData: W.ImageData, HTMLImageElement: W.ImageElement, HTMLInputElement: W.InputElement, InterventionReport: W.InterventionReport, KeyboardEvent: W.KeyboardEvent, HTMLLIElement: W.LIElement, Location: W.Location, HTMLMapElement: W.MapElement, MediaDeviceInfo: W.MediaDeviceInfo, HTMLAudioElement: W.MediaElement, HTMLMediaElement: W.MediaElement, MediaError: W.MediaError, MediaKeyMessageEvent: W.MediaKeyMessageEvent, MediaKeySession: W.MediaKeySession, MediaList: W.MediaList, MediaStream: W.MediaStream, CanvasCaptureMediaStreamTrack: W.MediaStreamTrack, MediaStreamTrack: W.MediaStreamTrack, MessageEvent: W.MessageEvent, MessagePort: W.MessagePort, HTMLMetaElement: W.MetaElement, HTMLMeterElement: W.MeterElement, MIDIInputMap: W.MidiInputMap, MIDIOutputMap: W.MidiOutputMap, MIDIInput: W.MidiPort, MIDIOutput: W.MidiPort, MIDIPort: W.MidiPort, MimeType: W.MimeType, MimeTypeArray: W.MimeTypeArray, PointerEvent: W.MouseEvent, MouseEvent: W.MouseEvent, DragEvent: W.MouseEvent, NavigatorUserMediaError: W.NavigatorUserMediaError, DocumentFragment: W.Node, ShadowRoot: W.Node, DocumentType: W.Node, Node: W.Node, NodeList: W.NodeList, RadioNodeList: W.NodeList, HTMLObjectElement: W.ObjectElement, HTMLOptionElement: W.OptionElement, HTMLOutputElement: W.OutputElement, OverconstrainedError: W.OverconstrainedError, HTMLParamElement: W.ParamElement, PasswordCredential: W.PasswordCredential, PaymentRequest: W.PaymentRequest, PerformanceEntry: W.PerformanceEntry, PerformanceLongTaskTiming: W.PerformanceEntry, PerformanceMark: W.PerformanceEntry, PerformanceMeasure: W.PerformanceEntry, PerformanceNavigationTiming: W.PerformanceEntry, PerformancePaintTiming: W.PerformanceEntry, PerformanceResourceTiming: W.PerformanceEntry, TaskAttributionTiming: W.PerformanceEntry, PerformanceServerTiming: W.PerformanceServerTiming, Plugin: W.Plugin, PluginArray: W.PluginArray, PopStateEvent: W.PopStateEvent, PositionError: W.PositionError, PresentationAvailability: W.PresentationAvailability, PresentationConnection: W.PresentationConnection, PresentationConnectionCloseEvent: W.PresentationConnectionCloseEvent, HTMLProgressElement: W.ProgressElement0, ProgressEvent: W.ProgressEvent, ResourceProgressEvent: W.ProgressEvent, PushMessageData: W.PushMessageData, RelatedApplication: W.RelatedApplication, ReportBody: W.ReportBody, ResizeObserver: W.ResizeObserver, ResizeObserverEntry: W.ResizeObserverEntry, RTCDataChannel: W.RtcDataChannel, DataChannel: W.RtcDataChannel, RTCLegacyStatsReport: W.RtcLegacyStatsReport, RTCStatsReport: W.RtcStatsReport, HTMLSelectElement: W.SelectElement, SharedWorkerGlobalScope: W.SharedWorkerGlobalScope, HTMLSlotElement: W.SlotElement, SourceBuffer: W.SourceBuffer, SourceBufferList: W.SourceBufferList, SpeechGrammar: W.SpeechGrammar, SpeechGrammarList: W.SpeechGrammarList, SpeechRecognitionError: W.SpeechRecognitionError, SpeechRecognitionResult: W.SpeechRecognitionResult, SpeechSynthesisEvent: W.SpeechSynthesisEvent, SpeechSynthesisVoice: W.SpeechSynthesisVoice, Storage: W.Storage, StorageEvent: W.StorageEvent, CSSStyleSheet: W.StyleSheet, StyleSheet: W.StyleSheet, HTMLTableElement: W.TableElement, HTMLTableRowElement: W.TableRowElement, HTMLTableSectionElement: W.TableSectionElement, HTMLTemplateElement: W.TemplateElement, HTMLTextAreaElement: W.TextAreaElement, TextTrack: W.TextTrack, TextTrackCue: W.TextTrackCue, VTTCue: W.TextTrackCue, TextTrackCueList: W.TextTrackCueList, TextTrackList: W.TextTrackList, TimeRanges: W.TimeRanges, Touch: W.Touch, TouchList: W.TouchList, TrackDefaultList: W.TrackDefaultList, HTMLTrackElement: W.TrackElement, CompositionEvent: W.UIEvent, FocusEvent: W.UIEvent, TextEvent: W.UIEvent, TouchEvent: W.UIEvent, UIEvent: W.UIEvent, URL: W.Url, HTMLVideoElement: W.VideoElement, VideoTrack: W.VideoTrack, VideoTrackList: W.VideoTrackList, VTTRegion: W.VttRegion, WheelEvent: W.WheelEvent, Window: W.Window, DOMWindow: W.Window, DedicatedWorkerGlobalScope: W.WorkerGlobalScope, ServiceWorkerGlobalScope: W.WorkerGlobalScope, WorkerGlobalScope: W.WorkerGlobalScope, Attr: W._Attr, CSSRuleList: W._CssRuleList, ClientRect: W._DomRect, DOMRect: W._DomRect, GamepadList: W._GamepadList, NamedNodeMap: W._NamedNodeMap, MozNamedAttrMap: W._NamedNodeMap, SpeechRecognitionResultList: W._SpeechRecognitionResultList, StyleSheetList: W._StyleSheetList, IDBCursor: P.Cursor, IDBCursorWithValue: P.CursorWithValue, IDBDatabase: P.Database, IDBIndex: P.Index, IDBKeyRange: P.KeyRange, IDBObjectStore: P.ObjectStore, IDBObservation: P.Observation, SVGAngle: P.Angle, SVGLength: P.Length, SVGLengthList: P.LengthList, SVGNumber: P.Number, SVGNumberList: P.NumberList, SVGPointList: P.PointList, SVGScriptElement: P.ScriptElement, SVGStringList: P.StringList, SVGAElement: P.SvgElement, SVGAnimateElement: P.SvgElement, SVGAnimateMotionElement: P.SvgElement, SVGAnimateTransformElement: P.SvgElement, SVGAnimationElement: P.SvgElement, SVGCircleElement: P.SvgElement, SVGClipPathElement: P.SvgElement, SVGDefsElement: P.SvgElement, SVGDescElement: P.SvgElement, SVGDiscardElement: P.SvgElement, SVGEllipseElement: P.SvgElement, SVGFEBlendElement: P.SvgElement, SVGFEColorMatrixElement: P.SvgElement, SVGFEComponentTransferElement: P.SvgElement, SVGFECompositeElement: P.SvgElement, SVGFEConvolveMatrixElement: P.SvgElement, SVGFEDiffuseLightingElement: P.SvgElement, SVGFEDisplacementMapElement: P.SvgElement, SVGFEDistantLightElement: P.SvgElement, SVGFEFloodElement: P.SvgElement, SVGFEFuncAElement: P.SvgElement, SVGFEFuncBElement: P.SvgElement, SVGFEFuncGElement: P.SvgElement, SVGFEFuncRElement: P.SvgElement, SVGFEGaussianBlurElement: P.SvgElement, SVGFEImageElement: P.SvgElement, SVGFEMergeElement: P.SvgElement, SVGFEMergeNodeElement: P.SvgElement, SVGFEMorphologyElement: P.SvgElement, SVGFEOffsetElement: P.SvgElement, SVGFEPointLightElement: P.SvgElement, SVGFESpecularLightingElement: P.SvgElement, SVGFESpotLightElement: P.SvgElement, SVGFETileElement: P.SvgElement, SVGFETurbulenceElement: P.SvgElement, SVGFilterElement: P.SvgElement, SVGForeignObjectElement: P.SvgElement, SVGGElement: P.SvgElement, SVGGeometryElement: P.SvgElement, SVGGraphicsElement: P.SvgElement, SVGImageElement: P.SvgElement, SVGLineElement: P.SvgElement, SVGLinearGradientElement: P.SvgElement, SVGMarkerElement: P.SvgElement, SVGMaskElement: P.SvgElement, SVGMetadataElement: P.SvgElement, SVGPathElement: P.SvgElement, SVGPatternElement: P.SvgElement, SVGPolygonElement: P.SvgElement, SVGPolylineElement: P.SvgElement, SVGRadialGradientElement: P.SvgElement, SVGRectElement: P.SvgElement, SVGSetElement: P.SvgElement, SVGStopElement: P.SvgElement, SVGStyleElement: P.SvgElement, SVGSVGElement: P.SvgElement, SVGSwitchElement: P.SvgElement, SVGSymbolElement: P.SvgElement, SVGTSpanElement: P.SvgElement, SVGTextContentElement: P.SvgElement, SVGTextElement: P.SvgElement, SVGTextPathElement: P.SvgElement, SVGTextPositioningElement: P.SvgElement, SVGTitleElement: P.SvgElement, SVGUseElement: P.SvgElement, SVGViewElement: P.SvgElement, SVGGradientElement: P.SvgElement, SVGComponentTransferFunctionElement: P.SvgElement, SVGFEDropShadowElement: P.SvgElement, SVGMPathElement: P.SvgElement, SVGElement: P.SvgElement, SVGTransform: P.Transform, SVGTransformList: P.TransformList, AudioBuffer: P.AudioBuffer, AudioParam: P.AudioParam, AudioParamMap: P.AudioParamMap, AudioTrack: P.AudioTrack, AudioTrackList: P.AudioTrackList, AudioContext: P.BaseAudioContext, webkitAudioContext: P.BaseAudioContext, BaseAudioContext: P.BaseAudioContext, OfflineAudioContext: P.OfflineAudioContext, WebGLActiveInfo: P.ActiveInfo, SQLError: P.SqlError, SQLResultSetRowList: P.SqlResultSetRowList});
    hunkHelpers.setOrUpdateLeafTags({AnimationEffectReadOnly: true, AnimationEffectTiming: true, AnimationEffectTimingReadOnly: true, AnimationTimeline: true, AnimationWorkletGlobalScope: true, AuthenticatorAssertionResponse: true, AuthenticatorAttestationResponse: true, AuthenticatorResponse: true, BackgroundFetchFetch: true, BackgroundFetchManager: true, BackgroundFetchSettledFetch: true, BarProp: true, BarcodeDetector: true, BudgetState: true, CacheStorage: true, CanvasGradient: true, CanvasPattern: true, Clients: true, CookieStore: true, Coordinates: true, CredentialsContainer: true, Crypto: true, CryptoKey: true, CSS: true, CSSVariableReferenceValue: true, CustomElementRegistry: true, DataTransfer: true, DeprecatedStorageInfo: true, DeprecatedStorageQuota: true, DetectedBarcode: true, DetectedFace: true, DetectedText: true, DeviceAcceleration: true, DeviceRotationRate: true, DirectoryReader: true, DocumentOrShadowRoot: true, DocumentTimeline: true, DOMImplementation: true, Iterator: true, DOMMatrix: true, DOMMatrixReadOnly: true, DOMParser: true, DOMPoint: true, DOMPointReadOnly: true, DOMQuad: true, DOMStringMap: true, External: true, FaceDetector: true, FontFaceSource: true, FormData: true, GamepadPose: true, Geolocation: true, Position: true, Headers: true, HTMLHyperlinkElementUtils: true, IdleDeadline: true, ImageBitmap: true, ImageBitmapRenderingContext: true, ImageCapture: true, InputDeviceCapabilities: true, IntersectionObserver: true, IntersectionObserverEntry: true, KeyframeEffect: true, KeyframeEffectReadOnly: true, MediaCapabilities: true, MediaCapabilitiesInfo: true, MediaKeyStatusMap: true, MediaKeySystemAccess: true, MediaKeys: true, MediaKeysPolicy: true, MediaMetadata: true, MediaSession: true, MediaSettingsRange: true, MemoryInfo: true, MessageChannel: true, Metadata: true, MutationObserver: true, WebKitMutationObserver: true, MutationRecord: true, NavigationPreloadManager: true, Navigator: true, NavigatorAutomationInformation: true, NavigatorConcurrentHardware: true, NavigatorCookies: true, NodeFilter: true, NodeIterator: true, NonDocumentTypeChildNode: true, NonElementParentNode: true, NoncedElement: true, OffscreenCanvasRenderingContext2D: true, PaintRenderingContext2D: true, PaintSize: true, PaintWorkletGlobalScope: true, Path2D: true, PaymentAddress: true, PaymentInstruments: true, PaymentManager: true, PaymentResponse: true, PerformanceNavigation: true, PerformanceObserver: true, PerformanceObserverEntryList: true, PerformanceTiming: true, Permissions: true, PhotoCapabilities: true, Presentation: true, PresentationReceiver: true, PushManager: true, PushSubscription: true, PushSubscriptionOptions: true, Range: true, ReportingObserver: true, RTCCertificate: true, RTCIceCandidate: true, mozRTCIceCandidate: true, RTCRtpContributingSource: true, RTCRtpReceiver: true, RTCRtpSender: true, RTCSessionDescription: true, mozRTCSessionDescription: true, RTCStatsResponse: true, Screen: true, ScrollState: true, ScrollTimeline: true, Selection: true, SharedArrayBuffer: true, SpeechRecognitionAlternative: true, StaticRange: true, StorageManager: true, StyleMedia: true, StylePropertyMap: true, StylePropertyMapReadonly: true, SyncManager: true, TextDetector: true, TextMetrics: true, TrackDefault: true, TreeWalker: true, TrustedHTML: true, TrustedScriptURL: true, TrustedURL: true, UnderlyingSourceBase: true, URLSearchParams: true, VRCoordinateSystem: true, VRDisplayCapabilities: true, VREyeParameters: true, VRFrameData: true, VRFrameOfReference: true, VRPose: true, VRStageBounds: true, VRStageBoundsPoint: true, VRStageParameters: true, ValidityState: true, VideoPlaybackQuality: true, WorkletAnimation: true, WorkletGlobalScope: true, XPathEvaluator: true, XPathExpression: true, XPathNSResolver: true, XPathResult: true, XMLSerializer: true, XSLTProcessor: true, Bluetooth: true, BluetoothCharacteristicProperties: true, BluetoothRemoteGATTServer: true, BluetoothRemoteGATTService: true, BluetoothUUID: true, BudgetService: true, Cache: true, DOMFileSystemSync: true, DirectoryEntrySync: true, DirectoryReaderSync: true, EntrySync: true, FileEntrySync: true, FileReaderSync: true, FileWriterSync: true, HTMLAllCollection: true, Mojo: true, MojoHandle: true, MojoWatcher: true, NFC: true, PagePopupController: true, Report: true, SubtleCrypto: true, USBAlternateInterface: true, USBConfiguration: true, USBDevice: true, USBEndpoint: true, USBInTransferResult: true, USBInterface: true, USBIsochronousInTransferPacket: true, USBIsochronousInTransferResult: true, USBIsochronousOutTransferPacket: true, USBIsochronousOutTransferResult: true, USBOutTransferResult: true, WorkerLocation: true, WorkerNavigator: true, Worklet: true, IDBFactory: true, IDBObserver: true, IDBObserverChanges: true, SVGAnimatedAngle: true, SVGAnimatedBoolean: true, SVGAnimatedEnumeration: true, SVGAnimatedInteger: true, SVGAnimatedLength: true, SVGAnimatedLengthList: true, SVGAnimatedNumber: true, SVGAnimatedNumberList: true, SVGAnimatedPreserveAspectRatio: true, SVGAnimatedRect: true, SVGAnimatedString: true, SVGAnimatedTransformList: true, SVGMatrix: true, SVGPoint: true, SVGPreserveAspectRatio: true, SVGRect: true, SVGUnitTypes: true, AudioListener: true, AudioWorkletGlobalScope: true, AudioWorkletProcessor: true, PeriodicWave: true, ANGLEInstancedArrays: true, ANGLE_instanced_arrays: true, WebGLBuffer: true, WebGLCanvas: true, WebGLColorBufferFloat: true, WebGLCompressedTextureASTC: true, WebGLCompressedTextureATC: true, WEBGL_compressed_texture_atc: true, WebGLCompressedTextureETC1: true, WEBGL_compressed_texture_etc1: true, WebGLCompressedTextureETC: true, WebGLCompressedTexturePVRTC: true, WEBGL_compressed_texture_pvrtc: true, WebGLCompressedTextureS3TC: true, WEBGL_compressed_texture_s3tc: true, WebGLCompressedTextureS3TCsRGB: true, WebGLDebugRendererInfo: true, WEBGL_debug_renderer_info: true, WebGLDebugShaders: true, WEBGL_debug_shaders: true, WebGLDepthTexture: true, WEBGL_depth_texture: true, WebGLDrawBuffers: true, WEBGL_draw_buffers: true, EXTsRGB: true, EXT_sRGB: true, EXTBlendMinMax: true, EXT_blend_minmax: true, EXTColorBufferFloat: true, EXTColorBufferHalfFloat: true, EXTDisjointTimerQuery: true, EXTDisjointTimerQueryWebGL2: true, EXTFragDepth: true, EXT_frag_depth: true, EXTShaderTextureLOD: true, EXT_shader_texture_lod: true, EXTTextureFilterAnisotropic: true, EXT_texture_filter_anisotropic: true, WebGLFramebuffer: true, WebGLGetBufferSubDataAsync: true, WebGLLoseContext: true, WebGLExtensionLoseContext: true, WEBGL_lose_context: true, OESElementIndexUint: true, OES_element_index_uint: true, OESStandardDerivatives: true, OES_standard_derivatives: true, OESTextureFloat: true, OES_texture_float: true, OESTextureFloatLinear: true, OES_texture_float_linear: true, OESTextureHalfFloat: true, OES_texture_half_float: true, OESTextureHalfFloatLinear: true, OES_texture_half_float_linear: true, OESVertexArrayObject: true, OES_vertex_array_object: true, WebGLProgram: true, WebGLQuery: true, WebGLRenderbuffer: true, WebGLRenderingContext: true, WebGL2RenderingContext: true, WebGLSampler: true, WebGLShader: true, WebGLShaderPrecisionFormat: true, WebGLSync: true, WebGLTexture: true, WebGLTimerQueryEXT: true, WebGLTransformFeedback: true, WebGLUniformLocation: true, WebGLVertexArrayObject: true, WebGLVertexArrayObjectOES: true, WebGL: true, WebGL2RenderingContextBase: true, Database: true, SQLResultSet: true, SQLTransaction: true, ArrayBuffer: true, ArrayBufferView: false, DataView: true, Float32Array: true, Float64Array: true, Int16Array: true, Int32Array: true, Int8Array: true, Uint16Array: true, Uint32Array: true, Uint8ClampedArray: true, CanvasPixelArray: true, Uint8Array: false, HTMLBRElement: true, HTMLContentElement: true, HTMLDListElement: true, HTMLDataListElement: true, HTMLDetailsElement: true, HTMLDialogElement: true, HTMLHRElement: true, HTMLHeadElement: true, HTMLHeadingElement: true, HTMLHtmlElement: true, HTMLLabelElement: true, HTMLLegendElement: true, HTMLLinkElement: true, HTMLMenuElement: true, HTMLModElement: true, HTMLOListElement: true, HTMLOptGroupElement: true, HTMLParagraphElement: true, HTMLPictureElement: true, HTMLPreElement: true, HTMLQuoteElement: true, HTMLScriptElement: true, HTMLShadowElement: true, HTMLSourceElement: true, HTMLSpanElement: true, HTMLStyleElement: true, HTMLTableCaptionElement: true, HTMLTableCellElement: true, HTMLTableDataCellElement: true, HTMLTableHeaderCellElement: true, HTMLTableColElement: true, HTMLTimeElement: true, HTMLTitleElement: true, HTMLUListElement: true, HTMLUnknownElement: true, HTMLDirectoryElement: true, HTMLFontElement: true, HTMLFrameElement: true, HTMLFrameSetElement: true, HTMLMarqueeElement: true, HTMLElement: false, AccessibleNodeList: true, HTMLAnchorElement: true, Animation: true, ApplicationCacheErrorEvent: true, HTMLAreaElement: true, BackgroundFetchClickEvent: true, BackgroundFetchEvent: true, BackgroundFetchFailEvent: true, BackgroundFetchedEvent: true, BackgroundFetchRegistration: true, HTMLBaseElement: true, Blob: false, BluetoothRemoteGATTDescriptor: true, Body: true, Request: true, Response: true, HTMLBodyElement: true, BroadcastChannel: true, HTMLButtonElement: true, HTMLCanvasElement: true, CanvasRenderingContext2D: true, CDATASection: true, CharacterData: true, Comment: true, ProcessingInstruction: true, Text: true, Client: true, WindowClient: true, CloseEvent: true, PublicKeyCredential: true, Credential: false, CredentialUserData: true, CSSKeyframesRule: true, MozCSSKeyframesRule: true, WebKitCSSKeyframesRule: true, CSSKeywordValue: true, CSSNumericValue: false, CSSPerspective: true, CSSCharsetRule: true, CSSConditionRule: true, CSSFontFaceRule: true, CSSGroupingRule: true, CSSImportRule: true, CSSKeyframeRule: true, MozCSSKeyframeRule: true, WebKitCSSKeyframeRule: true, CSSMediaRule: true, CSSNamespaceRule: true, CSSPageRule: true, CSSStyleRule: true, CSSSupportsRule: true, CSSViewportRule: true, CSSRule: false, CSSStyleDeclaration: true, MSStyleCSSProperties: true, CSS2Properties: true, CSSImageValue: true, CSSPositionValue: true, CSSResourceValue: true, CSSURLImageValue: true, CSSStyleValue: false, CSSMatrixComponent: true, CSSRotation: true, CSSScale: true, CSSSkew: true, CSSTranslation: true, CSSTransformComponent: false, CSSTransformValue: true, CSSUnitValue: true, CSSUnparsedValue: true, HTMLDataElement: true, DataTransferItem: true, DataTransferItemList: true, DeprecationReport: true, HTMLDivElement: true, Document: true, HTMLDocument: true, XMLDocument: true, DOMError: true, DOMException: true, ClientRectList: true, DOMRectList: true, DOMRectReadOnly: false, DOMStringList: true, DOMTokenList: true, Element: false, HTMLEmbedElement: true, DirectoryEntry: true, Entry: true, FileEntry: true, ErrorEvent: true, AnimationEvent: true, AnimationPlaybackEvent: true, BeforeInstallPromptEvent: true, BeforeUnloadEvent: true, BlobEvent: true, ClipboardEvent: true, CustomEvent: true, DeviceMotionEvent: true, DeviceOrientationEvent: true, FontFaceSetLoadEvent: true, GamepadEvent: true, HashChangeEvent: true, MediaEncryptedEvent: true, MediaQueryListEvent: true, MediaStreamEvent: true, MediaStreamTrackEvent: true, MIDIConnectionEvent: true, MIDIMessageEvent: true, MutationEvent: true, PageTransitionEvent: true, PaymentRequestUpdateEvent: true, PresentationConnectionAvailableEvent: true, PromiseRejectionEvent: true, RTCDataChannelEvent: true, RTCDTMFToneChangeEvent: true, RTCPeerConnectionIceEvent: true, RTCTrackEvent: true, SecurityPolicyViolationEvent: true, SensorErrorEvent: true, SpeechRecognitionEvent: true, TrackEvent: true, TransitionEvent: true, WebKitTransitionEvent: true, VRDeviceEvent: true, VRDisplayEvent: true, VRSessionEvent: true, MojoInterfaceRequestEvent: true, USBConnectionEvent: true, IDBVersionChangeEvent: true, AudioProcessingEvent: true, OfflineAudioCompletionEvent: true, WebGLContextEvent: true, Event: false, InputEvent: false, AbsoluteOrientationSensor: true, Accelerometer: true, AccessibleNode: true, AmbientLightSensor: true, ApplicationCache: true, DOMApplicationCache: true, OfflineResourceList: true, BatteryManager: true, EventSource: true, FontFaceSet: true, Gyroscope: true, LinearAccelerationSensor: true, Magnetometer: true, MediaDevices: true, MediaQueryList: true, MediaRecorder: true, MediaSource: true, MIDIAccess: true, NetworkInformation: true, Notification: true, OffscreenCanvas: true, OrientationSensor: true, Performance: true, PermissionStatus: true, PresentationConnectionList: true, PresentationRequest: true, RelativeOrientationSensor: true, RemotePlayback: true, RTCDTMFSender: true, RTCPeerConnection: true, webkitRTCPeerConnection: true, mozRTCPeerConnection: true, ScreenOrientation: true, Sensor: true, ServiceWorker: true, ServiceWorkerContainer: true, ServiceWorkerRegistration: true, SharedWorker: true, SpeechRecognition: true, SpeechSynthesis: true, SpeechSynthesisUtterance: true, VR: true, VRDevice: true, VRDisplay: true, VRSession: true, VisualViewport: true, WebSocket: true, Worker: true, WorkerPerformance: true, BluetoothDevice: true, BluetoothRemoteGATTCharacteristic: true, Clipboard: true, MojoInterfaceInterceptor: true, USB: true, IDBOpenDBRequest: true, IDBVersionChangeRequest: true, IDBRequest: true, IDBTransaction: true, AnalyserNode: true, RealtimeAnalyserNode: true, AudioBufferSourceNode: true, AudioDestinationNode: true, AudioNode: true, AudioScheduledSourceNode: true, AudioWorkletNode: true, BiquadFilterNode: true, ChannelMergerNode: true, AudioChannelMerger: true, ChannelSplitterNode: true, AudioChannelSplitter: true, ConstantSourceNode: true, ConvolverNode: true, DelayNode: true, DynamicsCompressorNode: true, GainNode: true, AudioGainNode: true, IIRFilterNode: true, MediaElementAudioSourceNode: true, MediaStreamAudioDestinationNode: true, MediaStreamAudioSourceNode: true, OscillatorNode: true, Oscillator: true, PannerNode: true, AudioPannerNode: true, webkitAudioPannerNode: true, ScriptProcessorNode: true, JavaScriptAudioNode: true, StereoPannerNode: true, WaveShaperNode: true, EventTarget: false, AbortPaymentEvent: true, CanMakePaymentEvent: true, ExtendableMessageEvent: true, FetchEvent: true, ForeignFetchEvent: true, InstallEvent: true, NotificationEvent: true, PaymentRequestEvent: true, PushEvent: true, SyncEvent: true, ExtendableEvent: false, FederatedCredential: true, HTMLFieldSetElement: true, File: true, FileList: true, FileReader: true, DOMFileSystem: true, FileWriter: true, FontFace: true, HTMLFormElement: true, Gamepad: true, GamepadButton: true, History: true, HTMLCollection: true, HTMLFormControlsCollection: true, HTMLOptionsCollection: true, XMLHttpRequest: true, XMLHttpRequestUpload: true, XMLHttpRequestEventTarget: false, HTMLIFrameElement: true, ImageData: true, HTMLImageElement: true, HTMLInputElement: true, InterventionReport: true, KeyboardEvent: true, HTMLLIElement: true, Location: true, HTMLMapElement: true, MediaDeviceInfo: true, HTMLAudioElement: true, HTMLMediaElement: false, MediaError: true, MediaKeyMessageEvent: true, MediaKeySession: true, MediaList: true, MediaStream: true, CanvasCaptureMediaStreamTrack: true, MediaStreamTrack: true, MessageEvent: true, MessagePort: true, HTMLMetaElement: true, HTMLMeterElement: true, MIDIInputMap: true, MIDIOutputMap: true, MIDIInput: true, MIDIOutput: true, MIDIPort: true, MimeType: true, MimeTypeArray: true, PointerEvent: true, MouseEvent: false, DragEvent: false, NavigatorUserMediaError: true, DocumentFragment: true, ShadowRoot: true, DocumentType: true, Node: false, NodeList: true, RadioNodeList: true, HTMLObjectElement: true, HTMLOptionElement: true, HTMLOutputElement: true, OverconstrainedError: true, HTMLParamElement: true, PasswordCredential: true, PaymentRequest: true, PerformanceEntry: true, PerformanceLongTaskTiming: true, PerformanceMark: true, PerformanceMeasure: true, PerformanceNavigationTiming: true, PerformancePaintTiming: true, PerformanceResourceTiming: true, TaskAttributionTiming: true, PerformanceServerTiming: true, Plugin: true, PluginArray: true, PopStateEvent: true, PositionError: true, PresentationAvailability: true, PresentationConnection: true, PresentationConnectionCloseEvent: true, HTMLProgressElement: true, ProgressEvent: true, ResourceProgressEvent: true, PushMessageData: true, RelatedApplication: true, ReportBody: false, ResizeObserver: true, ResizeObserverEntry: true, RTCDataChannel: true, DataChannel: true, RTCLegacyStatsReport: true, RTCStatsReport: true, HTMLSelectElement: true, SharedWorkerGlobalScope: true, HTMLSlotElement: true, SourceBuffer: true, SourceBufferList: true, SpeechGrammar: true, SpeechGrammarList: true, SpeechRecognitionError: true, SpeechRecognitionResult: true, SpeechSynthesisEvent: true, SpeechSynthesisVoice: true, Storage: true, StorageEvent: true, CSSStyleSheet: true, StyleSheet: true, HTMLTableElement: true, HTMLTableRowElement: true, HTMLTableSectionElement: true, HTMLTemplateElement: true, HTMLTextAreaElement: true, TextTrack: true, TextTrackCue: true, VTTCue: true, TextTrackCueList: true, TextTrackList: true, TimeRanges: true, Touch: true, TouchList: true, TrackDefaultList: true, HTMLTrackElement: true, CompositionEvent: true, FocusEvent: true, TextEvent: true, TouchEvent: true, UIEvent: false, URL: true, HTMLVideoElement: true, VideoTrack: true, VideoTrackList: true, VTTRegion: true, WheelEvent: true, Window: true, DOMWindow: true, DedicatedWorkerGlobalScope: true, ServiceWorkerGlobalScope: true, WorkerGlobalScope: false, Attr: true, CSSRuleList: true, ClientRect: true, DOMRect: true, GamepadList: true, NamedNodeMap: true, MozNamedAttrMap: true, SpeechRecognitionResultList: true, StyleSheetList: true, IDBCursor: false, IDBCursorWithValue: true, IDBDatabase: true, IDBIndex: true, IDBKeyRange: true, IDBObjectStore: true, IDBObservation: true, SVGAngle: true, SVGLength: true, SVGLengthList: true, SVGNumber: true, SVGNumberList: true, SVGPointList: true, SVGScriptElement: true, SVGStringList: true, SVGAElement: true, SVGAnimateElement: true, SVGAnimateMotionElement: true, SVGAnimateTransformElement: true, SVGAnimationElement: true, SVGCircleElement: true, SVGClipPathElement: true, SVGDefsElement: true, SVGDescElement: true, SVGDiscardElement: true, SVGEllipseElement: true, SVGFEBlendElement: true, SVGFEColorMatrixElement: true, SVGFEComponentTransferElement: true, SVGFECompositeElement: true, SVGFEConvolveMatrixElement: true, SVGFEDiffuseLightingElement: true, SVGFEDisplacementMapElement: true, SVGFEDistantLightElement: true, SVGFEFloodElement: true, SVGFEFuncAElement: true, SVGFEFuncBElement: true, SVGFEFuncGElement: true, SVGFEFuncRElement: true, SVGFEGaussianBlurElement: true, SVGFEImageElement: true, SVGFEMergeElement: true, SVGFEMergeNodeElement: true, SVGFEMorphologyElement: true, SVGFEOffsetElement: true, SVGFEPointLightElement: true, SVGFESpecularLightingElement: true, SVGFESpotLightElement: true, SVGFETileElement: true, SVGFETurbulenceElement: true, SVGFilterElement: true, SVGForeignObjectElement: true, SVGGElement: true, SVGGeometryElement: true, SVGGraphicsElement: true, SVGImageElement: true, SVGLineElement: true, SVGLinearGradientElement: true, SVGMarkerElement: true, SVGMaskElement: true, SVGMetadataElement: true, SVGPathElement: true, SVGPatternElement: true, SVGPolygonElement: true, SVGPolylineElement: true, SVGRadialGradientElement: true, SVGRectElement: true, SVGSetElement: true, SVGStopElement: true, SVGStyleElement: true, SVGSVGElement: true, SVGSwitchElement: true, SVGSymbolElement: true, SVGTSpanElement: true, SVGTextContentElement: true, SVGTextElement: true, SVGTextPathElement: true, SVGTextPositioningElement: true, SVGTitleElement: true, SVGUseElement: true, SVGViewElement: true, SVGGradientElement: true, SVGComponentTransferFunctionElement: true, SVGFEDropShadowElement: true, SVGMPathElement: true, SVGElement: false, SVGTransform: true, SVGTransformList: true, AudioBuffer: true, AudioParam: true, AudioParamMap: true, AudioTrack: true, AudioTrackList: true, AudioContext: true, webkitAudioContext: true, BaseAudioContext: false, OfflineAudioContext: true, WebGLActiveInfo: true, SQLError: true, SQLResultSetRowList: true});
    H.NativeTypedArray.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfDouble.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H._NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin.$nativeSuperclassTag = "ArrayBufferView";
    H.NativeTypedArrayOfInt.$nativeSuperclassTag = "ArrayBufferView";
    W._SourceBufferList_EventTarget_ListMixin.$nativeSuperclassTag = "EventTarget";
    W._SourceBufferList_EventTarget_ListMixin_ImmutableListMixin.$nativeSuperclassTag = "EventTarget";
    W._TextTrackList_EventTarget_ListMixin.$nativeSuperclassTag = "EventTarget";
    W._TextTrackList_EventTarget_ListMixin_ImmutableListMixin.$nativeSuperclassTag = "EventTarget";
  })();
  Function.prototype.call$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$0 = function() {
    return this();
  };
  Function.prototype.call$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$1$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$1$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$5 = function(a, b, c, d, e) {
    return this(a, b, c, d, e);
  };
  Function.prototype.call$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$2$5 = function(a, b, c, d, e) {
    return this(a, b, c, d, e);
  };
  Function.prototype.call$2$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$3$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$2$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$3$6 = function(a, b, c, d, e, f) {
    return this(a, b, c, d, e, f);
  };
  Function.prototype.call$3$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$3$4 = function(a, b, c, d) {
    return this(a, b, c, d);
  };
  Function.prototype.call$1$2 = function(a, b) {
    return this(a, b);
  };
  Function.prototype.call$2$3 = function(a, b, c) {
    return this(a, b, c);
  };
  Function.prototype.call$2$1 = function(a) {
    return this(a);
  };
  Function.prototype.call$1$0 = function() {
    return this();
  };
  convertAllToFastObject(holders);
  convertToFastObject($);
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(F.main, []);
    else
      F.main([]);
  });
})();

//# sourceMappingURL=main.dart.js.map
